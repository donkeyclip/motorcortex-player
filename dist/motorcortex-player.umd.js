'use strict';

var motorcortex = require('@donkeyclip/motorcortex');

// the players start name
const name = "--mc-player";

var play = "<!-- Generated by IcoMoon.io -->\n<svg id=\"play-svg\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>play</title>\n<path fill=\"#999\" d=\"M27.558 13.624l-21.827-13.232c-0.402-0.248-0.89-0.395-1.411-0.395-1.502 0-2.72 1.218-2.72 2.72 0 0.002 0 0.004 0 0.006v-0 26.461c0 0.001 0 0.002 0 0.003 0 1.502 1.218 2.72 2.72 2.72 0.522 0 1.009-0.147 1.423-0.401l-0.012 0.007 21.827-13.232c0.792-0.485 1.313-1.346 1.313-2.328s-0.521-1.843-1.301-2.321l-0.012-0.007z\"></path>\n</svg>";

var pause = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>pause</title>\n<path d=\"M6.059 4.639h8.521v22.722h-8.521zM18.84 4.639h8.521v22.722h-8.521z\"></path>\n</svg>";

var expandFull = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>expand-full</title>\n<path fill=\"#999\" d=\"M31.667 3.271c-0.004-1.619-1.315-2.93-2.934-2.934h-7.642c-0.921 0-1.667 0.747-1.667 1.667s0.747 1.667 1.667 1.667h6.909c0.185 0 0.333 0.148 0.333 0.332v4.359c0 0.921 0.747 1.667 1.667 1.667s1.667-0.746 1.667-1.667v0-5.091zM0.333 8.362c0 0.921 0.746 1.667 1.667 1.667s1.667-0.746 1.667-1.667v0-4.362c0-0.001 0-0.001 0-0.002 0-0.184 0.148-0.333 0.332-0.333h6.909c0.898-0.029 1.614-0.764 1.614-1.667s-0.717-1.637-1.612-1.666l-0.003-0h-7.635c-1.619 0.005-2.931 1.315-2.934 2.936l-0.007 5.095zM31.667 28.726v-5.091c0-0.921-0.747-1.667-1.667-1.667s-1.667 0.747-1.667 1.667v0 4.365c0 0.185-0.148 0.333-0.332 0.333h-6.909c-0.921 0-1.667 0.747-1.667 1.667s0.747 1.667 1.667 1.667v0h7.635c1.624-0.002 2.941-1.319 2.941-2.942zM0.333 28.726c0.004 1.621 1.319 2.934 2.941 2.934 0 0 0 0 0 0h7.635c0.016 0.001 0.034 0.001 0.053 0.001 0.921 0 1.667-0.747 1.667-1.667s-0.746-1.667-1.667-1.667c-0.019 0-0.037 0-0.056 0.001l0.003-0h-6.909c-0 0-0 0-0 0-0.182 0-0.33-0.145-0.333-0.326v-4.366c0-0.921-0.747-1.667-1.667-1.667s-1.667 0.747-1.667 1.667v0 5.091z\"></path>\n<path fill=\"#999\" d=\"M10.321 10.848h11.357c1.818 0 3.291 1.473 3.291 3.291v3.72c0 1.818-1.473 3.291-3.291 3.291h-11.357c-1.818 0-3.291-1.473-3.291-3.291v-3.72c0-1.818 1.473-3.291 3.291-3.291z\"></path>\n</svg>";

var angleLeft = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"32\" viewBox=\"0 0 16 32\">\n<title>angle-left</title>\n<path d=\"M1.981 14.938l8.5-8.5c0.588-0.588 1.537-0.588 2.119 0l1.412 1.412c0.588 0.588 0.588 1.537 0 2.119l-6.019 6.031 6.025 6.025c0.588 0.587 0.588 1.538 0 2.119l-1.412 1.419c-0.588 0.587-1.537 0.587-2.119 0l-8.5-8.5c-0.594-0.587-0.594-1.537-0.006-2.125z\"></path>\n</svg>";

var angleRight = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"32\" viewBox=\"0 0 16 32\">\n<title>angle-right</title>\n<path d=\"M14.019 17.063l-8.5 8.5c-0.588 0.587-1.538 0.587-2.119 0l-1.413-1.413c-0.587-0.587-0.587-1.538 0-2.119l6.019-6.031-6.025-6.025c-0.587-0.588-0.587-1.537 0-2.119l1.413-1.419c0.587-0.588 1.538-0.588 2.119 0l8.5 8.5c0.594 0.588 0.594 1.538 0.006 2.125z\"></path>\n</svg>";

var checkSolid = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>check-solid</title>\n<path d=\"M10.869 27.463l-10.4-10.4c-0.625-0.625-0.625-1.638 0-2.263l2.263-2.263c0.625-0.625 1.638-0.625 2.263 0l7.006 7.006 15.006-15.006c0.625-0.625 1.638-0.625 2.263 0l2.263 2.263c0.625 0.625 0.625 1.638 0 2.263l-18.4 18.4c-0.625 0.625-1.638 0.625-2.263-0z\"></path>\n</svg>";

var settings = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>settings</title>\n<path fill=\"#999\" d=\"M29.999 12.665h-2.483c-0.275-0.938-0.621-1.751-1.048-2.512l0.031 0.060 1.757-1.755c0.362-0.362 0.587-0.862 0.587-1.415s-0.224-1.053-0.587-1.415l-1.886-1.883c-0.362-0.362-0.862-0.586-1.415-0.586s-1.053 0.224-1.415 0.586l-1.757 1.755c-0.701-0.397-1.514-0.743-2.366-0.996l-0.084-0.021v-2.483c0.002-1.107-0.894-2.001-1.999-2.001h-2.668c-1.105 0-1.999 0.896-1.999 2.001v2.483c-0.938 0.275-1.751 0.621-2.513 1.048l0.060-0.031-1.757-1.755c-0.362-0.362-0.862-0.587-1.415-0.587s-1.053 0.224-1.415 0.587l-1.886 1.886c-0.362 0.362-0.586 0.862-0.586 1.415s0.224 1.053 0.586 1.415v0l1.758 1.755c-0.431 0.775-0.771 1.598-1.017 2.451h-2.483c-1.107-0.002-2.001 0.894-2.001 1.999v2.668c0 1.105 0.896 1.999 2.001 1.999h2.483c0.246 0.854 0.586 1.676 1.017 2.452l-1.762 1.758c-0.362 0.362-0.586 0.862-0.586 1.415s0.224 1.053 0.586 1.415v0l1.886 1.885c0.368 0.348 0.866 0.563 1.415 0.563s1.047-0.214 1.416-0.564l-0.001 0.001 1.757-1.757c0.778 0.429 1.6 0.771 2.454 1.019v2.479c0 1.105 0.894 2.001 1.999 2.001h2.668c1.105 0 1.999-0.896 1.999-2.001v-2.479c0.852-0.248 1.676-0.589 2.452-1.017l1.757 1.757c0.362 0.362 0.862 0.586 1.415 0.586s1.053-0.224 1.415-0.586v0l1.885-1.886c0.362-0.362 0.586-0.862 0.586-1.414s-0.224-1.052-0.586-1.414l-1.757-1.757c0.431-0.776 0.771-1.6 1.017-2.452h2.483c0 0 0.001 0 0.002 0 1.105 0 2.001-0.896 2.001-2.001 0-0.002 0-0.004 0-0.005v0-2.663c0-1.105-0.896-1.999-2.001-1.999zM16 22.668c-3.682 0-6.666-2.985-6.666-6.666s2.985-6.666 6.666-6.666v0c3.682 0 6.666 2.985 6.666 6.666s-2.985 6.666-6.666 6.666v0z\"></path>\n</svg>";

var loop = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>loop</title>\n<path fill=\"#999\" d=\"M22.364 21.968h-0.631c-0.92 0-1.667 0.746-1.667 1.667s0.746 1.667 1.667 1.667h0.637c0.013 0 0.028 0 0.044 0 5.113 0 9.259-4.145 9.259-9.259 0-4.668-3.454-8.529-7.946-9.166l-0.049-0.006c-0.158-0.028-0.276-0.164-0.277-0.328v-2.636c-0-0.92-0.746-1.666-1.667-1.666-0.357 0-0.689 0.112-0.96 0.304l0.005-0.003-6.371 4.455c-0.432 0.305-0.711 0.803-0.711 1.365 0 0.92 0.746 1.667 1.667 1.667 0 0 0 0 0 0h6.352c3.772 0 6.617 2.567 6.617 5.971-0.004 3.295-2.674 5.966-5.969 5.969h-0zM8.329 25.127c0.16 0.027 0.277 0.165 0.277 0.328v2.635c0 0.001 0 0.001 0 0.002 0 0.92 0.746 1.665 1.665 1.665 0.358 0 0.69-0.113 0.961-0.305l-0.005 0.003 6.364-4.453c0.432-0.306 0.71-0.803 0.71-1.365 0-0.92-0.746-1.667-1.666-1.668h-6.352c-3.772 0-6.617-2.567-6.617-5.968 0.002-3.296 2.673-5.968 5.969-5.972h0.638c0.92 0 1.667-0.746 1.667-1.667s-0.746-1.667-1.667-1.667v0h-0.637c-0.010-0-0.022-0-0.034-0-5.114 0-9.26 4.146-9.26 9.26 0 4.665 3.45 8.524 7.937 9.166l0.049 0.006z\"></path>\n</svg>";

var volumeOn = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>volume-on</title>\n<path d=\"M26.107 2.991l-3.729 3.185c2.867 2.354 4.694 5.879 4.694 9.824s-1.827 7.47-4.694 9.824l3.729 3.185c3.612-3.226 5.893-7.852 5.893-13.009s-2.281-9.783-5.893-13.009zM19.861 8.326l-3.876 3.312c1.692 0.762 3.038 2.423 3.038 4.362s-1.346 3.6-3.038 4.362l3.876 3.312c2.379-1.756 4.028-4.535 4.028-7.674s-1.649-5.918-4.028-7.674zM12.143 5.399l-7.143 5.601h-3c-1.478 0-2 0.539-2 2v6c0 1.461 0.553 2 2 2h3l7.143 5.595c0.857 0.553 1.85 0.727 1.85-0.823v-19.55c0-1.55-0.993-1.376-1.85-0.823z\"></path>\n</svg>";

var volumeOff = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>volume-off</title>\n<path d=\"M27.397 16.001l4.134-4.144c0.625-0.627 0.625-1.641 0-2.267l-1.132-1.134c-0.625-0.626-1.638-0.626-2.263 0l-4.134 4.144-4.133-4.141c-0.625-0.626-1.638-0.626-2.263 0l-1.132 1.134c-0.625 0.626-0.625 1.641 0 2.267l4.134 4.142-4.131 4.142c-0.625 0.626-0.625 1.641 0 2.267l1.132 1.134c0.625 0.626 1.638 0.626 2.263 0l4.131-4.141 4.133 4.14c0.625 0.627 1.638 0.627 2.263 0l1.132-1.134c0.625-0.626 0.625-1.641 0-2.267l-4.134-4.141zM12.148 5.399l-7.146 5.603h-3.001c-1.479 0-2.001 0.539-2.001 2.001l-0 2.951 0 3.051c0 1.461 0.553 2.001 2.001 2.001h3.001l7.146 5.597c0.857 0.553 1.851 0.727 1.851-0.823v-19.556c-0-1.55-0.994-1.376-1.851-0.823z\"></path>\n</svg>";

var donkeyclip = "<!-- Generated by IcoMoon.io -->\n<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"32\" height=\"32\" viewBox=\"0 0 32 32\">\n<title>DonkeyClip</title>\n<path fill=\"#777\" d=\"M25.811 3.454v11.010h-3.479c-0.696-2.447-2.974-4.246-5.638-4.246-3.238 0-5.877 2.638-5.877 5.877s2.638 5.877 5.877 5.877c2.686 0 4.942-1.799 5.638-4.246h3.334c-0.767 4.246-4.485 7.509-8.972 7.509-5.014 0-9.115-4.078-9.115-9.115 0-5.014 4.078-9.115 9.115-9.115 2.231 0 4.294 0.815 5.877 2.159v-7.652c-1.992-0.912-4.222-1.415-6.572-1.415-8.779 0-15.904 7.125-15.904 15.904s7.125 15.904 15.904 15.904c8.779 0 15.904-7.125 15.904-15.904 0.024-5.109-2.375-9.644-6.093-12.546z\"></path>\n</svg>";

var SVG = {
  play: play,
  pause: pause,
  "expand-full": expandFull,
  "angle-left": angleLeft,
  "angle-right": angleRight,
  settings: settings,
  loop: loop,
  "volume-on": volumeOn,
  "volume-off": volumeOff,
  "donkeyclip-logo": donkeyclip,
  spinner: `<div class="lds-ring"><div></div><div></div><div></div><div></div></div>`,
  "check-solid": checkSolid
};

const VOLUME_CHANGE = "volume-change";
const MUTE_CHANGE = "mute-change";
const SPEED_CHANGE = "speed-change";
const LOOP_CHANGE = "loop-change";
const SCALE_CHANGE = "scale-change";
const SHOW_VOLUME_CHANGE = "show-volume-change";
const STATE_CHANGE = "state-change";
const DURATION_CHANGE = "duration-change";

// Mouce/Touch
const mouseup = "mouseup";
const mousedown = "mousedown";
const touchstart = "touchstart";
const mousemove = "mousemove";
const touchend = "touchend";
const touchmove = "touchmove";

function exitFullscreen() {
  try {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    }
  } catch (e) {
    console.error(e);
  }
}
function launchIntoFullscreen(element) {
  try {
    if (element.requestFullscreen) {
      element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
      element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
      element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) {
      element.msRequestFullscreen();
    }
  } catch (e) {
    console.error(e);
  }
}
function trigger$5(_this) {
  const elFullScreen = _this.clip.props.host.className.includes("full-screen");
  if (_this.clip.props.host !== _this.options.host) {
    if (!elFullScreen) {
      _this.clip.props.host.appendChild(_this.elements.mcPlayer);
    } else {
      _this.options.host.appendChild(_this.elements.mcPlayer);
    }
  }
  elFullScreen ? exitFullscreen() : launchIntoFullscreen(_this.clip.props.host);
}
function add$6(_this) {
  _this.elements.fullScreenButton.onclick = () => trigger$5(_this);
}

function addPlayIcon(playPausePanelContainer) {
  changeIcon(playPausePanelContainer, null, "play");
}
function addPauseIcon(playPausePanelContainer) {
  changeIcon(playPausePanelContainer, null, "pause");
}
function trigger$4(_this) {
  playPauseIconFunctionality(_this);
}
function add$5(_this) {
  _this.elements.pointerEventPanel.onclick = () => trigger$4(_this);
  _this.elements.pointerEventPanel.ondblclick = () => trigger$5(_this);
}

const timeCapsule = new motorcortex.TimeCapsule();
let playPauseTimeout = setTimeout(() => {}, 0);
// export const el = document.querySelectorAll.bind(document);
// export const elid = document.getElementById.bind(document);
function elFirstClass(player, className) {
  return player.getElementsByClassName(className)[0];
}
// export const eltag = document.getElementsByTagName.bind(document);
// export const elcreate = document.createElement.bind(document);

// export const addListener = document.addEventListener.bind(document);
function addListenerWithElement(element) {
  for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    rest[_key - 1] = arguments[_key];
  }
  return element.addEventListener(...rest);
}
document.removeEventListener.bind(document);
function sanitizeCSS(css) {
  return css.replace(/(behaviour|javascript|expression)/gm, "");
}
const playPauseIconFunctionality = _this => {
  clearTimeout(playPauseTimeout);
  _this.elements.playPausePanel.classList.remove("hide");
  _this.elements.playPausePanel.classList.remove("run-animation-play");
  _this.elements.playPausePanel.classList.remove("run-animation-pause");
  _this.elements.playPausePanel.classList.remove("run-animation-idle");
  if (_this.clip.runTimeInfo.state === "idle") {
    _this.play();
    addPlayIcon(_this.elements.playPausePanelContainer);
    _this.elements.playPausePanel.classList.add("run-animation-idle");
  } else if (_this.clip.runTimeInfo.state !== "playing") {
    _this.play();
    addPlayIcon(_this.elements.playPausePanelContainer);
    _this.elements.playPausePanel.classList.add("run-animation-play");
  } else {
    _this.pause();
    addPauseIcon(_this.elements.playPausePanelContainer);
    _this.elements.playPausePanel.classList.add("run-animation-pause");
  }
  playPauseTimeout = setTimeout(() => {
    _this.elements.playPausePanel.classList.add("hide");
  }, 800);
};
function isNumber(value) {
  return typeof value === "number" && isFinite(value);
}
const numberPartRegexp = /^[+-]?(\d+([.]\d*)?|[.]\d+)/gi;
function calculateDimension(dimensionToMatch) {
  const widthNumberPart = dimensionToMatch.match(numberPartRegexp)[0];
  const widthUnitPart = dimensionToMatch.substring(widthNumberPart.length);
  if (isNumber(Number(widthNumberPart)) && (widthUnitPart !== "%" || widthUnitPart !== "px")) {
    return {
      number: Number(widthNumberPart),
      unit: widthUnitPart
    };
  }
}
function calcClipScale(containerParams, platoDims) {
  let cover = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!containerParams) {
    return {
      scale: 1,
      position: {}
    };
  }
  let widthAnalysed, heightAnalysed;
  if (containerParams.width) {
    widthAnalysed = calculateDimension(containerParams.width);
  }
  if (containerParams.height) {
    heightAnalysed = calculateDimension(containerParams.height);
  }

  // the only case the Clip needs to be scaled is when any of the two axis of the Clip
  // is defined in pixels and the value of it is greater than the available space of
  // the plato
  let scaleDifWidth = 1,
    scaleDifHeight = 1;
  if (widthAnalysed?.unit === "px" && widthAnalysed.number !== platoDims.width) {
    scaleDifWidth = platoDims.width / widthAnalysed.number;
  }
  if (heightAnalysed?.unit === "px" && heightAnalysed.number !== platoDims.height) {
    scaleDifHeight = platoDims.height / heightAnalysed.number;
  }
  const boundaryToUse = cover ? scaleDifHeight > scaleDifWidth : scaleDifHeight <= scaleDifWidth;
  const finalScale = boundaryToUse ? scaleDifHeight : scaleDifWidth;
  const position = {};
  if (widthAnalysed != null) {
    let clipWidth = widthAnalysed.number * finalScale;
    if (widthAnalysed.unit !== "px") {
      clipWidth *= platoDims.width / 100;
    }
    const blankSpace = platoDims.width - clipWidth;
    position.left = blankSpace / 2;
  }
  if (heightAnalysed != null) {
    let clipHeight = heightAnalysed.number * finalScale;
    if (heightAnalysed.unit !== "px") {
      clipHeight *= platoDims.height / 100;
    }
    const blankSpace = platoDims.height - clipHeight;
    position.top = blankSpace / 2;
  }
  return {
    scale: finalScale,
    position: position
  };
}

// FIXME: This is a super unreliable way of testing, we need to update this
function isMobile() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
}
function addMouseUpAndMoveListeners(_this, callbackForUp, callbackForMove) {
  _this.document.addEventListener(mouseup, callbackForUp, false);
  _this.document.addEventListener(touchend, callbackForUp, false);
  _this.document.addEventListener(mousemove, callbackForMove, {
    passive: false
  });
  _this.document.addEventListener(touchmove, callbackForMove, {
    passive: false
  });
}
function removeMouseUpAndMoveListeners(_this, callbackForUp, callbackForMove) {
  _this.document.removeEventListener(mouseup, callbackForUp, false);
  _this.document.removeEventListener(touchend, callbackForUp, false);
  _this.document.removeEventListener(mousemove, callbackForMove, {
    passive: false
  });
  _this.document.removeEventListener(touchmove, callbackForMove, {
    passive: false
  });
}
function addStartListeners(callback) {
  let element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
  let passive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  addListenerWithElement(element, mousedown, callback, {
    passive
  });
  addListenerWithElement(element, touchstart, callback, {
    passive
  });
}
function changeIcon(element, from, to) {
  if (from) {
    element.classList.remove(`icon-${from}`);
    element.innerHTML = "";
  }
  if (to) {
    element.classList.add(`icon-${to}`);
    element.innerHTML = SVG[to];
  }
}
function initializeIcons(playerElements) {
  playerElements.loopButton.innerHTML = SVG.loop;
  playerElements.volumeBtn.innerHTML = SVG["volume-on"];
  playerElements.statusButton.innerHTML = SVG.play;
  playerElements.settingsButton.innerHTML = SVG.settings;
  playerElements.donkeyclipButton.innerHTML = SVG["donkeyclip-logo"];
  playerElements.fullScreenButton.innerHTML = SVG["expand-full"];
  playerElements.speedButtonShow.innerHTML = SVG["angle-right"];
  playerElements.speedButtonHide.innerHTML = SVG["angle-left"];
}
function sortFunc(a, b) {
  return a - b;
}
function initializeOptions(options, _this) {
  options.id ??= Date.now();
  options.showVolume ??= !!Object.keys(options.clip?.audioClip?.children || []).length;
  options.showIndicator ??= false;
  options.theme ??= "default";
  options.host ??= options.clip.props.host;
  options.buttons ??= {};
  options.buttons.donkeyclip = (() => {
    if (typeof window === "undefined" || !window.Donkeyclip?.clipId) return false;
    return options.buttons.donkeyclip;
  })();
  options.timeFormat ??= "ss";
  options.backgroundColor ??= "black";
  options.fullscreen ??= false;
  options.scaleToFit ??= true;
  options.sectionsEasing ??= "easeOutQuart";
  options.pointerEvents ??= false;
  options.scrollAnimation ??= false;
  options.onMillisecondChange ??= null;
  options.speedValues ??= [-1, 0, 0.5, 1, 2];
  options.speed ??= 1;
  options.muted ??= false;
  options.maxScrollStorage ??= 50;
  options.controls ??= true;
  options.loop ??= false;
  options.volume ??= 1;
  options.currentScript ??= null;
  if (options.millisecond) {
    const clip = _this.clip;
    if (options.millisecond > clip.duration) options.millisecond = clip.duration;
    if (options.millisecond < 0 || !isFinite(options.millisecond)) options.millisecond = 0;
    _this.goToMillisecond(options.millisecond);
  }
  // remove strings
  for (const i in options.speedValues) {
    if (!isFinite(options.speedValues[i])) {
      options.speedValues.splice(i, 1);
    }
  }
  options.speedValues.sort(sortFunc);
  return options;
}

var htmlplayer = "<div class=\"--mcp-background\"></div> <div class=\"--mcp-context\" tabindex=\"0\"> <div class=\"--mcp-pointer-events-panel\"></div> <div class=\"--mcp-play-pause-panel\"> <div class=\"--mcp-play-pause-panel-container\"></div> </div> <div class=\"--mcp-listener-helper\"></div> <div class=\"--mcp-controls\"> <div class=\"--mcp-grad\"></div> <div class=\"--mcp-progressbar\"> <div class=\"--mcp-totalbar\"> <div class=\"--mcp-loopbar\"> <div class=\"--mcp-loopbar-color\"></div> <div class=\"--mcp-loop-boundaries --mcp-loopbar-start\"> <span></span> </div> <div class=\"--mcp-loop-boundaries --mcp-loopbar-end\"> <span></span> </div> <div class=\"--mcp-runningbar\"> <div class=\"--mcp-cursor\"></div> </div> </div> </div> </div> <div class=\"--mcp-buttons\"> <div class=\"--mcp-left-buttons\"> <div class=\"--mcp-status\"> <span class=\"--mcp-btn --mcp-status-btn icon-play\"></span> <span class=\"--mcp-indicator\">i</span> </div> <div class=\"--mcp-volume\"> <div class=\"--mcp-btn --mcp-volume-btn icon-volume-on\"></div> <div class=\"--mcp-volumebar\"> <div class=\"--mcp-volumebar-color\"> <div class=\"--mcp-volumebar-color-active\"> <div class=\"--mcp-volume-cursor\"></div> </div> </div> </div> </div> <div class=\"--mcp-time-display\"> <span class=\"--mcp-time-current\">00:00</span> <span class=\"--mcp-time-separator\">/</span> <span class=\"--mcp-time-total\">00:00</span> </div> </div> <div class=\"--mcp-right-buttons\"> <div class=\"--mcp-loop-btn-container\"> <div class=\"--mcp-btn --mcp-loop-btn icon-loop\"></div> </div> <div class=\"--mcp-btn --mcp-settings-btn icon-settings\"></div> <div class=\"--mcp-btn --mcp-dc-btn icon-donkeyclip-logo\"></div> <div class=\"--mcp-btn --mcp-full-screen-btn icon-expand-full\"></div> </div> </div> </div> <div class=\"--mcp-settings-panel\" tabindex=\"0\"> <ul class=\"--mcp-main-settings\"> <li class=\"--mcp-settings-pointer-events\"> <p>Pointer events</p> <div> <div class=\"switch settings-switch\"> <input class=\"--mcp-show-pointer-events-checkbox\" type=\"checkbox\"> <span class=\"slider round\"></span> </div> </div> </li> <li class=\"--mcp-settings-volume\"> <p>Show volume</p> <div> <div class=\"switch settings-switch\"> <input class=\"--mcp-show-volume-checkbox\" type=\"checkbox\"> <span class=\"slider round\"></span> </div> </div> </li> <li class=\"--mcp-settings-speed-show\"> <p>Playback speed</p> <div> <span class=\"--mcp-speed-current\"></span> <div class=\"--mcp-btn --mcp-speed-btn --mcp-speed-btn-show icon-angle-right\"></div> </div> </li> </ul> <ul class=\"--mcp-speed-settings\"> <li class=\"--mcp-settings-speed-hide\"> <div class=\"--mcp-btn --mcp-speed-btn --mcp-speed-btn-hide icon-angle-left\"></div> <p class=\"--mcp-speed-runtime\">Playback speed</p> </li> <li class=\"--mcp-no-hover\"> <ul class=\"--mcp-speed-values\"></ul> </li> </ul> </div> </div> ";

var setElements = (_this => {
  initializePlayer(_this);
  const {
    mcPlayer
  } = _this.elements;
  _this.elements.pointerEventPanel = elFirstClass(mcPlayer, `--mcp-pointer-events-panel`);
  _this.elements.playPausePanel = elFirstClass(mcPlayer, `--mcp-play-pause-panel`);
  _this.elements.playPausePanelContainer = elFirstClass(mcPlayer, `--mcp-play-pause-panel-container`);
  _this.elements.listenerHelper = elFirstClass(mcPlayer, `--mcp-listener-helper`);
  _this.elements.loopBar = elFirstClass(mcPlayer, `--mcp-loopbar`);
  _this.elements.totalBar = elFirstClass(mcPlayer, `--mcp-totalbar`);
  _this.elements.indicator = elFirstClass(mcPlayer, `--mcp-indicator`);
  _this.elements.loopButton = elFirstClass(mcPlayer, `--mcp-loop-btn`);
  _this.elements.volumeBar = elFirstClass(mcPlayer, `--mcp-volumebar`);
  _this.elements.totalTime = elFirstClass(mcPlayer, `--mcp-time-total`);
  _this.elements.volumeControl = elFirstClass(mcPlayer, `--mcp-volume`);
  _this.elements.volumeBtn = elFirstClass(mcPlayer, `--mcp-volume-btn`);
  _this.elements.runningBar = elFirstClass(mcPlayer, `--mcp-runningbar`);
  _this.elements.loopBarEnd = elFirstClass(mcPlayer, `--mcp-loopbar-end`);
  _this.elements.statusButton = elFirstClass(mcPlayer, `--mcp-status-btn`);
  _this.elements.speedBar = elFirstClass(mcPlayer, `--mcp-speed-values`);
  _this.elements.currentTime = elFirstClass(mcPlayer, `--mcp-time-current`);
  _this.elements.timeDisplay = elFirstClass(mcPlayer, `--mcp-time-display`);
  _this.elements.speedButtonShow = elFirstClass(mcPlayer, `--mcp-speed-btn-show`);
  _this.elements.speedButtonHide = elFirstClass(mcPlayer, `--mcp-speed-btn-hide`);
  _this.elements.speedCurrent = elFirstClass(mcPlayer, `--mcp-speed-current`);
  _this.elements.loopBarStart = elFirstClass(mcPlayer, `--mcp-loopbar-start`);
  _this.elements.volumeCursor = elFirstClass(mcPlayer, `--mcp-volume-cursor`);
  _this.elements.settingsButton = elFirstClass(mcPlayer, `--mcp-settings-btn`);
  _this.elements.donkeyclipButton = elFirstClass(mcPlayer, `--mcp-dc-btn`);
  _this.elements.timeSeparator = elFirstClass(mcPlayer, `--mcp-time-separator`);
  _this.elements.settingsPanel = elFirstClass(mcPlayer, `--mcp-settings-panel`);
  _this.elements.background = elFirstClass(mcPlayer, `--mcp-background`);
  _this.elements.settingsMainPanel = elFirstClass(mcPlayer, `--mcp-main-settings`);
  _this.elements.fullScreenButton = elFirstClass(mcPlayer, `--mcp-full-screen-btn`);
  _this.elements.context = elFirstClass(mcPlayer, `--mcp-context`);
  _this.elements.volumeBarHelper = elFirstClass(mcPlayer, `--mcp-volumebar`);
  _this.elements.volumeBarActive = elFirstClass(mcPlayer, `--mcp-volumebar-color-active`);
  _this.elements.settingsSpeedPanel = elFirstClass(mcPlayer, `--mcp-speed-settings`);
  _this.elements.settingsShowVolume = elFirstClass(mcPlayer, `--mcp-settings-volume`);
  _this.elements.settingsPointerEvents = elFirstClass(mcPlayer, `--mcp-settings-pointer-events`);
  _this.elements.settingsSpeedButtonShow = elFirstClass(mcPlayer, `--mcp-settings-speed-show`);
  _this.elements.settingsSpeedButtonHide = elFirstClass(mcPlayer, `--mcp-settings-speed-hide`);
  _this.elements.controls = elFirstClass(mcPlayer, `--mcp-controls`);
  _this.elements.volumeCheckbox = elFirstClass(mcPlayer, `--mcp-show-volume-checkbox`);
  _this.elements.showVolumeCheckbox = elFirstClass(mcPlayer, `--mcp-show-volume-checkbox`);
  _this.elements.showPointerEventsCheckbox = elFirstClass(mcPlayer, `--mcp-show-pointer-events-checkbox`);
  _this.elements.leftButtons = elFirstClass(mcPlayer, `--mcp-left-buttons`);
  initializeIcons(_this.elements);
  addStyles(_this);
  createSpeedValues(_this);
  showHideButtons(_this);
});
const initializePlayer = _this => {
  const clipIframe = _this.clip.props.host;
  if (!clipIframe.offsetWidth) {
    clipIframe.style.width = _this.clip.props.containerParams.width;
  }
  if (!clipIframe.offsetHeight) {
    clipIframe.style.height = _this.clip.props.containerParams.height;
  }
  clipIframe.style.display = `flex`;
  clipIframe.style.justifyContent = `center`;
  clipIframe.style.alignItems = `center`;
  clipIframe.style.overflow = "hidden";
  _this.clip.props.host.style.position = `relative`;
  _this.clip.props.host.style.zIndex = 0;
  _this.elements.mcPlayer = _this.document.createElement("div");
  _this.elements.mcPlayer.id = `${_this.name}`;
  _this.elements.mcPlayer.className = `${_this.className}`;
  _this.elements.mcPlayer.innerHTML = htmlplayer;
  if (typeof _this.options.host === "string") {
    const nodelist = _this.document.querySelectorAll(_this.options.host);
    for (const i in nodelist) {
      if (!isNaN(i)) {
        nodelist[i].appendChild(_this.elements.mcPlayer);
      }
    }
  } else {
    _this.options.host.appendChild(_this.elements.mcPlayer);
  }
};
const addStyles = _this => {
  _this.elements.volumeBarActive.style.width = `${_this.settings.volume * 100}%`;
  _this.elements.currentTime.innerHTML = _this.timeFormat(0);
  _this.elements.totalTime.innerHTML = _this.timeFormat(_this.clip.duration);
  _this.elements.timeSeparator.innerHTML = "/";
  _this.elements.settingsPanel.classList.add("m-fadeOut", `${_this.name}-hide`);
  if (_this.options.backgroundColor) {
    _this.elements.background.style.background = _this.options.backgroundColor;
  }
  if (_this.options.type === "scroller") {
    window.document.body.style.overscrollBehaviorY = "contain";
  }
  if (!_this.options.showIndicator) {
    _this.elements.indicator.style.display = "none";
  } else {
    _this.elements.indicator.style.display = undefined;
    _this.elements.statusButton.style.width = "35px";
    _this.elements.statusButton.style.height = "20px";
    _this.elements.statusButton.style.bottom = "5px";
  }
  _this.elements.indicator.innerHTML = _this.clip.runTimeInfo.state;
  _this.elements.settingsSpeedPanel.style.display = "none";

  // _this.elements.loopBarStart.style.left = "0%";
  _this.elements.loopBarStart.classList.add("m-fadeOut", `${_this.name}-hide`);

  // _this.elements.loopBarEnd.style.left = "100%";
  _this.elements.loopBarEnd.classList.add("m-fadeOut", `${_this.name}-hide`);
  _this.elements.volumeCheckbox.checked = _this.options.showVolume;
  _this.elements.showPointerEventsCheckbox.checked = _this.options.pointerEvents;
  if (_this.options.pointerEvents) {
    _this.elements.pointerEventPanel.style.pointerEvents = "none";
  } else {
    _this.elements.pointerEventPanel.style.pointerEvents = "auto";
  }
  if (!_this.options.showVolume) {
    _this.elements.volumeControl.classList.toggle("m-fadeOut");
  }
};
const createSpeedValues = _this => {
  for (const i in _this.options.speedValues) {
    if (_this.options.speedValues[i] == 0) continue;
    const iconCheckClass = "check-solid";
    const selectedClass = "--mcp-selected";

    //create the parent li element
    const li = _this.document.createElement("li");
    li.className = `--mcp-speed-value`;
    li.dataset.speedValue = _this.options.speedValues[i];

    //create the check holder
    const span = _this.document.createElement("span");
    li.append(span);

    //create the value of the speed
    const valueDiv = _this.document.createElement("p");
    const isNormal = _this.options.speedValues[i] == 1;
    valueDiv.innerHTML = isNormal ? "Normal" : _this.options.speedValues[i];
    valueDiv.dataset.zone = i;
    valueDiv.classList.add("--mcp-speed-value-item");

    //add the check if this is the speed
    if (_this.options.speedValues[i] == _this.options.speed ?? _this.clip.speed) {
      changeIcon(span, null, iconCheckClass);
      valueDiv.classList.add(selectedClass);
    }
    li.append(valueDiv);
    _this.elements.speedBar.append(li);
    li.onclick = function () {
      _this.options.speed = _this.options.speedValues[i];
      _this.clip.speed = _this.options.speedValues[i];
      _this.elements.speedCurrent.innerHTML = _this.clip.speed == 1 ? "Normal" : _this.clip.speed;
      const previousChecked = elFirstClass(_this.elements.mcPlayer, "icon-check-solid");
      changeIcon(previousChecked, iconCheckClass);
      changeIcon(span, null, iconCheckClass);
      elFirstClass(_this.elements.mcPlayer, selectedClass).classList.remove(selectedClass);
      valueDiv.classList.add(selectedClass);
    };
  }
};
const showHideButtons = _this => {
  // show hide buttons
  if (_this.options.buttons.fullScreen === false) {
    _this.elements.fullScreenButton.remove();
  }
  if (_this.options.buttons.settings === false) {
    _this.elements.settingsButton.remove();
  }
  if (!_this.options.buttons.donkeyclip) {
    _this.elements.donkeyclipButton.remove();
  }
  if (_this.options.buttons.loop === false) {
    _this.elements.loopButton.remove();
  }
};

var bodyListener = (_this => {
  function handleFullScreenChange() {
    _this.elements.mcPlayer.classList.toggle(`full-screen`);
    _this.clip.props.host.classList.toggle(`full-screen`);
  }
  _this.document.addEventListener("fullscreenchange", handleFullScreenChange);
  _this.document.addEventListener("webkitfullscreenchange", handleFullScreenChange);
  _this.document.addEventListener("mozfullscreenchange", handleFullScreenChange);
  _this.document.addEventListener("MSFullscreenChange", handleFullScreenChange);
});

var donkeyclipListener = (_this => {
  _this.elements.donkeyclipButton.addEventListener("click", () => {
    const clipID = window.DonkeyClip?.clipId;
    const staging = window.location.host.includes("staging") ? "staging." : "";
    window.open(`https://${staging}donkeyclip.com/${clipID ? `explore/donkeyclips/${clipID}` : ""}`);
  });
});

const showControls = "--mcp-force-show-controls";
const PLAYING = "playing";
const VOLUME_OFF = "volume-off";
const VOLUME_ON = "volume-on";

var css_248z = ".--mc-player.theme-default{--activeColor:136,136,136;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-yellow{--activeColor:255,235,59;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-dark{--activeColor:136,136,136;--defaultColor:136,136,136;--backgroundColor:0,0,0,1;--backgroundSettingsColor:rgba(0,0,0,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-whiteGold{--activeColor:161,127,26;--defaultColor:136,136,136;--backgroundColor:245,245,245,1;--backgroundSettingsColor:hsla(0,0%,96%,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-darkGold{--activeColor:161,127,26;--defaultColor:136,136,136;--backgroundColor:0,0,0,1;--backgroundSettingsColor:rgba(0,0,0,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-transparent{--activeColor:255,0,0;--defaultColor:239,238,236;--backgroundColor:0,0,0,0;--backgroundSettingsColor:rgba(0,0,0,0.9);--loopBarColor:rgba(var(--defaultColor),0.2);--grad-display:block;--grad-color:0,0,0}.--mc-player.theme-green{--activeColor:0,184,139;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-blue{--activeColor:0,153,225;--defaultColor:255,255,255;--backgroundColor:29,31,37,1;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:none;--grad-color:0,0,0}.--mc-player.theme-donkeyclip{--activeColor:0,153,225;--defaultColor:255,255,255;--backgroundColor:0,0,0,0;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:block;--grad-color:24,25,29}.--mc-player.theme-donkeyclipDark{--activeColor:0,153,225;--defaultColor:255,255,255;--backgroundColor:0,0,0,0;--backgroundSettingsColor:rgba(29,31,37,0.9);--loopBarColor:rgba(var(--activeColor),0.2);--grad-display:block;--grad-color:22,22,26}.--mc-player,.--mc-player *{user-select:none!important;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none}.--mc-player *{box-sizing:border-box;color:rgb(var(--defaultColor));cursor:default;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;font-size:13px}.--mc-player svg{width:22px}.--mcp-settings-panel:focus{outline:none}.--mc-player *{outline:none!important}.--mcp-settings-panel svg{width:10px}.--mc-player svg,.--mc-player svg *{fill:rgb(var(--defaultColor))!important}.--mc-player{left:0;overscroll-behavior:none;top:0}.--mc-player,.--mcp-background,.--mcp-context{height:100%;pointer-events:none;position:absolute;width:100%}.--mcp-background,.--mcp-context{display:flex;flex-direction:column}.--mcp-background{background:#000;z-index:-1000}.--mcp-pointer-events-panel.initial{min-height:100%;width:100%;z-index:100}.--mcp-pointer-events-panel{min-height:calc(100% - 50px);width:100%}.--mcp-pointer-events-panel.loading{align-items:center;background:rgba(0,0,0,.8);display:flex;justify-content:center}.--mcp-grad{background-image:linear-gradient(rgba(var(--grad-color),.001),rgba(var(--grad-color),.004),rgba(var(--grad-color),.007),rgba(var(--grad-color),.01),rgba(var(--grad-color),.04),rgba(var(--grad-color),.07),rgba(var(--grad-color),.1),rgba(var(--grad-color),.15),rgba(var(--grad-color),.2),rgba(var(--grad-color),.25),rgba(var(--grad-color),.3),rgba(var(--grad-color),.35),rgba(var(--grad-color),.4),rgba(var(--grad-color),.45),rgba(var(--grad-color),.5),rgba(var(--grad-color),.55),rgba(var(--grad-color),.6),rgba(var(--grad-color),.65),rgba(var(--grad-color),.7),rgba(var(--grad-color),.75),rgba(var(--grad-color),.8),rgba(var(--grad-color),.88));bottom:0;display:var(--grad-display);height:200px;left:0;pointer-events:none!important;position:absolute;width:100%;z-index:0}.--mc-player:hover .--mcp-controls,.--mcp-controls:active{opacity:1!important}.--mcp-controls{background:rgba(var(--backgroundColor));display:flex;flex-direction:column;height:50px;opacity:0;padding:0 15px;pointer-events:auto;position:relative;transition:all .2s ease;z-index:0}.--mcp-controls *{user-select:none!important}.--mcp-play-pause-panel #play-svg{margin-left:4px}.--mcp-always-show-controls,.--mcp-force-show-controls{opacity:1!important}.--mcp-progressbar{align-items:center;display:flex;justify-content:center;position:relative}.--mcp-loopbar,.--mcp-runningbar,.--mcp-totalbar{height:5px;position:relative}.--mcp-cursor{background-color:rgb(var(--activeColor));border-radius:100%;height:14px;position:absolute;right:-8px;top:-5px;width:14px;z-index:10}.--mcp-totalbar{background-color:rgba(var(--defaultColor),.3);min-width:100%}.--mcp-loopbar{padding:10px 0;position:relative;top:-10px;width:100%}.--mcp-loopbar-color{background-color:var(--loopBarColor);bottom:5px;height:5px;left:0;position:absolute;width:100%}.--mcp-runningbar{background-color:rgb(var(--activeColor));width:0}.--mcp-buttons,.--mcp-left-buttons,.--mcp-left-buttons>div,.--mcp-right-buttons,.--mcp-right-buttons>div{align-items:center;display:flex;gap:5px;z-index:1}.--mcp-left-buttons{flex:1}.--mcp-buttons,.--mcp-left-buttons,.--mcp-right-buttons{gap:20px;height:100%}.--mcp-left-buttons{justify-content:flex-start}.--mcp-right-buttons{justify-content:flex-end}.--mcp-prevent-point-events{z-index:100}.--mcp-play-pause-panel,.--mcp-prevent-point-events{height:100%;left:0;position:absolute;top:0;width:100%}.--mcp-play-pause-panel{align-items:center;background-position:50%!important;background-repeat:no-repeat!important;background-size:contain!important;display:flex;justify-content:center;pointer-events:none;z-index:2}.--mcp-play-pause-panel.initial{background-color:#000}.--mcp-play-pause-panel.initial svg{height:32px;width:32px}.--mcp-play-pause-panel.initial .--mcp-play-pause-panel-container{height:80px;width:80px}.--mcp-play-pause-panel.hide{opacity:0}.run-animation-play{animation:scale-and-opaque .8s 1}.run-animation-pause{animation:scale-and-opaque1 .8s 1}.run-animation-idle{animation:scale-and-opaque2 .8s 1}.--mcp-play-pause-panel-container{align-items:center;background-color:#000000c7;border-radius:100%;display:flex;height:60px;justify-content:center;width:60px}.--mcp-play-pause-panel .--mcp-play-pause-panel-container{animation-duration:.8s;transform-origin:center center}@keyframes scale-and-opaque{0%{opacity:.5;transform:scale(1)}to{opacity:0;transform:scale(2)}}@keyframes scale-and-opaque1{0%{opacity:.5;transform:scale(1)}to{opacity:0;transform:scale(2)}}@keyframes scale-and-opaque2{0%{opacity:.5;transform:scale(1)}to{opacity:0;transform:scale(2)}}.--mcp-loop-boundaries{display:flex!important;position:relative}.--mcp-loop-boundaries span{background-color:#aeaeae;border-radius:100%;height:13px;left:-6px;position:absolute;top:-4px;width:13px;z-index:100}.--mcp-loopbar-start{left:0}.--mcp-loopbar-end{left:100%}.--mc-player svg,.--mc-player svg *,.--mcp-btn,.--mcp-cursor,.--mcp-loop-boundaries,.--mcp-loopbar,.--mcp-loopbar-color,.--mcp-runningbar,.--mcp-status-btn,.--mcp-volume *{cursor:pointer}.--mcp-btn{font-size:20px}.--mcp-btn,.--mcp-status-btn{align-items:center;display:flex;justify-content:center}.--mcp-status-btn{gap:3px}.--mcp-indicator{font-size:12px}.--mcp-listener-helper{pointer-events:none}.--mcp-volume-btn{font-size:15px}.--mcp-volumebar{align-items:center;display:flex;height:100%;justify-content:center;padding-left:0;padding-right:0;transition:all .2s ease;width:0}.--mcp-volume{height:100%}.--mcp-volume:hover{padding-right:10px}.--mcp-volume:active .--mcp-volumebar,.--mcp-volume:hover .--mcp-volumebar{padding-left:5px;width:52px}.--mcp-volume:active .--mcp-volume-cursor,.--mcp-volume:hover .--mcp-volume-cursor{display:block}.--mcp-btn:before{color:var(--defaultColor)!important}.--mcp-btn:before:hover{filter:brightness(40)}.--mcp-settings-speed-hide{border-bottom:1px solid hsla(0,0%,100%,.2)}ul.--mcp-speed-values{align-items:center;display:flex;justify-content:center;padding:0}ul.--mcp-speed-values li,ul.--mcp-speed-values li p{width:100%}.--mcp-settings-panel ul{display:flex;flex:1;flex-direction:column;list-style-type:none;margin:0;padding:5px 0}.--mcp-settings-panel ul li{align-items:center;cursor:pointer;display:flex;flex:1;min-height:40px;padding:0 21px}.--mcp-settings-panel ul li *{cursor:pointer}.--mcp-settings-panel ul li:not(.--mcp-no-hover):hover{background-color:rgba(var(--activeColor),.2)}.--mcp-settings-panel ul li>div{align-items:center;display:flex;flex:1;gap:10px;justify-content:flex-end;width:48px}.--mcp-settings-panel{background-color:var(--backgroundSettingsColor);bottom:60px;pointer-events:auto;position:absolute;right:15px;transition:all .2s ease;width:251px;z-index:1000}.--mcp-speed-values{padding:0}.--mcp-no-hover{padding:0!important}.--mcp-speed-value-item:not(.--mcp-selected){padding-left:15px}.--mcp-speed-value-item.--mcp-selected{padding-left:10px}.--mcp-speed-value .icon-check-solid{margin-left:-5px}.--mcp-settings-panel ul.--mcp-speed-settings li>div{flex:unset;justify-content:flex-start;width:20px}.--mcp-main-settings ul li>p{align-items:center;display:flex;flex:1;padding-left:10px}.--mc-player .switch{display:inline-block;height:14px;position:relative;width:36px}.--mc-player .switch input{display:none}.--mc-player .settings-switch:after{clear:both}.--mc-player .slider{background-color:#999;bottom:0;cursor:pointer;right:0;top:0}.--mc-player .slider,.--mc-player .slider:before{left:0;position:absolute;-webkit-transition:.4s;transition:.4s}.--mc-player .slider:before{background-color:#cfcfcf;bottom:-3px;content:\"\";height:20px;width:20px}.--mc-player input:checked+.slider{background-color:rgb(var(--activeColor))}.--mc-player input:focus+.slider{box-shadow:0 0 1px rgb(var(--activeColor))}.--mc-player input:checked+.slider:before{background-color:#fff;-webkit-transform:translateX(16px);-ms-transform:translateX(16px);transform:translateX(16px)}.--mc-player .slider.round{border-radius:34px}.--mc-player .slider.round:before{border-radius:50%}.--mc-player .m-fadeOut{display:none!important;opacity:0!important;visibility:hidden!important}.--mc-player .m-fadeIn{display:unset;opacity:1!important;visibility:visible!important}.--mcp-volume-cursor{background-color:rgb(var(--defaultColor));border-radius:100%;display:none;height:14px;position:absolute;right:-8px;width:14px}.--mcp-volumebar-color{background-color:rgba(var(--defaultColor),.3);height:3px;width:100%}.--mcp-volumebar-color-active{align-items:center;background-color:rgb(var(--defaultColor));display:flex;height:100%;justify-content:center;position:relative;width:100%}.lds-ring{aspect-ratio:1/1;display:inline-block;max-width:64px;position:relative;width:18%}.lds-ring div{animation:lds-ring 1.5s cubic-bezier(.5,.5,.5,.8) infinite;aspect-ratio:1/1;border:3px solid transparent;border-radius:50%;border-top-color:#fff;box-sizing:border-box;display:block;margin:3px;position:absolute;width:100%}.lds-ring div:first-child{animation-delay:-.3s}.lds-ring div:nth-child(2){animation-delay:-.2s}.lds-ring div:nth-child(3){animation-delay:-.1s}@keyframes lds-ring{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}";

function add$4(_this) {
  _this.elements.context.onkeydown = e => {
    switch (e.code) {
      case "Space":
        {
          playPauseIconFunctionality(_this);
          break;
        }
      case "ArrowRight":
        {
          _this.goToMillisecond(_this.clip.runTimeInfo.currentMillisecond + 5000);
          break;
        }
      case "ArrowLeft":
        {
          _this.goToMillisecond(_this.clip.runTimeInfo.currentMillisecond - 5000);
          break;
        }
    }
  };
}

var loopBarEndListener = (_this => {
  _this.listeners.onCursorMoveLoopEnd = e => {
    e.stopPropagation();
    if (isMobile()) e.preventDefault();
    const clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;
    const viewportOffset = _this.elements.totalBar.getBoundingClientRect();
    let positionX = clientX - viewportOffset.left;
    if (positionX < 0) {
      positionX = 0;
    } else if (positionX > _this.elements.totalBar.offsetWidth) {
      positionX = _this.elements.totalBar.offsetWidth;
    }
    if (_this.elements.runningBar.offsetWidth >= _this.elements.loopBar.offsetWidth) {
      _this.elements.runningBar.style.width = _this.elements.loopBar.offsetWidth + `px`;
    }
    if (_this.settings.loopLastPositionXPxls - positionX < 0) {
      _this.elements.loopBar.style.width = Math.abs(_this.settings.loopLastPositionXPxls - positionX) + `px`;
    } else {
      _this.elements.loopBar.style.left = positionX + `px`;
      _this.settings.loopLastPositionXPxls = positionX;
    }
    _this.settings.loopEndMillisecond = Math.round(_this.clip.duration * ((parseFloat(_this.elements.loopBar.style.left) || 0) + parseFloat(_this.elements.loopBar.style.width)) / _this.elements.totalBar.offsetWidth);
    if (_this.settings.loopEndMillisecond < _this.clip.runTimeInfo.currentMillisecond) {
      _this.settings.loopJourney = true;
    }
    if (_this.settings.loopStartMillisecond > _this.settings.loopEndMillisecond) {
      _this.settings.loopStartMillisecond = _this.settings.loopEndMillisecond;
      _this.settings.loopJourney = true;
    }
  };
  _this.listeners.onMouseUpLoopEnd = () => {
    _this.elements.listenerHelper.style.pointerEvents = "none";
    _this.settings.resizeLoop = false;
    const {
      loopBar,
      totalBar,
      runningBar
    } = _this.elements;
    runningBar.style.width = runningBar.offsetWidth / loopBar.offsetWidth * 100 + `%`;
    loopBar.style.left = `${loopBar.offsetLeft / totalBar.offsetWidth * 100}%`;
    loopBar.style.width = `${loopBar.offsetWidth / totalBar.offsetWidth * 100}%`;
    if (_this.settings.loopJourney) {
      _this.createProgressDrag(runningBar.offsetWidth);
      _this.settings.loopJourney = false;
    }
    removeMouseUpAndMoveListeners(_this, _this.listeners.onMouseUpLoopEnd, _this.listeners.onCursorMoveLoopEnd);
    addStartListeners(_this.listeners.onMouseDown, loopBar, true);
    if (!_this.settings.playAfterResize) {
      return;
    }
    if (_this.clip.runTimeInfo.state === "idle" || _this.clip.runTimeInfo.state === "completed") {
      let loopms;
      if (_this.clip.speed >= 0) {
        loopms = _this.settings.loopStartMillisecond + 1;
      } else {
        loopms = _this.settings.loopEndMillisecond - 1;
      }
      _this.settings.needsUpdate = true;
      _this.goToMillisecond(loopms, {
        before: "pause",
        after: "play"
      });
    } else {
      _this.clip.play();
    }
    _this.settings.playAfterResize = false;
  };
  _this.listeners.onMouseDownLoopEnd = e => {
    e.stopPropagation();
    _this.elements.listenerHelper.style.pointerEvents = "auto";
    _this.settings.resizeLoop = true;
    _this.settings.needsUpdate = true;
    if (_this.clip.runTimeInfo.state === "playing") {
      _this.clip.pause();
      _this.settings.playAfterResize = true;
    }
    _this.elements.runningBar.style.width = `${_this.elements.runningBar.offsetWidth}px`;
    const loopBar = _this.elements.loopBar;
    loopBar.style.left = `${loopBar.offsetLeft}px`;
    loopBar.style.width = `${loopBar.offsetWidth}px`;
    _this.listeners.onCursorMoveLoopEnd(e);
    addMouseUpAndMoveListeners(_this, _this.listeners.onMouseUpLoopEnd, _this.listeners.onCursorMoveLoopEnd);
  };
  addStartListeners(_this.listeners.onMouseDownLoopEnd, _this.elements.loopBarEnd, false);
});

var loopBarStartListener = (_this => {
  _this.listeners.onCursorMoveLoopStart = e => {
    e.stopPropagation();
    if (isMobile()) e.preventDefault();
    const clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;
    const viewportOffset = _this.elements.totalBar.getBoundingClientRect();
    let positionX = Math.round(clientX - viewportOffset.left);
    const endPositionsInPxls = Math.round(_this.settings.loopEndMillisecond / _this.clip.duration * _this.elements.totalBar.offsetWidth);
    if (positionX < 0) {
      positionX = 0;
    } else if (positionX > _this.elements.totalBar.offsetWidth) {
      positionX = _this.elements.totalBar.offsetWidth;
    }
    const runningBarWidthInPxls = _this.clip.runTimeInfo.currentMillisecond / _this.clip.duration * _this.elements.totalBar.offsetWidth - positionX;
    _this.elements.loopBar.style.left = positionX + `px`;
    _this.elements.loopBar.style.width = endPositionsInPxls - positionX + `px`;
    _this.elements.runningBar.style.width = runningBarWidthInPxls + `px`;
    _this.settings.loopLastPositionXPxls = positionX;
    _this.settings.loopStartMillisecond = Math.round(_this.clip.duration * _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth);
    if (_this.settings.loopEndMillisecond < _this.settings.loopStartMillisecond) {
      _this.settings.loopEndMillisecond = _this.settings.loopStartMillisecond;
      _this.elements.loopBar.style.width = "0px";
      _this.elements.runningBar.style.width = "0px";
    }
    if (_this.settings.loopStartMillisecond > _this.clip.runTimeInfo.currentMillisecond) {
      _this.settings.loopJourney = true;
    }
  };
  _this.listeners.onMouseUpLoopStart = () => {
    _this.elements.listenerHelper.style.pointerEvents = "none";
    _this.settings.resizeLoop = false;
    if (_this.settings.loopJourney) {
      _this.createProgressDrag(_this.elements.runningBar.offsetWidth);
      _this.settings.loopJourney = false;
    }
    _this.elements.loopBar.style.left = _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth * 100 + `%`;
    _this.elements.loopBar.style.width = _this.elements.loopBar.offsetWidth / _this.elements.totalBar.offsetWidth * 100 + `%`;
    _this.settings.loopStartMillisecond = Math.round(_this.clip.duration * _this.elements.loopBar.offsetLeft / _this.elements.totalBar.offsetWidth);
    _this.elements.runningBar.style.width = _this.elements.runningBar.offsetWidth / _this.elements.loopBar.offsetWidth * 100 + `%`;
    removeMouseUpAndMoveListeners(_this, _this.listeners.onMouseUpLoopStart, _this.listeners.onCursorMoveLoopStart);
    addStartListeners(_this.listeners.onMouseDown, _this.elements.loopBar, true);
    if (_this.settings.playAfterResize) {
      if (_this.clip.runTimeInfo.state === `idle`) {
        let loopms;
        if (_this.clip.speed >= 0) {
          loopms = _this.settings.loopStartMillisecond + 1;
        } else {
          loopms = _this.settings.loopEndMillisecond - 1;
        }
        _this.settings.needsUpdate = true;
        _this.goToMillisecond(loopms, {
          before: "pause",
          after: "play"
        });
      } else {
        _this.clip.play();
      }
      _this.settings.playAfterResize = false;
    }
  };
  _this.listeners.onMouseDownLoopStart = e => {
    e.stopPropagation();
    _this.elements.listenerHelper.style.pointerEvents = "auto";
    _this.settings.resizeLoop = true;
    _this.settings.needsUpdate = true;
    if (_this.clip.runTimeInfo.state === `playing`) {
      _this.clip.pause();
      _this.settings.playAfterResize = true;
    }
    _this.listeners.onCursorMoveLoopStart(e);
    addMouseUpAndMoveListeners(_this, _this.listeners.onMouseUpLoopStart, _this.listeners.onCursorMoveLoopStart);
  };
  addStartListeners(_this.listeners.onMouseDownLoopStart, _this.elements.loopBarStart);
});

function trigger$3(_this) {
  _this.settings.loopActivated = !_this.settings.loopActivated;
  _this.eventBroadcast(LOOP_CHANGE, _this.settings.loopActivated);
  _this.elements.loopButton.classList.toggle("svg-selected");
  _this.elements.loopBarStart.classList.toggle("m-fadeOut");
  _this.elements.loopBarEnd.classList.toggle("m-fadeOut");
  _this.elements.loopBarStart.classList.toggle("m-fadeIn");
  _this.elements.loopBarStart.classList.toggle(`${_this.name}-hide`);
  _this.elements.loopBarEnd.classList.toggle("m-fadeIn");
  _this.elements.loopBarEnd.classList.toggle(`${_this.name}-hide`);
  _this.settings.needsUpdate = true;
  if (!_this.settings.loopActivated) {
    _this.elements.loopBar.style.left = "0%";
    _this.elements.loopBar.style.width = "100%";
    _this.settings.loopStartMillisecond = 0;
    _this.settings.loopEndMillisecond = _this.clip.duration;
    _this.settings.loopLastPositionXPxls = 0;
    _this.settings.loopLastPositionXPercentage = 0;
    _this.elements.runningBar.style.width = _this.clip.runTimeInfo.currentMillisecond / _this.clip.duration * 100 + `%`;
  }
}
function add$3(_this) {
  _this.elements.loopButton.onclick = () => trigger$3(_this);
}

var progressBarListener = (_this => {
  _this.listeners.onCursorMove = e => {
    e.stopPropagation();
    if (isMobile()) e.preventDefault();
    const clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;
    const viewportOffset = _this.elements.loopBar.getBoundingClientRect();
    let positionX = clientX - viewportOffset.left;
    if (positionX < 0) {
      positionX = 0;
    } else if (positionX > _this.elements.loopBar.offsetWidth) {
      positionX = _this.elements.loopBar.offsetWidth;
    }
    _this.handleDrag(positionX);
  };
  _this.listeners.onMouseUp = () => {
    _this.elements.listenerHelper.style.pointerEvents = "none";
    removeMouseUpAndMoveListeners(_this, _this.listeners.onMouseUp, _this.listeners.onCursorMove);
    _this.handleDragEnd(_this.settings);
  };
  _this.listeners.onMouseDown = e => {
    _this.elements.listenerHelper.style.pointerEvents = "auto";
    if (_this.clip.runTimeInfo.state === "playing") {
      _this.settings.playAfterResize = true;
    }
    _this.handleDragStart(_this.clip);
    _this.listeners.onCursorMove(e);
    addMouseUpAndMoveListeners(_this, _this.listeners.onMouseUp, _this.listeners.onCursorMove);
  };
  addStartListeners(_this.listeners.onMouseDown, _this.elements.loopBar);
});

const showPointerEvents = _this => {
  if (!_this.elements.showPointerEventsCheckbox.checked) {
    _this.elements.showPointerEventsCheckbox.checked = true;
    _this.options.pointerEvents = false;
    _this.elements.mcPlayer.style.pointerEvents = "none";
    _this.elements.pointerEventPanel.style.pointerEvents = "none";
    _this.elements.controls.style.pointerEvents = "auto";
    _this.elements.settingsPanel.style.pointerEvents = "auto";
  } else {
    _this.elements.showPointerEventsCheckbox.checked = false;
    _this.elements.mcPlayer.style.pointerEvents = "none";
    _this.elements.pointerEventPanel.style.pointerEvents = "auto";
    _this.elements.controls.style.pointerEvents = "auto";
    _this.elements.settingsPanel.style.pointerEvents = "auto";
  }
  _this.eventBroadcast("show-pointer-events-change", _this.elements.showPointerEventsCheckbox.checked);
};
const showVolume = _this => {
  _this.elements.volumeControl.classList.toggle("m-fadeOut");
  if (_this.elements.showVolumeCheckbox.checked) {
    _this.elements.showVolumeCheckbox.checked = false;
  } else {
    _this.elements.showVolumeCheckbox.checked = true;
  }
  _this.eventBroadcast(SHOW_VOLUME_CHANGE, _this.elements.showVolumeCheckbox.checked);
};
function add$2(_this) {
  _this.elements.settingsPanel.onblur = () => {
    _this.elements.settingsButton.click();
  };
  _this.elements.settingsPointerEvents.onclick = () => showPointerEvents(_this);
  _this.elements.settingsShowVolume.onclick = () => showVolume(_this);
  _this.elements.settingsButton.onclick = () => {
    const showHideSettings = e => {
      if (_this.elements.settingsPanel.contains(e.target)) {
        return true;
      }
      _this.elements.settingsPanel.classList.toggle(`${_this.name}-hide`);
      _this.elements.settingsPanel.classList.toggle("m-fadeOut");
      _this.elements.settingsPanel.classList.toggle("m-fadeIn");
      if (_this.elements.settingsPanel.className.includes("m-fadeOut")) {
        _this.document.removeEventListener("click", showHideSettings, false);
        _this.eventBroadcast(STATE_CHANGE, _this.state);
      } else {
        _this.elements.settingsPanel.focus();
      }
    };
    if (_this.elements.settingsPanel.className.includes(`m-fadeOut`)) {
      if (!_this.elements.controls.classList.value.includes("--mcp-force-show-controls")) {
        _this.elements.controls.classList.toggle("--mcp-force-show-controls");
      }
      _this.document.addEventListener(`click`, showHideSettings, false);
    } else {
      _this.document.removeEventListener(`click`, showHideSettings, false);
    }
  };
}
function trigger$2(_this, setting) {
  if (setting === "showPointerEvents") {
    showPointerEvents(_this);
  } else if (setting === "showVolume") {
    showVolume(_this);
  }
}

function add$1(_this) {
  _this.elements.settingsSpeedButtonShow.onclick = _this.elements.settingsSpeedButtonHide.onclick = () => {
    _this.elements.settingsPanel.classList.toggle(`${_this.name}-settings-speed-panel`);
    const includesClass = _this.elements.settingsPanel.className.includes(`${_this.name}-settings-speed-panel`);
    if (includesClass) {
      _this.elements.settingsMainPanel.style.display = "none";
      _this.elements.settingsSpeedPanel.style.display = "block";
    } else {
      _this.elements.settingsSpeedPanel.style.display = "none";
      _this.elements.settingsMainPanel.style.display = "block";
    }
  };
}
function trigger$1(_this, speed) {
  speed = parseFloat(speed) || 1;
  _this.eventBroadcast(SPEED_CHANGE, speed);
  const speedDisplay = speed == 1 ? "Normal" : speed;
  _this.clip.executionSpeed = speed;
  _this.elements.speedCurrent.innerHTML = speedDisplay;
}

var statusBtnListener = (_this => {
  _this.elements.statusButton.onclick = () => {
    switch (_this.clip.runTimeInfo.state) {
      case "playing":
        _this.clip.pause();
        break;
      case "paused":
      case "idle":
      case "transitional":
      case "armed":
        _this.clip.play();
        break;
    }
    return false;
  };
});

function trigger(_this, volume, mute) {
  const elements = _this.elements;
  if (typeof mute !== "undefined") {
    if (mute === false) {
      elements.volumeBarActive.style.width = `${_this.settings.volume * 100}%`;
      _this.clip.setVolume(_this.settings.previousVolume);
      _this.settings.volumeMute = false;
      changeIcon(elements.volumeBtn, VOLUME_OFF, VOLUME_ON);
    } else if (mute === true) {
      _this.settings.volumeMute = true;
      elements.volumeBarActive.style.width = "0%";
      _this.clip.setVolume(0);
      changeIcon(elements.volumeBtn, VOLUME_ON, VOLUME_OFF);
    }
    _this.options.muted = _this.settings.volumeMute;
    _this.eventBroadcast(MUTE_CHANGE, _this.settings.volumeMute);
  }
  if (typeof volume === "undefined") {
    return;
  }
  _this.settings.volume = volume;
  if (_this.settings.volume > 0) {
    _this.settings.previousVolume = volume;
  }
  elements.volumeBarActive.style.width = `${_this.settings.volume * 100}%`;
  _this.clip.setVolume(_this.settings.volume);
  if (_this.settings.volume > 0) {
    _this.settings.volumeMute = false;
    changeIcon(elements.volumeBtn, VOLUME_OFF, VOLUME_ON);
  } else if (_this.settings.volume === 0) {
    _this.settings.volumeMute = true;
    changeIcon(elements.volumeBtn, VOLUME_ON, VOLUME_OFF);
  }
  _this.options.volume = _this.settings.volume;
  _this.eventBroadcast(VOLUME_CHANGE, _this.settings.volume);
  _this.eventBroadcast(MUTE_CHANGE, _this.settings.volumeMute);
}
function add(_this) {
  const elements = _this.elements;
  let volumeDrag = false;
  elements.volumeBtn.onclick = () => {
    if (_this.settings.volumeMute) {
      elements.volumeBarActive.style.width = `${_this.settings.volume * 100}%`;
      _this.clip.setVolume(_this.settings.previousVolume);
      elements.volumeBarActive.style.width = `${_this.settings.previousVolume * 100}%`;
      _this.settings.volumeMute = false;
      changeIcon(elements.volumeBtn, VOLUME_OFF, VOLUME_ON);
    } else {
      _this.settings.volumeMute = true;
      changeIcon(elements.volumeBtn, VOLUME_ON, VOLUME_OFF);
      elements.volumeBarActive.style.width = `0%`;
      _this.clip.setVolume(0);
    }
    _this.eventBroadcast(VOLUME_CHANGE, _this.settings.previousVolume);
    _this.eventBroadcast(MUTE_CHANGE, _this.settings.volumeMute);
  };
  let volumeOpen = false;
  elements.volumeBtn.onmouseover = () => {
    volumeOpen = true;
  };
  _this.elements.leftButtons.onmouseout = () => {
    if (!volumeOpen || volumeDrag) {
      return;
    }
    const e = event.toElement || event.relatedTarget || event.target;
    if (e === _this.elements.leftButtons || isDescendant(_this.elements.leftButtons, e)) {
      return;
    }
    volumeOpen = false;
  };
  const listeners = _this.listeners;
  listeners.onCursorMoveVolumeBar = e => {
    const clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;
    let positionX = clientX - elements.volumeBarHelper.getBoundingClientRect().left;
    if (positionX < 0) {
      positionX = 0;
    } else if (positionX > elements.volumeBarHelper.offsetWidth) {
      positionX = elements.volumeBarHelper.offsetWidth;
    }
    _this.settings.volume = Number((positionX / elements.volumeBarHelper.offsetWidth).toFixed(2));
    elements.volumeBarActive.style.width = `${_this.settings.volume * 100}%`;
    _this.clip.setVolume(_this.settings.volume);
    if (_this.settings.volume >= 0) {
      const mute = _this.settings.volume === 0;
      _this.settings.volumeMute = mute;
      mute ? changeIcon(elements.volumeBtn, VOLUME_ON, VOLUME_OFF) : changeIcon(elements.volumeBtn, VOLUME_OFF, VOLUME_ON);
    }
    _this.eventBroadcast(VOLUME_CHANGE, _this.settings.volume);
    _this.eventBroadcast(MUTE_CHANGE, _this.settings.volumeMute);
  };
  listeners.onMouseUpVolumeBar = () => {
    volumeDrag = false;
    elements.listenerHelper.style.pointerEvents = "none";
    if (_this.settings.volume > 0) {
      _this.settings.previousVolume = _this.settings.volume;
    }
    removeMouseUpAndMoveListeners(_this, listeners.onMouseUpVolumeBar, listeners.onCursorMoveVolumeBar);
  };
  listeners.onMouseDownVolumeBar = e => {
    volumeDrag = true;
    elements.listenerHelper.style.pointerEvents = "auto";
    listeners.onCursorMoveVolumeBar(e);
    addMouseUpAndMoveListeners(_this, listeners.onMouseUpVolumeBar, listeners.onCursorMoveVolumeBar);
  };
  addStartListeners(listeners.onMouseDownVolumeBar, elements.volumeBarHelper);
  addStartListeners(listeners.onMouseDownVolumeBar, elements.volumeCursor);
}
function isDescendant(parent, child) {
  let node = child.parentNode;
  while (node != null) {
    if (node == parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}

const passive = {
  passive: true
};
var wheelListener = (_this => {
  // initialize wheelseek options

  addListenerWithElement(window, "wheel", e => {
    _this.stepper(e.deltaY);
  });
  addListenerWithElement(window, "touchmove", e => {
    const currentY = e.touches[0].clientY;
    _this.lastY ??= currentY;
    const delta = -(currentY - _this.lastY);
    _this.stepper(delta);
    _this.lastY = currentY;
  }, passive);
  addListenerWithElement(window, "touchend", () => {
    _this.lastY = null;
  }, passive);
  addListenerWithElement(window, "touchstart", () => {
    _this.cancelAnimation();
    _this.lastY = null;
  }, passive);
});

const themeKeyToClass = {
  default: "theme-default",
  transparent: "theme-transparent",
  whiteGold: "theme-whiteGold",
  darkGold: "theme-darkGold",
  green: "theme-green",
  blue: "theme-blue",
  dark: "theme-dark",
  yellow: "theme-yellow",
  donkeyclip: "theme-donkeyclip",
  donkeyclipDark: "theme-donkeyclipDark"
};
function addSpinner(pointerEventPanel) {
  changeIcon(pointerEventPanel, null, "spinner");
  pointerEventPanel.classList.add("loading");
}
function removeSpinner(pointerEventPanel) {
  changeIcon(pointerEventPanel, "spinner", null);
  pointerEventPanel.classList.remove("loading");
}
const timeCache = [];

/**
 * @classdesc
 * Timer's purpose is to provide an interface through which any TimedIncident
 * (such as a Scene or a Clip) can both privide info regarding their timing
 * state but also provide an interface for interacting/altering the timing of it
 */
class Player {
  constructor(options) {
    this.elements = {};
    this.clip = options.clip; // host to apply the timer
    this.options = initializeOptions(options, this);
    this.document = this.options.host.ownerDocument;
    this.className = name;
    this.id = this.options.id;
    this.name = name;
    this.clipClass = options.clipClass;
    this.state = this.clip.runTimeInfo.state;
    this.listeners = {};
    this.settings = {
      volume: 1,
      journey: null,
      previousVolume: 1,
      volumeMute: false,
      needsUpdate: true,
      resizeLoop: false,
      loopJourney: false,
      loopActivated: false,
      requestingLoop: false,
      playAfterResize: false,
      loopStartMillisecond: 0,
      loopLastPositionXPxls: 0,
      loopLastPositionXPercentage: 0,
      loopEndMillisecond: this.clip.duration,
      controls: true
    };

    // create the timer controls main div
    setElements(this);
    this.setTheme();
    this.setSpeed();
    this.subscribeToTimer();
    this.subscribeToDurationChange();
    this.addEventListeners();
    this.scaleClipHost();
    this.eventBroadcast(STATE_CHANGE, this.state);
    if (this.options.type === "scroller") {
      this.timeBucket = 0;
      this.timeProgress = 0;
      this.options.sections?.sort(sortFunc);
    }
    const resizeObserver = new ResizeObserver(() => {
      if (window.innerWidth < 450) {
        this.elements.timeDisplay.style.display = "none";
      } else {
        this.elements.timeDisplay.style.display = "block";
      }
      if (this.options.scaleToFit) {
        this.scaleClipHost();
      }
    });
    this.changeSettings(options, true);
    resizeObserver.observe(this.options.host);
    if (this.options.autoPlay) {
      this.play();
    }
    window.clip = this.clip;
  }
  play() {
    this.clip.play();
  }
  pause() {
    this.clip.pause();
  }
  enterFullScreen() {
    launchIntoFullscreen(this.clip.props.host);
  }
  exitFullScreen() {
    exitFullscreen();
  }
  changeSettings(newOptions, initial) {
    newOptions = initializeOptions({
      ...this.options,
      ...newOptions
    }, this);
    if (newOptions.clip !== this.options.clip) {
      initial = true;
      this.clip = newOptions.clip;
      this.options.clip = newOptions.clip;
    }
    if (newOptions.controls === false) {
      this.elements.mcPlayer.style.display = "none";
    } else if (newOptions.controls === true) {
      this.elements.mcPlayer.style.display = "block";
    }
    const checkObject = {
      loop: () => trigger$3(this),
      fullscreen: () => trigger$5(this),
      muted: () => trigger(this, undefined, newOptions.mute),
      volume: () => trigger(this, newOptions.volume),
      speed: () => trigger$1(this, newOptions.speed),
      scaleToFit: () => {
        this.options.scaleToFit = newOptions.scaleToFit;
        this.scaleClipHost();
      },
      showVolume: () => trigger$2(this, "showVolume"),
      type: () => {
        if (newOptions.type === "scroller") wheelListener(this);
      },
      theme: () => {
        this.options.theme = newOptions.theme;
        this.setTheme();
      },
      overflow: () => {
        this.clip.props.host.shadowRoot.children[0].style.overflow = newOptions.overflow;
      },
      outline: () => {
        this.clip.props.host.shadowRoot.children[0].style.outline = newOptions.outline;
      },
      visible: () => {
        if (newOptions.visible == "always") {
          this.elements.controls.classList.add("--mcp-always-show-controls");
        } else if (newOptions.visible == "normal") {
          this.elements.controls.classList.remove("--mcp-always-show-controls");
        }
      }
    };
    const checkWhenInitial = ["fullscreen", "muted", "volume", "speed", "scaleToFit", "loop", "overflow", "outline", "visible"];
    for (const key in checkObject) {
      if (typeof newOptions[key] !== "undefined" && (this.options[key] !== newOptions[key] || initial && this.options[key] !== false && checkWhenInitial.includes(key))) {
        checkObject[key]();
      }
    }
    this.options = {
      ...this.options,
      ...newOptions
    };
  }
  scaleClipHost() {
    if (this.options.scaleToFit) {
      const props = this.clip.props;
      const transform = calcClipScale(props.containerParams, {
        width: props.host.offsetWidth,
        height: props.host.offsetHeight - (this.options.visible == "always" ? 50 : 0)
      }, this.options.scaleToFit === "cover");
      this.clip.realClip.rootElement.style.transform = `scale(${transform.scale}`;
      this.clip.realClip.rootElement.style.left = `${transform.position.left}px`;
      this.clip.realClip.rootElement.style.top = `${transform.position.top}px`;
    } else {
      this.clip.realClip.rootElement.style.transform = "scale(1)";
      this.clip.realClip.rootElement.style.left = "0px";
      this.clip.realClip.rootElement.style.top = "0px";
    }
    this.eventBroadcast(SCALE_CHANGE, this.options.scaleToFit);
  }
  goToMillisecond(ms) {
    let {
      before,
      after
    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    if (ms > this.clip.duration) ms = this.clip.duration;else if (ms < 0) ms = 0;
    setTimeout(() => {
      const clip = this.clip;
      if (!clip.id) return;
      if (before) clip[before]();
      this.settings.journey = timeCapsule.startJourney(clip);
      this.settings.journey.station(ms);
      this.settings.journey.destination();
      if (after) clip[after]();
    }, 0);
  }
  createLoop(msStart, msEnd) {
    this.settings.loopStartMillisecond = msStart;
    this.settings.loopEndMillisecond = msEnd;
    this.elements.loopBar.style.left = `${msStart / this.clip.duration * 100}%`;
    this.elements.loopBar.style.width = `${(msEnd - msStart) / this.clip.duration * 100}%`;
    this.goToMillisecond(msStart);
    this.elements.runningBar.style.width = "0%";
    !this.settings.loopActivated && trigger$3(this);
  }
  calculateMinMaxOfTimeProgress() {
    if (this.timeProgress >= this.clip.duration) this.timeProgress = this.clip.duration;
    if (this.timeProgress <= 0) this.timeProgress = 0;
  }
  requestAnimation() {
    this.requestAnimationID = window.requestAnimationFrame(this.animateTimeBucket.bind(this));
  }
  cancelAnimation() {
    window.cancelAnimationFrame(this.requestAnimationID);
    this.requestAnimationID = null;
  }
  removeTimeFromBucket() {
    const log = Math.log(this.timeBucket);
    const timeRemove = Math.pow(log, 2);
    this.timeBucket -= this.options.scrollAnimation ? log : timeRemove;
    return timeRemove;
  }
  addTimeToProgress(timeRemove) {
    this.timeProgress += timeRemove * this.multiplier * this.clip.speed;
  }
  checkIfBucketHasTime() {
    if (this.timeBucket <= 0) {
      this.requestAnimationID = null;
      return false;
    }
    return true;
  }
  calculateJourneyPosition(progress) {
    const easedProgress = motorcortex.utils.easings[this.options.sectionsEasing](progress);
    return this.startPosition + easedProgress * this.options.speed * this.multiplier * this.endAnimationTime;
  }
  animateTimeBucket() {
    if (!this.checkIfBucketHasTime) return;
    this.addTimeToProgress(this.removeTimeFromBucket());
    this.calculateMinMaxOfTimeProgress();
    if (!this.options.sections) {
      this.goToMillisecond(this.timeProgress);
    } else {
      const progress = (Date.now() - this.startAnimationTime) / this.endAnimationTime;
      if (progress >= 1 || this.endAnimationTime === 0) return this.cancelAnimation();
      const sectionPosition = this.calculateJourneyPosition(progress);
      this.goToMillisecond(Math.ceil(sectionPosition));
    }
    this.requestAnimation();
  }
  setUpTimeBucket(deltaY) {
    const newMultiplier = deltaY > 0 ? 1 : -1;
    deltaY = Math.ceil(Math.abs(deltaY)) * newMultiplier;
    this.timeBucket += Math.abs(deltaY);
    /* clear timebucket if check of direction */
    if (newMultiplier != this.multiplier) this.timeBucket = Math.abs(deltaY);
    /* check if bucket exceeds the maximum value */
    if (this.timeBucket > this.options.maxScrollStorage) this.timeBucket = this.options.maxScrollStorage;
    this.multiplier = newMultiplier;
  }
  getSectionTime(direction) {
    let sectionIndex;
    const sortedSections = this.options.sections;
    if (direction > 0) {
      const newPosition = this.startPosition + this.timeBucket;
      for (let i = 0; i < sortedSections.length; i++) {
        if (newPosition < sortedSections[i]) {
          sectionIndex = i;
          break;
        }
      }
      sectionIndex ??= sortedSections.length - 1;
    } else {
      const newPosition = this.startPosition - this.timeBucket;
      for (let i = sortedSections.length - 1; i >= 0; i--) {
        if (newPosition > sortedSections[i]) {
          sectionIndex = i;
          break;
        }
      }
      sectionIndex ??= 0;
    }
    return sectionIndex;
  }
  initializeSections() {
    this.startAnimationTime = Date.now();
    this.startPosition = this.clip.runTimeInfo.currentMillisecond;
    this.currentSectionIndex = this.getSectionTime(this.multiplier);
    this.endAnimationTime = Math.abs(this.startPosition - this.options.sections[this.currentSectionIndex]);
  }
  stepper(deltaY) {
    this.setUpTimeBucket(deltaY);
    if (this.options.sections) this.initializeSections();
    if (!this.requestAnimationID) this.animateTimeBucket();
  }
  /* scroller end*/
  millisecondChange(millisecond, state, _, makeJouney) {
    let executeOnMillisecondChange = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
    const {
      totalBar,
      loopBar
    } = this.elements;
    if (this.state !== state) {
      this.state = state;
      this.eventBroadcast(STATE_CHANGE, state);
    }
    if (!this.settings.needsUpdate) {
      this.clip.pause();
      return 1;
    }
    if (this.settings.loopActivated && this.clip.speed) {
      this.calculateJourney(millisecond);
    }
    const duration = this.clip.duration;
    const localMillisecond = millisecond - duration * loopBar.offsetLeft / totalBar.offsetWidth;
    const localDuration = duration / totalBar.offsetWidth * loopBar.offsetWidth;
    if (makeJouney) {
      this.goToMillisecond(millisecond, {
        after: this.settings.playAfterResize ? "play" : null
      });
    }
    this.elements.runningBar.style.width = localMillisecond / localDuration * 100 + `%`;
    const newTime = this.timeFormat(millisecond);
    if (this.elements.currentTime.innerHTML !== newTime) this.elements.currentTime.innerHTML = newTime;
    if (this.options.onMillisecondChange && executeOnMillisecondChange) {
      this.options.onMillisecondChange(millisecond);
    }
  }
  calculateJourney(millisecond) {
    const {
      loopEndMillisecond,
      loopStartMillisecond
    } = this.settings;
    const atEndOfLoop = millisecond > loopEndMillisecond || millisecond === this.clip.duration;
    const atStartOfLoop = millisecond < loopStartMillisecond || millisecond === 0;
    const positiveSpeed = this.clip.speed > 0;
    if (this.clip.runTimeInfo.state === PLAYING) {
      if (positiveSpeed) {
        if (atEndOfLoop) {
          this.goToMillisecond(loopStartMillisecond + 1, {
            after: "play"
          });
          return true;
        }
        return false;
      }
      if (atStartOfLoop) {
        this.goToMillisecond(loopEndMillisecond - 1, {
          after: "play"
        });
        return true;
      }
    }
    return false;
  }
  broadcastNotPlaying(state) {
    if (!this.elements.controls.classList.value.includes(showControls)) {
      this.elements.controls.classList.toggle(showControls);
    }
    changeIcon(this.elements.statusButton, "pause", "play");
    this.elements.indicator.innerHTML = `${state.charAt(0).toUpperCase() + state.slice(1)}`;
    if (state == "blocked") {
      addSpinner(this.elements.pointerEventPanel);
    } else if (state !== "idle") {
      removeSpinner(this.elements.pointerEventPanel);
    }
  }
  changeInitParams(initParams) {
    const response = {
      result: true
    };
    this.clip.pause();
    const definition = this.clip?.exportLiveDefinition();
    definition.props.host = this.clip.props.host;
    let oldMillisecond = this.clip.runTimeInfo.currentMillisecond;
    const wasPlaying = this.clip.runTimeInfo.state === PLAYING;
    const oldParams = JSON.parse(JSON.stringify(definition.props.initParams || {}));
    definition.props.initParams = initParams;
    // unmount the previous clip
    this.clip.realClip.context.unmount();
    for (const key in this.clip) {
      delete this.clip[key];
    }
    let newClip;
    try {
      newClip = motorcortex.utils.clipFromDefinition(definition);
      if (newClip.nonBlockingErrorClip || newClip?.errors?.length) throw "Error: Params Error: Clip cannot be created!";
    } catch (e) {
      response.result = false;
      response.clip = newClip;
      console.error(e);
      definition.props.initParams = oldParams;
      newClip = motorcortex.utils.clipFromDefinition(definition);
    }
    //assign the new clip
    this.clip = newClip;
    this.options.clip = this.clip;
    this.elements.totalTime.innerHTML = this.timeFormat(this.clip.duration);
    this.changeSettings(this.options, true);
    this.subscribeToTimer();
    this.subscribeToDurationChange();
    if (oldMillisecond > this.clip.duration) oldMillisecond = this.clip.duration;
    this.goToMillisecond(oldMillisecond);
    if (wasPlaying) this.clip.play();
    return response;
  }
  broadcastPlaying(state) {
    removeSpinner(this.elements.pointerEventPanel);
    if (this.elements.controls.classList.value.includes(showControls)) {
      this.elements.controls.classList.toggle(showControls);
    }
    this.elements.indicator.innerHTML = "Playing";
    changeIcon(this.elements.statusButton, "play", "pause");
    if (state !== PLAYING) {
      return;
    }
    if (this.clip.runTimeInfo.currentMillisecond === this.clip.duration && this.clip.speed >= 0) {
      this.goToMillisecond(1, {
        after: "play"
      });
    } else if ((this.clip.runTimeInfo.currentMillisecond === this.clip.duration || this.clip.runTimeInfo.currentMillisecond === 0) && this.clip.speed < 0) {
      this.goToMillisecond(this.clip.duration - 1, {
        after: "play"
      });
    }
  }
  broadcastDurationChange() {
    this.elements.totalTime.innerHTML = this.timeFormat(this.clip.duration);
    this.settings.loopEndMillisecond = this.clip.duration;
    this.elements.pointerEventPanel.innerHTML = "";
    this.millisecondChange(this.clip.runTimeInfo.currentMillisecond);
  }
  broadcastVolumeChange(state) {
    this.options.volume = state;
    this.options.currentScript.dataset.volume = state;
  }
  broadcastSpeedChange(state) {
    this.options.speed = state;
    this.options.currentScript.dataset.speed = state;
  }
  broadcastMuteChange(state) {
    if (state) {
      this.options.muted = true;
      this.options.currentScript.dataset.muted = "";
      return;
    }
    this.options.muted = false;
    delete this.options.currentScript.dataset.muted;
  }
  broadcastLoopChange(state) {
    if (state) {
      this.options.loop = true;
      this.options.currentScript.dataset.loop = "";
      return;
    }
    this.options.loop = false;
    delete this.options.currentScript.dataset.loop;
  }
  broadcastScaleChange(state) {
    if (state) {
      this.options.scaleToFit = state;
      this.options.currentScript.dataset.scaleToFit = state;
      return;
    }
    this.options.scaleToFit = false;
    delete this.options.currentScript.dataset.scaleToFit;
  }
  broadcastShowVolumeChange(state) {
    if (state) {
      this.options.showVolume = true;
      this.options.currentScript.dataset.showVolume = "";
      return;
    }
    this.options.showVolume = false;
    delete this.options.currentScript.dataset.showVolume;
  }
  broadcastToScript(eventName, state) {
    if (eventName === VOLUME_CHANGE) {
      this.broadcastVolumeChange(state);
    } else if (eventName === SPEED_CHANGE) {
      this.broadcastSpeedChange(state);
    } else if (eventName === MUTE_CHANGE) {
      this.broadcastMuteChange(state);
    } else if (eventName === LOOP_CHANGE) {
      this.broadcastLoopChange(state);
    } else if (eventName === SCALE_CHANGE) {
      this.broadcastScaleChange(state);
    } else if (eventName === SHOW_VOLUME_CHANGE) {
      this.broadcastShowVolumeChange(state);
    }
  }
  calculateThumbnail(state) {
    const hasThumbnail = this.options.thumbnail || this.options.thumbnailColor;
    const isZeroMs = this.clip.runTimeInfo.currentMillisecond === 0 && this.clip.speed > 0;
    const hasAutoplay = this.options.autoPlay;
    if (state === "idle") {
      if (hasAutoplay) {
        this.elements.playPausePanel.classList.add("hide");
        return;
      }
      if (isZeroMs) {
        if (!hasThumbnail) {
          this.elements.playPausePanel.classList.add("hide");
          return;
        }
        addPlayIcon(this.elements.playPausePanelContainer);
        this.elements.playPausePanel.style.backgroundColor = this.options.thumbnailColor || "black";
        this.elements.playPausePanel.style.backgroundImage = this.options.thumbnail && `url(${this.options.thumbnail})`;
        this.elements.playPausePanel.classList.add("initial");
        this.elements.pointerEventPanel.classList.add("initial");
        return;
      }
    }
    this.elements.playPausePanel.style.backgroundColor = "transparent";
    this.elements.playPausePanel.style.backgroundImage = "none";
    this.elements.pointerEventPanel.classList.remove("initial");
    this.elements.playPausePanel.classList.remove("initial");
  }
  eventBroadcast(eventName, state) {
    if (eventName === STATE_CHANGE) {
      if (this.options.currentScript) {
        this.options.currentScript.dataset.status = state;
      }
      this.calculateThumbnail(state);
      const playingStates = ["paused", "idle", "transitional", "armed", "blocked"];
      if (playingStates.includes(state)) {
        this.broadcastNotPlaying(state);
      } else {
        this.broadcastPlaying(state);
      }
    } else if (eventName === DURATION_CHANGE) {
      this.broadcastDurationChange();
    } else if (this.options.currentScript) {
      this.broadcastToScript(eventName, state);
    }
  }
  subscribeToDurationChange() {
    this.clip.subscribeToDurationChange(this.subscribeToDurationChangeCallback.bind(this));
  }
  subscribeToDurationChangeCallback() {
    this.eventBroadcast(DURATION_CHANGE);
  }
  subscribeToTimer() {
    this.clip.subscribe(this.id, this.millisecondChange.bind(this));
  }
  handleDragStart() {
    this.settings.needsUpdate = true;
    this.settings.journey = timeCapsule.startJourney(this.clip);
  }
  timeFormat(ms) {
    if (this.options.timeFormat !== "ss") {
      return ms;
    }
    const diff = ms - timeCache[0];
    // If the diff from previous calculated value is less than a second, return the cached result
    if (0 < diff && diff < 1000) {
      return timeCache[1];
    }
    const hours = ms / 1000 / 60 / 60;
    const minutes = hours % 1 * 60;
    const seconds = minutes % 1 * 60;

    // By default, JavaScript converts any floating-point number
    // with six or more leading zeros into e-notation
    // to avoid this problem we round to 5 float digits
    const h = ("0" + parseInt(hours.toFixed(5))).slice(-2);
    const m = ("0" + parseInt(minutes.toFixed(5))).slice(-2);
    const s = ("0" + parseInt(seconds.toFixed(5))).slice(-2);
    const date = `${h === "00" ? "" : h + ":"}${m}:${s}`;
    if (timeCache[0] == null || ms - timeCache[0] < 2000) {
      // Make sure to round our cache number to the beginning of the second
      // So we don't get any stale cache results, as we would if we cached 1009 for example
      timeCache[0] = Math.floor(ms / 1000) * 1000;
      timeCache[1] = date;
    }
    return date;
  }
  handleDrag(loopBarPositionX) {
    let executeOnMillisecondChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (!isFinite(loopBarPositionX)) {
      loopBarPositionX = 0;
    }
    const {
      loopBar,
      totalBar,
      runningBar,
      currentTime
    } = this.elements;
    const totalBarPositionX = loopBarPositionX + loopBar.offsetLeft;
    const millisecond = Math.round(this.clip.duration * totalBarPositionX / totalBar.offsetWidth);
    currentTime.innerHTML = this.timeFormat(millisecond);
    runningBar.style.width = loopBarPositionX / loopBar.offsetWidth * 100 + `%`;
    this.settings.journey.station(millisecond);
    if (this.options.onMillisecondChange && executeOnMillisecondChange) {
      this.options.onMillisecondChange(millisecond);
    }
  }
  handleDragEnd() {
    this.settings.journey.destination();
  }
  createProgressDrag(loopBarPositionX) {
    this.handleDragStart();
    this.handleDrag(loopBarPositionX);
    this.handleDragEnd();
  }
  addEventListeners() {
    loopBarEndListener(this);
    progressBarListener(this);
    loopBarStartListener(this);
    add$4(this);
    add(this);
    statusBtnListener(this);
    add$2(this);
    add$1(this);
    add$3(this);
    add$6(this);
    add$5(this);
    donkeyclipListener(this);
    bodyListener(this);
    if (this.options.type === "scroller") wheelListener(this);
  }
  setTheme() {
    this.options.theme.replace(/\s\s+/g, ` `);
    this.options.theme.trim();
    const themeClass = themeKeyToClass[this.options.theme];
    if (themeClass) {
      this.elements.mcPlayer.classList.add(themeClass);
    } else if (this.options.themeCSS && !this.document.getElementById("--mc-player-style-custom")) {
      this.options.themeCSS = sanitizeCSS(this.options.themeCSS);
      const customStyle = this.document.createElement("style");
      customStyle.id = "--mc-player-style-custom";
      if (customStyle.styleSheet) {
        customStyle.styleSheet.cssText = this.options.themeCSS;
      } else {
        customStyle.appendChild(document.createTextNode(this.options.themeCSS));
      }
      this.document.querySelector("head").appendChild(customStyle);
      this.elements.mcPlayer.classList.add(this.options.theme);
    }
    if (!this.document.getElementById("--mc-player-style")) {
      const style = this.document.createElement("style");
      style.id = "--mc-player-style";
      style.styleSheet ? style.styleSheet.cssText = css_248z : style.appendChild(document.createTextNode(css_248z));

      // append player style to document
      this.document.querySelector("head").appendChild(style);
    }
    this.eventBroadcast("theme-change", this.options.theme);
  }
  setSpeed() {
    const currentSpeed = this.clip.speed == 1 ? "Normal" : this.clip.speed;
    this.elements.speedCurrent.innerHTML = currentSpeed;
  }
}

module.exports = Player;

/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var head = document.getElementsByTagName("head")[0];
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		;
/******/ 		head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "f77a6e60c6c5619f4848";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (typeof dep === "undefined") hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (typeof dep === "undefined") hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.slice().map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted
/******/ 			)
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Not in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./index.js")(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js":
/*!****************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TimedIncident = __webpack_require__(/*! ./TimedIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar checkTransition = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").checkTransition;\n\n/** @classdesc\n * A Scene is a TimeIncident that can have other Incidents (any kind of) on its timeline and its state mainly derives\n * from the state of its incidents rather than itself.\n */\n\nvar Group = function (_TimedIncident) {\n    _inherits(Group, _TimedIncident);\n\n    function Group() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, Group);\n\n        var attrsToPass = void 0,\n            propsToPass = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToPass = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToPass = oldProps;\n        }\n\n        var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, attrsToPass, propsToPass));\n\n        _this.hasIncidents = true;\n        _this.isChannel = false;\n\n        /**\n          keyframes are special points on the Scene's time where Incidents should be executed\n          The keys of the keyframes array are the millisecond on which the keyframes should get executed:\n          e.g.:\n          keyframes = {\n                sec_2000: {\n                    incident_id: IncidentObject,\n                    incident_id: IncidentObject,\n                    ...\n                },\n                ...\n          }\n          */\n        _this.keyframes = {};\n\n        /**\n          An object holding the mapping incidentid / keyframekey, from which we can get the keyframe id as defined on\n          the this.keyframes object where the incident belongs to\n          e.g.:\n          incidentsKeyframeKeys = {\n                incidentid: sec_2000,\n                ...\n          }\n           */\n        _this.incidentsKeyframeKeys = {};\n\n        /**\n          The array holds the Incidents of the Scene on the format:\n          {\n                id // the id of the Incident object\n                incident // the incident object\n                millisecond // the millisecond the incident should be executed\n          }\n           */\n        _this.incidents = [];\n\n        /*\n        an object / associative array holding all Incidents in the form:\n        <incident_id>: Incident object\n         */\n        _this.incidentsById = {};\n\n        _this.calculatedDuration = 0;\n\n        /**\n         * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip\n         * this attribute is only valuable when the Group becomes the Clip\n         * The format of the attribute is:\n         *  key-value pairs in the manner:\n         * <mc_plugin_npm_name>: Channel object\n        */\n        _this.instantiatedChannels = {};\n\n        _this.isTheClip = false;\n\n        _this.onGroupInitialise();\n        return _this;\n    }\n\n    _createClass(Group, [{\n        key: 'onGroupInitialise',\n        value: function onGroupInitialise() {\n            // called when group gets initialised\n        }\n    }, {\n        key: '_getChannel',\n\n\n        /*\n        returns the initialised channel by the Clip the Incident belongs to\n        */\n        value: function _getChannel(mc_plugin_npm_name) {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject._getChannel(mc_plugin_npm_name);\n            } else {\n                return null;\n            }\n        }\n\n        /*\n        return the direct parent of a specific Incident\n        */\n\n    }, {\n        key: '_getDirectParent',\n        value: function _getDirectParent(incidentId) {\n            if (this.incidentsById.hasOwnProperty(incidentId)) {\n                return this;\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var directParent = this.incidents[i].incident._getDirectParent(incidentId);\n                        if (directParent != null) {\n                            return directParent;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Returns all of its Incidents (not groups) in a collection of the form:\n         * {\n                id,\n                millisecond\n                incident\n            }\n        */\n\n    }, {\n        key: 'getIncidentsByPlugin',\n\n\n        /**\n         * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n         * tree of the Group. All Incidents are projected to the Group's timeline.\n         * The array includes the Group's projection too\n        */\n        value: function getIncidentsByPlugin() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do\n            var incidentsByPlugin = {};\n            incidentsByPlugin[this.mc_plugin_npm_name] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n\n            // if it is a self contained incident return just that\n            if (this.isTheClip) {\n                return incidentsByPlugin;\n            }\n\n            // otherwise proceed to gather the contained incidents as well\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incidentsToAdd = this.incidents[i].incident.getIncidentsByPlugin(adjustMillisecond + this.incidents[i].millisecond);\n                for (var key in incidentsToAdd) {\n                    if (incidentsByPlugin.hasOwnProperty(key)) {\n                        incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);\n                    } else {\n                        incidentsByPlugin[key] = incidentsToAdd[key];\n                    }\n                }\n            }\n            return incidentsByPlugin;\n        }\n    }, {\n        key: 'checkStateTransition',\n        value: function checkStateTransition(targetState) {\n            if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * This method returns the Incidents of each Incident in array format holding the incidents in the structure:\n            {\n                id,\n                millisecond\n                incident\n            }\n            Depending on who asks for the incidents, it might pass the adjustMillisecond argument. This argument is\n            used in case a parent Group wants to receive the Incidents of its child but by passing a correction millisecond\n            that represents the millisecond the Incident starts on its parent's timeline.\n            @param {int} adjustMillisecond\n        */\n\n    }, {\n        key: 'getProjectedIncidents',\n        value: function getProjectedIncidents() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var projectedIncidents = [];\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incidentsToAdd = this.incidents[i].incident.getProjectedIncidents(adjustMillisecond + this.incidents[i].millisecond);\n                projectedIncidents = projectedIncidents.concat(incidentsToAdd);\n            }\n            return projectedIncidents;\n        }\n\n        // ******** METHODS TO CALCULATE OVERALL DURATION OF SCENE\n        // *******************************************************\n\n        /**\n         * called when an Incident of the Scene gets affected by an edit or a deletion. The command targets the\n         * root of the scenes tree where a recalc state and a set current millisecond should take place\n         */\n\n    }, {\n        key: 'getDurationAfterIncidentAffected',\n        value: function getDurationAfterIncidentAffected() {\n            var durationBeforeChange = this.duration * 1;\n            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;\n            var stateBeforeChage = this.state + '';\n\n            var newDuration = 0;\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i];\n                if (incident.incident.duration + incident.millisecond > newDuration) {\n                    newDuration = incident.incident.duration + incident.millisecond;\n                }\n            }\n            this.duration = newDuration;\n            // helper.log('duration changed on incident: ' + this.id + '. New duration: ' + newDuration);\n            if (this.duration != durationBeforeChange) {\n                this.broadcastEvent('duration-change', { newDuration: newDuration });\n            }\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            } else {\n                this.stop();\n                this.setCurrentMillisecond(currentMillisecondBeforeChange);\n                this.recalcState(currentMillisecondBeforeChange);\n                this.restore();\n            }\n        }\n\n        /**\n         * called when an Incident gets added on the Scene\n         * @param {int} startMillisecond\n         * @param {int} incidentDuration\n         */\n\n    }, {\n        key: 'getDurationAfterIncidentAdded',\n        value: function getDurationAfterIncidentAdded(startMillisecond, incidentDuration) {\n            var durationBeforeChange = this.duration * 1;\n            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;\n            // const stateBeforeRecal = this.state + \"\";\n\n            if (startMillisecond + incidentDuration > this.calculatedDuration) {\n                this.calculatedDuration = startMillisecond + incidentDuration;\n            }\n\n            if (this.duration != durationBeforeChange) {\n                this.broadcastEvent('duration-change', { newDuration: this.duration });\n            }\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            } else {\n                this.stop();\n                this.setCurrentMillisecond(currentMillisecondBeforeChange);\n                this.recalcState(currentMillisecondBeforeChange);\n                this.restore();\n            }\n        }\n\n        // ******** INCIDENT METHODS IMPLEMENTATION **************\n        // *******************************************************\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.isHeadlessClip) {\n                return false;\n            }\n            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'play', this).call(this, props);\n        }\n\n        /** timer blocking */\n\n    }, {\n        key: 'wait',\n        value: function wait() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'wait', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (props.callerId === this.incidents[i].id) continue;\n                    this.incidents[i].incident.block(props);\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /** timer blocking */\n\n    }, {\n        key: 'block',\n        value: function block(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'block', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.block();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /** timer unblocking */\n\n    }, {\n        key: 'resume',\n        value: function resume(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'resume', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.resume();\n                }\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'reset',\n        value: function reset(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'reset', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.reset();\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'stop',\n        value: function stop(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'stop', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.stop();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n        */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState(targetMillisecondDeltaFromStart) {\n            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'recalcState', this).call(this, targetMillisecondDeltaFromStart);\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i].incident;\n                var startMillisecond = this.incidents[i].millisecond;\n                incident.recalcState(targetMillisecondDeltaFromStart - startMillisecond);\n            }\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.lastWish();\n            }\n            this.stop();\n        }\n\n        // *******************************************************\n        // SCENE SPECIFIC FUNCTIONS / HELPER FUNCTIONS\n\n    }, {\n        key: 'reverse',\n        value: function reverse(_reverse) {\n            this.reversed = _reverse;\n        }\n    }, {\n        key: 'getIncidentMillisecond',\n        value: function getIncidentMillisecond(incidentId) {\n            return conf.getMillisecondFromKeyframeKey(this.incidentsKeyframeKeys[incidentId]);\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var incidents = [];\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = {};\n                incident.millisecond = this.incidents[i].millisecond;\n                incident.incident = this.incidents[i].incident.exportState(props);\n                incident.id = this.incidents[i].id;\n                incidents.push(incident);\n            }\n\n            var state = _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'exportState', this).call(this);\n            state.incidents = incidents;\n\n            return state;\n        }\n    }, {\n        key: 'setCurrentMillisecond',\n        value: function setCurrentMillisecond(millisecond) {\n            // helper.log(`setting currentUser of ${this.id} to ${millisecond}`);\n            this.runTimeInfo.currentMillisecond = millisecond;\n\n            for (var i = 0; i < this.incidents.length; i++) {\n                var childIncident = this.incidents[i];\n\n                // if the child incident starts before the millisecond and has not ended yet\n                if (childIncident.millisecond < millisecond && childIncident.incident.duration + childIncident.millisecond > millisecond) {\n                    childIncident.incident.setCurrentMillisecond(millisecond - childIncident.millisecond);\n                } else {\n                    childIncident.incident.setCurrentMillisecond(0);\n                }\n            }\n        }\n\n        /**\n         * Returns the Incident by ID no matter if the Incident balongs directly to the Scene of to a child Scene\n         * @param {string} id - the id of the Incident to get\n        */\n\n    }, {\n        key: 'getIncidentById',\n        value: function getIncidentById(id) {\n            if (this.incidentsById.hasOwnProperty(id)) {\n                return this.incidentsById[id];\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var incident = this.incidents[i].incident.getIncidentById(id);\n                        if (incident != null) {\n                            return incident;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        // *******************************************************\n        // INCIDENTS MANAGEMENT METHODS\n        // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS\n        // A \"TRANSPARENT GROUP\"\n\n        /**\n         * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.\n         * The method takes as input the management type. On error / conflict:\n         *  - on type === 'all-or-nothing' completely discard addition of all incidents\n         *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed\n         * @param {object} incident - the incident to add\n         * @param {int} millisecond - the millisecond to add the Incident to\n         * @param {string} type - as explained above\n         * The method returns either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incident, millisecond) {\n            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"all-or-nothing\";\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip) {\n                var existingIncidentWithTheSameId = this.getIncidentById(incident.id);\n                if (existingIncidentWithTheSameId != null) {\n                    return { result: false, errors: [{ reason: 'Already existing Incident with id ' + incident.id, incident: existingIncidentWithTheSameId }] };\n                }\n\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin(millisecond);\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n\n                // for each key of the incidentsById object perform the check\n                for (var key in incidentsById) {\n                    // if the clip had no channel instantiated for the specific key (plugin id) yet create it\n                    if (!this.instantiatedChannels.hasOwnProperty(key)) {\n                        // intstantiate the channel of the plugin by using the reference to the class definition stored on\n                        // the very first incident of the array\n                        this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({\n                            runTimeInfo: this.runTimeInfo,\n                            context: this.context\n                        });\n                    }\n\n                    // perform the check\n                    var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var additionResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return additionResult;\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkAddition(incident, millisecond + this.parentSceneObject.getIncidentMillisecond(this.id), type);\n            }\n        }\n\n        /**\n         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time\n         The method should return either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will edit the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incident, millisecondsDelta) {\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip) {\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n\n                // for each key of the incidentsById object perform the check\n                for (var key in incidentsById) {\n                    // perform the check\n                    var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkEdit(incident, millisecondsDelta);\n            }\n        }\n\n        /**\n         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n          The result might be either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will remove the Incident on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentId) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip) {\n                var incident = this.getIncidentById(incidentId);\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n\n                // for each key of the incidentsById object perform the check\n                for (var key in incidentsById) {\n                    // perform the check\n                    var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key], props);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkDelete(incidentId, props);\n            }\n        }\n\n        /**\n         * It's called always by a child to Scene that wants to expand to the left to its parent.\n         * Expanding a Scene to the left means it tries to add extra (initially unsued) space (in milliseconds) before its\n         * current starting point.\n         * In order for this action to be allowed the Scene's context should allow such an expansion. This means:\n         *  - that if the Scene has no parents this expansion is not legal\n         *  - that if the root Scene of the Scene's parents tree needs to expand on the left in order to apply the expansion\n         *      then the expansion is not acceptable\n         * @param {int} howManyMilliseconds - the milliseconds to expand the Scene to the left\n         * @param {string} sceneId - the child scene id that wants to gain extra space to the left\n         * @returns {object} - the result is an object with two keys:\n         *  - the first key is the \"result\" which might either be true or false\n         *  - the second key is the \"undo\" which is a function that can undo the (approved) expansion\n        */\n\n    }, {\n        key: 'expandSceneToTheLeft',\n        value: function expandSceneToTheLeft(howManyMilliseconds, sceneId) {\n            var _this2 = this;\n\n            // First we identify the expansion within the context of the parent (this) Scene\n            var currentStartMillisecondOfTheChildScene = this.getIncidentMillisecond(sceneId);\n            var newStartMillisecondOfTheChildScene = howManyMilliseconds - currentStartMillisecondOfTheChildScene;\n\n            // Check if the expansion is allowed\n            // if the millisecons to expand are zero or less (meaning the current Scene is actually not affected by the expansion)\n            if (newStartMillisecondOfTheChildScene <= 0) {\n                var rootScene = this;\n                var changeResult = this.changeIncidentsStartMillisecond(-newStartMillisecondOfTheChildScene, sceneId);\n                var undo = function undo() {\n                    _this2.changeIncidentsStartMillisecond(changeResult.oldMillisecond, sceneId);\n                };\n                return {\n                    result: true,\n                    undo: undo,\n                    rootScene: rootScene\n                };\n            }\n\n            // if it reaches to that point that means the expansion afects the left borders of this (parent) Scene as well\n            // If it doesn't have a parent scene that means the expansion is illegal\n            if (!this.checkParentScene()) {\n                return {\n                    result: false\n                };\n            }\n\n            // if it has a parent scene and the this Scene needs to expand to the left as well then this Scene\n            // assigns the obligation to evaluate the expansion to its parent\n            var parentDecision = this.parentSceneObject.expandSceneToTheLeft(newStartMillisecondOfTheChildScene, this.id);\n            // if the parent approves the expansion\n            if (parentDecision.result === true) {\n                // TODO apply the expansion itself and bundle its undo along with the undo coming from the parent\n                this.expandStartPoint(-newStartMillisecondOfTheChildScene);\n                var overallUndo = function overallUndo() {\n                    parentDecision.undo();\n                    _this2.expandStartPoint(newStartMillisecondOfTheChildScene);\n                };\n                return {\n                    result: true,\n                    undo: overallUndo,\n                    rootScene: parentDecision.rootScene\n                };\n            } else {\n                // otherwise\n                return {\n                    result: false\n                };\n            }\n        }\n\n        /**\n         * expands or collapses the Scene's start millisecond by the given milliseconds\n         * e.g. expandStartPoint(200) will expand the Scene by 200 milliseconds to the left keeping all\n         *      of its incidents to the exact same place they were before on the overall timeline\n         * e.g. expandStartPoint(-200) will collapse the Scene, moving its start point by 200 milliseconds\n         *      to the right, again without affecting at all its Incidents' start point on the overall timeline\n         * @param {int} byMilliseconds - the number of milliseconds to expand (positive number) or collapse (minus number) number of milliseconds\n        */\n\n    }, {\n        key: 'expandStartPoint',\n        value: function expandStartPoint(byMilliseconds) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i];\n                this.changeIncidentsStartMillisecond(incident.millisecond + byMilliseconds, incident.id);\n            }\n        }\n\n        /**\n         * it alters the start millisecond of any already existing Incident of the Scene\n         * @param {int} newmillisecond - the new millisecond to place the Incident\n         * @param {string} incidentId - the incident id\n         * @returns {function} - the undo function of the change\n        */\n\n    }, {\n        key: 'changeIncidentsStartMillisecond',\n        value: function changeIncidentsStartMillisecond(newmillisecond, id) {\n            var keyframe_sec_key = this.incidentsKeyframeKeys[id];\n            //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined\n            delete this.keyframes[keyframe_sec_key][id];\n\n            if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {\n                delete this.keyframes[keyframe_sec_key];\n            }\n\n            delete this.listeners[id]; // delete the listener that currently manages the Incident's execution\n\n\n            var oldMillisecond = void 0; // the previous millisecond of the edited incident before the edit\n            for (var i = 0; i < this.incidents.length; i++) {\n                if (this.incidents[i].id === id) {\n                    oldMillisecond = this.incidents[i].millisecond * 1; // *1 to avoid reference, keep value\n                    this.incidents[i].millisecond = newmillisecond;\n                    break;\n                }\n            }\n\n            var incident = this.incidentsById[id];\n            var new_keyframe_sec_key = conf.keyframe_sec_key + newmillisecond;\n            if (!this.keyframes.hasOwnProperty(new_keyframe_sec_key)) {\n                this.keyframes[new_keyframe_sec_key] = {};\n            }\n            this.keyframes[new_keyframe_sec_key][incident.id] = incident;\n            this.incidentsKeyframeKeys[incident.id] = new_keyframe_sec_key;\n\n            // subscribe Incident start on the listeners\n            var funct = function funct(sceneMillisecond, previousTimeStamp, sceneState) {\n                if (sceneMillisecond >= newmillisecond && sceneMillisecond <= newmillisecond + incident.duration) {\n                    incident.play({ startFrom: sceneMillisecond - newmillisecond, previousTimeStamp: previousTimeStamp });\n                }\n            };\n\n            this.subscribe(incident.id, funct);\n\n            return {\n                oldMillisecond: oldMillisecond,\n                incident: incident\n            };\n        }\n\n        /**\n         * Plain groups\n            Can have on their timeline:\n            - Another plain group\n            - An incident with no selector\n            - A dom group (this method should actually turn any incident with selector to one)\n            Can’t have on their timeline:\n            - An attribute group\n         */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.props.hasOwnProperty('selector') && !incident.hasIncidents) {\n                // if the incident is not a group and it has no selector proceed normally\n                return incident;\n            } else if (incident.groupType === \"plain\") {\n                // if the Incident is a plain group proceed normally\n                return incident;\n            } else if (incident.groupType === \"attribute\") {\n                helper.error(\"Plain groups can not accept attribute groups on their timeline\");\n                return null;\n            }\n\n            // We need to turn the Incident to a DOMAwareIncident\n            // before adding it to the group\n            var DOMAwareIncident = __webpack_require__(/*! ../_responsiveness/DOMAwareIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\");\n            var theDOMAwareIncident = new DOMAwareIncident(incident);\n            return theDOMAwareIncident;\n        }\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            var result = {\n                failedAdditions: []\n            };\n            for (var i = 0; i < this.incidents.length; i++) {\n                var flashResult = this.incidents[i].incident.flashDOM();\n                result.failedAdditions = result.failedAdditions.concat(flashResult.failedAdditions);\n            }\n            return result;\n        }\n\n        /**\n        Any Scene can receive the addIncdent command either for adding an Incident on its own Incidents list or in order\n        to pass deeper the command to the parent Scene of the Incident (sceneId).\n        No matter which Scene took the command, all parent Scenes get informed\n         addIncident takes 3 arguments:\n        @param {Incident} incident - the Incident object to get added\n        @param {int} millisecond - the millisecond to which we want the Incident to get added, starting from the zero point of the\n            target Scene. It can't be negative\n        @param {string} sceneId - the sceneId to which we want to put the new Incident. It is optional and if it is not specified the\n            target Scene is the current one\n        @param {string} type - one of \"all-or-nothing\" / \"keep-passing\"\n         */\n\n    }, {\n        key: 'addIncident',\n        value: function addIncident(incident, millisecond, sceneId) {\n            var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"all-or-nothing\";\n\n            if (millisecond < 0) {\n                return {\n                    result: false,\n                    conflicts: [{\n                        type: 'minus millisecond violation'\n                    }]\n                };\n            }\n\n            var originalMillisecond = millisecond * 1; // a backup variable holding the original millisecond passed as\n            // this might change during potential left expansion manipulation\n\n            if (!sceneId || sceneId === this.id) {\n                var that = this;\n                incident = this._prepareInicdentForAddition(incident);\n\n                // when adding headless Clips to a group that has context (either because it's the clip itself or because\n                // it belongs to a clip that has context) we need to run flash the newly entered group's dom so it creates\n                // its elementIncidents\n                var flashIncidentsDOMAfterEnter = false;\n\n                if (incident.hasIncidents && incident.isHeadlessClip && this.context != null) {\n                    flashIncidentsDOMAfterEnter = true;\n                }\n\n                incident.setParentScene(that);\n\n                // check if the Incident is eligible for addition\n                var additionCheck = this.checkAddition(incident, millisecond, type);\n                if (additionCheck.result === false) {\n                    return additionCheck;\n                }\n                additionCheck.execute();\n\n                // indexing start\n                this.incidents.push({\n                    id: incident.id,\n                    incident: incident,\n                    millisecond: millisecond\n                });\n                this.incidentsById[incident.id] = incident;\n                var keyframe_sec_key = conf.keyframe_sec_key + millisecond;\n                if (!this.keyframes.hasOwnProperty(keyframe_sec_key)) {\n                    this.keyframes[keyframe_sec_key] = {};\n                }\n                this.keyframes[keyframe_sec_key][incident.id] = incident;\n                this.incidentsKeyframeKeys[incident.id] = keyframe_sec_key;\n                // indexing end\n\n                incident.executionSpeed = this.speed;\n\n                // subscribe Incident start on the listeners\n                // currentMillisecond: the millisecond the Group is on\n                // millisecond: the millisecond we set our Incident to get executed on the Group's timeline\n                var funct = function funct(currentMillisecond, previousTimeStamp, sceneState) {\n                    if (incident.speed > 0) {\n                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'idle' && currentMillisecond > millisecond) {\n                            // helper.log('greater');\n                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });\n                        }\n                    } else {\n                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'completed' && currentMillisecond < millisecond) {\n                            // helper.log('greater');\n                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });\n                        }\n                    }\n                };\n\n                this.subscribe(incident.id, funct);\n                this.getDurationAfterIncidentAdded(millisecond, incident.duration);\n\n                if (flashIncidentsDOMAfterEnter) {\n                    var result = incident.flashDOM();\n                    if (result.failedAdditions.length > 0 && type === \"all-or-nothing\") {\n                        this.removeIncident(incident.id);\n                        return {\n                            result: false,\n                            conflicts: result.failedAdditions\n                        };\n                    } else {\n                        // if flashing incident's DOM passes let the Incident know that\n                        // it now has context\n                        incident._onGetContextOnce();\n                        this.onAddIncident(incident, millisecond);\n                        helper.notice('incident added');\n\n                        return {\n                            result: true\n                        };\n                    }\n                } else {\n                    this.onAddIncident(incident, millisecond);\n                    helper.notice('incident added');\n                    return { result: true };\n                }\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        if (this.incidents[i].incident.addIncident(incident, millisecond - this.incidents[i].millisecond, sceneId).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n        Any Scene can receive the editIncident command in order to set a new starting point for one of its own Incidents or to\n        pass the command deeper down to its children Scenes so the parent of it can take care of it.\n        The Incident object and id remain the same after the edit.\n        No matter which Scene takes the command, all Parents get infomed about the edit.\n         It takes two params:\n         @param {string} id - the id of the incident to be edited\n         @param {int} newmillisecond - the new position of the Incident compared to the target Scene start (and not to the Scene it belongs)\n         */\n\n    }, {\n        key: 'editIncident',\n        value: function editIncident(id, newmillisecond) {\n            var expansionValidation = null;\n            var originalMillisecond = newmillisecond * 1;\n\n            if (!helper.isString(id)) {\n                helper.error('editIncident method of Group expects as its first argument the id of the Incident to edit in string format. ' + (typeof id === 'undefined' ? 'undefined' : _typeof(id)) + ' passed');\n                return {\n                    result: false,\n                    conflicts: [{\n                        type: 'wrong parameter type'\n                    }]\n                };\n            }\n\n            if (this.incidentsById[id]) {\n                var existingMillisecond = this.getIncidentMillisecond(id);\n                var millisecondDelta = newmillisecond - existingMillisecond;\n                // first check for minus expansion\n                if (newmillisecond < 0) {\n                    // if the Scene doesn't have a parent then it is the root and thus it can't expand to the left\n                    if (!this.checkParentScene()) {\n                        return {\n                            result: false,\n                            conflicts: [{\n                                type: 'minus millisecond violation'\n                            }]\n                        };\n                    }\n\n                    expansionValidation = this.parentSceneObject.expandSceneToTheLeft(-newmillisecond, this.id);\n                    if (expansionValidation.result === false) {\n                        return {\n                            result: false,\n                            conflicts: [{\n                                type: 'minus millisecond violation'\n                            }]\n                        };\n                    } else {\n                        newmillisecond = 0;\n                    }\n                } // end of if millisecond < 0\n\n                // if the edit is allowed (thus we come to that point) and the originalMillisecond is lower than 0\n                if (originalMillisecond < 0) {\n                    this.expandStartPoint(-originalMillisecond);\n                }\n\n                this.incidentsById[id].stop();\n\n                var editCheck = this.checkEdit(this.incidentsById[id], millisecondDelta);\n                if (editCheck.result === false) {\n                    helper.error(editCheck);\n                    if (expansionValidation !== null) {\n                        expansionValidation.undo();\n                        this.expandStartPoint(originalMillisecond);\n                    }\n                    return editCheck;\n                }\n\n                editCheck.execute();\n\n                var editIncidentStartResult = this.changeIncidentsStartMillisecond(newmillisecond, id);\n\n                this.getDurationAfterIncidentAffected();\n\n                this.onEditIncident(this.incidentsById[id], editIncidentStartResult.oldMillisecond, newmillisecond);\n\n                return { result: true };\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        if (this.incidents[i].incident.editIncident(id, newmillisecond - this.incidents[i].millisecond).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n        Any Scene can receive the removeIncident command either for removing one of its own Incidents or for passing the command\n        deeper down to its Scenes tree and have the Incident deleted no matter to which child Scene it belongs\n        No matter which Scene took the command, all parent Scenes get informed\n         It takes just one argument:\n        @param {string} id - the id of the Incident to be deleted\n        @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n         */\n\n    }, {\n        key: 'removeIncident',\n        value: function removeIncident(id) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            if (this.incidentsById[id]) {\n                var deleteCheck = this.checkDelete(id, props);\n                if (deleteCheck.result === false) {\n                    helper.error(deleteCheck);\n                    return deleteCheck;\n                }\n\n                deleteCheck.execute();\n\n                this.incidentsById[id].lastWish();\n\n                var keyframe_sec_key = this.incidentsKeyframeKeys[id];\n                //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined\n                delete this.incidentsKeyframeKeys[id];\n                delete this.keyframes[keyframe_sec_key][id];\n                delete this.incidentsById[id];\n                if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {\n                    delete this.keyframes[keyframe_sec_key];\n                }\n                delete this.listeners[id]; // delete the listener that manages the Incident's execution\n\n                var deletedIncident = void 0;\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].id === id) {\n                        deletedIncident = this.incidents.splice(i, 1);\n                        break;\n                    }\n                }\n\n                this.getDurationAfterIncidentAffected();\n                this.onRemoveIncident(deletedIncident[0]);\n\n                return { result: true };\n            } else {\n                for (var _i = 0; _i < this.incidents.length; _i++) {\n                    if (this.incidents[_i].incident.hasIncidents) {\n                        if (this.incidents[_i].incident.removeIncident(id).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n         * This method which is provided only by Groups accepts an incidentId and a new duration and \n         * edits the duration of the corresponding incident accordingly\n         * @param {string} incidentId - the id of the incident to resize\n         * @param {int} newDuration - the new duration of the incident in milliseconds\n        */\n\n    }, {\n        key: 'resizeIncident',\n        value: function resizeIncident(incidentId, newDuration) {\n            var existingIncident = this.getIncidentById(incidentId);\n            if (existingIncident === null) {\n                return { result: false, errors: [{ reason: 'The incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups' }] };\n            }\n            return existingIncident.resize(newDuration);\n        }\n\n        /**\n         * This method which is provided only by Groups accepts an incidentId and a new attrs object \n         * and edits the attributes of the corresponding incident accordingly\n         * If the attribute editing ends up with conflicts the edit is discarded.\n         * @param {string} incidentId - the id of the incident to resize\n         * @param {int} attrs - the new attrs of the Incident\n        */\n\n    }, {\n        key: 'editIncidentAttributes',\n        value: function editIncidentAttributes(incidentId, attrs) {\n            var directParent = this._getDirectParent(incidentId);\n            if (directParent === null) {\n                return {\n                    result: false,\n                    errors: ['The Incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups']\n                };\n            }\n            return directParent._editChildIncidentAttributes(incidentId, attrs);\n        }\n\n        /**\n         * By this method a Group tries to edit the attributes of one of its children. The process goes as follows:\n         * 1. The Group gets an export of the Incident's state\n         * 2. The Group deletes the Incident\n         * 3. The Group tries to create a new Incident with the same id as the old one and with type=\"all-or-nothing\"\n         * 4.a. If the new Incident gets added ok process finishes\n         * 4.b. If the new Incident doesn't get added because of conflicts the previous Incident gets back in\n         * @param {string} incidentId - the id of the Incident to edit its attrs\n         * @param {object} attrs - the new attributes of the Incident\n        */\n\n    }, {\n        key: '_editChildIncidentAttributes',\n        value: function _editChildIncidentAttributes(incidentId, attrs) {\n            var incidentToEdit = this.getIncidentById(incidentId);\n            var existingIncidentDefinition = incidentToEdit.exportState();\n            var millisecond = this.getIncidentMillisecond(incidentId);\n            this.removeIncident(incidentId);\n            var newIncidentProps = Object.assign({}, existingIncidentDefinition.props);\n            var newIncident = new existingIncidentDefinition.Incident(attrs, newIncidentProps);\n            var result = this.addIncident(newIncident, millisecond);\n            if (result.result === false) {\n                var myOldIncident = new existingIncidentDefinition.Incident(existingIncidentDefinition.attrs, newIncidentProps);\n                this.addIncident(myOldIncident, millisecond);\n                return result;\n            } else {\n                return {\n                    result: true\n                };\n            }\n        }\n\n        /**\n         * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the\n         * Incidents\n         * @param {float} durationFraction the fraction of the new duration to the existing duration\n        **/\n\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            this.calculatedDuration = durationFraction * this.duration;\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.changeIncidentsStartMillisecond(this.incidents[i].millisecond * durationFraction, this.incidents[i].incident.id);\n                this.incidents[i].incident.systolDiastole(durationFraction);\n            }\n\n            // if it is a Clip all Channels of it should get resized\n            if (this.isTheClip) {\n                for (var key in this.instantiatedChannels) {\n                    this.instantiatedChannels[key]._resize(durationFraction);\n                }\n            }\n        }\n\n        // THE \"EARS\" OF THE SCENE TO ITS CHILD INCIDENTS\n        /**\n              NEW STATE CALCULATION RULES:\n              If a Scene has at least one clipBlockingWaiting (meaning the full Clip is halted at the moment) the Scene’s state will be “clipBlockingWaiting” unless it is the Clip so its state will be “waiting”.\n              If a Scene has all children on the completed state, the Scene has the completed state as well.\n              If a Scene has at least one of its children on one of the following states:\n                    waiting     it has started playing and has been halted internally\n                    playing     it has started playing\n                    idle            it has not been executed yet\n              the Scene is on playing state\n               */\n\n    }, {\n        key: 'incidentStateChange',\n        value: function incidentStateChange(id, oldState, newState, props) {\n            if (newState === 'clipBlockingWaiting' || newState === 'sceneBlockingWaiting') {\n                var propsToPass = props;\n                propsToPass.callerId = id;\n                if (newState === 'sceneBlockingWaiting') {\n                    // stop propagation as this should only affect the Scene and not its parents\n                    props.waitingStateName = 'waiting';\n                }\n                this.wait(propsToPass);\n            } else if (newState === 'completed' && this.speed > 0) {\n                // helper.log('Incident ' + id + ' got into completed state');\n                // helper.log('Incident ' + this.id + ' takes care of it');\n                var allCompleted = true;\n                // helper.log('going to iterate on all Incidents');\n                for (var i = 0; i < this.incidents.length; i++) {\n                    // helper.log(\n                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state\n                    // );\n                    if (this.incidents[i].incident.state != 'completed') {\n                        allCompleted = false;\n                        break;\n                    }\n                }\n                if (allCompleted) {\n                    this.complete();\n                }\n            } else if (newState === 'idle' && this.speed < 0) {\n                // helper.log('Incident ' + id + ' got into completed state');\n                // helper.log('Incident ' + this.id + ' takes care of it');\n                var _allCompleted = true;\n                // helper.log('going to iterate on all Incidents');\n                for (var _i2 = 0; _i2 < this.incidents.length; _i2++) {\n                    // helper.log(\n                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state\n                    // );\n                    if (this.incidents[_i2].incident.state != 'idle') {\n                        _allCompleted = false;\n                        break;\n                    }\n                }\n                if (_allCompleted) {\n                    this.complete();\n                }\n            } else {\n                // in case the child was either on sceneBlockingWaiting or clipBlockingWaiting and now is changing\n                this.resume();\n            }\n        }\n\n        /*\n        BLOCK WAITINGS MANIPULATION METHODS\n        */\n        /**\n        @param {object} props -\n        the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - channelBlockingWaiting\n             - clipBlockingWaiting\n        id: the id of the triggering Incident\n        */\n\n    }, {\n        key: 'setBlockWaiting',\n        value: function setBlockWaiting(props) {\n            if (props.waitingStateName === 'sceneBlockingWaiting') {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else if (props.waitingStateName === 'channelBlockingWaiting' && this.isChannel) {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else if (props.waitingStateName === 'clipBlockingWaiting' && this.isTheClip) {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.setBlockWaiting(props);\n                }\n            }\n        }\n\n        /**\n         @param {object} props -\n        the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - channelBlockingWaiting\n             - clipBlockingWaiting\n        id: the id of the triggering Incident\n        */\n\n    }, {\n        key: 'unsetBlockWaiting',\n        value: function unsetBlockWaiting(props) {\n            if (props.waitingStateName === 'sceneBlockingWaiting') {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else if (props.waitingStateName === 'channelBlockingWaiting' && this.isChannel) {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else if (props.waitingStateName === 'clipBlockingWaiting' && this.isTheClip) {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.unsetBlockWaiting(props);\n                }\n            }\n        }\n\n        /**\n         * it checks if a block with the provided props exists on its blockingWaitings array\n         * if it exists it removes it.\n         * If the remaining blocking waitings are equal to 0 it returns true otherwise it returns false\n        */\n\n    }, {\n        key: 'removeBlock',\n        value: function removeBlock(props) {\n            var newBlockingWaitings = [];\n            var found = false;\n            for (var i = 0; i < this.blockingWaitings.length; i++) {\n                var bWaiting = this.blockingWaitings[i];\n                if (bWaiting.id === props.id) {\n                    found = true;\n                    continue;\n                }\n                newBlockingWaitings.push(this.blockingWaitings[i]);\n            }\n\n            this.blockingWaitings = newBlockingWaitings;\n            return found;\n        }\n\n        /**\n         * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.\n         * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo\n         * by passing the command to its Channels.\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            if (millisecond > this.duration) {\n                millisecond = this.duration;\n            } else if (millisecond < 0) {\n                millisecond = 0;\n            }\n\n            if (this.isTheClip) {\n                for (var key in this.instantiatedChannels) {\n                    this.instantiatedChannels[key].goTo(millisecond, props);\n                }\n                return true;\n            } else if (this.isHeadlessClip) {\n                return false;\n            } else {\n                props.relativeTo = this.id;\n                if (this.parentSceneObject.goTo(millisecond, props)) {\n                    return true;\n                }\n            }\n        }\n\n        /**\n         * when the Group is on test mode (this.isOnTestMode = true) the emulateStep method\n         * becomes functional.\n         * The method takes as input the millisecondsDelta from the previous timestamp and triggers\n         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run\n         * passing a timestamp that has exactly millisecondsDelta difference from the previous one\n         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one\n        */\n\n    }, {\n        key: 'emulateStep',\n        value: function emulateStep(millisecondsDelta) {\n            if (!this.isOnTestMode) {\n                helper.error('emulateStep method can only be used on test mode');\n            } else {\n                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);\n                for (var i = 0; i < this.incidents.length; i++) {\n                    var childIncident = this.incidents[i];\n\n                    if (childIncident.incident.state === \"playing\") {\n                        childIncident.incident.emulateStep(Math.abs((this.runTimeInfo.currentMillisecond - childIncident.millisecond - childIncident.incident.runTimeInfo.currentMillisecond) / this.speed));\n                    }\n                }\n            }\n        }\n\n        /**\n         * The Scene receives this command from its chilren and the purpose of it is to help the caller\n         * identify the milliseconds delta of its start compared to the root Scene of it.\n         * In a multi-level situation with Scenes within scenes the Scene that receives this command might not own\n         * the Incident that triggered this thread directly. That's why we use the extraDelta helping parameter that\n         * actually delivers level by level the delta of the triggering Incident within the tree\n         * @param {string} incidentId = the id of the child incident of the scene that trigerred the method\n         * @param {int} extraDelta - the extra delta to add to the result\n        **/\n\n    }, {\n        key: 'getRootCurrentMillisecondDeltaFromIncidentsStart',\n        value: function getRootCurrentMillisecondDeltaFromIncidentsStart(incidentId) {\n            var extraDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            // first step find the start millisecond of the incident\n            var incidentMillisecond = this.getIncidentMillisecond(incidentId);\n            if (!this.checkParentScene()) {\n                return this.runTimeInfo.currentMillisecond - incidentMillisecond - extraDelta;\n            } else {\n                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id, incidentMillisecond + extraDelta);\n            }\n        }\n\n        /*\n        CALLBACKS AFTER SUCCESSFUL ADDING / EDITING / DELETING AN INCIDENT\n         */\n\n    }, {\n        key: 'onAddIncident',\n        value: function onAddIncident(incident, millisecond) {}\n    }, {\n        key: 'onEditIncident',\n        value: function onEditIncident(incident, oldMillisecond, newMillisecond) {}\n    }, {\n        key: 'onRemoveIncident',\n        value: function onRemoveIncident(incident) {}\n\n        // on Groups there is no need to prevent re-invoking the onGetContext method\n\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            this.onGetContext();\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident._onGetContextOnce();\n            }\n        }\n    }, {\n        key: 'duration',\n        get: function get() {\n            return this.calculatedDuration;\n        },\n        set: function set(duration) {\n            this.calculatedDuration = duration;\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"plain\";\n        }\n    }, {\n        key: 'projectedIncidents',\n        get: function get() {\n            return this.getProjectedIncidents();\n        }\n    }, {\n        key: 'executionSpeed',\n        set: function set(speed) {\n            helper.notice(this.id + ' is setting its execution speed to: ' + speed + ' while on millisecond: ' + this.runTimeInfo.currentMillisecond);\n            if (speed === 0) {\n                helper.error(\"Speed can't be 0\");\n                return false;\n            }\n\n            this.speed = speed;\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.executionSpeed = speed;\n            }\n        }\n    }, {\n        key: 'isHeadlessClip',\n        get: function get() {\n            return !this.checkParentScene() && !this.isTheClip;\n        }\n    }, {\n        key: 'context',\n        get: function get() {\n            if (this.isTheClip) {\n                return this.ownContext;\n            } else if (this.isHeadlessClip) {\n                return null;\n            } else {\n                return this.parentSceneObject.context;\n            }\n        }\n    }]);\n\n    return Group;\n}(TimedIncident);\n\nmodule.exports = Group;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvR3JvdXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvR3JvdXAuanM/NjkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBUaW1lZEluY2lkZW50ID0gcmVxdWlyZSgnLi9UaW1lZEluY2lkZW50Jyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBjaGVja1RyYW5zaXRpb24gPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2FsbG93ZWRTdGF0ZUNoYW5nZXMnKS5jaGVja1RyYW5zaXRpb247XG5cbi8qKiBAY2xhc3NkZXNjXG4gKiBBIFNjZW5lIGlzIGEgVGltZUluY2lkZW50IHRoYXQgY2FuIGhhdmUgb3RoZXIgSW5jaWRlbnRzIChhbnkga2luZCBvZikgb24gaXRzIHRpbWVsaW5lIGFuZCBpdHMgc3RhdGUgbWFpbmx5IGRlcml2ZXNcbiAqIGZyb20gdGhlIHN0YXRlIG9mIGl0cyBpbmNpZGVudHMgcmF0aGVyIHRoYW4gaXRzZWxmLlxuICovXG5cbnZhciBHcm91cCA9IGZ1bmN0aW9uIChfVGltZWRJbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhHcm91cCwgX1RpbWVkSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gR3JvdXAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBvbGRQcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR3JvdXApO1xuXG4gICAgICAgIHZhciBhdHRyc1RvUGFzcyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHByb3BzVG9QYXNzID0gdm9pZCAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJZiB0aGUgdXNlciBkb2Vzbid0IHBhc3MgYSBzZWNvbmQgYXJndW1lbnQgb24gdGhlIGNvbnN0cnVjdG9yIHRoZW4gdGhpcyBpcyBcbiAgICAgICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICAgICAqL1xuICAgICAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzVG9QYXNzID0ge307XG4gICAgICAgICAgICBwcm9wc1RvUGFzcyA9IHByb3BzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZWxzZSwgaW4gY2FzZSB0aGUgdXNlciBoYXMgcGFzc2VkIHR3byBhcmd1bWVudHMgdGhlbiBib3RoIHNob3VsZCBiZSB1c2VkXG4gICAgICAgICAgICBhdHRyc1RvUGFzcyA9IHByb3BzO1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3MgPSBvbGRQcm9wcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChHcm91cC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwKSkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1Bhc3MpKTtcblxuICAgICAgICBfdGhpcy5oYXNJbmNpZGVudHMgPSB0cnVlO1xuICAgICAgICBfdGhpcy5pc0NoYW5uZWwgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICBrZXlmcmFtZXMgYXJlIHNwZWNpYWwgcG9pbnRzIG9uIHRoZSBTY2VuZSdzIHRpbWUgd2hlcmUgSW5jaWRlbnRzIHNob3VsZCBiZSBleGVjdXRlZFxuICAgICAgICAgIFRoZSBrZXlzIG9mIHRoZSBrZXlmcmFtZXMgYXJyYXkgYXJlIHRoZSBtaWxsaXNlY29uZCBvbiB3aGljaCB0aGUga2V5ZnJhbWVzIHNob3VsZCBnZXQgZXhlY3V0ZWQ6XG4gICAgICAgICAgZS5nLjpcbiAgICAgICAgICBrZXlmcmFtZXMgPSB7XG4gICAgICAgICAgICAgICAgc2VjXzIwMDA6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRfaWQ6IEluY2lkZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudF9pZDogSW5jaWRlbnRPYmplY3QsXG4gICAgICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgfVxuICAgICAgICAgICovXG4gICAgICAgIF90aGlzLmtleWZyYW1lcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgIEFuIG9iamVjdCBob2xkaW5nIHRoZSBtYXBwaW5nIGluY2lkZW50aWQgLyBrZXlmcmFtZWtleSwgZnJvbSB3aGljaCB3ZSBjYW4gZ2V0IHRoZSBrZXlmcmFtZSBpZCBhcyBkZWZpbmVkIG9uXG4gICAgICAgICAgdGhlIHRoaXMua2V5ZnJhbWVzIG9iamVjdCB3aGVyZSB0aGUgaW5jaWRlbnQgYmVsb25ncyB0b1xuICAgICAgICAgIGUuZy46XG4gICAgICAgICAgaW5jaWRlbnRzS2V5ZnJhbWVLZXlzID0ge1xuICAgICAgICAgICAgICAgIGluY2lkZW50aWQ6IHNlY18yMDAwLFxuICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgIH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5jaWRlbnRzS2V5ZnJhbWVLZXlzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgVGhlIGFycmF5IGhvbGRzIHRoZSBJbmNpZGVudHMgb2YgdGhlIFNjZW5lIG9uIHRoZSBmb3JtYXQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkIC8vIHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQgb2JqZWN0XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQgLy8gdGhlIGluY2lkZW50IG9iamVjdFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kIC8vIHRoZSBtaWxsaXNlY29uZCB0aGUgaW5jaWRlbnQgc2hvdWxkIGJlIGV4ZWN1dGVkXG4gICAgICAgICAgfVxuICAgICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbmNpZGVudHMgPSBbXTtcblxuICAgICAgICAvKlxuICAgICAgICBhbiBvYmplY3QgLyBhc3NvY2lhdGl2ZSBhcnJheSBob2xkaW5nIGFsbCBJbmNpZGVudHMgaW4gdGhlIGZvcm06XG4gICAgICAgIDxpbmNpZGVudF9pZD46IEluY2lkZW50IG9iamVjdFxuICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5jaWRlbnRzQnlJZCA9IHt9O1xuXG4gICAgICAgIF90aGlzLmNhbGN1bGF0ZWREdXJhdGlvbiA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjbmFubmVscyBhdHRyaWJ1dGUgaG9sZHMgYSBsaXN0IG9mIGFsbCBpbnRhbnRpYXRlZCBDaGFubmVscyBvZiB0aGUgSW5jaWRlbnRzIGJlbG9uZ2luZyB0byB0aGUgY2xpcFxuICAgICAgICAgKiB0aGlzIGF0dHJpYnV0ZSBpcyBvbmx5IHZhbHVhYmxlIHdoZW4gdGhlIEdyb3VwIGJlY29tZXMgdGhlIENsaXBcbiAgICAgICAgICogVGhlIGZvcm1hdCBvZiB0aGUgYXR0cmlidXRlIGlzOlxuICAgICAgICAgKiAga2V5LXZhbHVlIHBhaXJzIGluIHRoZSBtYW5uZXI6XG4gICAgICAgICAqIDxtY19wbHVnaW5fbnBtX25hbWU+OiBDaGFubmVsIG9iamVjdFxuICAgICAgICAqL1xuICAgICAgICBfdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscyA9IHt9O1xuXG4gICAgICAgIF90aGlzLmlzVGhlQ2xpcCA9IGZhbHNlO1xuXG4gICAgICAgIF90aGlzLm9uR3JvdXBJbml0aWFsaXNlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoR3JvdXAsIFt7XG4gICAgICAgIGtleTogJ29uR3JvdXBJbml0aWFsaXNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uR3JvdXBJbml0aWFsaXNlKCkge1xuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gZ3JvdXAgZ2V0cyBpbml0aWFsaXNlZFxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0Q2hhbm5lbCcsXG5cblxuICAgICAgICAvKlxuICAgICAgICByZXR1cm5zIHRoZSBpbml0aWFsaXNlZCBjaGFubmVsIGJ5IHRoZSBDbGlwIHRoZSBJbmNpZGVudCBiZWxvbmdzIHRvXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2hhbm5lbChtY19wbHVnaW5fbnBtX25hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0Ll9nZXRDaGFubmVsKG1jX3BsdWdpbl9ucG1fbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgcmV0dXJuIHRoZSBkaXJlY3QgcGFyZW50IG9mIGEgc3BlY2lmaWMgSW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldERpcmVjdFBhcmVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0RGlyZWN0UGFyZW50KGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c0J5SWQuaGFzT3duUHJvcGVydHkoaW5jaWRlbnRJZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGlyZWN0UGFyZW50ID0gdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuX2dldERpcmVjdFBhcmVudChpbmNpZGVudElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3RQYXJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3RQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYWxsIG9mIGl0cyBJbmNpZGVudHMgKG5vdCBncm91cHMpIGluIGEgY29sbGVjdGlvbiBvZiB0aGUgZm9ybTpcbiAgICAgICAgICoge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5jaWRlbnRzQnlQbHVnaW4nLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGgga2V5cyB0aGUga2V5cyBvZiBhbGwgdGhlIHBsdWdpbnMgSW5jaWRlbnRzIG9mIHdoaWNoIGFwcGVhciBpbiB0aGVcbiAgICAgICAgICogdHJlZSBvZiB0aGUgR3JvdXAuIEFsbCBJbmNpZGVudHMgYXJlIHByb2plY3RlZCB0byB0aGUgR3JvdXAncyB0aW1lbGluZS5cbiAgICAgICAgICogVGhlIGFycmF5IGluY2x1ZGVzIHRoZSBHcm91cCdzIHByb2plY3Rpb24gdG9vXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeVBsdWdpbigpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgICAgICAgICAgLy8gaW5pdGlhbGx5IGl0IG9ubHkgcHV0cyBpdHNlbGYgb250aGUgaW5jaWRlbnRzQnlQbHVnaW4gYXJyYXksIGV4YWN0bHkgYXMgdGhlIHBsYWluIEluY2lkZW50cyBkb1xuICAgICAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0ge307XG4gICAgICAgICAgICBpbmNpZGVudHNCeVBsdWdpblt0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZV0gPSBbe1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBhZGp1c3RNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogdGhpcyxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgICAgfV07XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgc2VsZiBjb250YWluZWQgaW5jaWRlbnQgcmV0dXJuIGp1c3QgdGhhdFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgcHJvY2VlZCB0byBnYXRoZXIgdGhlIGNvbnRhaW5lZCBpbmNpZGVudHMgYXMgd2VsbFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudHNUb0FkZCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmdldEluY2lkZW50c0J5UGx1Z2luKGFkanVzdE1pbGxpc2Vjb25kICsgdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudHNUb0FkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5jaWRlbnRzQnlQbHVnaW4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5ba2V5XSA9IGluY2lkZW50c0J5UGx1Z2luW2tleV0uY29uY2F0KGluY2lkZW50c1RvQWRkW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5ba2V5XSA9IGluY2lkZW50c1RvQWRkW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5jaWRlbnRzQnlQbHVnaW47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrU3RhdGVUcmFuc2l0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU3RhdGVUcmFuc2l0aW9uKHRhcmdldFN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tUcmFuc2l0aW9uKHRoaXMucnVuVGltZUluZm8uc3RhdGUsIHRhcmdldFN0YXRlLCB0aGlzLmRpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIEluY2lkZW50cyBvZiBlYWNoIEluY2lkZW50IGluIGFycmF5IGZvcm1hdCBob2xkaW5nIHRoZSBpbmNpZGVudHMgaW4gdGhlIHN0cnVjdHVyZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBEZXBlbmRpbmcgb24gd2hvIGFza3MgZm9yIHRoZSBpbmNpZGVudHMsIGl0IG1pZ2h0IHBhc3MgdGhlIGFkanVzdE1pbGxpc2Vjb25kIGFyZ3VtZW50LiBUaGlzIGFyZ3VtZW50IGlzXG4gICAgICAgICAgICB1c2VkIGluIGNhc2UgYSBwYXJlbnQgR3JvdXAgd2FudHMgdG8gcmVjZWl2ZSB0aGUgSW5jaWRlbnRzIG9mIGl0cyBjaGlsZCBidXQgYnkgcGFzc2luZyBhIGNvcnJlY3Rpb24gbWlsbGlzZWNvbmRcbiAgICAgICAgICAgIHRoYXQgcmVwcmVzZW50cyB0aGUgbWlsbGlzZWNvbmQgdGhlIEluY2lkZW50IHN0YXJ0cyBvbiBpdHMgcGFyZW50J3MgdGltZWxpbmUuXG4gICAgICAgICAgICBAcGFyYW0ge2ludH0gYWRqdXN0TWlsbGlzZWNvbmRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0UHJvamVjdGVkSW5jaWRlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2plY3RlZEluY2lkZW50cygpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgICAgICAgICAgdmFyIHByb2plY3RlZEluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudHNUb0FkZCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmdldFByb2plY3RlZEluY2lkZW50cyhhZGp1c3RNaWxsaXNlY29uZCArIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICBwcm9qZWN0ZWRJbmNpZGVudHMgPSBwcm9qZWN0ZWRJbmNpZGVudHMuY29uY2F0KGluY2lkZW50c1RvQWRkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9qZWN0ZWRJbmNpZGVudHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKioqKiBNRVRIT0RTIFRPIENBTENVTEFURSBPVkVSQUxMIERVUkFUSU9OIE9GIFNDRU5FXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbGVkIHdoZW4gYW4gSW5jaWRlbnQgb2YgdGhlIFNjZW5lIGdldHMgYWZmZWN0ZWQgYnkgYW4gZWRpdCBvciBhIGRlbGV0aW9uLiBUaGUgY29tbWFuZCB0YXJnZXRzIHRoZVxuICAgICAgICAgKiByb290IG9mIHRoZSBzY2VuZXMgdHJlZSB3aGVyZSBhIHJlY2FsYyBzdGF0ZSBhbmQgYSBzZXQgY3VycmVudCBtaWxsaXNlY29uZCBzaG91bGQgdGFrZSBwbGFjZVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb25CZWZvcmVDaGFuZ2UgPSB0aGlzLmR1cmF0aW9uICogMTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWlsbGlzZWNvbmRCZWZvcmVDaGFuZ2UgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAqIDE7XG4gICAgICAgICAgICB2YXIgc3RhdGVCZWZvcmVDaGFnZSA9IHRoaXMuc3RhdGUgKyAnJztcblxuICAgICAgICAgICAgdmFyIG5ld0R1cmF0aW9uID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5jaWRlbnQuaW5jaWRlbnQuZHVyYXRpb24gKyBpbmNpZGVudC5taWxsaXNlY29uZCA+IG5ld0R1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0R1cmF0aW9uID0gaW5jaWRlbnQuaW5jaWRlbnQuZHVyYXRpb24gKyBpbmNpZGVudC5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gbmV3RHVyYXRpb247XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdkdXJhdGlvbiBjaGFuZ2VkIG9uIGluY2lkZW50OiAnICsgdGhpcy5pZCArICcuIE5ldyBkdXJhdGlvbjogJyArIG5ld0R1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmR1cmF0aW9uICE9IGR1cmF0aW9uQmVmb3JlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RFdmVudCgnZHVyYXRpb24tY2hhbmdlJywgeyBuZXdEdXJhdGlvbjogbmV3RHVyYXRpb24gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlsbGlzZWNvbmQoY3VycmVudE1pbGxpc2Vjb25kQmVmb3JlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY1N0YXRlKGN1cnJlbnRNaWxsaXNlY29uZEJlZm9yZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogY2FsbGVkIHdoZW4gYW4gSW5jaWRlbnQgZ2V0cyBhZGRlZCBvbiB0aGUgU2NlbmVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0TWlsbGlzZWNvbmRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGluY2lkZW50RHVyYXRpb25cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFkZGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFkZGVkKHN0YXJ0TWlsbGlzZWNvbmQsIGluY2lkZW50RHVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBkdXJhdGlvbkJlZm9yZUNoYW5nZSA9IHRoaXMuZHVyYXRpb24gKiAxO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRNaWxsaXNlY29uZEJlZm9yZUNoYW5nZSA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgICAgICAgIC8vIGNvbnN0IHN0YXRlQmVmb3JlUmVjYWwgPSB0aGlzLnN0YXRlICsgXCJcIjtcblxuICAgICAgICAgICAgaWYgKHN0YXJ0TWlsbGlzZWNvbmQgKyBpbmNpZGVudER1cmF0aW9uID4gdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbiA9IHN0YXJ0TWlsbGlzZWNvbmQgKyBpbmNpZGVudER1cmF0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiAhPSBkdXJhdGlvbkJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ2R1cmF0aW9uLWNoYW5nZScsIHsgbmV3RHVyYXRpb246IHRoaXMuZHVyYXRpb24gfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlsbGlzZWNvbmQoY3VycmVudE1pbGxpc2Vjb25kQmVmb3JlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY2FsY1N0YXRlKGN1cnJlbnRNaWxsaXNlY29uZEJlZm9yZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKioqKiBJTkNJREVOVCBNRVRIT0RTIElNUExFTUVOVEFUSU9OICoqKioqKioqKioqKioqXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGxheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNIZWFkbGVzc0NsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdwbGF5JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogdGltZXIgYmxvY2tpbmcgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd2FpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YWl0KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ3dhaXQnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmNhbGxlcklkID09PSB0aGlzLmluY2lkZW50c1tpXS5pZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmJsb2NrKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogdGltZXIgYmxvY2tpbmcgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2socHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdibG9jaycsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5ibG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiB0aW1lciB1bmJsb2NraW5nICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdyZXN1bWUnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldChwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ3Jlc2V0JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdzdG9wJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBhcmFtZXRlciBpdCB0YWtlcyBpcyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBJbmNpZGVudCBpdHNlbGYgYW5kIGl0IG1pZ2h0IGJlIG5lZ2F0aXZlXG4gICAgICAgICAqIE5lZ2F0aXZlIHRhcmdldE1pbGxpc2Vjb25kIG1lYW5zIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgaXMgTiBtaWxsaXNlY29uZHMgQkVGT1JFIHRoZSBzdGFydCBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgLSB0aGUgZGVsdGEgb2YgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBjb21wYXJlZCB0byB0aGUgSW5jaWRlbnQgc3RhcnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjYWxjU3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjYWxjU3RhdGUodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCkge1xuICAgICAgICAgICAgX2dldChHcm91cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCAncmVjYWxjU3RhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQucmVjYWxjU3RhdGUodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCAtIHN0YXJ0TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYXN0V2lzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5sYXN0V2lzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIFNDRU5FIFNQRUNJRklDIEZVTkNUSU9OUyAvIEhFTFBFUiBGVU5DVElPTlNcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmV2ZXJzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlcnNlKF9yZXZlcnNlKSB7XG4gICAgICAgICAgICB0aGlzLnJldmVyc2VkID0gX3JldmVyc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50TWlsbGlzZWNvbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpbmNpZGVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4gY29uZi5nZXRNaWxsaXNlY29uZEZyb21LZXlmcmFtZUtleSh0aGlzLmluY2lkZW50c0tleWZyYW1lS2V5c1tpbmNpZGVudElkXSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFN0YXRlKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIGluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudCA9IHt9O1xuICAgICAgICAgICAgICAgIGluY2lkZW50Lm1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuaW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5leHBvcnRTdGF0ZShwcm9wcyk7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuaWQgPSB0aGlzLmluY2lkZW50c1tpXS5pZDtcbiAgICAgICAgICAgICAgICBpbmNpZGVudHMucHVzaChpbmNpZGVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ2V4cG9ydFN0YXRlJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHN0YXRlLmluY2lkZW50cyA9IGluY2lkZW50cztcblxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRDdXJyZW50TWlsbGlzZWNvbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudE1pbGxpc2Vjb25kKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKGBzZXR0aW5nIGN1cnJlbnRVc2VyIG9mICR7dGhpcy5pZH0gdG8gJHttaWxsaXNlY29uZH1gKTtcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRJbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNoaWxkIGluY2lkZW50IHN0YXJ0cyBiZWZvcmUgdGhlIG1pbGxpc2Vjb25kIGFuZCBoYXMgbm90IGVuZGVkIHlldFxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kIDwgbWlsbGlzZWNvbmQgJiYgY2hpbGRJbmNpZGVudC5pbmNpZGVudC5kdXJhdGlvbiArIGNoaWxkSW5jaWRlbnQubWlsbGlzZWNvbmQgPiBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEluY2lkZW50LmluY2lkZW50LnNldEN1cnJlbnRNaWxsaXNlY29uZChtaWxsaXNlY29uZCAtIGNoaWxkSW5jaWRlbnQubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkSW5jaWRlbnQuaW5jaWRlbnQuc2V0Q3VycmVudE1pbGxpc2Vjb25kKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBJbmNpZGVudCBieSBJRCBubyBtYXR0ZXIgaWYgdGhlIEluY2lkZW50IGJhbG9uZ3MgZGlyZWN0bHkgdG8gdGhlIFNjZW5lIG9mIHRvIGEgY2hpbGQgU2NlbmVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB0byBnZXRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5jaWRlbnRCeUlkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50QnlJZChpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZC5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbmNpZGVudHNCeUlkW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5nZXRJbmNpZGVudEJ5SWQoaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluY2lkZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBJTkNJREVOVFMgTUFOQUdFTUVOVCBNRVRIT0RTXG4gICAgICAgIC8vIFBPTFlNT1JQSElTTSBBUFBMSUVELiBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVCBJVCBBQ1RTIEFTIEEgU0NFTkUuIElGIFRIRSBHUk9VUCBIQVMgUEFSRU5UIElUIEFDVFMgQVNcbiAgICAgICAgLy8gQSBcIlRSQU5TUEFSRU5UIEdST1VQXCJcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIHNlcnZlcyBleGFjdGx5IHdoYXQgaXRzIG5hbWUgaW1wbGllcy4gVG8gY2hlY2sgaWYgdGhlIGFkZGl0aW9uIG9mIGFuIEluY2lkZW50XG4gICAgICAgICAqIGlzIHZhbGlkIGFuZCBhY2NlcHRlZCwgYWNjb3JkaW5nIHRvIHRoZSBydWxlcyBkZWZpbmVkIG9uIHRoZSBjaGFubmVscy5cbiAgICAgICAgICogVGhlIG1ldGhvZCBib29ibGVzIHVwIHVudGlsIGl0IHJlYWNoZXMgdGhlIENsaXAgYnkgY2FycnlpbmcgYWRqdXN0aW5nIHRoZSBtaWxsaXNlY29uZC5cbiAgICAgICAgICogVGhlIG1ldGhvZCB0YWtlcyBhcyBpbnB1dCB0aGUgbWFuYWdlbWVudCB0eXBlLiBPbiBlcnJvciAvIGNvbmZsaWN0OlxuICAgICAgICAgKiAgLSBvbiB0eXBlID09PSAnYWxsLW9yLW5vdGhpbmcnIGNvbXBsZXRlbHkgZGlzY2FyZCBhZGRpdGlvbiBvZiBhbGwgaW5jaWRlbnRzXG4gICAgICAgICAqICAtIG9uIHR5cGUgPT09ICdrZWVwLXBhc3NpbmcnIGl0IHdpbGwgb25seSBhZGQgdGhlIHBhc3NpbmcgaW5jaWRlbnRzIG5vIG1hdHRlciBpZiBzb21lIG90aGVyIGluY2lkZW50cyBvZiB0aGUgYWRkaXRpb24gZmFpbGVkXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBpbmNpZGVudCAtIHRoZSBpbmNpZGVudCB0byBhZGRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRvIGFkZCB0aGUgSW5jaWRlbnQgdG9cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBhcyBleHBsYWluZWQgYWJvdmVcbiAgICAgICAgICogVGhlIG1ldGhvZCByZXR1cm5zIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrQWRkaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudCwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBcImFsbC1vci1ub3RoaW5nXCI7XG5cbiAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UUyAoSVMgQSBDTElQKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nSW5jaWRlbnRXaXRoVGhlU2FtZUlkID0gdGhpcy5nZXRJbmNpZGVudEJ5SWQoaW5jaWRlbnQuaWQpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0luY2lkZW50V2l0aFRoZVNhbWVJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIGVycm9yczogW3sgcmVhc29uOiAnQWxyZWFkeSBleGlzdGluZyBJbmNpZGVudCB3aXRoIGlkICcgKyBpbmNpZGVudC5pZCwgaW5jaWRlbnQ6IGV4aXN0aW5nSW5jaWRlbnRXaXRoVGhlU2FtZUlkIH1dIH07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBpbmNpZGVudHMgc2VwYXJhdGVkIGJ5IHBsdWdpblxuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeUlkID0gaW5jaWRlbnQuZ2V0SW5jaWRlbnRzQnlQbHVnaW4obWlsbGlzZWNvbmQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgcmV0dXJuIHBheWxvYWRcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGFibGVzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNsaXAgaGFkIG5vIGNoYW5uZWwgaW5zdGFudGlhdGVkIGZvciB0aGUgc3BlY2lmaWMga2V5IChwbHVnaW4gaWQpIHlldCBjcmVhdGUgaXRcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGludHN0YW50aWF0ZSB0aGUgY2hhbm5lbCBvZiB0aGUgcGx1Z2luIGJ5IHVzaW5nIHRoZSByZWZlcmVuY2UgdG8gdGhlIGNsYXNzIGRlZmluaXRpb24gc3RvcmVkIG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmVyeSBmaXJzdCBpbmNpZGVudCBvZiB0aGUgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XSA9IG5ldyBpbmNpZGVudHNCeUlkW2tleV1bMF0uaW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1blRpbWVJbmZvOiB0aGlzLnJ1blRpbWVJbmZvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmFkZEluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzLnB1c2gocGx1Z2luUmVzdWx0LmV4ZWN1dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGUgPSBmdW5jdGlvbiB0b1JldHVybkV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZXR1cm5FeGVjdXRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0b1JldHVyblJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25SZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIZWFkbGVzc0NsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVCAoQUNUIEFTIFRIRSBDTElQKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmNoZWNrQWRkaXRpb24oaW5jaWRlbnQsIG1pbGxpc2Vjb25kICsgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKHRoaXMuaWQpLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY2hlY2tFZGl0IG1ldGhvZCBzZXJ2ZXMgZXhhY3RseSB3aGF0IGl0cyBuYW1lIGltcGxpZXMuIFRvIGNoZWNrIGlmIHRoZSBlZGl0IG9mIGFuIEluY2lkZW50IChlZGl0IG9mIEluY2lkZW50J3MgcG9zaXRpb24gZ2l2ZW4gaW4gbWlsbGlzZWNvbmRzIGRlbHRhKVxuICAgICAgICAgKiBpcyB2YWxpZCBhbmQgYWNjZXB0ZWQsIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBvbiB0aGUgY2hhbm5lbHMuXG4gICAgICAgICAqIFRoZSBtZXRob2QgYm9vYmxlcyB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBDbGlwLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5jaWRlbnQgLSB0aGUgaW5jaWRlbnQgdG8gZWRpdFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEgLSB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIG9mIHRoZSBJbmNpZGVudCdzIHN0YXJ0IHRpbWVcbiAgICAgICAgIFRoZSBtZXRob2Qgc2hvdWxkIHJldHVybiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGVkaXQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudCwgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UUyAoSVMgQSBDTElQKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBpbmNpZGVudHMgc2VwYXJhdGVkIGJ5IHBsdWdpblxuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeUlkID0gaW5jaWRlbnQuZ2V0SW5jaWRlbnRzQnlQbHVnaW4oKTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudHNCeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uZWRpdEluY2lkZW50cyhpbmNpZGVudHNCeUlkW2tleV0sIG1pbGxpc2Vjb25kc0RlbHRhKTtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXJyb3JzID0gdG9SZXR1cm5FcnJvcnMuY29uY2F0KHBsdWdpblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXNbaV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0b1JldHVyblJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hlYWRsZXNzQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UIChBQ1QgQVMgVEhFIENMSVApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuY2hlY2tFZGl0KGluY2lkZW50LCBtaWxsaXNlY29uZHNEZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrRGVsZXRlIG1ldGhvZCBzZXJ2ZXMgZXhhY3RseSB3aGF0IGl0cyBuYW1lIGltcGxpZXMuIFRvIGNoZWNrIGlmIHRoZSBkZWxldGlvbiBvZiBhbiBJbmNpZGVudFxuICAgICAgICAgKiBpcyB2YWxpZCBhbmQgYWNjZXB0ZWQsIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBvbiB0aGUgY2hhbm5lbHMuXG4gICAgICAgICAqIFRoZSBtZXRob2QgYm9vYmxlcyB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBDbGlwLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5jaWRlbnQgLSB0aGUgaW5jaWRlbnQgdG8gZWRpdFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBpZiBwYXNzZWQgaXQgc3VwcG9ydHMgdGhlIHByZXZlbnRTbGlwIGtleSB3aGljaCBpZiBmYWxzZSB0aGUgY2hhbm5lbCBzaG91bGQgbm90IHNsaXAuIFRoaXMgY2FzZSBpcyBmb3IgXG4gICAgICAgICAgICBmbGFzaERPTSBvZiBET01Bd2FyZUluY2lkZW50cyB3aGVyZSB3ZSBoYXZlIGVsZW1lbnRzIGRlbGV0ZWQgc28gc2xpcHBpbmcgb24gdGhlaXIgbGFuZXMgaXMgbm90IHZhbGlkIG5vciBuZWNlc3NhcnlcbiAgICAgICAgICBUaGUgcmVzdWx0IG1pZ2h0IGJlIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgcmVtb3ZlIHRoZSBJbmNpZGVudCBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEZWxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEZWxldGUoaW5jaWRlbnRJZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlRTIChJUyBBIENMSVApXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLmdldEluY2lkZW50QnlJZChpbmNpZGVudElkKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGluY2lkZW50cyBzZXBhcmF0ZWQgYnkgcGx1Z2luXG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50c0J5SWQgPSBpbmNpZGVudC5nZXRJbmNpZGVudHNCeVBsdWdpbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgcmV0dXJuIHBheWxvYWRcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGFibGVzID0gW107XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpblJlc3VsdCA9IHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5yZW1vdmVJbmNpZGVudHMoaW5jaWRlbnRzQnlJZFtrZXldLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuUmVzdWx0ID0gdG9SZXR1cm5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVuZiBvZiBpdGVyYXRpb24gb24gdGhlIGluY2lkZW50c0J5SWQga2V5c1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIZWFkbGVzc0NsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVCAoQUNUIEFTIFRIRSBDTElQKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmNoZWNrRGVsZXRlKGluY2lkZW50SWQsIHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCdzIGNhbGxlZCBhbHdheXMgYnkgYSBjaGlsZCB0byBTY2VuZSB0aGF0IHdhbnRzIHRvIGV4cGFuZCB0byB0aGUgbGVmdCB0byBpdHMgcGFyZW50LlxuICAgICAgICAgKiBFeHBhbmRpbmcgYSBTY2VuZSB0byB0aGUgbGVmdCBtZWFucyBpdCB0cmllcyB0byBhZGQgZXh0cmEgKGluaXRpYWxseSB1bnN1ZWQpIHNwYWNlIChpbiBtaWxsaXNlY29uZHMpIGJlZm9yZSBpdHNcbiAgICAgICAgICogY3VycmVudCBzdGFydGluZyBwb2ludC5cbiAgICAgICAgICogSW4gb3JkZXIgZm9yIHRoaXMgYWN0aW9uIHRvIGJlIGFsbG93ZWQgdGhlIFNjZW5lJ3MgY29udGV4dCBzaG91bGQgYWxsb3cgc3VjaCBhbiBleHBhbnNpb24uIFRoaXMgbWVhbnM6XG4gICAgICAgICAqICAtIHRoYXQgaWYgdGhlIFNjZW5lIGhhcyBubyBwYXJlbnRzIHRoaXMgZXhwYW5zaW9uIGlzIG5vdCBsZWdhbFxuICAgICAgICAgKiAgLSB0aGF0IGlmIHRoZSByb290IFNjZW5lIG9mIHRoZSBTY2VuZSdzIHBhcmVudHMgdHJlZSBuZWVkcyB0byBleHBhbmQgb24gdGhlIGxlZnQgaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGV4cGFuc2lvblxuICAgICAgICAgKiAgICAgIHRoZW4gdGhlIGV4cGFuc2lvbiBpcyBub3QgYWNjZXB0YWJsZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gaG93TWFueU1pbGxpc2Vjb25kcyAtIHRoZSBtaWxsaXNlY29uZHMgdG8gZXhwYW5kIHRoZSBTY2VuZSB0byB0aGUgbGVmdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2NlbmVJZCAtIHRoZSBjaGlsZCBzY2VuZSBpZCB0aGF0IHdhbnRzIHRvIGdhaW4gZXh0cmEgc3BhY2UgdG8gdGhlIGxlZnRcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gLSB0aGUgcmVzdWx0IGlzIGFuIG9iamVjdCB3aXRoIHR3byBrZXlzOlxuICAgICAgICAgKiAgLSB0aGUgZmlyc3Qga2V5IGlzIHRoZSBcInJlc3VsdFwiIHdoaWNoIG1pZ2h0IGVpdGhlciBiZSB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAqICAtIHRoZSBzZWNvbmQga2V5IGlzIHRoZSBcInVuZG9cIiB3aGljaCBpcyBhIGZ1bmN0aW9uIHRoYXQgY2FuIHVuZG8gdGhlIChhcHByb3ZlZCkgZXhwYW5zaW9uXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cGFuZFNjZW5lVG9UaGVMZWZ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cGFuZFNjZW5lVG9UaGVMZWZ0KGhvd01hbnlNaWxsaXNlY29uZHMsIHNjZW5lSWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBGaXJzdCB3ZSBpZGVudGlmeSB0aGUgZXhwYW5zaW9uIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgcGFyZW50ICh0aGlzKSBTY2VuZVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lID0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKHNjZW5lSWQpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0TWlsbGlzZWNvbmRPZlRoZUNoaWxkU2NlbmUgPSBob3dNYW55TWlsbGlzZWNvbmRzIC0gY3VycmVudFN0YXJ0TWlsbGlzZWNvbmRPZlRoZUNoaWxkU2NlbmU7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBleHBhbnNpb24gaXMgYWxsb3dlZFxuICAgICAgICAgICAgLy8gaWYgdGhlIG1pbGxpc2Vjb25zIHRvIGV4cGFuZCBhcmUgemVybyBvciBsZXNzIChtZWFuaW5nIHRoZSBjdXJyZW50IFNjZW5lIGlzIGFjdHVhbGx5IG5vdCBhZmZlY3RlZCBieSB0aGUgZXhwYW5zaW9uKVxuICAgICAgICAgICAgaWYgKG5ld1N0YXJ0TWlsbGlzZWNvbmRPZlRoZUNoaWxkU2NlbmUgPD0gMCkge1xuICAgICAgICAgICAgICAgIHZhciByb290U2NlbmUgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VSZXN1bHQgPSB0aGlzLmNoYW5nZUluY2lkZW50c1N0YXJ0TWlsbGlzZWNvbmQoLW5ld1N0YXJ0TWlsbGlzZWNvbmRPZlRoZUNoaWxkU2NlbmUsIHNjZW5lSWQpO1xuICAgICAgICAgICAgICAgIHZhciB1bmRvID0gZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMyLmNoYW5nZUluY2lkZW50c1N0YXJ0TWlsbGlzZWNvbmQoY2hhbmdlUmVzdWx0Lm9sZE1pbGxpc2Vjb25kLCBzY2VuZUlkKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5kbzogdW5kbyxcbiAgICAgICAgICAgICAgICAgICAgcm9vdFNjZW5lOiByb290U2NlbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpdCByZWFjaGVzIHRvIHRoYXQgcG9pbnQgdGhhdCBtZWFucyB0aGUgZXhwYW5zaW9uIGFmZWN0cyB0aGUgbGVmdCBib3JkZXJzIG9mIHRoaXMgKHBhcmVudCkgU2NlbmUgYXMgd2VsbFxuICAgICAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBoYXZlIGEgcGFyZW50IHNjZW5lIHRoYXQgbWVhbnMgdGhlIGV4cGFuc2lvbiBpcyBpbGxlZ2FsXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBhIHBhcmVudCBzY2VuZSBhbmQgdGhlIHRoaXMgU2NlbmUgbmVlZHMgdG8gZXhwYW5kIHRvIHRoZSBsZWZ0IGFzIHdlbGwgdGhlbiB0aGlzIFNjZW5lXG4gICAgICAgICAgICAvLyBhc3NpZ25zIHRoZSBvYmxpZ2F0aW9uIHRvIGV2YWx1YXRlIHRoZSBleHBhbnNpb24gdG8gaXRzIHBhcmVudFxuICAgICAgICAgICAgdmFyIHBhcmVudERlY2lzaW9uID0gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5leHBhbmRTY2VuZVRvVGhlTGVmdChuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lLCB0aGlzLmlkKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBwYXJlbnQgYXBwcm92ZXMgdGhlIGV4cGFuc2lvblxuICAgICAgICAgICAgaWYgKHBhcmVudERlY2lzaW9uLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gYXBwbHkgdGhlIGV4cGFuc2lvbiBpdHNlbGYgYW5kIGJ1bmRsZSBpdHMgdW5kbyBhbG9uZyB3aXRoIHRoZSB1bmRvIGNvbWluZyBmcm9tIHRoZSBwYXJlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFN0YXJ0UG9pbnQoLW5ld1N0YXJ0TWlsbGlzZWNvbmRPZlRoZUNoaWxkU2NlbmUpO1xuICAgICAgICAgICAgICAgIHZhciBvdmVyYWxsVW5kbyA9IGZ1bmN0aW9uIG92ZXJhbGxVbmRvKCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnREZWNpc2lvbi51bmRvKCk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5leHBhbmRTdGFydFBvaW50KG5ld1N0YXJ0TWlsbGlzZWNvbmRPZlRoZUNoaWxkU2NlbmUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB1bmRvOiBvdmVyYWxsVW5kbyxcbiAgICAgICAgICAgICAgICAgICAgcm9vdFNjZW5lOiBwYXJlbnREZWNpc2lvbi5yb290U2NlbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBleHBhbmRzIG9yIGNvbGxhcHNlcyB0aGUgU2NlbmUncyBzdGFydCBtaWxsaXNlY29uZCBieSB0aGUgZ2l2ZW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICAqIGUuZy4gZXhwYW5kU3RhcnRQb2ludCgyMDApIHdpbGwgZXhwYW5kIHRoZSBTY2VuZSBieSAyMDAgbWlsbGlzZWNvbmRzIHRvIHRoZSBsZWZ0IGtlZXBpbmcgYWxsXG4gICAgICAgICAqICAgICAgb2YgaXRzIGluY2lkZW50cyB0byB0aGUgZXhhY3Qgc2FtZSBwbGFjZSB0aGV5IHdlcmUgYmVmb3JlIG9uIHRoZSBvdmVyYWxsIHRpbWVsaW5lXG4gICAgICAgICAqIGUuZy4gZXhwYW5kU3RhcnRQb2ludCgtMjAwKSB3aWxsIGNvbGxhcHNlIHRoZSBTY2VuZSwgbW92aW5nIGl0cyBzdGFydCBwb2ludCBieSAyMDAgbWlsbGlzZWNvbmRzXG4gICAgICAgICAqICAgICAgdG8gdGhlIHJpZ2h0LCBhZ2FpbiB3aXRob3V0IGFmZmVjdGluZyBhdCBhbGwgaXRzIEluY2lkZW50cycgc3RhcnQgcG9pbnQgb24gdGhlIG92ZXJhbGwgdGltZWxpbmVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGJ5TWlsbGlzZWNvbmRzIC0gdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZXhwYW5kIChwb3NpdGl2ZSBudW1iZXIpIG9yIGNvbGxhcHNlIChtaW51cyBudW1iZXIpIG51bWJlciBvZiBtaWxsaXNlY29uZHNcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhwYW5kU3RhcnRQb2ludCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRTdGFydFBvaW50KGJ5TWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKGluY2lkZW50Lm1pbGxpc2Vjb25kICsgYnlNaWxsaXNlY29uZHMsIGluY2lkZW50LmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBhbHRlcnMgdGhlIHN0YXJ0IG1pbGxpc2Vjb25kIG9mIGFueSBhbHJlYWR5IGV4aXN0aW5nIEluY2lkZW50IG9mIHRoZSBTY2VuZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbmV3bWlsbGlzZWNvbmQgLSB0aGUgbmV3IG1pbGxpc2Vjb25kIHRvIHBsYWNlIHRoZSBJbmNpZGVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5jaWRlbnRJZCAtIHRoZSBpbmNpZGVudCBpZFxuICAgICAgICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259IC0gdGhlIHVuZG8gZnVuY3Rpb24gb2YgdGhlIGNoYW5nZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZUluY2lkZW50c1N0YXJ0TWlsbGlzZWNvbmQobmV3bWlsbGlzZWNvbmQsIGlkKSB7XG4gICAgICAgICAgICB2YXIga2V5ZnJhbWVfc2VjX2tleSA9IHRoaXMuaW5jaWRlbnRzS2V5ZnJhbWVLZXlzW2lkXTtcbiAgICAgICAgICAgIC8vT1BUSU1JWkUgZGVsZXRlIGlzIHNsb3cgb24gdjggZW5naW5lIHdlIHNob3VsZCBjaGVjayBpZiB3ZSBjYW4gYWNoaWV2ZSB0aGUgc2FtZSByZXN1bHQgYnkgc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGtleSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1trZXlmcmFtZV9zZWNfa2V5XVtpZF07XG5cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLmtleWZyYW1lc1trZXlmcmFtZV9zZWNfa2V5XSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbaWRdOyAvLyBkZWxldGUgdGhlIGxpc3RlbmVyIHRoYXQgY3VycmVudGx5IG1hbmFnZXMgdGhlIEluY2lkZW50J3MgZXhlY3V0aW9uXG5cblxuICAgICAgICAgICAgdmFyIG9sZE1pbGxpc2Vjb25kID0gdm9pZCAwOyAvLyB0aGUgcHJldmlvdXMgbWlsbGlzZWNvbmQgb2YgdGhlIGVkaXRlZCBpbmNpZGVudCBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZE1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQgKiAxOyAvLyAqMSB0byBhdm9pZCByZWZlcmVuY2UsIGtlZXAgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQgPSBuZXdtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c0J5SWRbaWRdO1xuICAgICAgICAgICAgdmFyIG5ld19rZXlmcmFtZV9zZWNfa2V5ID0gY29uZi5rZXlmcmFtZV9zZWNfa2V5ICsgbmV3bWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICBpZiAoIXRoaXMua2V5ZnJhbWVzLmhhc093blByb3BlcnR5KG5ld19rZXlmcmFtZV9zZWNfa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW25ld19rZXlmcmFtZV9zZWNfa2V5XSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5rZXlmcmFtZXNbbmV3X2tleWZyYW1lX3NlY19rZXldW2luY2lkZW50LmlkXSA9IGluY2lkZW50O1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaW5jaWRlbnQuaWRdID0gbmV3X2tleWZyYW1lX3NlY19rZXk7XG5cbiAgICAgICAgICAgIC8vIHN1YnNjcmliZSBJbmNpZGVudCBzdGFydCBvbiB0aGUgbGlzdGVuZXJzXG4gICAgICAgICAgICB2YXIgZnVuY3QgPSBmdW5jdGlvbiBmdW5jdChzY2VuZU1pbGxpc2Vjb25kLCBwcmV2aW91c1RpbWVTdGFtcCwgc2NlbmVTdGF0ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2VuZU1pbGxpc2Vjb25kID49IG5ld21pbGxpc2Vjb25kICYmIHNjZW5lTWlsbGlzZWNvbmQgPD0gbmV3bWlsbGlzZWNvbmQgKyBpbmNpZGVudC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5wbGF5KHsgc3RhcnRGcm9tOiBzY2VuZU1pbGxpc2Vjb25kIC0gbmV3bWlsbGlzZWNvbmQsIHByZXZpb3VzVGltZVN0YW1wOiBwcmV2aW91c1RpbWVTdGFtcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZShpbmNpZGVudC5pZCwgZnVuY3QpO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9sZE1pbGxpc2Vjb25kOiBvbGRNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogaW5jaWRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGxhaW4gZ3JvdXBzXG4gICAgICAgICAgICBDYW4gaGF2ZSBvbiB0aGVpciB0aW1lbGluZTpcbiAgICAgICAgICAgIC0gQW5vdGhlciBwbGFpbiBncm91cFxuICAgICAgICAgICAgLSBBbiBpbmNpZGVudCB3aXRoIG5vIHNlbGVjdG9yXG4gICAgICAgICAgICAtIEEgZG9tIGdyb3VwICh0aGlzIG1ldGhvZCBzaG91bGQgYWN0dWFsbHkgdHVybiBhbnkgaW5jaWRlbnQgd2l0aCBzZWxlY3RvciB0byBvbmUpXG4gICAgICAgICAgICBDYW7igJl0IGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgICAgICAtIEFuIGF0dHJpYnV0ZSBncm91cFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3ByZXBhcmVJbmljZGVudEZvckFkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbihpbmNpZGVudCkge1xuICAgICAgICAgICAgaWYgKCFpbmNpZGVudC5wcm9wcy5oYXNPd25Qcm9wZXJ0eSgnc2VsZWN0b3InKSAmJiAhaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGluY2lkZW50IGlzIG5vdCBhIGdyb3VwIGFuZCBpdCBoYXMgbm8gc2VsZWN0b3IgcHJvY2VlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnQuZ3JvdXBUeXBlID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgSW5jaWRlbnQgaXMgYSBwbGFpbiBncm91cCBwcm9jZWVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmNpZGVudC5ncm91cFR5cGUgPT09IFwiYXR0cmlidXRlXCIpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoXCJQbGFpbiBncm91cHMgY2FuIG5vdCBhY2NlcHQgYXR0cmlidXRlIGdyb3VwcyBvbiB0aGVpciB0aW1lbGluZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0dXJuIHRoZSBJbmNpZGVudCB0byBhIERPTUF3YXJlSW5jaWRlbnRcbiAgICAgICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGdyb3VwXG4gICAgICAgICAgICB2YXIgRE9NQXdhcmVJbmNpZGVudCA9IHJlcXVpcmUoJy4uL19yZXNwb25zaXZlbmVzcy9ET01Bd2FyZUluY2lkZW50Jyk7XG4gICAgICAgICAgICB2YXIgdGhlRE9NQXdhcmVJbmNpZGVudCA9IG5ldyBET01Bd2FyZUluY2lkZW50KGluY2lkZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGVET01Bd2FyZUluY2lkZW50O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmbGFzaERPTScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFzaERPTSgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgZmFpbGVkQWRkaXRpb25zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmxhc2hSZXN1bHQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5mbGFzaERPTSgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5mYWlsZWRBZGRpdGlvbnMgPSByZXN1bHQuZmFpbGVkQWRkaXRpb25zLmNvbmNhdChmbGFzaFJlc3VsdC5mYWlsZWRBZGRpdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICBBbnkgU2NlbmUgY2FuIHJlY2VpdmUgdGhlIGFkZEluY2RlbnQgY29tbWFuZCBlaXRoZXIgZm9yIGFkZGluZyBhbiBJbmNpZGVudCBvbiBpdHMgb3duIEluY2lkZW50cyBsaXN0IG9yIGluIG9yZGVyXG4gICAgICAgIHRvIHBhc3MgZGVlcGVyIHRoZSBjb21tYW5kIHRvIHRoZSBwYXJlbnQgU2NlbmUgb2YgdGhlIEluY2lkZW50IChzY2VuZUlkKS5cbiAgICAgICAgTm8gbWF0dGVyIHdoaWNoIFNjZW5lIHRvb2sgdGhlIGNvbW1hbmQsIGFsbCBwYXJlbnQgU2NlbmVzIGdldCBpbmZvcm1lZFxuICAgICAgICAgYWRkSW5jaWRlbnQgdGFrZXMgMyBhcmd1bWVudHM6XG4gICAgICAgIEBwYXJhbSB7SW5jaWRlbnR9IGluY2lkZW50IC0gdGhlIEluY2lkZW50IG9iamVjdCB0byBnZXQgYWRkZWRcbiAgICAgICAgQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHdoaWNoIHdlIHdhbnQgdGhlIEluY2lkZW50IHRvIGdldCBhZGRlZCwgc3RhcnRpbmcgZnJvbSB0aGUgemVybyBwb2ludCBvZiB0aGVcbiAgICAgICAgICAgIHRhcmdldCBTY2VuZS4gSXQgY2FuJ3QgYmUgbmVnYXRpdmVcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHNjZW5lSWQgLSB0aGUgc2NlbmVJZCB0byB3aGljaCB3ZSB3YW50IHRvIHB1dCB0aGUgbmV3IEluY2lkZW50LiBJdCBpcyBvcHRpb25hbCBhbmQgaWYgaXQgaXMgbm90IHNwZWNpZmllZCB0aGVcbiAgICAgICAgICAgIHRhcmdldCBTY2VuZSBpcyB0aGUgY3VycmVudCBvbmVcbiAgICAgICAgQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBvbmUgb2YgXCJhbGwtb3Itbm90aGluZ1wiIC8gXCJrZWVwLXBhc3NpbmdcIlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5jaWRlbnQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kLCBzY2VuZUlkKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJhbGwtb3Itbm90aGluZ1wiO1xuXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21pbnVzIG1pbGxpc2Vjb25kIHZpb2xhdGlvbidcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kICogMTsgLy8gYSBiYWNrdXAgdmFyaWFibGUgaG9sZGluZyB0aGUgb3JpZ2luYWwgbWlsbGlzZWNvbmQgcGFzc2VkIGFzXG4gICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGNoYW5nZSBkdXJpbmcgcG90ZW50aWFsIGxlZnQgZXhwYW5zaW9uIG1hbmlwdWxhdGlvblxuXG4gICAgICAgICAgICBpZiAoIXNjZW5lSWQgfHwgc2NlbmVJZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpbmNpZGVudCA9IHRoaXMuX3ByZXBhcmVJbmljZGVudEZvckFkZGl0aW9uKGluY2lkZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIHdoZW4gYWRkaW5nIGhlYWRsZXNzIENsaXBzIHRvIGEgZ3JvdXAgdGhhdCBoYXMgY29udGV4dCAoZWl0aGVyIGJlY2F1c2UgaXQncyB0aGUgY2xpcCBpdHNlbGYgb3IgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIGl0IGJlbG9uZ3MgdG8gYSBjbGlwIHRoYXQgaGFzIGNvbnRleHQpIHdlIG5lZWQgdG8gcnVuIGZsYXNoIHRoZSBuZXdseSBlbnRlcmVkIGdyb3VwJ3MgZG9tIHNvIGl0IGNyZWF0ZXNcbiAgICAgICAgICAgICAgICAvLyBpdHMgZWxlbWVudEluY2lkZW50c1xuICAgICAgICAgICAgICAgIHZhciBmbGFzaEluY2lkZW50c0RPTUFmdGVyRW50ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmNpZGVudC5oYXNJbmNpZGVudHMgJiYgaW5jaWRlbnQuaXNIZWFkbGVzc0NsaXAgJiYgdGhpcy5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZmxhc2hJbmNpZGVudHNET01BZnRlckVudGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpbmNpZGVudC5zZXRQYXJlbnRTY2VuZSh0aGF0KTtcblxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBJbmNpZGVudCBpcyBlbGlnaWJsZSBmb3IgYWRkaXRpb25cbiAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25DaGVjayA9IHRoaXMuY2hlY2tBZGRpdGlvbihpbmNpZGVudCwgbWlsbGlzZWNvbmQsIHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRpdGlvbkNoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZGl0aW9uQ2hlY2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZGl0aW9uQ2hlY2suZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICAgICAgLy8gaW5kZXhpbmcgc3RhcnRcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGluY2lkZW50LmlkLFxuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudDogaW5jaWRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZFtpbmNpZGVudC5pZF0gPSBpbmNpZGVudDtcbiAgICAgICAgICAgICAgICB2YXIga2V5ZnJhbWVfc2VjX2tleSA9IGNvbmYua2V5ZnJhbWVfc2VjX2tleSArIG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5rZXlmcmFtZXMuaGFzT3duUHJvcGVydHkoa2V5ZnJhbWVfc2VjX2tleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV1baW5jaWRlbnQuaWRdID0gaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaW5jaWRlbnQuaWRdID0ga2V5ZnJhbWVfc2VjX2tleTtcbiAgICAgICAgICAgICAgICAvLyBpbmRleGluZyBlbmRcblxuICAgICAgICAgICAgICAgIGluY2lkZW50LmV4ZWN1dGlvblNwZWVkID0gdGhpcy5zcGVlZDtcblxuICAgICAgICAgICAgICAgIC8vIHN1YnNjcmliZSBJbmNpZGVudCBzdGFydCBvbiB0aGUgbGlzdGVuZXJzXG4gICAgICAgICAgICAgICAgLy8gY3VycmVudE1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgdGhlIEdyb3VwIGlzIG9uXG4gICAgICAgICAgICAgICAgLy8gbWlsbGlzZWNvbmQ6IHRoZSBtaWxsaXNlY29uZCB3ZSBzZXQgb3VyIEluY2lkZW50IHRvIGdldCBleGVjdXRlZCBvbiB0aGUgR3JvdXAncyB0aW1lbGluZVxuICAgICAgICAgICAgICAgIHZhciBmdW5jdCA9IGZ1bmN0aW9uIGZ1bmN0KGN1cnJlbnRNaWxsaXNlY29uZCwgcHJldmlvdXNUaW1lU3RhbXAsIHNjZW5lU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2lkZW50LnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNaWxsaXNlY29uZCA+PSBtaWxsaXNlY29uZCAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQgKyBpbmNpZGVudC5kdXJhdGlvbiB8fCBpbmNpZGVudC5zdGF0ZSA9PT0gJ2lkbGUnICYmIGN1cnJlbnRNaWxsaXNlY29uZCA+IG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnZ3JlYXRlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50LnBsYXkoeyBzdGFydEZyb206IGN1cnJlbnRNaWxsaXNlY29uZCAtIG1pbGxpc2Vjb25kLCBwcmV2aW91c1RpbWVTdGFtcDogcHJldmlvdXNUaW1lU3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudE1pbGxpc2Vjb25kID49IG1pbGxpc2Vjb25kICYmIGN1cnJlbnRNaWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZCArIGluY2lkZW50LmR1cmF0aW9uIHx8IGluY2lkZW50LnN0YXRlID09PSAnY29tcGxldGVkJyAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPCBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dyZWF0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5wbGF5KHsgc3RhcnRGcm9tOiBjdXJyZW50TWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCwgcHJldmlvdXNUaW1lU3RhbXA6IHByZXZpb3VzVGltZVN0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKGluY2lkZW50LmlkLCBmdW5jdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZGRlZChtaWxsaXNlY29uZCwgaW5jaWRlbnQuZHVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZsYXNoSW5jaWRlbnRzRE9NQWZ0ZXJFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gaW5jaWRlbnQuZmxhc2hET00oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5mYWlsZWRBZGRpdGlvbnMubGVuZ3RoID4gMCAmJiB0eXBlID09PSBcImFsbC1vci1ub3RoaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5jaWRlbnQoaW5jaWRlbnQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogcmVzdWx0LmZhaWxlZEFkZGl0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGZsYXNoaW5nIGluY2lkZW50J3MgRE9NIHBhc3NlcyBsZXQgdGhlIEluY2lkZW50IGtub3cgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgbm93IGhhcyBjb250ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5fb25HZXRDb250ZXh0T25jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkFkZEluY2lkZW50KGluY2lkZW50LCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIubm90aWNlKCdpbmNpZGVudCBhZGRlZCcpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25BZGRJbmNpZGVudChpbmNpZGVudCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIubm90aWNlKCdpbmNpZGVudCBhZGRlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmFkZEluY2lkZW50KGluY2lkZW50LCBtaWxsaXNlY29uZCAtIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kLCBzY2VuZUlkKS5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gaWYgaXQgcmVhY2hlcyB0aGUgZW5kIG9mIHRoZSBsb29wIHdpdGhvdXQgaGF2aW5nIHJldHVybmVkIHRydWVcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgQW55IFNjZW5lIGNhbiByZWNlaXZlIHRoZSBlZGl0SW5jaWRlbnQgY29tbWFuZCBpbiBvcmRlciB0byBzZXQgYSBuZXcgc3RhcnRpbmcgcG9pbnQgZm9yIG9uZSBvZiBpdHMgb3duIEluY2lkZW50cyBvciB0b1xuICAgICAgICBwYXNzIHRoZSBjb21tYW5kIGRlZXBlciBkb3duIHRvIGl0cyBjaGlsZHJlbiBTY2VuZXMgc28gdGhlIHBhcmVudCBvZiBpdCBjYW4gdGFrZSBjYXJlIG9mIGl0LlxuICAgICAgICBUaGUgSW5jaWRlbnQgb2JqZWN0IGFuZCBpZCByZW1haW4gdGhlIHNhbWUgYWZ0ZXIgdGhlIGVkaXQuXG4gICAgICAgIE5vIG1hdHRlciB3aGljaCBTY2VuZSB0YWtlcyB0aGUgY29tbWFuZCwgYWxsIFBhcmVudHMgZ2V0IGluZm9tZWQgYWJvdXQgdGhlIGVkaXQuXG4gICAgICAgICBJdCB0YWtlcyB0d28gcGFyYW1zOlxuICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIGlkIG9mIHRoZSBpbmNpZGVudCB0byBiZSBlZGl0ZWRcbiAgICAgICAgIEBwYXJhbSB7aW50fSBuZXdtaWxsaXNlY29uZCAtIHRoZSBuZXcgcG9zaXRpb24gb2YgdGhlIEluY2lkZW50IGNvbXBhcmVkIHRvIHRoZSB0YXJnZXQgU2NlbmUgc3RhcnQgKGFuZCBub3QgdG8gdGhlIFNjZW5lIGl0IGJlbG9uZ3MpXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlZGl0SW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZWRpdEluY2lkZW50KGlkLCBuZXdtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGV4cGFuc2lvblZhbGlkYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTWlsbGlzZWNvbmQgPSBuZXdtaWxsaXNlY29uZCAqIDE7XG5cbiAgICAgICAgICAgIGlmICghaGVscGVyLmlzU3RyaW5nKGlkKSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignZWRpdEluY2lkZW50IG1ldGhvZCBvZiBHcm91cCBleHBlY3RzIGFzIGl0cyBmaXJzdCBhcmd1bWVudCB0aGUgaWQgb2YgdGhlIEluY2lkZW50IHRvIGVkaXQgaW4gc3RyaW5nIGZvcm1hdC4gJyArICh0eXBlb2YgaWQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlkKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd3cm9uZyBwYXJhbWV0ZXIgdHlwZSdcbiAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNCeUlkW2lkXSkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ01pbGxpc2Vjb25kID0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKGlkKTtcbiAgICAgICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmREZWx0YSA9IG5ld21pbGxpc2Vjb25kIC0gZXhpc3RpbmdNaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICAvLyBmaXJzdCBjaGVjayBmb3IgbWludXMgZXhwYW5zaW9uXG4gICAgICAgICAgICAgICAgaWYgKG5ld21pbGxpc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgU2NlbmUgZG9lc24ndCBoYXZlIGEgcGFyZW50IHRoZW4gaXQgaXMgdGhlIHJvb3QgYW5kIHRodXMgaXQgY2FuJ3QgZXhwYW5kIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtaW51cyBtaWxsaXNlY29uZCB2aW9sYXRpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25WYWxpZGF0aW9uID0gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5leHBhbmRTY2VuZVRvVGhlTGVmdCgtbmV3bWlsbGlzZWNvbmQsIHRoaXMuaWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwYW5zaW9uVmFsaWRhdGlvbi5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWludXMgbWlsbGlzZWNvbmQgdmlvbGF0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3bWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgaWYgbWlsbGlzZWNvbmQgPCAwXG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWRpdCBpcyBhbGxvd2VkICh0aHVzIHdlIGNvbWUgdG8gdGhhdCBwb2ludCkgYW5kIHRoZSBvcmlnaW5hbE1pbGxpc2Vjb25kIGlzIGxvd2VyIHRoYW4gMFxuICAgICAgICAgICAgICAgIGlmIChvcmlnaW5hbE1pbGxpc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV4cGFuZFN0YXJ0UG9pbnQoLW9yaWdpbmFsTWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0uc3RvcCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRDaGVjayA9IHRoaXMuY2hlY2tFZGl0KHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0sIG1pbGxpc2Vjb25kRGVsdGEpO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0Q2hlY2sucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoZWRpdENoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvblZhbGlkYXRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGFuc2lvblZhbGlkYXRpb24udW5kbygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGFydFBvaW50KG9yaWdpbmFsTWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlZGl0Q2hlY2s7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWRpdENoZWNrLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0SW5jaWRlbnRTdGFydFJlc3VsdCA9IHRoaXMuY2hhbmdlSW5jaWRlbnRzU3RhcnRNaWxsaXNlY29uZChuZXdtaWxsaXNlY29uZCwgaWQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZmZlY3RlZCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRJbmNpZGVudCh0aGlzLmluY2lkZW50c0J5SWRbaWRdLCBlZGl0SW5jaWRlbnRTdGFydFJlc3VsdC5vbGRNaWxsaXNlY29uZCwgbmV3bWlsbGlzZWNvbmQpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmVkaXRJbmNpZGVudChpZCwgbmV3bWlsbGlzZWNvbmQgLSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCkucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGlmIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiB0aGUgbG9vcCB3aXRob3V0IGhhdmluZyByZXR1cm5lZCB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEFueSBTY2VuZSBjYW4gcmVjZWl2ZSB0aGUgcmVtb3ZlSW5jaWRlbnQgY29tbWFuZCBlaXRoZXIgZm9yIHJlbW92aW5nIG9uZSBvZiBpdHMgb3duIEluY2lkZW50cyBvciBmb3IgcGFzc2luZyB0aGUgY29tbWFuZFxuICAgICAgICBkZWVwZXIgZG93biB0byBpdHMgU2NlbmVzIHRyZWUgYW5kIGhhdmUgdGhlIEluY2lkZW50IGRlbGV0ZWQgbm8gbWF0dGVyIHRvIHdoaWNoIGNoaWxkIFNjZW5lIGl0IGJlbG9uZ3NcbiAgICAgICAgTm8gbWF0dGVyIHdoaWNoIFNjZW5lIHRvb2sgdGhlIGNvbW1hbmQsIGFsbCBwYXJlbnQgU2NlbmVzIGdldCBpbmZvcm1lZFxuICAgICAgICAgSXQgdGFrZXMganVzdCBvbmUgYXJndW1lbnQ6XG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQgdG8gYmUgZGVsZXRlZFxuICAgICAgICBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBpZiBwYXNzZWQgaXQgc3VwcG9ydHMgdGhlIHByZXZlbnRTbGlwIGtleSB3aGljaCBpZiBmYWxzZSB0aGUgY2hhbm5lbCBzaG91bGQgbm90IHNsaXAuIFRoaXMgY2FzZSBpcyBmb3IgXG4gICAgICAgICAgICBmbGFzaERPTSBvZiBET01Bd2FyZUluY2lkZW50cyB3aGVyZSB3ZSBoYXZlIGVsZW1lbnRzIGRlbGV0ZWQgc28gc2xpcHBpbmcgb24gdGhlaXIgbGFuZXMgaXMgbm90IHZhbGlkIG5vciBuZWNlc3NhcnlcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluY2lkZW50KGlkKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNCeUlkW2lkXSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWxldGVDaGVjayA9IHRoaXMuY2hlY2tEZWxldGUoaWQsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlQ2hlY2sucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoZGVsZXRlQ2hlY2spO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVsZXRlQ2hlY2s7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVsZXRlQ2hlY2suZXhlY3V0ZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkW2lkXS5sYXN0V2lzaCgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGtleWZyYW1lX3NlY19rZXkgPSB0aGlzLmluY2lkZW50c0tleWZyYW1lS2V5c1tpZF07XG4gICAgICAgICAgICAgICAgLy9PUFRJTUlaRSBkZWxldGUgaXMgc2xvdyBvbiB2OCBlbmdpbmUgd2Ugc2hvdWxkIGNoZWNrIGlmIHdlIGNhbiBhY2hpZXZlIHRoZSBzYW1lIHJlc3VsdCBieSBzZXR0aW5nIHRoZSB2YWx1ZSBvZiB0aGUga2V5IHRvIHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmluY2lkZW50c0tleWZyYW1lS2V5c1tpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldW2lkXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbmNpZGVudHNCeUlkW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxpc3RlbmVyc1tpZF07IC8vIGRlbGV0ZSB0aGUgbGlzdGVuZXIgdGhhdCBtYW5hZ2VzIHRoZSBJbmNpZGVudCdzIGV4ZWN1dGlvblxuXG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0ZWRJbmNpZGVudCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZWRJbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZmZlY3RlZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25SZW1vdmVJbmNpZGVudChkZWxldGVkSW5jaWRlbnRbMF0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW19pXS5pbmNpZGVudC5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tfaV0uaW5jaWRlbnQucmVtb3ZlSW5jaWRlbnQoaWQpLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBpZiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgdGhlIGxvb3Agd2l0aG91dCBoYXZpbmcgcmV0dXJuZWQgdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aGljaCBpcyBwcm92aWRlZCBvbmx5IGJ5IEdyb3VwcyBhY2NlcHRzIGFuIGluY2lkZW50SWQgYW5kIGEgbmV3IGR1cmF0aW9uIGFuZCBcbiAgICAgICAgICogZWRpdHMgdGhlIGR1cmF0aW9uIG9mIHRoZSBjb3JyZXNwb25kaW5nIGluY2lkZW50IGFjY29yZGluZ2x5XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmNpZGVudElkIC0gdGhlIGlkIG9mIHRoZSBpbmNpZGVudCB0byByZXNpemVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG5ld0R1cmF0aW9uIC0gdGhlIG5ldyBkdXJhdGlvbiBvZiB0aGUgaW5jaWRlbnQgaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2l6ZUluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUluY2lkZW50KGluY2lkZW50SWQsIG5ld0R1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmNpZGVudCA9IHRoaXMuZ2V0SW5jaWRlbnRCeUlkKGluY2lkZW50SWQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW5jaWRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCBlcnJvcnM6IFt7IHJlYXNvbjogJ1RoZSBpbmNpZGVudCB3aXRoIGlkICcgKyBpbmNpZGVudElkICsgJyBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIEdyb3VwIG9yIGFueSBvZiBpdHMgY2hpbGQgR3JvdXBzJyB9XSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5jaWRlbnQucmVzaXplKG5ld0R1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCB3aGljaCBpcyBwcm92aWRlZCBvbmx5IGJ5IEdyb3VwcyBhY2NlcHRzIGFuIGluY2lkZW50SWQgYW5kIGEgbmV3IGF0dHJzIG9iamVjdCBcbiAgICAgICAgICogYW5kIGVkaXRzIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBjb3JyZXNwb25kaW5nIGluY2lkZW50IGFjY29yZGluZ2x5XG4gICAgICAgICAqIElmIHRoZSBhdHRyaWJ1dGUgZWRpdGluZyBlbmRzIHVwIHdpdGggY29uZmxpY3RzIHRoZSBlZGl0IGlzIGRpc2NhcmRlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluY2lkZW50SWQgLSB0aGUgaWQgb2YgdGhlIGluY2lkZW50IHRvIHJlc2l6ZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gYXR0cnMgLSB0aGUgbmV3IGF0dHJzIG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlZGl0SW5jaWRlbnRBdHRyaWJ1dGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudEF0dHJpYnV0ZXMoaW5jaWRlbnRJZCwgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RQYXJlbnQgPSB0aGlzLl9nZXREaXJlY3RQYXJlbnQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICBpZiAoZGlyZWN0UGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBbJ1RoZSBJbmNpZGVudCB3aXRoIGlkICcgKyBpbmNpZGVudElkICsgJyBkb2VzIG5vdCBiZWxvbmcgdG8gdGhlIEdyb3VwIG9yIGFueSBvZiBpdHMgY2hpbGQgR3JvdXBzJ11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpcmVjdFBhcmVudC5fZWRpdENoaWxkSW5jaWRlbnRBdHRyaWJ1dGVzKGluY2lkZW50SWQsIGF0dHJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeSB0aGlzIG1ldGhvZCBhIEdyb3VwIHRyaWVzIHRvIGVkaXQgdGhlIGF0dHJpYnV0ZXMgb2Ygb25lIG9mIGl0cyBjaGlsZHJlbi4gVGhlIHByb2Nlc3MgZ29lcyBhcyBmb2xsb3dzOlxuICAgICAgICAgKiAxLiBUaGUgR3JvdXAgZ2V0cyBhbiBleHBvcnQgb2YgdGhlIEluY2lkZW50J3Mgc3RhdGVcbiAgICAgICAgICogMi4gVGhlIEdyb3VwIGRlbGV0ZXMgdGhlIEluY2lkZW50XG4gICAgICAgICAqIDMuIFRoZSBHcm91cCB0cmllcyB0byBjcmVhdGUgYSBuZXcgSW5jaWRlbnQgd2l0aCB0aGUgc2FtZSBpZCBhcyB0aGUgb2xkIG9uZSBhbmQgd2l0aCB0eXBlPVwiYWxsLW9yLW5vdGhpbmdcIlxuICAgICAgICAgKiA0LmEuIElmIHRoZSBuZXcgSW5jaWRlbnQgZ2V0cyBhZGRlZCBvayBwcm9jZXNzIGZpbmlzaGVzXG4gICAgICAgICAqIDQuYi4gSWYgdGhlIG5ldyBJbmNpZGVudCBkb2Vzbid0IGdldCBhZGRlZCBiZWNhdXNlIG9mIGNvbmZsaWN0cyB0aGUgcHJldmlvdXMgSW5jaWRlbnQgZ2V0cyBiYWNrIGluXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmNpZGVudElkIC0gdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB0byBlZGl0IGl0cyBhdHRyc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gYXR0cnMgLSB0aGUgbmV3IGF0dHJpYnV0ZXMgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19lZGl0Q2hpbGRJbmNpZGVudEF0dHJpYnV0ZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2VkaXRDaGlsZEluY2lkZW50QXR0cmlidXRlcyhpbmNpZGVudElkLCBhdHRycykge1xuICAgICAgICAgICAgdmFyIGluY2lkZW50VG9FZGl0ID0gdGhpcy5nZXRJbmNpZGVudEJ5SWQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdJbmNpZGVudERlZmluaXRpb24gPSBpbmNpZGVudFRvRWRpdC5leHBvcnRTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKGluY2lkZW50SWQpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbmNpZGVudChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIHZhciBuZXdJbmNpZGVudFByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmdJbmNpZGVudERlZmluaXRpb24ucHJvcHMpO1xuICAgICAgICAgICAgdmFyIG5ld0luY2lkZW50ID0gbmV3IGV4aXN0aW5nSW5jaWRlbnREZWZpbml0aW9uLkluY2lkZW50KGF0dHJzLCBuZXdJbmNpZGVudFByb3BzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFkZEluY2lkZW50KG5ld0luY2lkZW50LCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXlPbGRJbmNpZGVudCA9IG5ldyBleGlzdGluZ0luY2lkZW50RGVmaW5pdGlvbi5JbmNpZGVudChleGlzdGluZ0luY2lkZW50RGVmaW5pdGlvbi5hdHRycywgbmV3SW5jaWRlbnRQcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRJbmNpZGVudChteU9sZEluY2lkZW50LCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydGluZyBmcm9tIGl0c2VsZiBhbmQgZ29pbmcgYWxsIHRoZSB3YXkgZG93biB0byBlYWNoIGFuZCBldmVyeSBsZWFmIG9mIGl0cyB0cmVlIGl0IHN5c3RvbHMvZGlhc3RvbGVzIHRoZVxuICAgICAgICAgKiBJbmNpZGVudHNcbiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gZHVyYXRpb25GcmFjdGlvbiB0aGUgZnJhY3Rpb24gb2YgdGhlIG5ldyBkdXJhdGlvbiB0byB0aGUgZXhpc3RpbmcgZHVyYXRpb25cbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gZHVyYXRpb25GcmFjdGlvbiAqIHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbiwgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBhIENsaXAgYWxsIENoYW5uZWxzIG9mIGl0IHNob3VsZCBnZXQgcmVzaXplZFxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLl9yZXNpemUoZHVyYXRpb25GcmFjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVEhFIFwiRUFSU1wiIE9GIFRIRSBTQ0VORSBUTyBJVFMgQ0hJTEQgSU5DSURFTlRTXG4gICAgICAgIC8qKlxuICAgICAgICAgICAgICBORVcgU1RBVEUgQ0FMQ1VMQVRJT04gUlVMRVM6XG4gICAgICAgICAgICAgIElmIGEgU2NlbmUgaGFzIGF0IGxlYXN0IG9uZSBjbGlwQmxvY2tpbmdXYWl0aW5nIChtZWFuaW5nIHRoZSBmdWxsIENsaXAgaXMgaGFsdGVkIGF0IHRoZSBtb21lbnQpIHRoZSBTY2VuZeKAmXMgc3RhdGUgd2lsbCBiZSDigJxjbGlwQmxvY2tpbmdXYWl0aW5n4oCdIHVubGVzcyBpdCBpcyB0aGUgQ2xpcCBzbyBpdHMgc3RhdGUgd2lsbCBiZSDigJx3YWl0aW5n4oCdLlxuICAgICAgICAgICAgICBJZiBhIFNjZW5lIGhhcyBhbGwgY2hpbGRyZW4gb24gdGhlIGNvbXBsZXRlZCBzdGF0ZSwgdGhlIFNjZW5lIGhhcyB0aGUgY29tcGxldGVkIHN0YXRlIGFzIHdlbGwuXG4gICAgICAgICAgICAgIElmIGEgU2NlbmUgaGFzIGF0IGxlYXN0IG9uZSBvZiBpdHMgY2hpbGRyZW4gb24gb25lIG9mIHRoZSBmb2xsb3dpbmcgc3RhdGVzOlxuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nICAgICBpdCBoYXMgc3RhcnRlZCBwbGF5aW5nIGFuZCBoYXMgYmVlbiBoYWx0ZWQgaW50ZXJuYWxseVxuICAgICAgICAgICAgICAgICAgICBwbGF5aW5nICAgICBpdCBoYXMgc3RhcnRlZCBwbGF5aW5nXG4gICAgICAgICAgICAgICAgICAgIGlkbGUgICAgICAgICAgICBpdCBoYXMgbm90IGJlZW4gZXhlY3V0ZWQgeWV0XG4gICAgICAgICAgICAgIHRoZSBTY2VuZSBpcyBvbiBwbGF5aW5nIHN0YXRlXG4gICAgICAgICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpbmNpZGVudFN0YXRlQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluY2lkZW50U3RhdGVDaGFuZ2UoaWQsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgcHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChuZXdTdGF0ZSA9PT0gJ2NsaXBCbG9ja2luZ1dhaXRpbmcnIHx8IG5ld1N0YXRlID09PSAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gcHJvcHM7XG4gICAgICAgICAgICAgICAgcHJvcHNUb1Bhc3MuY2FsbGVySWQgPSBpZDtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09ICdzY2VuZUJsb2NraW5nV2FpdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RvcCBwcm9wYWdhdGlvbiBhcyB0aGlzIHNob3VsZCBvbmx5IGFmZmVjdCB0aGUgU2NlbmUgYW5kIG5vdCBpdHMgcGFyZW50c1xuICAgICAgICAgICAgICAgICAgICBwcm9wcy53YWl0aW5nU3RhdGVOYW1lID0gJ3dhaXRpbmcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLndhaXQocHJvcHNUb1Bhc3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdTdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgJiYgdGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdJbmNpZGVudCAnICsgaWQgKyAnIGdvdCBpbnRvIGNvbXBsZXRlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ0luY2lkZW50ICcgKyB0aGlzLmlkICsgJyB0YWtlcyBjYXJlIG9mIGl0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGFsbENvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnZ29pbmcgdG8gaXRlcmF0ZSBvbiBhbGwgSW5jaWRlbnRzJyk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKFxuICAgICAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuaWQgKyAnLnN0YXRlID0gJyArIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnN0YXRlXG4gICAgICAgICAgICAgICAgICAgIC8vICk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zdGF0ZSAhPSAnY29tcGxldGVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWxsQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld1N0YXRlID09PSAnaWRsZScgJiYgdGhpcy5zcGVlZCA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdJbmNpZGVudCAnICsgaWQgKyAnIGdvdCBpbnRvIGNvbXBsZXRlZCBzdGF0ZScpO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ0luY2lkZW50ICcgKyB0aGlzLmlkICsgJyB0YWtlcyBjYXJlIG9mIGl0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIF9hbGxDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dvaW5nIHRvIGl0ZXJhdGUgb24gYWxsIEluY2lkZW50cycpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmlkICsgJy5zdGF0ZSA9ICcgKyB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zdGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbX2kyXS5pbmNpZGVudC5zdGF0ZSAhPSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hbGxDb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfYWxsQ29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGNoaWxkIHdhcyBlaXRoZXIgb24gc2NlbmVCbG9ja2luZ1dhaXRpbmcgb3IgY2xpcEJsb2NraW5nV2FpdGluZyBhbmQgbm93IGlzIGNoYW5naW5nXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIEJMT0NLIFdBSVRJTkdTIE1BTklQVUxBVElPTiBNRVRIT0RTXG4gICAgICAgICovXG4gICAgICAgIC8qKlxuICAgICAgICBAcGFyYW0ge29iamVjdH0gcHJvcHMgLVxuICAgICAgICB0aGUgbmF0dXJlIG9mIGEgd2FpdGluZyBtaWdodCBiZTpcbiAgICAgICAgICAgICAtIHNjaGVkdWxlZCAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRcbiAgICAgICAgICAgICAtIGR5bmFtaWNcbiAgICAgICAgICAgICAtIHN5c3RlbS1lcnJvclxuICAgICAgICAgIHRoZSB3YWl0aW5nU3RhdGVOYW1lIG9mIGEgd2FpdGluZyBjYW4gYmU6XG4gICAgICAgICAgICAgLSB3YWl0aW5nICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBzY2VuZUJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgIC0gY2hhbm5lbEJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgIC0gY2xpcEJsb2NraW5nV2FpdGluZ1xuICAgICAgICBpZDogdGhlIGlkIG9mIHRoZSB0cmlnZ2VyaW5nIEluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEJsb2NrV2FpdGluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRCbG9ja1dhaXRpbmcocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy53YWl0aW5nU3RhdGVOYW1lID09PSAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0KHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MucHVzaChwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLndhaXRpbmdTdGF0ZU5hbWUgPT09ICdjaGFubmVsQmxvY2tpbmdXYWl0aW5nJyAmJiB0aGlzLmlzQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdChwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy53YWl0aW5nU3RhdGVOYW1lID09PSAnY2xpcEJsb2NraW5nV2FpdGluZycgJiYgdGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXQocHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ3dhaXRpbmcnICYmIHByb3BzLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0KHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MucHVzaChwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LnNldEJsb2NrV2FpdGluZyhwcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBAcGFyYW0ge29iamVjdH0gcHJvcHMgLVxuICAgICAgICB0aGUgbmF0dXJlIG9mIGEgd2FpdGluZyBtaWdodCBiZTpcbiAgICAgICAgICAgICAtIHNjaGVkdWxlZCAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRcbiAgICAgICAgICAgICAtIGR5bmFtaWNcbiAgICAgICAgICAgICAtIHN5c3RlbS1lcnJvclxuICAgICAgICAgIHRoZSB3YWl0aW5nU3RhdGVOYW1lIG9mIGEgd2FpdGluZyBjYW4gYmU6XG4gICAgICAgICAgICAgLSB3YWl0aW5nICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBzY2VuZUJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgIC0gY2hhbm5lbEJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgIC0gY2xpcEJsb2NraW5nV2FpdGluZ1xuICAgICAgICBpZDogdGhlIGlkIG9mIHRoZSB0cmlnZ2VyaW5nIEluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Vuc2V0QmxvY2tXYWl0aW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2V0QmxvY2tXYWl0aW5nKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQmxvY2socHJvcHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ2NoYW5uZWxCbG9ja2luZ1dhaXRpbmcnICYmIHRoaXMuaXNDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCbG9jayhwcm9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy53YWl0aW5nU3RhdGVOYW1lID09PSAnY2xpcEJsb2NraW5nV2FpdGluZycgJiYgdGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUJsb2NrKHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ibG9ja2luZ1dhaXRpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLndhaXRpbmdTdGF0ZU5hbWUgPT09ICd3YWl0aW5nJyAmJiBwcm9wcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQmxvY2socHJvcHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QudW5zZXRCbG9ja1dhaXRpbmcocHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBjaGVja3MgaWYgYSBibG9jayB3aXRoIHRoZSBwcm92aWRlZCBwcm9wcyBleGlzdHMgb24gaXRzIGJsb2NraW5nV2FpdGluZ3MgYXJyYXlcbiAgICAgICAgICogaWYgaXQgZXhpc3RzIGl0IHJlbW92ZXMgaXQuXG4gICAgICAgICAqIElmIHRoZSByZW1haW5pbmcgYmxvY2tpbmcgd2FpdGluZ3MgYXJlIGVxdWFsIHRvIDAgaXQgcmV0dXJucyB0cnVlIG90aGVyd2lzZSBpdCByZXR1cm5zIGZhbHNlXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUJsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUJsb2NrKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgbmV3QmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuICAgICAgICAgICAgdmFyIGZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiV2FpdGluZyA9IHRoaXMuYmxvY2tpbmdXYWl0aW5nc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYldhaXRpbmcuaWQgPT09IHByb3BzLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld0Jsb2NraW5nV2FpdGluZ3MucHVzaCh0aGlzLmJsb2NraW5nV2FpdGluZ3NbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MgPSBuZXdCbG9ja2luZ1dhaXRpbmdzO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdvVG8gbWV0aG9kIHNob3VsZCBhbHdheXMgYmUgaGFuZGxlZCBieSB0aGUgQ2xpcC4gTm8gb3RoZXIgR3JvdXAgbm9yIEluY2lkZW50IGNhbiBoYW5kbGUgZ29UbyBhbG9uZS5cbiAgICAgICAgICogVGh1cywgaWYgdGhlIEdyb3VwIGlzIG5vdCB0aGUgQ2xpcCBpdCBwYXNzZXMgdGhlIGNvbW1hbmQgdXAuIElmIHRoZSBHcm91cCBpcyB0aGUgQ2xpcCB0aGVuIGl0IGhhbmRsZXMgZ29Ub1xuICAgICAgICAgKiBieSBwYXNzaW5nIHRoZSBjb21tYW5kIHRvIGl0cyBDaGFubmVscy5cbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dvVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ29UbyhtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgLy8gZmlyc3QgZGVjaWRlIHRoZSBtaWxsaXNlY29uZCB3ZSB3YW50IHRvIGdvVG9cbiAgICAgICAgICAgIGlmIChtaWxsaXNlY29uZCA9PT0gbnVsbCB8fCBtaWxsaXNlY29uZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgncmVsYXRpdmVUbycpKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgKz0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKHByb3BzLnJlbGF0aXZlVG8pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPiB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5nb1RvKG1pbGxpc2Vjb25kLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5yZWxhdGl2ZVRvID0gdGhpcy5pZDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nb1RvKG1pbGxpc2Vjb25kLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZW4gdGhlIEdyb3VwIGlzIG9uIHRlc3QgbW9kZSAodGhpcy5pc09uVGVzdE1vZGUgPSB0cnVlKSB0aGUgZW11bGF0ZVN0ZXAgbWV0aG9kXG4gICAgICAgICAqIGJlY29tZXMgZnVuY3Rpb25hbC5cbiAgICAgICAgICogVGhlIG1ldGhvZCB0YWtlcyBhcyBpbnB1dCB0aGUgbWlsbGlzZWNvbmRzRGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgdGltZXN0YW1wIGFuZCB0cmlnZ2Vyc1xuICAgICAgICAgKiB0aGUgc3RlcCBmdW5jdGlvbiBwYXNzaW5nIGluIGEgYmFrZWQgdGltZXN0YW1wIHNvIHRoZSBJbmNpZGVudCBiZWhhdmVzIGV4YWN0bHkgYXMgaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5cbiAgICAgICAgICogcGFzc2luZyBhIHRpbWVzdGFtcCB0aGF0IGhhcyBleGFjdGx5IG1pbGxpc2Vjb25kc0RlbHRhIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwcmV2aW91cyB0aW1lc3RhbXAgYW5kIHRoZSBuZXcgb25lXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VtdWxhdGVTdGVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtdWxhdGVTdGVwKG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPblRlc3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdlbXVsYXRlU3RlcCBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBvbiB0ZXN0IG1vZGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwKHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgKyBtaWxsaXNlY29uZHNEZWx0YSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGRJbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZEluY2lkZW50LmluY2lkZW50LnN0YXRlID09PSBcInBsYXlpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmNpZGVudC5pbmNpZGVudC5lbXVsYXRlU3RlcChNYXRoLmFicygodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLSBjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kIC0gY2hpbGRJbmNpZGVudC5pbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpIC8gdGhpcy5zcGVlZCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBTY2VuZSByZWNlaXZlcyB0aGlzIGNvbW1hbmQgZnJvbSBpdHMgY2hpbHJlbiBhbmQgdGhlIHB1cnBvc2Ugb2YgaXQgaXMgdG8gaGVscCB0aGUgY2FsbGVyXG4gICAgICAgICAqIGlkZW50aWZ5IHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgb2YgaXRzIHN0YXJ0IGNvbXBhcmVkIHRvIHRoZSByb290IFNjZW5lIG9mIGl0LlxuICAgICAgICAgKiBJbiBhIG11bHRpLWxldmVsIHNpdHVhdGlvbiB3aXRoIFNjZW5lcyB3aXRoaW4gc2NlbmVzIHRoZSBTY2VuZSB0aGF0IHJlY2VpdmVzIHRoaXMgY29tbWFuZCBtaWdodCBub3Qgb3duXG4gICAgICAgICAqIHRoZSBJbmNpZGVudCB0aGF0IHRyaWdnZXJlZCB0aGlzIHRocmVhZCBkaXJlY3RseS4gVGhhdCdzIHdoeSB3ZSB1c2UgdGhlIGV4dHJhRGVsdGEgaGVscGluZyBwYXJhbWV0ZXIgdGhhdFxuICAgICAgICAgKiBhY3R1YWxseSBkZWxpdmVycyBsZXZlbCBieSBsZXZlbCB0aGUgZGVsdGEgb2YgdGhlIHRyaWdnZXJpbmcgSW5jaWRlbnQgd2l0aGluIHRoZSB0cmVlXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmNpZGVudElkID0gdGhlIGlkIG9mIHRoZSBjaGlsZCBpbmNpZGVudCBvZiB0aGUgc2NlbmUgdGhhdCB0cmlnZXJyZWQgdGhlIG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZXh0cmFEZWx0YSAtIHRoZSBleHRyYSBkZWx0YSB0byBhZGQgdG8gdGhlIHJlc3VsdFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbUluY2lkZW50c1N0YXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvb3RDdXJyZW50TWlsbGlzZWNvbmREZWx0YUZyb21JbmNpZGVudHNTdGFydChpbmNpZGVudElkKSB7XG4gICAgICAgICAgICB2YXIgZXh0cmFEZWx0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcblxuICAgICAgICAgICAgLy8gZmlyc3Qgc3RlcCBmaW5kIHRoZSBzdGFydCBtaWxsaXNlY29uZCBvZiB0aGUgaW5jaWRlbnRcbiAgICAgICAgICAgIHZhciBpbmNpZGVudE1pbGxpc2Vjb25kID0gdGhpcy5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKGluY2lkZW50SWQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAtIGluY2lkZW50TWlsbGlzZWNvbmQgLSBleHRyYURlbHRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXRSb290Q3VycmVudE1pbGxpc2Vjb25kRGVsdGFGcm9tSW5jaWRlbnRzU3RhcnQodGhpcy5pZCwgaW5jaWRlbnRNaWxsaXNlY29uZCArIGV4dHJhRGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgQ0FMTEJBQ0tTIEFGVEVSIFNVQ0NFU1NGVUwgQURESU5HIC8gRURJVElORyAvIERFTEVUSU5HIEFOIElOQ0lERU5UXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkFkZEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQWRkSW5jaWRlbnQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kKSB7fVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25FZGl0SW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25FZGl0SW5jaWRlbnQoaW5jaWRlbnQsIG9sZE1pbGxpc2Vjb25kLCBuZXdNaWxsaXNlY29uZCkge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uUmVtb3ZlSW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZW1vdmVJbmNpZGVudChpbmNpZGVudCkge31cblxuICAgICAgICAvLyBvbiBHcm91cHMgdGhlcmUgaXMgbm8gbmVlZCB0byBwcmV2ZW50IHJlLWludm9raW5nIHRoZSBvbkdldENvbnRleHQgbWV0aG9kXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbkdldENvbnRleHRPbmNlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdldENvbnRleHRPbmNlKCkge1xuICAgICAgICAgICAgdGhpcy5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5fb25HZXRDb250ZXh0T25jZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkdXJhdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ3JvdXBUeXBlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJwbGFpblwiO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwcm9qZWN0ZWRJbmNpZGVudHMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFByb2plY3RlZEluY2lkZW50cygpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleGVjdXRpb25TcGVlZCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNwZWVkKSB7XG4gICAgICAgICAgICBoZWxwZXIubm90aWNlKHRoaXMuaWQgKyAnIGlzIHNldHRpbmcgaXRzIGV4ZWN1dGlvbiBzcGVlZCB0bzogJyArIHNwZWVkICsgJyB3aGlsZSBvbiBtaWxsaXNlY29uZDogJyArIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIGlmIChzcGVlZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcihcIlNwZWVkIGNhbid0IGJlIDBcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZXhlY3V0aW9uU3BlZWQgPSBzcGVlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNIZWFkbGVzc0NsaXAnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5jaGVja1BhcmVudFNjZW5lKCkgJiYgIXRoaXMuaXNUaGVDbGlwO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250ZXh0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vd25Db250ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR3JvdXA7XG59KFRpbWVkSW5jaWRlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js":
/*!*******************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar checkTransition = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").checkTransition;\nvar helper = new Helper();\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\n/** @classdesc\n * Incidents are all events that should happen on a specific time on the timeline. An incident can have parametric\n      execution behaviour based on the times it has been executed and (might be) on other parameters.\n\n      The state an Incident can have is one of the following:\n                 idle\n                 playing\n                 waiting\n                 sceneBlockingWaiting\n                 clipBlockingWaiting\n                 blocked    // in the case the Incident is blocked / paused by a waiting\n                 completed\n\n      Each Incident has the obligation to inform the Scene about its state changes.\n      For this Incident provides the method “setParentScene” which takes just one argument a Timer object.\n      Timer provides the method “incidentStateChange” which lets the Incidents change their state by\n      providing their id and their new state.\n * */\n\nvar Incident = function () {\n    /**\n     It takes just one argument, \"props\". Props pass data useful only for the following:\n     An incident can be set to be either inexhaustible (meaning it can be executed again and again infinite times -- default)\n     or finite meaning it can only be executed a limited (specific) number of times. This info can be found on the maxLifeCycles\n     Of course the incident can be reset to its initial condition at any time through the \"reset\" method it provides.\n      As a luxuriousness, and along WITH the maxLifeCycles parameter, the Incident also provides the executionPattern parameter\n     through which the programmer / user can define a more complex behaviour of the Incident execution depending on the number times\n     the incident has alrady be executed ( is the 1st time, the 2nd time, the 3rd time etc) and any custom parameter it\n     holds. The execution times are held on the \"executionTimes\" attribute of the class.\n      props:\n     {\n        id: if passed that's the id of the Incident. If not we create a new one\n        plugin_channel_class - if passed gets set to it\n        mc_plugin_npm_name - if passed gets set to it\n     }\n        @param {object} props */\n    function Incident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Incident);\n\n        this.attrs = attrs;\n        this.props = props;\n        this.id = props.id || helper.getAnId();\n\n        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter\n        // is set to true so we prevent multiple executions of the onGetContext method\n        this.gotContext = false;\n\n        /*\n        these are the default values that define channeling for the default Incidents. These values get ovewriden through\n        the loadPlugin method of MC with the values found on the main.js file of the plugin\n        */\n        this.plugin_channel_class = Channel;\n        this.mc_plugin_npm_name = \"motor-cortex-js\";\n        if (props.hasOwnProperty('plugin_channel_class')) {\n            this.plugin_channel_class = props.plugin_channel_class;\n        }\n        if (props.hasOwnProperty('mc_plugin_npm_name')) {\n            this.mc_plugin_npm_name = props.mc_plugin_npm_name;\n        }\n\n        /* \n        The following two properties (\"statusBeforeHalt\" and \"stateBeforeStop\") which have stupidly \n        used \"status\" in the one case and \"state\" in the other\n        act as the memory of the Incident in the case of a stop or\n        a halting command (wait or block), storing the state of it just before any of the two get \n        executed. \n        These properties can be used in various ways in the program\n        and they do not target specific functionality.\n        */\n        // the status of the Incident before it got halted by either the block or the wait command\n        this.statusBeforeHalt = 'idle';\n        // holds the state of the Incident before the stop command\n        this.stateBeforeStop = 'idle';\n\n        this.timesExecuted = 0;\n        this.parentSceneObject = null;\n\n        this.runTimeInfo = {\n            state: 'idle' // one of \"idle\", \"playing\", \"waiting\"\n        };\n\n        this.bitIncident = true;\n        this.hasIncidents = false;\n\n        /* an array holding all  */\n        this.eventsSubscriptions = {};\n\n        /*\n        Right now many keys of the Incident (such as \"props\", \"attrs\", etc) are already been used by the Incident \n        class. The final users of the library (the plugin developers) might want to keep special / specific data\n        on their Incidents and:\n        a) they might don't know which keys are already taken and which are not\n        b) might use an already used key and ruin the functionality\n        c) so they feel unsafe keeping data and it's not safe for the lib too\n        For this reason we have a blank object reserved for them, the \"customParams\", in order for them to \n        put anything they want and we encourage them to use the built-in methods:\n        setParam\n        getParam\n        setParams\n        for this job\n        */\n        this.customParams = {};\n\n        this.speed = 1;\n\n        /*\n        initialValues is an object holding the autmatically computed initial values of the animatedAttrs \n        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to \n        an AttributesChannel have initialValues).\n        The keys set of this object is identical to the object attrs.animatedAttrs \n        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr\n        of a specific element when there are no other Incidents entered on its lanes yet. These values are\n        the \"scratchValues\" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation\n        what we are looking for can be found on the computedStyle.\n        */\n        this.initialValues = {};\n\n        /*\n        The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user\n        can do that by providing the initialValues object on the attrs of the constructor.\n        */\n        this.userDefinedInitialValues = {};\n        if (attrs != null && attrs != undefined) {\n            if (attrs.hasOwnProperty('initialValues')) {\n                this.userDefinedInitialValues = attrs.initialValues;\n            }\n        }\n\n        /*\n        blockingWaitings is an array, a collection, of blocing waitings that have the Scene as target.\n        The logic is simple:\n        - if the scene receives a \"sceneBlockingWaiting\" then it is the target and it adopts it\n        - if the scene receives a \"channelBlockingWaiting\" then if it is a channel it adopts it otherwise it tries to\n            pass it further up until it finds a channel\n        - if the scene receives a \"clipBlockingWaiting\" if it is the Clip it adopts it otherwise it tries to pass it\n            further up until it reaches the clip\n        Each object on this array represents a blocking waiting triggered by a child of the Scene\n            and which targets the Scene itself.\n        Each child signs the blocking waiting by assigning its own id to it. Each child can only assign just one\n            blocking waiting at a time.\n        The structure of each blocking waiting appearing on this array is the following:\n        {\n            id: the-signature-of-the-triggering-incident,\n            type: any of the sceneBlockingWaiting / channelBlockingWaiting / ClipBlockingWaiting,\n            nature: any of the scheduled / dynamic / system-problem\n        }\n        */\n        this.blockingWaitings = [];\n\n        /**\n        * @member {boolean} - if testingMode is set to true the requestAnimationFrame method is not going\n        * to get executed automatically but instead the emaulateStep method will start functioning allowing\n        * developers to pass the milliseconds difference from the previous timestamp manually\n        **/\n        this.testMode = false;\n        if (props.hasOwnProperty('testMode')) {\n            this.testMode = props.testMode;\n        }\n\n        this.onInitialise(attrs, props);\n    }\n\n    _createClass(Incident, [{\n        key: 'getScratchValue',\n\n\n        /**\n        This method shoudl be overwritten by the Incidents of the plugins. The method accepts\n        as arguments the mcid (an element) and the attribue (one of the animatedAttrs, if any)\n        and return the initial value of them as the library calculates / defines them. The \n        returned value represents the very initial value of the element's attribute before\n        any Incident that alters it gets added.\n        @param {string} mcid\n        @param {string} attribute\n        @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS\n        of the Clip gets rendered\n        */\n        value: function getScratchValue(mcid, attribute) {\n            return 0;\n        }\n    }, {\n        key: 'getElementAttribute',\n        value: function getElementAttribute(attr) {\n            return this.element.getAttribute(attr);\n        }\n    }, {\n        key: 'getElementByMCID',\n        value: function getElementByMCID(mcid) {\n            if (this.context === null) {\n                return null;\n            }\n\n            return helper.getElementByMCID(this.context, mcid);\n        }\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            return {\n                failedAdditions: []\n            };\n        }\n    }, {\n        key: 'turnIncidentToMC',\n        value: function turnIncidentToMC() {\n            this.plugin_channel_class = Channel;\n            this.mc_plugin_npm_name = \"motor-cortex-js\";\n        }\n    }, {\n        key: 'resetState',\n        value: function resetState() {}\n    }, {\n        key: 'getIncidentsByPlugin',\n\n\n        /**\n         * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n         * tree of the Group. All Incidents are projected to the Group's timeline.\n         * The array includes the Group's projection too\n        */\n        value: function getIncidentsByPlugin() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var incidentsByPlugin = {};\n            incidentsByPlugin[this.mc_plugin_npm_name] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n            return incidentsByPlugin;\n        }\n    }, {\n        key: 'setParam',\n        value: function setParam(param, value) {\n            this.customParams[param] = value;\n        }\n    }, {\n        key: 'getParam',\n        value: function getParam(param) {\n            return this.customParams[param];\n        }\n    }, {\n        key: 'setParams',\n        value: function setParams() {\n            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.customParams = params;\n        }\n\n        /** *************************************************\n        HELPER FUNCTIONS\n        checks if the parent Scene object has been defined */\n\n    }, {\n        key: 'checkParentScene',\n        value: function checkParentScene() {\n            if (this.parentSceneObject === null) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }, {\n        key: 'checkStateTransition',\n        value: function checkStateTransition(targetState) {\n            // we prevent play (and thus any other transition) in cases the Incident has no parent\n            // group. The method changes on Group\n            if (this.checkParentScene()) {\n                if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: '_hasUserDefinedInitialValue',\n        value: function _hasUserDefinedInitialValue(attr) {\n            return this.userDefinedInitialValues.hasOwnProperty(attr);\n        }\n    }, {\n        key: '_getUserDefinedInitialValue',\n        value: function _getUserDefinedInitialValue(attr) {\n            return this.userDefinedInitialValues[attr];\n        }\n    }, {\n        key: 'setInitialValue',\n        value: function setInitialValue(attr, value) {\n            if (this._hasUserDefinedInitialValue(attr)) {\n                helper.notice('Incident with id ' + this.id + ' has initial value defined for ' + attr + ' and no change is allowed on it');\n                return;\n            }\n            this.initialValues[attr] = value;\n        }\n    }, {\n        key: 'hasInitialValue',\n        value: function hasInitialValue(attr) {\n            return this._hasUserDefinedInitialValue(attr) || this.initialValues.hasOwnProperty(attr);\n        }\n    }, {\n        key: 'getInitialValue',\n        value: function getInitialValue(attr) {\n            if (this._hasUserDefinedInitialValue(attr)) {\n                return this._getUserDefinedInitialValue(attr);\n            }\n            return this.initialValues[attr];\n        }\n    }, {\n        key: 'setParentScene',\n        value: function setParentScene(parentSceneObject) {\n            this.parentSceneObject = parentSceneObject;\n        }\n\n        /* *************************************************\n        STATE CHANGING FUNCTION\n        method from which we can set the state of the Incident.\n        this method should never be invoked directly from code outside the core definition of Incident. All state changes\n        should occur through the corresponding built-in functions (play, wait, etc) */\n\n    }, {\n        key: '_setState',\n        value: function _setState(state) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var oldState = this.runTimeInfo.state;\n            this.runTimeInfo.state = state;\n\n            if (this.checkParentScene() && state === 'completed' && this.speed > 0) {\n                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);\n            } else if (this.checkParentScene() && state === 'idle' && this.speed < 0) {\n                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);\n            }\n\n            var newState = state;\n            if ((state === 'waiting' || state === 'blocked') && props.waitingStateName != 'waiting') {\n                newState = props.waitingStateName;\n            }\n            this.broadcastEvent('state-change', { oldState: oldState, newState: newState });\n        }\n    }, {\n        key: 'setCurrentMillisecond',\n        value: function setCurrentMillisecond(millisecond) {\n            this.runTimeInfo.currentMillisecond = millisecond;\n        }\n\n        /**\n         * sets the state of the Incident silently without broadcasting the event nor informing the parent Incident\n         */\n\n    }, {\n        key: '_dontTellMamaStateChange',\n        value: function _dontTellMamaStateChange(state) {\n            if (this.checkStateTransition(state)) {\n                // helper.log('setting state of ' + this.id + ' to ' + state);\n                var oldState = this.runTimeInfo.state;\n                this.runTimeInfo.state = state;\n                this.broadcastEvent('state-change', { oldState: oldState, newState: state });\n            }\n        }\n\n        /** *************************************************\n        EXECUTION FUNCTIONS\n        sets state to \"playing\" */\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('playing')) {\n                return false;\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.statusBeforeHalt = 'playing';\n                return false;\n            }\n\n            this.timesExecuted += 1;\n            this.onPlay(props);\n            this._setState('playing');\n\n            if (this.bitIncident) {\n                this.complete();\n            }\n            return true;\n        }\n\n        /**\n         wait method can be invoked by the object itself or by its parent Scene. No children are allowd to call the wait\n         method.\n          the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - clipBlockingWaiting\n          An Incident can only exit waiting mode through the resume method\n          */\n\n    }, {\n        key: 'wait',\n        value: function wait(props) {\n            if (!props.waitingStateName) {\n                props = { nature: 'scheduled', waitingStateName: 'waiting' };\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.blockingWaitings = [];\n            } else if (!this.checkStateTransition('waiting')) {\n                return false;\n            }\n\n            this.statusBeforeHalt = this.runTimeInfo.state;\n            this._setState('waiting', props);\n            this.onWait(props);\n            return true;\n        }\n    }, {\n        key: 'setBlockWaiting',\n        value: function setBlockWaiting(props) {\n            if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.blockingWaitings.push(props);\n                this.wait();\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.setBlockWaiting(props);\n                }\n            }\n        }\n    }, {\n        key: 'unsetBlockWaiting',\n        value: function unsetBlockWaiting(props) {\n            if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.blockingWaitings = [];\n                this.unblock();\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.unsetBlockWaiting(props);\n                }\n            }\n        }\n    }, {\n        key: 'unblock',\n        value: function unblock() {\n            if (this.statusBeforeHalt === 'playing') {\n                this.resume();\n            }\n        }\n\n        /**\n         block and unblock methods can only be invoked by a parent of the Incident. No children (in the case of a Scene) nor\n         the Incident itself can block or unblock itself.\n          */\n\n    }, {\n        key: 'block',\n        value: function block() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('blocked')) {\n                return false;\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.statusBeforeHalt = 'blocked';\n                return false;\n            }\n\n            this.statusBeforeHalt = this.runTimeInfo.state;\n            this._setState('blocked', props);\n            this.onBlock(props);\n            return true;\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition(this.statusBeforeHalt)) {\n                return false;\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.statusBeforeHalt = 'playing';\n                return false;\n            }\n\n            this.onResume(props);\n            this._setState(this.statusBeforeHalt);\n\n            return true;\n        }\n    }, {\n        key: 'reset',\n        value: function reset() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            // this.stop();\n            if (!this.checkStateTransition('idle')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this.timesExecuted = 0;\n            this._setState('idle');\n            this.onReset(props);\n            return true;\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.speed > 0) {\n                if (!this.checkStateTransition('completed')) {\n                    return false;\n                }\n            } else {\n                if (!this.checkStateTransition('idle')) {\n                    return false;\n                }\n            }\n\n            this.onBeforeComplete(props);\n\n            if (this.speed > 0) {\n                this._setState('completed');\n            } else {\n                this._setState('idle');\n            }\n\n            if (this.speed > 0) {\n                this.runTimeInfo.currentMillisecond = this.duration;\n            } else {\n                this.runTimeInfo.currentMillisecond = 0;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('transitional')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this.stateBeforeStop = this.state + \"\";\n            this._setState('transitional');\n            this.onStop(props);\n            return true;\n        }\n\n        /**\n         * Restores the execution of the Incident after a stop\n        **/\n\n    }, {\n        key: 'restore',\n        value: function restore() {\n            if ((this.state === 'waiting' || this.state === 'blocked') && this.stateBeforeStop === 'playing') {\n                this.resume();\n            }\n        }\n    }, {\n        key: 'arm',\n        value: function arm() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('waiting')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this._dontTellMamaStateChange('waiting');\n            this.onArm(props);\n            return true;\n        }\n\n        /**\n         * There are various events happening on the scope of an Incident. Any class extending Incident might have / define its own\n         * events.\n         *\n         * The \"broadcastEvent\" method of the Incident allows the Incident (of any type, even on classes extending it) broadcast\n         * events on any of the interested parties that have subscribed to it.\n         *\n         * The \"subscribeToEvents\" method allows any third party subscribe and listen to events' broadcasts by any Incident\n         *\n         * @param {string} id - the unique id of the event listener\n         * @param {function} fnct - a function to get executed whenever an event gets broadcasted by the specific Incident. The\n         *  fnct will be executed on all events' broadcasts and it will receive the event object as argument. The event object is\n         *  of format:\n         *  {\n                name: the name of the event,\n                meta: an object holding all the meta-info of the event\n            }\n         }\n        */\n\n    }, {\n        key: 'subscribeToEvents',\n        value: function subscribeToEvents(id, fnct) {\n            this.eventsSubscriptions[id] = fnct;\n        }\n\n        /**\n         * unsubscribes any subscribed listener to the Incident's events broadcasting\n         * @param {string} id\n         */\n\n    }, {\n        key: 'unsubscribeFromEvents',\n        value: function unsubscribeFromEvents(id) {\n            if (this.eventsSubscriptions[id]) {\n                delete this.eventsSubscriptions[id];\n            }\n        }\n\n        /**\n         * broadcasts any event\n         * @param {string} eventName\n         * @param {object} meta\n         */\n\n    }, {\n        key: 'broadcastEvent',\n        value: function broadcastEvent(eventName, meta) {\n            for (var key in this.eventsSubscriptions) {\n                this.eventsSubscriptions[key](eventName, meta);\n            }\n        }\n\n        /**\n         * This method's (which should be called whenever a slip ends) purpose is to calculate and set\n         * the right state of the Incident based on the target millisecond.\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n         */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState(targetMillisecondDeltaFromStart) {\n            if (targetMillisecondDeltaFromStart >= 0) {\n                // if it ends before the target millisecond\n                this._dontTellMamaStateChange('completed');\n            } else {\n                // if it has been completed on targetMillisecond\n                this._dontTellMamaStateChange('idle');\n            }\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            return true;\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            return {\n                id: this.id,\n                duration: this.duration,\n                class: this.constructor.name,\n                mc_plugin_npm_name: this.mc_plugin_npm_name,\n                plugin_channel_class: this.plugin_channel_class,\n                state: this.state,\n                customParams: this.customParams,\n                attrs: Object.assign({}, this.attrs),\n                props: Object.assign({}, this.props),\n                Incident: this.constructor\n            };\n        }\n\n        // *************************************************\n        /* PIPES SYSTEM\n            The Pipes system is a vertical interconnection system that runs out the full Incidents tree and connects all of them.\n            Through Pipes any Incident can communicate anything to all of its children or parents.\n            \n            In order to initialise a pipe message the user should use the putMessageOnPipe method. This method is exposed by all\n                Incidents, of all types, and it is first been processed by the receiver Incident and then passed further down to\n                its children (if any).\n            This method takes exactly 5 arguments:\n            - name (the name of the command). This should be unique among the full MC ecosystem including native message names & \n                plugins' message names. In order to avoid conflicts is good to use the convention: <plugin_npm_name>.<message_name>\n            - parameters (an object holding the parameters of the command)\n            - selfExecute (true/false) - If true the Incident will try to process the pipe command before further passing further up or down\n            - direction (default \"down\") - defines the direction of the pipe command. It can be either \"down\" so it passes it down to \n                its children or \"up\" so it passes it up to its parents\n            - target. The target defines / describes the receivers of the pipe message. This might be:\n                - null (default) - targets all incidents\n                - type: \"group\" - targets only groups (including clips)\n                - type: \"clip\" - targets only clips\n                - type: \"rootClip\" - targets only the root clip of the tree\n                - id: \"<id>\" - targets a specific incident with specific id\n                - plugin: \"<plugin_npm_name>\" - targets only Incidents of a specific plugin\n            \n            Handling pipe messages:\n            The putMessageOnPipe method decides whether it should be processed or\n            not by the Incident depending on the target. This method is the _processPipeMessage. If the Incident should process the \n            pipe message the _processPipeMessage method calls the \"handlePipeMessage\" method passing the name and the parameters.\n            The \"handlePipeMessage\" is a built in method as well and the developers should just overwrite it so they handle the \n            various pipes messages based on their names.\n        */\n\n    }, {\n        key: 'putMessageOnPipe',\n        value: function putMessageOnPipe(name, params, selfExecute, direction) {\n            var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            if (selfExecute) {\n                if (target === null) {\n                    this.handlePipeMessage(name, params);\n                } else {\n                    if (target.hasOwnProperty('type')) {\n                        if (target.type === 'group' && this.hasIncidents) {\n                            this.handlePipeMessage(name, params);\n                        } else if (target.type === 'clip' && this.isTheClip) {\n                            this.handlePipeMessage(name, params);\n                        } else if (target.type === \"rootClip\" && this.isTheClip && !this.checkParentScene()) {\n                            this.handlePipeMessage(name, params);\n                            return;\n                        }\n                    } else if (target.hasOwnProperty('id')) {\n                        if (this.id === target.id) {\n                            this.handlePipeMessage(name, params);\n                            return;\n                        }\n                    } else if (target.hasOwnProperty('plugin')) {\n                        if (this.mc_plugin_npm_name === target.plugin) {\n                            this.handlePipeMessage(name, params);\n                        }\n                    }\n                }\n            }\n\n            if (direction === \"down\" && this.hasIncidents) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.putMessageOnPipe(name, params, true, direction, target);\n                }\n            } else if (direction === \"up\" && this.checkParentScene()) {\n                this.parentSceneObject.putMessageOnPipe(name, params, true, direction, target);\n            }\n        }\n    }, {\n        key: 'handlePipeMessage',\n        value: function handlePipeMessage(name, params) {}\n        // Plugins developers can overwrite this method so they can handle pipe messages per name\n\n\n        // *************************************************\n        // ACTUAL BAHAVIOUR FUNCTIONS THAT SHOULD BE IMPLEMENTED BY ALL CLASSES EXTENDING INCIDENT\n\n    }, {\n        key: 'onPlay',\n        value: function onPlay(props) {\n            helper.info('Overwritte the \"onPlay\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onResume',\n        value: function onResume(props) {\n            helper.info('Overwritte the \"onResume\" method with the code you want to get executed', 'info');\n        }\n\n        /**\n         * Helper function that normalises the millisecond to pass to the Incidents on goTo\n         * If millisecond < 0 it makes it 0\n         * If millisecond > duration of the Incident it makes it equals to the duration\n         * @param {int} millisecond - the millisecond to normalise. It represents the distance of the time to go to from\n         *  the start of the Incident\n         * @returns {int} - the normalised millisecond\n        **/\n\n    }, {\n        key: 'normaliseGoToTarget',\n        value: function normaliseGoToTarget(millisecond) {\n            if (millisecond < 0) {\n                millisecond = 0;\n            } else if (millisecond > this.duration) {\n                millisecond = this.duration;\n            }\n\n            return millisecond;\n        }\n\n        /**\n         * goTo on the Incident level implements the logic of passing the authority of execution to its parent\n         * (if there is any)\n         * Incidents that implement their own goTo logic should overwrite the goTo method otherwise the goTo\n         * will be passed up until either it reaches a context owner or a tree root\n         * @param {int} millisecond - (optional) the millisecond where we want to goTo. If not provided we use the current millisecond of the Incident\n         * @returns {boolean} - if the context owner of the Incident actually executes the goTo command the\n         *  method returns true otherwise it returns false\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisedond) {\n            // if the incident has a parent scene\n            if (this.checkParentScene()) {\n                if (this.parentSceneObject.goTo(millisedond, { relativeTo: this.id })) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Returns the milliseconds delta between the Incident's start point and its root Scene's current millisecond.\n         * If the result is negative it means the root scene's current millisecond is prior to the Incident's start point\n         * @returns {int}\n        **/\n\n    }, {\n        key: 'getRootCurrentMillisecondDeltaFromStart',\n        value: function getRootCurrentMillisecondDeltaFromStart() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id);\n            } else {\n                return this.runTimeInfo.currentMillisecond;\n            }\n        }\n    }, {\n        key: 'beOn',\n        value: function beOn(millisecond) {\n            var goTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            var previousState = this.state + \"\";\n            this.stop();\n            if (goTo) {\n                this.goTo(millisecond);\n            }\n            this.setCurrentMillisecond(millisecond);\n            this.recalcState(millisecond);\n            var newState = this.state + \"\";\n            return {\n                previousState: previousState,\n                newState: newState\n            };\n        }\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            if (!this.gotContext) {\n                this.onGetContext();\n                this.gotContext = true;\n            }\n        }\n    }, {\n        key: 'onGetContext',\n        value: function onGetContext() {\n            helper.info('Overwritte the \"onGetContext\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onStop',\n        value: function onStop(props) {\n            helper.info('Overwritte the \"onBeforeStop\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onReset',\n        value: function onReset(props) {\n            helper.info('Overwritte the \"onReset\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBeforeComplete',\n        value: function onBeforeComplete(props) {\n            helper.info('Overwritte the \"onBeforeEnd\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBlock',\n        value: function onBlock(props) {\n            helper.info('Overwritte the \"onBlock\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onUnblock',\n        value: function onUnblock(props) {\n            helper.info('Overwritte the \"onUnblock\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onWait',\n        value: function onWait(props) {\n            helper.info('Overwritte the \"onWait\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onArm',\n        value: function onArm(props) {\n            helper.info('Overwritte the \"onArm\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            this.stop();\n        }\n    }, {\n        key: 'onInitialise',\n        value: function onInitialise(attrs, props) {\n            helper.info('Overwritte the \"onInialise\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'isOnTestMode',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.isOnTestMode;\n            } else {\n                return this.testMode;\n            }\n        }\n    }, {\n        key: 'selector',\n        get: function get() {\n            return this.props.selector;\n        }\n\n        /* shortcuts for attrs.attrs and attrs.animatedAttrs */\n\n    }, {\n        key: 'animAttributes',\n        get: function get() {\n            return this.attrs.animatedAttrs;\n        }\n    }, {\n        key: 'confAttributes',\n        get: function get() {\n            return this.attrs.attrs;\n        }\n    }, {\n        key: 'element',\n        get: function get() {\n            if (this.contex === null) {\n                return [];\n            }\n            return this.context.getElements(this.selector)[0];\n        }\n\n        /*\n        returns the initialised channel by the Clip the Incident belongs to\n        */\n\n    }, {\n        key: 'channel',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject._getChannel(this.mc_plugin_npm_name);\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'elements',\n        get: function get() {\n            if (this.contex === null) {\n                return [];\n            }\n            return this.context.getElements(this.selector);\n        }\n    }, {\n        key: 'executionSpeed',\n        set: function set(speed) {\n            this.speed = speed;\n            // this.beOn(this.runTimeInfo.currentMillisecond);\n        }\n\n        /**\n         * gets the Incident's duration. This method should be overwriten accordingly by all Incidents\n         */\n\n    }, {\n        key: 'duration',\n        get: function get() {\n            return 0;\n        },\n        set: function set(duration) {\n            ;\n        }\n    }, {\n        key: 'state',\n        get: function get() {\n            return this.runTimeInfo.state;\n        }\n    }, {\n        key: 'context',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.context;\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'direction',\n        get: function get() {\n            return this.speed > 0 ? \"forwards\" : \"backwards\";\n        }\n    }]);\n\n    return Incident;\n}();\n\nmodule.exports = Incident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvSW5jaWRlbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvSW5jaWRlbnQuanM/NDA1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGNoZWNrVHJhbnNpdGlvbiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vYWxsb3dlZFN0YXRlQ2hhbmdlcycpLmNoZWNrVHJhbnNpdGlvbjtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL19DaGFubmVscy9DaGFubmVsJyk7XG5cbi8qKiBAY2xhc3NkZXNjXG4gKiBJbmNpZGVudHMgYXJlIGFsbCBldmVudHMgdGhhdCBzaG91bGQgaGFwcGVuIG9uIGEgc3BlY2lmaWMgdGltZSBvbiB0aGUgdGltZWxpbmUuIEFuIGluY2lkZW50IGNhbiBoYXZlIHBhcmFtZXRyaWNcbiAgICAgIGV4ZWN1dGlvbiBiZWhhdmlvdXIgYmFzZWQgb24gdGhlIHRpbWVzIGl0IGhhcyBiZWVuIGV4ZWN1dGVkIGFuZCAobWlnaHQgYmUpIG9uIG90aGVyIHBhcmFtZXRlcnMuXG5cbiAgICAgIFRoZSBzdGF0ZSBhbiBJbmNpZGVudCBjYW4gaGF2ZSBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgICAgICAgICAgaWRsZVxuICAgICAgICAgICAgICAgICBwbGF5aW5nXG4gICAgICAgICAgICAgICAgIHdhaXRpbmdcbiAgICAgICAgICAgICAgICAgc2NlbmVCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAgICAgY2xpcEJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgICAgICBibG9ja2VkICAgIC8vIGluIHRoZSBjYXNlIHRoZSBJbmNpZGVudCBpcyBibG9ja2VkIC8gcGF1c2VkIGJ5IGEgd2FpdGluZ1xuICAgICAgICAgICAgICAgICBjb21wbGV0ZWRcblxuICAgICAgRWFjaCBJbmNpZGVudCBoYXMgdGhlIG9ibGlnYXRpb24gdG8gaW5mb3JtIHRoZSBTY2VuZSBhYm91dCBpdHMgc3RhdGUgY2hhbmdlcy5cbiAgICAgIEZvciB0aGlzIEluY2lkZW50IHByb3ZpZGVzIHRoZSBtZXRob2Qg4oCcc2V0UGFyZW50U2NlbmXigJ0gd2hpY2ggdGFrZXMganVzdCBvbmUgYXJndW1lbnQgYSBUaW1lciBvYmplY3QuXG4gICAgICBUaW1lciBwcm92aWRlcyB0aGUgbWV0aG9kIOKAnGluY2lkZW50U3RhdGVDaGFuZ2XigJ0gd2hpY2ggbGV0cyB0aGUgSW5jaWRlbnRzIGNoYW5nZSB0aGVpciBzdGF0ZSBieVxuICAgICAgcHJvdmlkaW5nIHRoZWlyIGlkIGFuZCB0aGVpciBuZXcgc3RhdGUuXG4gKiAqL1xuXG52YXIgSW5jaWRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgIEl0IHRha2VzIGp1c3Qgb25lIGFyZ3VtZW50LCBcInByb3BzXCIuIFByb3BzIHBhc3MgZGF0YSB1c2VmdWwgb25seSBmb3IgdGhlIGZvbGxvd2luZzpcbiAgICAgQW4gaW5jaWRlbnQgY2FuIGJlIHNldCB0byBiZSBlaXRoZXIgaW5leGhhdXN0aWJsZSAobWVhbmluZyBpdCBjYW4gYmUgZXhlY3V0ZWQgYWdhaW4gYW5kIGFnYWluIGluZmluaXRlIHRpbWVzIC0tIGRlZmF1bHQpXG4gICAgIG9yIGZpbml0ZSBtZWFuaW5nIGl0IGNhbiBvbmx5IGJlIGV4ZWN1dGVkIGEgbGltaXRlZCAoc3BlY2lmaWMpIG51bWJlciBvZiB0aW1lcy4gVGhpcyBpbmZvIGNhbiBiZSBmb3VuZCBvbiB0aGUgbWF4TGlmZUN5Y2xlc1xuICAgICBPZiBjb3Vyc2UgdGhlIGluY2lkZW50IGNhbiBiZSByZXNldCB0byBpdHMgaW5pdGlhbCBjb25kaXRpb24gYXQgYW55IHRpbWUgdGhyb3VnaCB0aGUgXCJyZXNldFwiIG1ldGhvZCBpdCBwcm92aWRlcy5cbiAgICAgIEFzIGEgbHV4dXJpb3VzbmVzcywgYW5kIGFsb25nIFdJVEggdGhlIG1heExpZmVDeWNsZXMgcGFyYW1ldGVyLCB0aGUgSW5jaWRlbnQgYWxzbyBwcm92aWRlcyB0aGUgZXhlY3V0aW9uUGF0dGVybiBwYXJhbWV0ZXJcbiAgICAgdGhyb3VnaCB3aGljaCB0aGUgcHJvZ3JhbW1lciAvIHVzZXIgY2FuIGRlZmluZSBhIG1vcmUgY29tcGxleCBiZWhhdmlvdXIgb2YgdGhlIEluY2lkZW50IGV4ZWN1dGlvbiBkZXBlbmRpbmcgb24gdGhlIG51bWJlciB0aW1lc1xuICAgICB0aGUgaW5jaWRlbnQgaGFzIGFscmFkeSBiZSBleGVjdXRlZCAoIGlzIHRoZSAxc3QgdGltZSwgdGhlIDJuZCB0aW1lLCB0aGUgM3JkIHRpbWUgZXRjKSBhbmQgYW55IGN1c3RvbSBwYXJhbWV0ZXIgaXRcbiAgICAgaG9sZHMuIFRoZSBleGVjdXRpb24gdGltZXMgYXJlIGhlbGQgb24gdGhlIFwiZXhlY3V0aW9uVGltZXNcIiBhdHRyaWJ1dGUgb2YgdGhlIGNsYXNzLlxuICAgICAgcHJvcHM6XG4gICAgIHtcbiAgICAgICAgaWQ6IGlmIHBhc3NlZCB0aGF0J3MgdGhlIGlkIG9mIHRoZSBJbmNpZGVudC4gSWYgbm90IHdlIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgcGx1Z2luX2NoYW5uZWxfY2xhc3MgLSBpZiBwYXNzZWQgZ2V0cyBzZXQgdG8gaXRcbiAgICAgICAgbWNfcGx1Z2luX25wbV9uYW1lIC0gaWYgcGFzc2VkIGdldHMgc2V0IHRvIGl0XG4gICAgIH1cbiAgICAgICAgQHBhcmFtIHtvYmplY3R9IHByb3BzICovXG4gICAgZnVuY3Rpb24gSW5jaWRlbnQoKSB7XG4gICAgICAgIHZhciBhdHRycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluY2lkZW50KTtcblxuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkIHx8IGhlbHBlci5nZXRBbklkKCk7XG5cbiAgICAgICAgLy8gdGhpcyBwYXJhbWV0ZXIgaXMgaW5pdGlhbGlzZWQgdG8gZmFsc2UuIE9uY2UgdGhlIG9uR2V0Q29udGV4dCBtZXRob2QgZ2V0cyBpbnZva2VkIHRoaXMgcGFyYW1ldGVyXG4gICAgICAgIC8vIGlzIHNldCB0byB0cnVlIHNvIHdlIHByZXZlbnQgbXVsdGlwbGUgZXhlY3V0aW9ucyBvZiB0aGUgb25HZXRDb250ZXh0IG1ldGhvZFxuICAgICAgICB0aGlzLmdvdENvbnRleHQgPSBmYWxzZTtcblxuICAgICAgICAvKlxuICAgICAgICB0aGVzZSBhcmUgdGhlIGRlZmF1bHQgdmFsdWVzIHRoYXQgZGVmaW5lIGNoYW5uZWxpbmcgZm9yIHRoZSBkZWZhdWx0IEluY2lkZW50cy4gVGhlc2UgdmFsdWVzIGdldCBvdmV3cmlkZW4gdGhyb3VnaFxuICAgICAgICB0aGUgbG9hZFBsdWdpbiBtZXRob2Qgb2YgTUMgd2l0aCB0aGUgdmFsdWVzIGZvdW5kIG9uIHRoZSBtYWluLmpzIGZpbGUgb2YgdGhlIHBsdWdpblxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzID0gQ2hhbm5lbDtcbiAgICAgICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBcIm1vdG9yLWNvcnRleC1qc1wiO1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3BsdWdpbl9jaGFubmVsX2NsYXNzJykpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBwcm9wcy5wbHVnaW5fY2hhbm5lbF9jbGFzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ21jX3BsdWdpbl9ucG1fbmFtZScpKSB7XG4gICAgICAgICAgICB0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSA9IHByb3BzLm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFxuICAgICAgICBUaGUgZm9sbG93aW5nIHR3byBwcm9wZXJ0aWVzIChcInN0YXR1c0JlZm9yZUhhbHRcIiBhbmQgXCJzdGF0ZUJlZm9yZVN0b3BcIikgd2hpY2ggaGF2ZSBzdHVwaWRseSBcbiAgICAgICAgdXNlZCBcInN0YXR1c1wiIGluIHRoZSBvbmUgY2FzZSBhbmQgXCJzdGF0ZVwiIGluIHRoZSBvdGhlclxuICAgICAgICBhY3QgYXMgdGhlIG1lbW9yeSBvZiB0aGUgSW5jaWRlbnQgaW4gdGhlIGNhc2Ugb2YgYSBzdG9wIG9yXG4gICAgICAgIGEgaGFsdGluZyBjb21tYW5kICh3YWl0IG9yIGJsb2NrKSwgc3RvcmluZyB0aGUgc3RhdGUgb2YgaXQganVzdCBiZWZvcmUgYW55IG9mIHRoZSB0d28gZ2V0IFxuICAgICAgICBleGVjdXRlZC4gXG4gICAgICAgIFRoZXNlIHByb3BlcnRpZXMgY2FuIGJlIHVzZWQgaW4gdmFyaW91cyB3YXlzIGluIHRoZSBwcm9ncmFtXG4gICAgICAgIGFuZCB0aGV5IGRvIG5vdCB0YXJnZXQgc3BlY2lmaWMgZnVuY3Rpb25hbGl0eS5cbiAgICAgICAgKi9cbiAgICAgICAgLy8gdGhlIHN0YXR1cyBvZiB0aGUgSW5jaWRlbnQgYmVmb3JlIGl0IGdvdCBoYWx0ZWQgYnkgZWl0aGVyIHRoZSBibG9jayBvciB0aGUgd2FpdCBjb21tYW5kXG4gICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9ICdpZGxlJztcbiAgICAgICAgLy8gaG9sZHMgdGhlIHN0YXRlIG9mIHRoZSBJbmNpZGVudCBiZWZvcmUgdGhlIHN0b3AgY29tbWFuZFxuICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3RvcCA9ICdpZGxlJztcblxuICAgICAgICB0aGlzLnRpbWVzRXhlY3V0ZWQgPSAwO1xuICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLnJ1blRpbWVJbmZvID0ge1xuICAgICAgICAgICAgc3RhdGU6ICdpZGxlJyAvLyBvbmUgb2YgXCJpZGxlXCIsIFwicGxheWluZ1wiLCBcIndhaXRpbmdcIlxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYml0SW5jaWRlbnQgPSB0cnVlO1xuICAgICAgICB0aGlzLmhhc0luY2lkZW50cyA9IGZhbHNlO1xuXG4gICAgICAgIC8qIGFuIGFycmF5IGhvbGRpbmcgYWxsICAqL1xuICAgICAgICB0aGlzLmV2ZW50c1N1YnNjcmlwdGlvbnMgPSB7fTtcblxuICAgICAgICAvKlxuICAgICAgICBSaWdodCBub3cgbWFueSBrZXlzIG9mIHRoZSBJbmNpZGVudCAoc3VjaCBhcyBcInByb3BzXCIsIFwiYXR0cnNcIiwgZXRjKSBhcmUgYWxyZWFkeSBiZWVuIHVzZWQgYnkgdGhlIEluY2lkZW50IFxuICAgICAgICBjbGFzcy4gVGhlIGZpbmFsIHVzZXJzIG9mIHRoZSBsaWJyYXJ5ICh0aGUgcGx1Z2luIGRldmVsb3BlcnMpIG1pZ2h0IHdhbnQgdG8ga2VlcCBzcGVjaWFsIC8gc3BlY2lmaWMgZGF0YVxuICAgICAgICBvbiB0aGVpciBJbmNpZGVudHMgYW5kOlxuICAgICAgICBhKSB0aGV5IG1pZ2h0IGRvbid0IGtub3cgd2hpY2gga2V5cyBhcmUgYWxyZWFkeSB0YWtlbiBhbmQgd2hpY2ggYXJlIG5vdFxuICAgICAgICBiKSBtaWdodCB1c2UgYW4gYWxyZWFkeSB1c2VkIGtleSBhbmQgcnVpbiB0aGUgZnVuY3Rpb25hbGl0eVxuICAgICAgICBjKSBzbyB0aGV5IGZlZWwgdW5zYWZlIGtlZXBpbmcgZGF0YSBhbmQgaXQncyBub3Qgc2FmZSBmb3IgdGhlIGxpYiB0b29cbiAgICAgICAgRm9yIHRoaXMgcmVhc29uIHdlIGhhdmUgYSBibGFuayBvYmplY3QgcmVzZXJ2ZWQgZm9yIHRoZW0sIHRoZSBcImN1c3RvbVBhcmFtc1wiLCBpbiBvcmRlciBmb3IgdGhlbSB0byBcbiAgICAgICAgcHV0IGFueXRoaW5nIHRoZXkgd2FudCBhbmQgd2UgZW5jb3VyYWdlIHRoZW0gdG8gdXNlIHRoZSBidWlsdC1pbiBtZXRob2RzOlxuICAgICAgICBzZXRQYXJhbVxuICAgICAgICBnZXRQYXJhbVxuICAgICAgICBzZXRQYXJhbXNcbiAgICAgICAgZm9yIHRoaXMgam9iXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY3VzdG9tUGFyYW1zID0ge307XG5cbiAgICAgICAgdGhpcy5zcGVlZCA9IDE7XG5cbiAgICAgICAgLypcbiAgICAgICAgaW5pdGlhbFZhbHVlcyBpcyBhbiBvYmplY3QgaG9sZGluZyB0aGUgYXV0bWF0aWNhbGx5IGNvbXB1dGVkIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBhbmltYXRlZEF0dHJzIFxuICAgICAgICAoaWYgYW55KS4gVGhlIGluaXRpYWxWYWx1ZXMgYXJlIGNhbGN1bGF0ZWQgYnkgdGhlIEF0dHJpYnV0ZXNDaGFubmVsIChvbmx5IEluY2lkZW50cyBiZWxvbmdpbmcgdG8gXG4gICAgICAgIGFuIEF0dHJpYnV0ZXNDaGFubmVsIGhhdmUgaW5pdGlhbFZhbHVlcykuXG4gICAgICAgIFRoZSBrZXlzIHNldCBvZiB0aGlzIG9iamVjdCBpcyBpZGVudGljYWwgdG8gdGhlIG9iamVjdCBhdHRycy5hbmltYXRlZEF0dHJzIFxuICAgICAgICBUaGUgb25seSB0aGluZyB0aGUgZ2VuZXJpYyBBdHRyaWJ1dGVzQ2hhbm5lbCBjYW4ndCBjYWxjdWxhdGUgaXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYW4gYW5pbWF0ZWQgYXR0clxuICAgICAgICBvZiBhIHNwZWNpZmljIGVsZW1lbnQgd2hlbiB0aGVyZSBhcmUgbm8gb3RoZXIgSW5jaWRlbnRzIGVudGVyZWQgb24gaXRzIGxhbmVzIHlldC4gVGhlc2UgdmFsdWVzIGFyZVxuICAgICAgICB0aGUgXCJzY3JhdGNoVmFsdWVzXCIgYW5kIHRoZXkgYXJlIHN0cm9uZ2x5IGRlcGVuZGVuZCBvbiB0aGUgbmF0dXJlIG9mIHRoZSBsaWIuIEUuZy4gZm9yIGEgQ1NTIGFuaW1hdGlvblxuICAgICAgICB3aGF0IHdlIGFyZSBsb29raW5nIGZvciBjYW4gYmUgZm91bmQgb24gdGhlIGNvbXB1dGVkU3R5bGUuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlcyA9IHt9O1xuXG4gICAgICAgIC8qXG4gICAgICAgIFRoZSB1c2VyIGhhcyB0aGUgYWJpbGl0eSB0byBleHBsaWNpdGVseSBkZWZpbmUgdGhlIGluaXRpYWwgdmFsdWVzIGZvciBhbnkgb2YgdGhlIGFuaW1hdGVkQXR0cnMuIFRoZSB1c2VyXG4gICAgICAgIGNhbiBkbyB0aGF0IGJ5IHByb3ZpZGluZyB0aGUgaW5pdGlhbFZhbHVlcyBvYmplY3Qgb24gdGhlIGF0dHJzIG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy51c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXMgPSB7fTtcbiAgICAgICAgaWYgKGF0dHJzICE9IG51bGwgJiYgYXR0cnMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoJ2luaXRpYWxWYWx1ZXMnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzID0gYXR0cnMuaW5pdGlhbFZhbHVlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIGJsb2NraW5nV2FpdGluZ3MgaXMgYW4gYXJyYXksIGEgY29sbGVjdGlvbiwgb2YgYmxvY2luZyB3YWl0aW5ncyB0aGF0IGhhdmUgdGhlIFNjZW5lIGFzIHRhcmdldC5cbiAgICAgICAgVGhlIGxvZ2ljIGlzIHNpbXBsZTpcbiAgICAgICAgLSBpZiB0aGUgc2NlbmUgcmVjZWl2ZXMgYSBcInNjZW5lQmxvY2tpbmdXYWl0aW5nXCIgdGhlbiBpdCBpcyB0aGUgdGFyZ2V0IGFuZCBpdCBhZG9wdHMgaXRcbiAgICAgICAgLSBpZiB0aGUgc2NlbmUgcmVjZWl2ZXMgYSBcImNoYW5uZWxCbG9ja2luZ1dhaXRpbmdcIiB0aGVuIGlmIGl0IGlzIGEgY2hhbm5lbCBpdCBhZG9wdHMgaXQgb3RoZXJ3aXNlIGl0IHRyaWVzIHRvXG4gICAgICAgICAgICBwYXNzIGl0IGZ1cnRoZXIgdXAgdW50aWwgaXQgZmluZHMgYSBjaGFubmVsXG4gICAgICAgIC0gaWYgdGhlIHNjZW5lIHJlY2VpdmVzIGEgXCJjbGlwQmxvY2tpbmdXYWl0aW5nXCIgaWYgaXQgaXMgdGhlIENsaXAgaXQgYWRvcHRzIGl0IG90aGVyd2lzZSBpdCB0cmllcyB0byBwYXNzIGl0XG4gICAgICAgICAgICBmdXJ0aGVyIHVwIHVudGlsIGl0IHJlYWNoZXMgdGhlIGNsaXBcbiAgICAgICAgRWFjaCBvYmplY3Qgb24gdGhpcyBhcnJheSByZXByZXNlbnRzIGEgYmxvY2tpbmcgd2FpdGluZyB0cmlnZ2VyZWQgYnkgYSBjaGlsZCBvZiB0aGUgU2NlbmVcbiAgICAgICAgICAgIGFuZCB3aGljaCB0YXJnZXRzIHRoZSBTY2VuZSBpdHNlbGYuXG4gICAgICAgIEVhY2ggY2hpbGQgc2lnbnMgdGhlIGJsb2NraW5nIHdhaXRpbmcgYnkgYXNzaWduaW5nIGl0cyBvd24gaWQgdG8gaXQuIEVhY2ggY2hpbGQgY2FuIG9ubHkgYXNzaWduIGp1c3Qgb25lXG4gICAgICAgICAgICBibG9ja2luZyB3YWl0aW5nIGF0IGEgdGltZS5cbiAgICAgICAgVGhlIHN0cnVjdHVyZSBvZiBlYWNoIGJsb2NraW5nIHdhaXRpbmcgYXBwZWFyaW5nIG9uIHRoaXMgYXJyYXkgaXMgdGhlIGZvbGxvd2luZzpcbiAgICAgICAge1xuICAgICAgICAgICAgaWQ6IHRoZS1zaWduYXR1cmUtb2YtdGhlLXRyaWdnZXJpbmctaW5jaWRlbnQsXG4gICAgICAgICAgICB0eXBlOiBhbnkgb2YgdGhlIHNjZW5lQmxvY2tpbmdXYWl0aW5nIC8gY2hhbm5lbEJsb2NraW5nV2FpdGluZyAvIENsaXBCbG9ja2luZ1dhaXRpbmcsXG4gICAgICAgICAgICBuYXR1cmU6IGFueSBvZiB0aGUgc2NoZWR1bGVkIC8gZHluYW1pYyAvIHN5c3RlbS1wcm9ibGVtXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQG1lbWJlciB7Ym9vbGVhbn0gLSBpZiB0ZXN0aW5nTW9kZSBpcyBzZXQgdG8gdHJ1ZSB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIG1ldGhvZCBpcyBub3QgZ29pbmdcbiAgICAgICAgKiB0byBnZXQgZXhlY3V0ZWQgYXV0b21hdGljYWxseSBidXQgaW5zdGVhZCB0aGUgZW1hdWxhdGVTdGVwIG1ldGhvZCB3aWxsIHN0YXJ0IGZ1bmN0aW9uaW5nIGFsbG93aW5nXG4gICAgICAgICogZGV2ZWxvcGVycyB0byBwYXNzIHRoZSBtaWxsaXNlY29uZHMgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcmV2aW91cyB0aW1lc3RhbXAgbWFudWFsbHlcbiAgICAgICAgKiovXG4gICAgICAgIHRoaXMudGVzdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd0ZXN0TW9kZScpKSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RNb2RlID0gcHJvcHMudGVzdE1vZGU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uSW5pdGlhbGlzZShhdHRycywgcHJvcHMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJbmNpZGVudCwgW3tcbiAgICAgICAga2V5OiAnZ2V0U2NyYXRjaFZhbHVlJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICBUaGlzIG1ldGhvZCBzaG91ZGwgYmUgb3ZlcndyaXR0ZW4gYnkgdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2lucy4gVGhlIG1ldGhvZCBhY2NlcHRzXG4gICAgICAgIGFzIGFyZ3VtZW50cyB0aGUgbWNpZCAoYW4gZWxlbWVudCkgYW5kIHRoZSBhdHRyaWJ1ZSAob25lIG9mIHRoZSBhbmltYXRlZEF0dHJzLCBpZiBhbnkpXG4gICAgICAgIGFuZCByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlbSBhcyB0aGUgbGlicmFyeSBjYWxjdWxhdGVzIC8gZGVmaW5lcyB0aGVtLiBUaGUgXG4gICAgICAgIHJldHVybmVkIHZhbHVlIHJlcHJlc2VudHMgdGhlIHZlcnkgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZSBiZWZvcmVcbiAgICAgICAgYW55IEluY2lkZW50IHRoYXQgYWx0ZXJzIGl0IGdldHMgYWRkZWQuXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSBtY2lkXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAgICAgICAgQHJldHVybnMge21peGVkfSAtIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlbGVtZW50J3MgYXR0cmlidXRlIGp1c3Qgd2hlbiB0aGUgSFRNTCAmIENTU1xuICAgICAgICBvZiB0aGUgQ2xpcCBnZXRzIHJlbmRlcmVkXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTY3JhdGNoVmFsdWUobWNpZCwgYXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudEF0dHJpYnV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QXR0cmlidXRlKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50QnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeU1DSUQobWNpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaGVscGVyLmdldEVsZW1lbnRCeU1DSUQodGhpcy5jb250ZXh0LCBtY2lkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmxhc2hET00nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2hET00oKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZhaWxlZEFkZGl0aW9uczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3R1cm5JbmNpZGVudFRvTUMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdHVybkluY2lkZW50VG9NQygpIHtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBDaGFubmVsO1xuICAgICAgICAgICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBcIm1vdG9yLWNvcnRleC1qc1wiO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7fVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5jaWRlbnRzQnlQbHVnaW4nLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgYW4gb2JqZWN0IHdpdGgga2V5cyB0aGUga2V5cyBvZiBhbGwgdGhlIHBsdWdpbnMgSW5jaWRlbnRzIG9mIHdoaWNoIGFwcGVhciBpbiB0aGVcbiAgICAgICAgICogdHJlZSBvZiB0aGUgR3JvdXAuIEFsbCBJbmNpZGVudHMgYXJlIHByb2plY3RlZCB0byB0aGUgR3JvdXAncyB0aW1lbGluZS5cbiAgICAgICAgICogVGhlIGFycmF5IGluY2x1ZGVzIHRoZSBHcm91cCdzIHByb2plY3Rpb24gdG9vXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudHNCeVBsdWdpbigpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogMDtcblxuICAgICAgICAgICAgdmFyIGluY2lkZW50c0J5UGx1Z2luID0ge307XG4gICAgICAgICAgICBpbmNpZGVudHNCeVBsdWdpblt0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZV0gPSBbe1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBhZGp1c3RNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogdGhpcyxcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgICAgfV07XG4gICAgICAgICAgICByZXR1cm4gaW5jaWRlbnRzQnlQbHVnaW47XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldFBhcmFtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhcmFtKHBhcmFtLCB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jdXN0b21QYXJhbXNbcGFyYW1dID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFBhcmFtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhcmFtKHBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21QYXJhbXNbcGFyYW1dO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQYXJhbXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyYW1zKCkge1xuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgSEVMUEVSIEZVTkNUSU9OU1xuICAgICAgICBjaGVja3MgaWYgdGhlIHBhcmVudCBTY2VuZSBvYmplY3QgaGFzIGJlZW4gZGVmaW5lZCAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1BhcmVudFNjZW5lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUGFyZW50U2NlbmUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRTY2VuZU9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrU3RhdGVUcmFuc2l0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrU3RhdGVUcmFuc2l0aW9uKHRhcmdldFN0YXRlKSB7XG4gICAgICAgICAgICAvLyB3ZSBwcmV2ZW50IHBsYXkgKGFuZCB0aHVzIGFueSBvdGhlciB0cmFuc2l0aW9uKSBpbiBjYXNlcyB0aGUgSW5jaWRlbnQgaGFzIG5vIHBhcmVudFxuICAgICAgICAgICAgLy8gZ3JvdXAuIFRoZSBtZXRob2QgY2hhbmdlcyBvbiBHcm91cFxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVHJhbnNpdGlvbih0aGlzLnJ1blRpbWVJbmZvLnN0YXRlLCB0YXJnZXRTdGF0ZSwgdGhpcy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYXNVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZShhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy51c2VyRGVmaW5lZEluaXRpYWxWYWx1ZXMuaGFzT3duUHJvcGVydHkoYXR0cik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXRVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzW2F0dHJdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRJbml0aWFsVmFsdWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5pdGlhbFZhbHVlKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIubm90aWNlKCdJbmNpZGVudCB3aXRoIGlkICcgKyB0aGlzLmlkICsgJyBoYXMgaW5pdGlhbCB2YWx1ZSBkZWZpbmVkIGZvciAnICsgYXR0ciArICcgYW5kIG5vIGNoYW5nZSBpcyBhbGxvd2VkIG9uIGl0Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbml0aWFsVmFsdWVzW2F0dHJdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc0luaXRpYWxWYWx1ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpIHx8IHRoaXMuaW5pdGlhbFZhbHVlcy5oYXNPd25Qcm9wZXJ0eShhdHRyKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5pdGlhbFZhbHVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxWYWx1ZShhdHRyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0aWFsVmFsdWVzW2F0dHJdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQYXJlbnRTY2VuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJlbnRTY2VuZShwYXJlbnRTY2VuZU9iamVjdCkge1xuICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdCA9IHBhcmVudFNjZW5lT2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBTVEFURSBDSEFOR0lORyBGVU5DVElPTlxuICAgICAgICBtZXRob2QgZnJvbSB3aGljaCB3ZSBjYW4gc2V0IHRoZSBzdGF0ZSBvZiB0aGUgSW5jaWRlbnQuXG4gICAgICAgIHRoaXMgbWV0aG9kIHNob3VsZCBuZXZlciBiZSBpbnZva2VkIGRpcmVjdGx5IGZyb20gY29kZSBvdXRzaWRlIHRoZSBjb3JlIGRlZmluaXRpb24gb2YgSW5jaWRlbnQuIEFsbCBzdGF0ZSBjaGFuZ2VzXG4gICAgICAgIHNob3VsZCBvY2N1ciB0aHJvdWdoIHRoZSBjb3JyZXNwb25kaW5nIGJ1aWx0LWluIGZ1bmN0aW9ucyAocGxheSwgd2FpdCwgZXRjKSAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfc2V0U3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0YXRlKHN0YXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkgJiYgc3RhdGUgPT09ICdjb21wbGV0ZWQnICYmIHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5pbmNpZGVudFN0YXRlQ2hhbmdlKHRoaXMuaWQsIG9sZFN0YXRlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSAmJiBzdGF0ZSA9PT0gJ2lkbGUnICYmIHRoaXMuc3BlZWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5pbmNpZGVudFN0YXRlQ2hhbmdlKHRoaXMuaWQsIG9sZFN0YXRlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgIGlmICgoc3RhdGUgPT09ICd3YWl0aW5nJyB8fCBzdGF0ZSA9PT0gJ2Jsb2NrZWQnKSAmJiBwcm9wcy53YWl0aW5nU3RhdGVOYW1lICE9ICd3YWl0aW5nJykge1xuICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gcHJvcHMud2FpdGluZ1N0YXRlTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ3N0YXRlLWNoYW5nZScsIHsgb2xkU3RhdGU6IG9sZFN0YXRlLCBuZXdTdGF0ZTogbmV3U3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldEN1cnJlbnRNaWxsaXNlY29uZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXJyZW50TWlsbGlzZWNvbmQobWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogc2V0cyB0aGUgc3RhdGUgb2YgdGhlIEluY2lkZW50IHNpbGVudGx5IHdpdGhvdXQgYnJvYWRjYXN0aW5nIHRoZSBldmVudCBub3IgaW5mb3JtaW5nIHRoZSBwYXJlbnQgSW5jaWRlbnRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19kb250VGVsbE1hbWFTdGF0ZUNoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2Uoc3RhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3NldHRpbmcgc3RhdGUgb2YgJyArIHRoaXMuaWQgKyAnIHRvICcgKyBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5icm9hZGNhc3RFdmVudCgnc3RhdGUtY2hhbmdlJywgeyBvbGRTdGF0ZTogb2xkU3RhdGUsIG5ld1N0YXRlOiBzdGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEVYRUNVVElPTiBGVU5DVElPTlNcbiAgICAgICAgc2V0cyBzdGF0ZSB0byBcInBsYXlpbmdcIiAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwbGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ3BsYXlpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gJ3BsYXlpbmcnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy50aW1lc0V4ZWN1dGVkICs9IDE7XG4gICAgICAgICAgICB0aGlzLm9uUGxheShwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgncGxheWluZycpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5iaXRJbmNpZGVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICB3YWl0IG1ldGhvZCBjYW4gYmUgaW52b2tlZCBieSB0aGUgb2JqZWN0IGl0c2VsZiBvciBieSBpdHMgcGFyZW50IFNjZW5lLiBObyBjaGlsZHJlbiBhcmUgYWxsb3dkIHRvIGNhbGwgdGhlIHdhaXRcbiAgICAgICAgIG1ldGhvZC5cbiAgICAgICAgICB0aGUgbmF0dXJlIG9mIGEgd2FpdGluZyBtaWdodCBiZTpcbiAgICAgICAgICAgICAtIHNjaGVkdWxlZCAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRcbiAgICAgICAgICAgICAtIGR5bmFtaWNcbiAgICAgICAgICAgICAtIHN5c3RlbS1lcnJvclxuICAgICAgICAgIHRoZSB3YWl0aW5nU3RhdGVOYW1lIG9mIGEgd2FpdGluZyBjYW4gYmU6XG4gICAgICAgICAgICAgLSB3YWl0aW5nICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBzY2VuZUJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgICAgIC0gY2xpcEJsb2NraW5nV2FpdGluZ1xuICAgICAgICAgIEFuIEluY2lkZW50IGNhbiBvbmx5IGV4aXQgd2FpdGluZyBtb2RlIHRocm91Z2ggdGhlIHJlc3VtZSBtZXRob2RcbiAgICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3YWl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXQocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghcHJvcHMud2FpdGluZ1N0YXRlTmFtZSkge1xuICAgICAgICAgICAgICAgIHByb3BzID0geyBuYXR1cmU6ICdzY2hlZHVsZWQnLCB3YWl0aW5nU3RhdGVOYW1lOiAnd2FpdGluZycgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0gW107XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCd3YWl0aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnd2FpdGluZycsIHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMub25XYWl0KHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRCbG9ja1dhaXRpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmxvY2tXYWl0aW5nKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ3dhaXRpbmcnICYmIHByb3BzLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5zZXRCbG9ja1dhaXRpbmcocHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5zZXRCbG9ja1dhaXRpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zZXRCbG9ja1dhaXRpbmcocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy53YWl0aW5nU3RhdGVOYW1lID09PSAnd2FpdGluZycgJiYgcHJvcHMuaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QudW5zZXRCbG9ja1dhaXRpbmcocHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5ibG9jaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJsb2NrKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9PT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgYmxvY2sgYW5kIHVuYmxvY2sgbWV0aG9kcyBjYW4gb25seSBiZSBpbnZva2VkIGJ5IGEgcGFyZW50IG9mIHRoZSBJbmNpZGVudC4gTm8gY2hpbGRyZW4gKGluIHRoZSBjYXNlIG9mIGEgU2NlbmUpIG5vclxuICAgICAgICAgdGhlIEluY2lkZW50IGl0c2VsZiBjYW4gYmxvY2sgb3IgdW5ibG9jayBpdHNlbGYuXG4gICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2soKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ2Jsb2NrZWQnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gJ2Jsb2NrZWQnO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdibG9ja2VkJywgcHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5vbkJsb2NrKHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXN1bWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKHRoaXMuc3RhdHVzQmVmb3JlSGFsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9ICdwbGF5aW5nJztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25SZXN1bWUocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUodGhpcy5zdGF0dXNCZWZvcmVIYWx0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgLy8gdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ2lkbGUnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0gW107XG5cbiAgICAgICAgICAgIHRoaXMudGltZXNFeGVjdXRlZCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgdGhpcy5vblJlc2V0KHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignY29tcGxldGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdpZGxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUNvbXBsZXRlKHByb3BzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2NvbXBsZXRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0b3AnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbigndHJhbnNpdGlvbmFsJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3RvcCA9IHRoaXMuc3RhdGUgKyBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3RyYW5zaXRpb25hbCcpO1xuICAgICAgICAgICAgdGhpcy5vblN0b3AocHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVzdG9yZXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgSW5jaWRlbnQgYWZ0ZXIgYSBzdG9wXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXN0b3JlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3RvcmUoKSB7XG4gICAgICAgICAgICBpZiAoKHRoaXMuc3RhdGUgPT09ICd3YWl0aW5nJyB8fCB0aGlzLnN0YXRlID09PSAnYmxvY2tlZCcpICYmIHRoaXMuc3RhdGVCZWZvcmVTdG9wID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhcm0nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJtKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCd3YWl0aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLl9kb250VGVsbE1hbWFTdGF0ZUNoYW5nZSgnd2FpdGluZycpO1xuICAgICAgICAgICAgdGhpcy5vbkFybShwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBhcmUgdmFyaW91cyBldmVudHMgaGFwcGVuaW5nIG9uIHRoZSBzY29wZSBvZiBhbiBJbmNpZGVudC4gQW55IGNsYXNzIGV4dGVuZGluZyBJbmNpZGVudCBtaWdodCBoYXZlIC8gZGVmaW5lIGl0cyBvd25cbiAgICAgICAgICogZXZlbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgXCJicm9hZGNhc3RFdmVudFwiIG1ldGhvZCBvZiB0aGUgSW5jaWRlbnQgYWxsb3dzIHRoZSBJbmNpZGVudCAob2YgYW55IHR5cGUsIGV2ZW4gb24gY2xhc3NlcyBleHRlbmRpbmcgaXQpIGJyb2FkY2FzdFxuICAgICAgICAgKiBldmVudHMgb24gYW55IG9mIHRoZSBpbnRlcmVzdGVkIHBhcnRpZXMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdG8gaXQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBcInN1YnNjcmliZVRvRXZlbnRzXCIgbWV0aG9kIGFsbG93cyBhbnkgdGhpcmQgcGFydHkgc3Vic2NyaWJlIGFuZCBsaXN0ZW4gdG8gZXZlbnRzJyBicm9hZGNhc3RzIGJ5IGFueSBJbmNpZGVudFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgdW5pcXVlIGlkIG9mIHRoZSBldmVudCBsaXN0ZW5lclxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmbmN0IC0gYSBmdW5jdGlvbiB0byBnZXQgZXhlY3V0ZWQgd2hlbmV2ZXIgYW4gZXZlbnQgZ2V0cyBicm9hZGNhc3RlZCBieSB0aGUgc3BlY2lmaWMgSW5jaWRlbnQuIFRoZVxuICAgICAgICAgKiAgZm5jdCB3aWxsIGJlIGV4ZWN1dGVkIG9uIGFsbCBldmVudHMnIGJyb2FkY2FzdHMgYW5kIGl0IHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQgb2JqZWN0IGFzIGFyZ3VtZW50LiBUaGUgZXZlbnQgb2JqZWN0IGlzXG4gICAgICAgICAqICBvZiBmb3JtYXQ6XG4gICAgICAgICAqICB7XG4gICAgICAgICAgICAgICAgbmFtZTogdGhlIG5hbWUgb2YgdGhlIGV2ZW50LFxuICAgICAgICAgICAgICAgIG1ldGE6IGFuIG9iamVjdCBob2xkaW5nIGFsbCB0aGUgbWV0YS1pbmZvIG9mIHRoZSBldmVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmVUb0V2ZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0V2ZW50cyhpZCwgZm5jdCkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNTdWJzY3JpcHRpb25zW2lkXSA9IGZuY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogdW5zdWJzY3JpYmVzIGFueSBzdWJzY3JpYmVkIGxpc3RlbmVyIHRvIHRoZSBJbmNpZGVudCdzIGV2ZW50cyBicm9hZGNhc3RpbmdcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1bnN1YnNjcmliZUZyb21FdmVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5zdWJzY3JpYmVGcm9tRXZlbnRzKGlkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHNTdWJzY3JpcHRpb25zW2lkXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1N1YnNjcmlwdGlvbnNbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGJyb2FkY2FzdHMgYW55IGV2ZW50XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Jyb2FkY2FzdEV2ZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJyb2FkY2FzdEV2ZW50KGV2ZW50TmFtZSwgbWV0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9uc1trZXldKGV2ZW50TmFtZSwgbWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QncyAod2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciBhIHNsaXAgZW5kcykgcHVycG9zZSBpcyB0byBjYWxjdWxhdGUgYW5kIHNldFxuICAgICAgICAgKiB0aGUgcmlnaHQgc3RhdGUgb2YgdGhlIEluY2lkZW50IGJhc2VkIG9uIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXIgaXQgdGFrZXMgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgSW5jaWRlbnQgaXRzZWxmIGFuZCBpdCBtaWdodCBiZSBuZWdhdGl2ZVxuICAgICAgICAgKiBOZWdhdGl2ZSB0YXJnZXRNaWxsaXNlY29uZCBtZWFucyB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGlzIE4gbWlsbGlzZWNvbmRzIEJFRk9SRSB0aGUgc3RhcnQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IC0gdGhlIGRlbHRhIG9mIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgY29tcGFyZWQgdG8gdGhlIEluY2lkZW50IHN0YXJ0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWNhbGNTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNTdGF0ZSh0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0KSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZW5kcyBiZWZvcmUgdGhlIHRhcmdldCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGJlZW4gY29tcGxldGVkIG9uIHRhcmdldE1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ2lkbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3lzdG9sRGlhc3RvbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sRGlhc3RvbGUoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFN0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBjbGFzczogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICAgICAgICAgIG1jX3BsdWdpbl9ucG1fbmFtZTogdGhpcy5tY19wbHVnaW5fbnBtX25hbWUsXG4gICAgICAgICAgICAgICAgcGx1Z2luX2NoYW5uZWxfY2xhc3M6IHRoaXMucGx1Z2luX2NoYW5uZWxfY2xhc3MsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhdGUsXG4gICAgICAgICAgICAgICAgY3VzdG9tUGFyYW1zOiB0aGlzLmN1c3RvbVBhcmFtcyxcbiAgICAgICAgICAgICAgICBhdHRyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hdHRycyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpLFxuICAgICAgICAgICAgICAgIEluY2lkZW50OiB0aGlzLmNvbnN0cnVjdG9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvKiBQSVBFUyBTWVNURU1cbiAgICAgICAgICAgIFRoZSBQaXBlcyBzeXN0ZW0gaXMgYSB2ZXJ0aWNhbCBpbnRlcmNvbm5lY3Rpb24gc3lzdGVtIHRoYXQgcnVucyBvdXQgdGhlIGZ1bGwgSW5jaWRlbnRzIHRyZWUgYW5kIGNvbm5lY3RzIGFsbCBvZiB0aGVtLlxuICAgICAgICAgICAgVGhyb3VnaCBQaXBlcyBhbnkgSW5jaWRlbnQgY2FuIGNvbW11bmljYXRlIGFueXRoaW5nIHRvIGFsbCBvZiBpdHMgY2hpbGRyZW4gb3IgcGFyZW50cy5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgSW4gb3JkZXIgdG8gaW5pdGlhbGlzZSBhIHBpcGUgbWVzc2FnZSB0aGUgdXNlciBzaG91bGQgdXNlIHRoZSBwdXRNZXNzYWdlT25QaXBlIG1ldGhvZC4gVGhpcyBtZXRob2QgaXMgZXhwb3NlZCBieSBhbGxcbiAgICAgICAgICAgICAgICBJbmNpZGVudHMsIG9mIGFsbCB0eXBlcywgYW5kIGl0IGlzIGZpcnN0IGJlZW4gcHJvY2Vzc2VkIGJ5IHRoZSByZWNlaXZlciBJbmNpZGVudCBhbmQgdGhlbiBwYXNzZWQgZnVydGhlciBkb3duIHRvXG4gICAgICAgICAgICAgICAgaXRzIGNoaWxkcmVuIChpZiBhbnkpLlxuICAgICAgICAgICAgVGhpcyBtZXRob2QgdGFrZXMgZXhhY3RseSA1IGFyZ3VtZW50czpcbiAgICAgICAgICAgIC0gbmFtZSAodGhlIG5hbWUgb2YgdGhlIGNvbW1hbmQpLiBUaGlzIHNob3VsZCBiZSB1bmlxdWUgYW1vbmcgdGhlIGZ1bGwgTUMgZWNvc3lzdGVtIGluY2x1ZGluZyBuYXRpdmUgbWVzc2FnZSBuYW1lcyAmIFxuICAgICAgICAgICAgICAgIHBsdWdpbnMnIG1lc3NhZ2UgbmFtZXMuIEluIG9yZGVyIHRvIGF2b2lkIGNvbmZsaWN0cyBpcyBnb29kIHRvIHVzZSB0aGUgY29udmVudGlvbjogPHBsdWdpbl9ucG1fbmFtZT4uPG1lc3NhZ2VfbmFtZT5cbiAgICAgICAgICAgIC0gcGFyYW1ldGVycyAoYW4gb2JqZWN0IGhvbGRpbmcgdGhlIHBhcmFtZXRlcnMgb2YgdGhlIGNvbW1hbmQpXG4gICAgICAgICAgICAtIHNlbGZFeGVjdXRlICh0cnVlL2ZhbHNlKSAtIElmIHRydWUgdGhlIEluY2lkZW50IHdpbGwgdHJ5IHRvIHByb2Nlc3MgdGhlIHBpcGUgY29tbWFuZCBiZWZvcmUgZnVydGhlciBwYXNzaW5nIGZ1cnRoZXIgdXAgb3IgZG93blxuICAgICAgICAgICAgLSBkaXJlY3Rpb24gKGRlZmF1bHQgXCJkb3duXCIpIC0gZGVmaW5lcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBwaXBlIGNvbW1hbmQuIEl0IGNhbiBiZSBlaXRoZXIgXCJkb3duXCIgc28gaXQgcGFzc2VzIGl0IGRvd24gdG8gXG4gICAgICAgICAgICAgICAgaXRzIGNoaWxkcmVuIG9yIFwidXBcIiBzbyBpdCBwYXNzZXMgaXQgdXAgdG8gaXRzIHBhcmVudHNcbiAgICAgICAgICAgIC0gdGFyZ2V0LiBUaGUgdGFyZ2V0IGRlZmluZXMgLyBkZXNjcmliZXMgdGhlIHJlY2VpdmVycyBvZiB0aGUgcGlwZSBtZXNzYWdlLiBUaGlzIG1pZ2h0IGJlOlxuICAgICAgICAgICAgICAgIC0gbnVsbCAoZGVmYXVsdCkgLSB0YXJnZXRzIGFsbCBpbmNpZGVudHNcbiAgICAgICAgICAgICAgICAtIHR5cGU6IFwiZ3JvdXBcIiAtIHRhcmdldHMgb25seSBncm91cHMgKGluY2x1ZGluZyBjbGlwcylcbiAgICAgICAgICAgICAgICAtIHR5cGU6IFwiY2xpcFwiIC0gdGFyZ2V0cyBvbmx5IGNsaXBzXG4gICAgICAgICAgICAgICAgLSB0eXBlOiBcInJvb3RDbGlwXCIgLSB0YXJnZXRzIG9ubHkgdGhlIHJvb3QgY2xpcCBvZiB0aGUgdHJlZVxuICAgICAgICAgICAgICAgIC0gaWQ6IFwiPGlkPlwiIC0gdGFyZ2V0cyBhIHNwZWNpZmljIGluY2lkZW50IHdpdGggc3BlY2lmaWMgaWRcbiAgICAgICAgICAgICAgICAtIHBsdWdpbjogXCI8cGx1Z2luX25wbV9uYW1lPlwiIC0gdGFyZ2V0cyBvbmx5IEluY2lkZW50cyBvZiBhIHNwZWNpZmljIHBsdWdpblxuICAgICAgICAgICAgXG4gICAgICAgICAgICBIYW5kbGluZyBwaXBlIG1lc3NhZ2VzOlxuICAgICAgICAgICAgVGhlIHB1dE1lc3NhZ2VPblBpcGUgbWV0aG9kIGRlY2lkZXMgd2hldGhlciBpdCBzaG91bGQgYmUgcHJvY2Vzc2VkIG9yXG4gICAgICAgICAgICBub3QgYnkgdGhlIEluY2lkZW50IGRlcGVuZGluZyBvbiB0aGUgdGFyZ2V0LiBUaGlzIG1ldGhvZCBpcyB0aGUgX3Byb2Nlc3NQaXBlTWVzc2FnZS4gSWYgdGhlIEluY2lkZW50IHNob3VsZCBwcm9jZXNzIHRoZSBcbiAgICAgICAgICAgIHBpcGUgbWVzc2FnZSB0aGUgX3Byb2Nlc3NQaXBlTWVzc2FnZSBtZXRob2QgY2FsbHMgdGhlIFwiaGFuZGxlUGlwZU1lc3NhZ2VcIiBtZXRob2QgcGFzc2luZyB0aGUgbmFtZSBhbmQgdGhlIHBhcmFtZXRlcnMuXG4gICAgICAgICAgICBUaGUgXCJoYW5kbGVQaXBlTWVzc2FnZVwiIGlzIGEgYnVpbHQgaW4gbWV0aG9kIGFzIHdlbGwgYW5kIHRoZSBkZXZlbG9wZXJzIHNob3VsZCBqdXN0IG92ZXJ3cml0ZSBpdCBzbyB0aGV5IGhhbmRsZSB0aGUgXG4gICAgICAgICAgICB2YXJpb3VzIHBpcGVzIG1lc3NhZ2VzIGJhc2VkIG9uIHRoZWlyIG5hbWVzLlxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwdXRNZXNzYWdlT25QaXBlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHB1dE1lc3NhZ2VPblBpcGUobmFtZSwgcGFyYW1zLCBzZWxmRXhlY3V0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoc2VsZkV4ZWN1dGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCd0eXBlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQudHlwZSA9PT0gJ2dyb3VwJyAmJiB0aGlzLmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnR5cGUgPT09ICdjbGlwJyAmJiB0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnR5cGUgPT09IFwicm9vdENsaXBcIiAmJiB0aGlzLmlzVGhlQ2xpcCAmJiAhdGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBpcGVNZXNzYWdlKG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgnaWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaWQgPT09IHRhcmdldC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdwbHVnaW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID09PSB0YXJnZXQucGx1Z2luKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQaXBlTWVzc2FnZShuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcImRvd25cIiAmJiB0aGlzLmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQucHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXJhbXMsIHRydWUsIGRpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gXCJ1cFwiICYmIHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5wdXRNZXNzYWdlT25QaXBlKG5hbWUsIHBhcmFtcywgdHJ1ZSwgZGlyZWN0aW9uLCB0YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVQaXBlTWVzc2FnZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVQaXBlTWVzc2FnZShuYW1lLCBwYXJhbXMpIHt9XG4gICAgICAgIC8vIFBsdWdpbnMgZGV2ZWxvcGVycyBjYW4gb3ZlcndyaXRlIHRoaXMgbWV0aG9kIHNvIHRoZXkgY2FuIGhhbmRsZSBwaXBlIG1lc3NhZ2VzIHBlciBuYW1lXG5cblxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIC8vIEFDVFVBTCBCQUhBVklPVVIgRlVOQ1RJT05TIFRIQVQgU0hPVUxEIEJFIElNUExFTUVOVEVEIEJZIEFMTCBDTEFTU0VTIEVYVEVORElORyBJTkNJREVOVFxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblBsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QbGF5KHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvblBsYXlcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblJlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc3VtZShwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25SZXN1bWVcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBlciBmdW5jdGlvbiB0aGF0IG5vcm1hbGlzZXMgdGhlIG1pbGxpc2Vjb25kIHRvIHBhc3MgdG8gdGhlIEluY2lkZW50cyBvbiBnb1RvXG4gICAgICAgICAqIElmIG1pbGxpc2Vjb25kIDwgMCBpdCBtYWtlcyBpdCAwXG4gICAgICAgICAqIElmIG1pbGxpc2Vjb25kID4gZHVyYXRpb24gb2YgdGhlIEluY2lkZW50IGl0IG1ha2VzIGl0IGVxdWFscyB0byB0aGUgZHVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIG1pbGxpc2Vjb25kIHRvIG5vcm1hbGlzZS4gSXQgcmVwcmVzZW50cyB0aGUgZGlzdGFuY2Ugb2YgdGhlIHRpbWUgdG8gZ28gdG8gZnJvbVxuICAgICAgICAgKiAgdGhlIHN0YXJ0IG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAgKiBAcmV0dXJucyB7aW50fSAtIHRoZSBub3JtYWxpc2VkIG1pbGxpc2Vjb25kXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdub3JtYWxpc2VHb1RvVGFyZ2V0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGlzZUdvVG9UYXJnZXQobWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIGlmIChtaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1pbGxpc2Vjb25kID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdvVG8gb24gdGhlIEluY2lkZW50IGxldmVsIGltcGxlbWVudHMgdGhlIGxvZ2ljIG9mIHBhc3NpbmcgdGhlIGF1dGhvcml0eSBvZiBleGVjdXRpb24gdG8gaXRzIHBhcmVudFxuICAgICAgICAgKiAoaWYgdGhlcmUgaXMgYW55KVxuICAgICAgICAgKiBJbmNpZGVudHMgdGhhdCBpbXBsZW1lbnQgdGhlaXIgb3duIGdvVG8gbG9naWMgc2hvdWxkIG92ZXJ3cml0ZSB0aGUgZ29UbyBtZXRob2Qgb3RoZXJ3aXNlIHRoZSBnb1RvXG4gICAgICAgICAqIHdpbGwgYmUgcGFzc2VkIHVwIHVudGlsIGVpdGhlciBpdCByZWFjaGVzIGEgY29udGV4dCBvd25lciBvciBhIHRyZWUgcm9vdFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmQgLSAob3B0aW9uYWwpIHRoZSBtaWxsaXNlY29uZCB3aGVyZSB3ZSB3YW50IHRvIGdvVG8uIElmIG5vdCBwcm92aWRlZCB3ZSB1c2UgdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSAtIGlmIHRoZSBjb250ZXh0IG93bmVyIG9mIHRoZSBJbmNpZGVudCBhY3R1YWxseSBleGVjdXRlcyB0aGUgZ29UbyBjb21tYW5kIHRoZVxuICAgICAgICAgKiAgbWV0aG9kIHJldHVybnMgdHJ1ZSBvdGhlcndpc2UgaXQgcmV0dXJucyBmYWxzZVxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ29UbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnb1RvKG1pbGxpc2Vkb25kKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgaW5jaWRlbnQgaGFzIGEgcGFyZW50IHNjZW5lXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nb1RvKG1pbGxpc2Vkb25kLCB7IHJlbGF0aXZlVG86IHRoaXMuaWQgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBiZXR3ZWVuIHRoZSBJbmNpZGVudCdzIHN0YXJ0IHBvaW50IGFuZCBpdHMgcm9vdCBTY2VuZSdzIGN1cnJlbnQgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIElmIHRoZSByZXN1bHQgaXMgbmVnYXRpdmUgaXQgbWVhbnMgdGhlIHJvb3Qgc2NlbmUncyBjdXJyZW50IG1pbGxpc2Vjb25kIGlzIHByaW9yIHRvIHRoZSBJbmNpZGVudCdzIHN0YXJ0IHBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIHtpbnR9XG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRSb290Q3VycmVudE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbUluY2lkZW50c1N0YXJ0KHRoaXMuaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JlT24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmVPbihtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGdvVG8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5zdGF0ZSArIFwiXCI7XG4gICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgIGlmIChnb1RvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pbGxpc2Vjb25kKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMucmVjYWxjU3RhdGUobWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZSArIFwiXCI7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzU3RhdGU6IHByZXZpb3VzU3RhdGUsXG4gICAgICAgICAgICAgICAgbmV3U3RhdGU6IG5ld1N0YXRlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfb25HZXRDb250ZXh0T25jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nb3RDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkdldENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmdvdENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkdldENvbnRleHQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25HZXRDb250ZXh0KCkge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25HZXRDb250ZXh0XCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25TdG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uU3RvcChwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25CZWZvcmVTdG9wXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25SZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc2V0KHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvblJlc2V0XCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25CZWZvcmVDb21wbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkJlZm9yZUNvbXBsZXRlKHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkJlZm9yZUVuZFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uQmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25CbG9jayhwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25CbG9ja1wiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uVW5ibG9jaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblVuYmxvY2socHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uVW5ibG9ja1wiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uV2FpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbldhaXQocHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uV2FpdFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uQXJtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQXJtKHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkFybVwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xhc3RXaXNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RXaXNoKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uSW5pdGlhbGlzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoYXR0cnMsIHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbkluaWFsaXNlXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNPblRlc3RNb2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5pc09uVGVzdE1vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRlc3RNb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZWxlY3RvcicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuc2VsZWN0b3I7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBzaG9ydGN1dHMgZm9yIGF0dHJzLmF0dHJzIGFuZCBhdHRycy5hbmltYXRlZEF0dHJzICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuaW1BdHRyaWJ1dGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb25mQXR0cmlidXRlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuYXR0cnM7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VsZW1lbnQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuZ2V0RWxlbWVudHModGhpcy5zZWxlY3RvcilbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICByZXR1cm5zIHRoZSBpbml0aWFsaXNlZCBjaGFubmVsIGJ5IHRoZSBDbGlwIHRoZSBJbmNpZGVudCBiZWxvbmdzIHRvXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoYW5uZWwnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0Ll9nZXRDaGFubmVsKHRoaXMubWNfcGx1Z2luX25wbV9uYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VsZW1lbnRzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEVsZW1lbnRzKHRoaXMuc2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleGVjdXRpb25TcGVlZCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHNwZWVkKSB7XG4gICAgICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICAvLyB0aGlzLmJlT24odGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGdldHMgdGhlIEluY2lkZW50J3MgZHVyYXRpb24uIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVyd3JpdGVuIGFjY29yZGluZ2x5IGJ5IGFsbCBJbmNpZGVudHNcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2R1cmF0aW9uJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RhdGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb250ZXh0JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jb250ZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGlyZWN0aW9uJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGVlZCA+IDAgPyBcImZvcndhcmRzXCIgOiBcImJhY2t3YXJkc1wiO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEluY2lkZW50O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js":
/*!************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js ***!
  \************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Incident = __webpack_require__(/*! ./Incident */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils//Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar isTimePausingState = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").isTimePausingState;\n\n/** @classdesc\n * A TimedIncident is an incident that lasts some time. It has duration and a timer of its own. It can take all the states.\n *\n */\n\nvar TimedIncident = function (_Incident) {\n    _inherits(TimedIncident, _Incident);\n\n    function TimedIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, TimedIncident);\n\n        var _this = _possibleConstructorReturn(this, (TimedIncident.__proto__ || Object.getPrototypeOf(TimedIncident)).call(this, attrs, props));\n\n        _this.resetState();\n\n        /**\n          @member {object} - listeners are functions to be executed on time change of the Timed Incident. It has the following format:\n           listeners: {\n            listener_id: {\n                     funct : the function to be executed\n                     threshold : the threshold of delta\n                     roundTo : round millisecond\n                 },\n                 listener_id: {\n                     funct : the function to be executed\n                     threshold : the threshold of delta\n                     roundTo : round millisecond\n                 },\n                 ...\n           }\n           */\n        _this.listeners = {};\n\n        _this.bitIncident = false;\n        return _this;\n    }\n\n    _createClass(TimedIncident, [{\n        key: 'requestAnimaFrame',\n        value: function requestAnimaFrame(fn) {\n            /* if the Incident is on test mode we want to prevent requestAnimationFrame as execution\n                during testing is controlled through emulateStep method */\n            if (this.isOnTestMode) {\n                return function () {};\n            }\n\n            try {\n                return this.context.window.requestAnimationFrame(fn);\n            } catch (e) {\n                helper.error('Your browser does not support requestAnimationFrame');\n                return function (fn) {};\n            }\n        }\n\n        /**\n         * when the Incident is on test mode (this.isOnTestMode = true) the emulateStep method\n         * becomes functional.\n         * The method takes as input the millisecondsDelta from the previous timestamp and triggers\n         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run\n         * passing a timestamp that has exactly millisecondsDelta difference from the previous one\n         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one\n        */\n\n    }, {\n        key: 'emulateStep',\n        value: function emulateStep(millisecondsDelta) {\n            if (!this.isOnTestMode) {\n                helper.error('emulateStep method can only be used on test mode');\n            } else {\n                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);\n            }\n        }\n\n        /**\n         * All TimedIncidents must implement the get duration method\n        **/\n\n    }, {\n        key: 'checkResizedIncident',\n\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n        **/\n        value: function checkResizedIncident(durationFraction, incident) {\n            var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip && incident.id != this.id) {\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n                // for each key of the incidentsById object perform the check\n\n                for (var key in incidentsById) {\n                    // perform the check\n                    var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);\n                    var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else if (this.isTheClip) {\n                return { result: true, execute: function execute() {} };\n                // the resizing of the internal Channels occurs on the systolDiastole method of the Groups when they identify that the Groups is actually a Clip\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkResizedIncident(durationFraction, incident, adjustMillisecond + this.parentSceneObject.getIncidentMillisecond(this.id));\n            }\n        }\n\n        /**\n         * Edits the duration of the Incident\n         * @param {int} duration - the new duration in milliseconds\n        **/\n\n    }, {\n        key: 'resize',\n        value: function resize(duration) {\n            // console.trace();\n            // don't waste cpu resources if the new duration equals the current value\n            if (duration === this.duration) {\n                return { result: true };\n            } else if (duration <= 0) {\n                helper.error('resizeIncident method of Scene only accepts integers > 0 as the new duration of the Scene. ' + duration + ' provided.');\n                return {\n                    result: false\n                };\n            }\n            // stop the execution\n            this.stop();\n\n            var editCheck = this.checkResizedIncident(duration / this.duration, this);\n\n            if (editCheck.result === false) {\n                helper.error(editCheck);\n                return editCheck;\n            }\n\n            this.systolDiastole(duration / this.duration);\n            editCheck.execute();\n            var whereAmI = this.getRootCurrentMillisecondDeltaFromStart();\n            // whereAmI = this.normaliseGoToTarget(whereAmI);\n            // this.goTo(whereAmI);\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            }\n\n            return { result: true };\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            this.duration = this.duration * durationFraction;\n        }\n    }, {\n        key: 'resetState',\n        value: function resetState() {\n            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resetState', this).call(this);\n            // the current millisecond having as 0 the start of the animation\n            if (this.state === 'idle') this.runTimeInfo.currentMillisecond = 0; // the current millisecond of the incident as it's calculated based on the speed of the Incident\n            else if (this.state === 'completed') this.runTimeInfo.currentMillisecond = this.duration;\n            // in other words the millisecond that the Incident is on the UI\n            this.runTimeInfo.start = null; // the millisecond started as provided by requestAnimationFrame\n            this.runTimeInfo.previousTimeStamp = null; // the timestamp of the previous circle as provided by requestAnimationFrame\n            this.runTimeInfo.pauseMoment = null; // the pause moment as provided by new Date().getTime()\n            this.runTimeInfo.pauseMillisecond = 0; // the pauseMillisecond is the current millisecond at the pause moment\n            for (var key in this.listeners) {\n                this.listeners[key].cavaDelta = 0;\n            }\n        }\n\n        /**\n         * This method calculates the previousTimeStamp based on the target UI millisecond we want to go to and\n         * the speed of the Incident.\n         * E.g. if targetUIMillisecond = 2000 and speed =2 then we will take the timestamp from requestAnimationFrame (ra_stamp) and\n         * set the previousMillisecond to ra_stamp-1000\n         * @param {int} currentMIllisecond - the millisecond to which we want our Inicdent to be on\n        */\n\n    }, {\n        key: 'programmaticSetPreviousTimeStamp',\n        value: function programmaticSetPreviousTimeStamp(targetUIMillisecond) {\n            var _this2 = this;\n\n            var that = this;\n\n            if (this.isOnTestMode) {\n                that.runTimeInfo.previousTimeStamp = 0;\n            }\n\n            this.requestAnimaFrame(function (timestamp) {\n                that.runTimeInfo.previousTimeStamp = timestamp - targetUIMillisecond / _this2.speed;\n            });\n        }\n\n        // ******** INCIDENT METHODS IMPLEMENTATION **************\n        // *******************************************************\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('playing')) {\n                return false;\n            }\n\n            var that = this;\n            this._setState('playing');\n            this.onPlay(props);\n\n            if (!this.isOnTestMode) {\n                this.requestAnimaFrame(function (timestamp) {\n                    that.step(timestamp, props);\n                }.bind(that));\n            } else {\n                this.runTimeInfo.previousTimeStamp = 0;\n                this.emulateStep(props.startFrom);\n            }\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'complete', this).call(this);\n            this.resetState();\n        }\n\n        // timer blocking\n\n    }, {\n        key: 'wait',\n        value: function wait(props, waitCallerId) {\n            var previousState = this.runTimeInfo.state;\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'wait', this).call(this, props, waitCallerId)) {\n                if (!isTimePausingState(previousState)) {\n                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                    this.runTimeInfo.pauseMoment = new Date().getTime();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        // timer blocking\n\n    }, {\n        key: 'block',\n        value: function block(props) {\n            var previousState = this.runTimeInfo.state;\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'block', this).call(this, props)) {\n                if (!isTimePausingState(previousState)) {\n                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                    this.runTimeInfo.pauseMoment = new Date().getTime();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        // timer unblocking\n\n    }, {\n        key: 'resume',\n        value: function resume(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resume', this).call(this, props)) {\n                var delta = new Date().getTime() - this.runTimeInfo.pauseMoment;\n                this.runTimeInfo.previousTimeStamp += delta;\n                this.requestAnimaFrame(this.step.bind(this));\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'reset',\n        value: function reset(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'reset', this).call(this, props)) {\n                this.resetState();\n            }\n\n            return false;\n        }\n    }, {\n        key: 'stop',\n        value: function stop(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'stop', this).call(this, props)) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'arm',\n        value: function arm(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'arm', this).call(this, props)) {\n                // sets the pause moment to the current time...\n                this.runTimeInfo.pauseMoment = new Date().getTime();\n                var that = this;\n\n                this.programmaticSetPreviousTimeStamp(0);\n                this.runTimeInfo.currentMillisecond = props.targetMillisecondDeltaFromStart;\n                this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                return true;\n            }\n            return false;\n        }\n\n        // *******************************************************\n        // STEP FUNCTION\n\n    }, {\n        key: 'step',\n        value: function step(timestamp) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var that = this;\n\n            // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly\n            // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond\n            // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than\n            // its actual starting point, so tth startFrom will be 10)\n            if (props != null) {\n                var startFrom = props.startFrom;\n                if (!props.hasOwnProperty('startFrom')) {\n                    if (this.direction === \"forwards\") {\n                        startFrom = 0;\n                    } else {\n                        startFrom = this.duration;\n                    }\n                }\n\n                if (this.speed > 0) {\n                    this.runTimeInfo.previousTimeStamp = timestamp - startFrom / this.speed;\n                } else {\n                    this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom) / Math.abs(this.speed);\n                }\n            }\n\n            var informListeners = function informListeners(progress) {\n                for (var key in that.listeners) {\n                    var listner = that.listeners[key];\n                    if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {\n                        listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));\n                        listner.cavaDelta = 0;\n                    } else {\n                        listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            // helper.log('got into step on ' + this.id);\n            if (this.runTimeInfo.state !== 'playing') {\n                return;\n            }\n\n            // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]\n            var progress = {\n                milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed),\n                fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed) / this.duration\n            };\n            // helper.notice(`calculation properties of progress for ${this.id}`);\n            // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)\n\n            // helper.log(this.id, progress);\n\n            if (progress.fraction >= 1) {\n                this.onProgress(1, this.duration);\n                informListeners({ fraction: 1, milliseconds: this.duration });\n                this.complete();\n                return;\n            } else if (progress.fraction < 0) {\n                this.onProgress(0, 0);\n                informListeners({ fraction: 0, milliseconds: 0 });\n                this._dontTellMamaStateChange('idle');\n                this.broadcastEvent('state-change', { oldState: \"playing\", newState: \"idle\" });\n                this.resetState();\n                return;\n            }\n\n            this.onProgress(progress.fraction, progress.milliseconds);\n\n            // helper.log(this.id);\n            // helper.log(this.runTimeInfo.currentMillisecond);\n            // helper.log(this.id + ' progress: ', progress);\n            // handle listeners\n            informListeners(progress);\n\n            this.runTimeInfo.currentMillisecond = progress.milliseconds;\n            this.runTimeInfo.previousTimeStamp = timestamp;\n\n            // helper.log(this.runTimeInfo.currentMillisecond);\n\n            // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);\n            this.requestAnimaFrame(that.step.bind(that));\n        }\n\n        // ***** PUB SUB ***********\n        // *************************\n\n        /** Scene is responsible for knowing the time of it at any given moment. Also it acts as the single pipeline\n          that transfers play, wait, resume, goto requests from to its Incidents.\n          Scene is responsible for distributing the time information to any interested party\n           In order for any Class / module to be aware about the time of any Scene it should subscribe to its dispatch functions\n          By subscribing a module can get notified about changes on the Scene's time\n           subscribe method subscribes a function to the time change dispatcher. As Scene uses requestAnimationFrame for its timing\n          each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed\n          since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given\n          number (e.g. greater than 300ms). That property is passed as the second argument \"threshold\".\n          Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:\n            - 1 (round it on its actual units\n           - 10 (round it on tenths)\n           - 100 (round it on hundreds)\n           - 1000 (round it on thousands)\n           the first argument provides an id to the listener for future reference (deletion etc)\n          the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene\n          and the state of it  */\n\n    }, {\n        key: 'subscribe',\n        value: function subscribe(id, funct, threshold, roundTo) {\n            if (!threshold) {\n                threshold = 0;\n            }\n            if (!roundTo) {\n                roundTo = 1; // round second to its units, meaning leave it as it is\n            }\n            this.listeners[id] = {\n                funct: funct,\n                threshold: threshold,\n                roundTo: roundTo,\n                cavaDelta: 0\n            };\n        }\n\n        /**\n         * This method's (which should be called whenever a slip ends) purpose is to calculate and set\n         * the right state of the Incident based on the target millisecond.\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n         */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState() {\n            var targetMillisecondDeltaFromStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (targetMillisecondDeltaFromStart === null) {\n                targetMillisecondDeltaFromStart = this.runTimeInfo.currentMillisecond;\n            }\n            // helper.log('recalculating state for Incident: ' + this.id, targetMillisecondDeltaFromStart);\n            if (targetMillisecondDeltaFromStart >= this.duration) {\n                // if it ends before the targetMillisecond\n                // helper.log('completes');\n                this.statusBeforeHalt = \"completed\";\n                this.runTimeInfo.currentMillisecond = this.duration;\n                this._dontTellMamaStateChange('completed');\n            } else if (targetMillisecondDeltaFromStart <= this.duration && targetMillisecondDeltaFromStart > 0) {\n                // if the targetMillisecond is in the middle of it\n                if (this.state === 'playing') {\n                    return;\n                }\n                this.statusBeforeHalt = \"playing\";\n                this.arm({ targetMillisecondDeltaFromStart: targetMillisecondDeltaFromStart });\n            } else if (targetMillisecondDeltaFromStart <= 0) {\n                // if it has been completed on targetMillisecond\n                // helper.log('resets to idle');\n                this.statusBeforeHalt = \"idle\";\n                this.runTimeInfo.currentMillisecond = 0;\n                this._dontTellMamaStateChange('idle');\n                this.resetState();\n            }\n        }\n\n        /**\n         * Method called on progress of the timed incident.\n         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n         * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n        */\n\n    }, {\n        key: 'onProgress',\n        value: function onProgress(fraction, milliseconds) {}\n    }, {\n        key: 'beOn',\n        value: function beOn(millisecond) {\n            var beOnResult = _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'beOn', this).call(this, millisecond);\n            if (beOnResult.previousState === \"playing\" && beOnResult.newState === \"waiting\") {\n                this.resume();\n                beOnResult.newState = \"playing\";\n            }\n            return beOnResult;\n        }\n    }, {\n        key: 'duration',\n        get: function get() {\n            return this.props.duration;\n        }\n\n        /**\n         * All TimedIncidents must implement the duration setter method\n        **/\n        ,\n        set: function set(duration) {\n            this.props.duration = duration;\n        }\n    }]);\n\n    return TimedIncident;\n}(Incident);\n\nmodule.exports = TimedIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvVGltZWRJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9UaW1lZEluY2lkZW50LmpzPzFjZTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEluY2lkZW50ID0gcmVxdWlyZSgnLi9JbmNpZGVudCcpO1xudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBpc1RpbWVQYXVzaW5nU3RhdGUgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2FsbG93ZWRTdGF0ZUNoYW5nZXMnKS5pc1RpbWVQYXVzaW5nU3RhdGU7XG5cbi8qKiBAY2xhc3NkZXNjXG4gKiBBIFRpbWVkSW5jaWRlbnQgaXMgYW4gaW5jaWRlbnQgdGhhdCBsYXN0cyBzb21lIHRpbWUuIEl0IGhhcyBkdXJhdGlvbiBhbmQgYSB0aW1lciBvZiBpdHMgb3duLiBJdCBjYW4gdGFrZSBhbGwgdGhlIHN0YXRlcy5cbiAqXG4gKi9cblxudmFyIFRpbWVkSW5jaWRlbnQgPSBmdW5jdGlvbiAoX0luY2lkZW50KSB7XG4gICAgX2luaGVyaXRzKFRpbWVkSW5jaWRlbnQsIF9JbmNpZGVudCk7XG5cbiAgICBmdW5jdGlvbiBUaW1lZEluY2lkZW50KCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lZEluY2lkZW50KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoVGltZWRJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQpKS5jYWxsKHRoaXMsIGF0dHJzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnJlc2V0U3RhdGUoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICBAbWVtYmVyIHtvYmplY3R9IC0gbGlzdGVuZXJzIGFyZSBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgb24gdGltZSBjaGFuZ2Ugb2YgdGhlIFRpbWVkIEluY2lkZW50LiBJdCBoYXMgdGhlIGZvbGxvd2luZyBmb3JtYXQ6XG4gICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgbGlzdGVuZXJfaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgIGZ1bmN0IDogdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgOiB0aGUgdGhyZXNob2xkIG9mIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgICByb3VuZFRvIDogcm91bmQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgbGlzdGVuZXJfaWQ6IHtcbiAgICAgICAgICAgICAgICAgICAgIGZ1bmN0IDogdGhlIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkXG4gICAgICAgICAgICAgICAgICAgICB0aHJlc2hvbGQgOiB0aGUgdGhyZXNob2xkIG9mIGRlbHRhXG4gICAgICAgICAgICAgICAgICAgICByb3VuZFRvIDogcm91bmQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgLi4uXG4gICAgICAgICAgIH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMubGlzdGVuZXJzID0ge307XG5cbiAgICAgICAgX3RoaXMuYml0SW5jaWRlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUaW1lZEluY2lkZW50LCBbe1xuICAgICAgICBrZXk6ICdyZXF1ZXN0QW5pbWFGcmFtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0QW5pbWFGcmFtZShmbikge1xuICAgICAgICAgICAgLyogaWYgdGhlIEluY2lkZW50IGlzIG9uIHRlc3QgbW9kZSB3ZSB3YW50IHRvIHByZXZlbnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGFzIGV4ZWN1dGlvblxuICAgICAgICAgICAgICAgIGR1cmluZyB0ZXN0aW5nIGlzIGNvbnRyb2xsZWQgdGhyb3VnaCBlbXVsYXRlU3RlcCBtZXRob2QgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzT25UZXN0TW9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LndpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZm4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignWW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmbikge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogd2hlbiB0aGUgSW5jaWRlbnQgaXMgb24gdGVzdCBtb2RlICh0aGlzLmlzT25UZXN0TW9kZSA9IHRydWUpIHRoZSBlbXVsYXRlU3RlcCBtZXRob2RcbiAgICAgICAgICogYmVjb21lcyBmdW5jdGlvbmFsLlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHRha2VzIGFzIGlucHV0IHRoZSBtaWxsaXNlY29uZHNEZWx0YSBmcm9tIHRoZSBwcmV2aW91cyB0aW1lc3RhbXAgYW5kIHRyaWdnZXJzXG4gICAgICAgICAqIHRoZSBzdGVwIGZ1bmN0aW9uIHBhc3NpbmcgaW4gYSBiYWtlZCB0aW1lc3RhbXAgc28gdGhlIEluY2lkZW50IGJlaGF2ZXMgZXhhY3RseSBhcyBpZiB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHJ1blxuICAgICAgICAgKiBwYXNzaW5nIGEgdGltZXN0YW1wIHRoYXQgaGFzIGV4YWN0bHkgbWlsbGlzZWNvbmRzRGVsdGEgZGlmZmVyZW5jZSBmcm9tIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIHByZXZpb3VzIHRpbWVzdGFtcCBhbmQgdGhlIG5ldyBvbmVcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW11bGF0ZVN0ZXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW11bGF0ZVN0ZXAobWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc09uVGVzdE1vZGUpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ2VtdWxhdGVTdGVwIG1ldGhvZCBjYW4gb25seSBiZSB1c2VkIG9uIHRlc3QgbW9kZScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXAodGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCArIG1pbGxpc2Vjb25kc0RlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgVGltZWRJbmNpZGVudHMgbXVzdCBpbXBsZW1lbnQgdGhlIGdldCBkdXJhdGlvbiBtZXRob2RcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrUmVzaXplZEluY2lkZW50JyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVja3MgaWYgYSBkdXJhdGlvbiBlZGl0IGlzIGZlYXNpYmxlIGFuZCBkb2Vzbid0IGNhdXNlIGNvbmZsaWN0c1xuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZHVyYXRpb24gLSB0aGUgbmV3IGR1cmF0aW9uXG4gICAgICAgICoqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnQoZHVyYXRpb25GcmFjdGlvbiwgaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIHZhciBhZGp1c3RNaWxsaXNlY29uZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMDtcblxuICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlRTIChJUyBBIENMSVApXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RoZUNsaXAgJiYgaW5jaWRlbnQuaWQgIT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgaW5jaWRlbnRzIHNlcGFyYXRlZCBieSBwbHVnaW5cbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlJZCA9IGluY2lkZW50LmdldEluY2lkZW50c0J5UGx1Z2luKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgICAgICAgICAgIHZhciB0b1JldHVyblJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBrZXkgb2YgdGhlIGluY2lkZW50c0J5SWQgb2JqZWN0IHBlcmZvcm0gdGhlIGNoZWNrXG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWRqdXN0ZWRJbmNpZGVudHMgPSBoZWxwZXIuc3lzdG9sZURpYXN0b2xlUHJvamVjdGlvbnMoaW5jaWRlbnRzQnlJZFtrZXldLCBkdXJhdGlvbkZyYWN0aW9uLCBhZGp1c3RNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uY2hlY2tSZXNpemVkSW5jaWRlbnRzKGFkanVzdGVkSW5jaWRlbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXJyb3JzID0gdG9SZXR1cm5FcnJvcnMuY29uY2F0KHBsdWdpblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXNbaV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdFJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0b1JldHVyblJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB0b1JldHVybkVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogdG9SZXR1cm5FeGVjdXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdFJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICAgICAgICAgIC8vIHRoZSByZXNpemluZyBvZiB0aGUgaW50ZXJuYWwgQ2hhbm5lbHMgb2NjdXJzIG9uIHRoZSBzeXN0b2xEaWFzdG9sZSBtZXRob2Qgb2YgdGhlIEdyb3VwcyB3aGVuIHRoZXkgaWRlbnRpZnkgdGhhdCB0aGUgR3JvdXBzIGlzIGFjdHVhbGx5IGEgQ2xpcFxuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgKEFDVCBBUyBUSEUgQ0xJUClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jaGVja1Jlc2l6ZWRJbmNpZGVudChkdXJhdGlvbkZyYWN0aW9uLCBpbmNpZGVudCwgYWRqdXN0TWlsbGlzZWNvbmQgKyB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmdldEluY2lkZW50TWlsbGlzZWNvbmQodGhpcy5pZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVkaXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGR1cmF0aW9uIC0gdGhlIG5ldyBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc2l6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgICAgICAgIC8vIGRvbid0IHdhc3RlIGNwdSByZXNvdXJjZXMgaWYgdGhlIG5ldyBkdXJhdGlvbiBlcXVhbHMgdGhlIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PT0gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkdXJhdGlvbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdyZXNpemVJbmNpZGVudCBtZXRob2Qgb2YgU2NlbmUgb25seSBhY2NlcHRzIGludGVnZXJzID4gMCBhcyB0aGUgbmV3IGR1cmF0aW9uIG9mIHRoZSBTY2VuZS4gJyArIGR1cmF0aW9uICsgJyBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHN0b3AgdGhlIGV4ZWN1dGlvblxuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG5cbiAgICAgICAgICAgIHZhciBlZGl0Q2hlY2sgPSB0aGlzLmNoZWNrUmVzaXplZEluY2lkZW50KGR1cmF0aW9uIC8gdGhpcy5kdXJhdGlvbiwgdGhpcyk7XG5cbiAgICAgICAgICAgIGlmIChlZGl0Q2hlY2sucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcihlZGl0Q2hlY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0Q2hlY2s7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3lzdG9sRGlhc3RvbGUoZHVyYXRpb24gLyB0aGlzLmR1cmF0aW9uKTtcbiAgICAgICAgICAgIGVkaXRDaGVjay5leGVjdXRlKCk7XG4gICAgICAgICAgICB2YXIgd2hlcmVBbUkgPSB0aGlzLmdldFJvb3RDdXJyZW50TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCgpO1xuICAgICAgICAgICAgLy8gd2hlcmVBbUkgPSB0aGlzLm5vcm1hbGlzZUdvVG9UYXJnZXQod2hlcmVBbUkpO1xuICAgICAgICAgICAgLy8gdGhpcy5nb1RvKHdoZXJlQW1JKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZmZlY3RlZCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3lzdG9sRGlhc3RvbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sRGlhc3RvbGUoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb24gKiBkdXJhdGlvbkZyYWN0aW9uO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gICAgICAgICAgICBfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAncmVzZXRTdGF0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAvLyB0aGUgY3VycmVudCBtaWxsaXNlY29uZCBoYXZpbmcgYXMgMCB0aGUgc3RhcnQgb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdpZGxlJykgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSAwOyAvLyB0aGUgY3VycmVudCBtaWxsaXNlY29uZCBvZiB0aGUgaW5jaWRlbnQgYXMgaXQncyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBzcGVlZCBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdjb21wbGV0ZWQnKSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAvLyBpbiBvdGhlciB3b3JkcyB0aGUgbWlsbGlzZWNvbmQgdGhhdCB0aGUgSW5jaWRlbnQgaXMgb24gdGhlIFVJXG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnN0YXJ0ID0gbnVsbDsgLy8gdGhlIG1pbGxpc2Vjb25kIHN0YXJ0ZWQgYXMgcHJvdmlkZWQgYnkgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wID0gbnVsbDsgLy8gdGhlIHRpbWVzdGFtcCBvZiB0aGUgcHJldmlvdXMgY2lyY2xlIGFzIHByb3ZpZGVkIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudCA9IG51bGw7IC8vIHRoZSBwYXVzZSBtb21lbnQgYXMgcHJvdmlkZWQgYnkgbmV3IERhdGUoKS5nZXRUaW1lKClcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNaWxsaXNlY29uZCA9IDA7IC8vIHRoZSBwYXVzZU1pbGxpc2Vjb25kIGlzIHRoZSBjdXJyZW50IG1pbGxpc2Vjb25kIGF0IHRoZSBwYXVzZSBtb21lbnRcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2tleV0uY2F2YURlbHRhID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBjYWxjdWxhdGVzIHRoZSBwcmV2aW91c1RpbWVTdGFtcCBiYXNlZCBvbiB0aGUgdGFyZ2V0IFVJIG1pbGxpc2Vjb25kIHdlIHdhbnQgdG8gZ28gdG8gYW5kXG4gICAgICAgICAqIHRoZSBzcGVlZCBvZiB0aGUgSW5jaWRlbnQuXG4gICAgICAgICAqIEUuZy4gaWYgdGFyZ2V0VUlNaWxsaXNlY29uZCA9IDIwMDAgYW5kIHNwZWVkID0yIHRoZW4gd2Ugd2lsbCB0YWtlIHRoZSB0aW1lc3RhbXAgZnJvbSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJhX3N0YW1wKSBhbmRcbiAgICAgICAgICogc2V0IHRoZSBwcmV2aW91c01pbGxpc2Vjb25kIHRvIHJhX3N0YW1wLTEwMDBcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGN1cnJlbnRNSWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0byB3aGljaCB3ZSB3YW50IG91ciBJbmljZGVudCB0byBiZSBvblxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwcm9ncmFtbWF0aWNTZXRQcmV2aW91c1RpbWVTdGFtcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9ncmFtbWF0aWNTZXRQcmV2aW91c1RpbWVTdGFtcCh0YXJnZXRVSU1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5pc09uVGVzdE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWFGcmFtZShmdW5jdGlvbiAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtIHRhcmdldFVJTWlsbGlzZWNvbmQgLyBfdGhpczIuc3BlZWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqIElOQ0lERU5UIE1FVEhPRFMgSU1QTEVNRU5UQVRJT04gKioqKioqKioqKioqKipcbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdwbGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ3BsYXlpbmcnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3BsYXlpbmcnKTtcbiAgICAgICAgICAgIHRoaXMub25QbGF5KHByb3BzKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT25UZXN0TW9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnN0ZXAodGltZXN0YW1wLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoYXQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5lbXVsYXRlU3RlcChwcm9wcy5zdGFydEZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdjb21wbGV0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWVyIGJsb2NraW5nXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dhaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdChwcm9wcywgd2FpdENhbGxlcklkKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICBpZiAoX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ3dhaXQnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzLCB3YWl0Q2FsbGVySWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RpbWVQYXVzaW5nU3RhdGUocHJldmlvdXNTdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1pbGxpc2Vjb25kID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnBhdXNlTW9tZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGltZXIgYmxvY2tpbmdcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmxvY2socHJvcHMpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1N0YXRlID0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgICAgIGlmIChfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAnYmxvY2snLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNUaW1lUGF1c2luZ1N0YXRlKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWVyIHVuYmxvY2tpbmdcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzdW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZShwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdyZXN1bWUnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudDtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wICs9IGRlbHRhO1xuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hRnJhbWUodGhpcy5zdGVwLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldChwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdyZXNldCcsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RvcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ3N0b3AnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhcm0nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXJtKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ2FybScsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0cyB0aGUgcGF1c2UgbW9tZW50IHRvIHRoZSBjdXJyZW50IHRpbWUuLi5cbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnBhdXNlTW9tZW50ID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9ncmFtbWF0aWNTZXRQcmV2aW91c1RpbWVTdGFtcCgwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHByb3BzLnRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1pbGxpc2Vjb25kID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBTVEVQIEZVTkNUSU9OXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0ZXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RlcCh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAvLyBzdGFydCBmcm9tIGlzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgZnJvbSB0aGUgYWN0dWFsIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBJbmNpZGVudCBjYXVzZWQgbWFpbmx5XG4gICAgICAgICAgICAvLyBieSBDUFUgcGVyZm9ybWFuY2UuIChlYWNoIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjaXJsY2UgZG9lc24ndCBoYXBwZW4gZXZlcnkgb25lIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAvLyBzbyBhbiBJbmNpZGVudCB0aGF0IHdhcyBzdXBwb3NlZCB0byBzdGFydCBvbiBtaWxsaXNlY29uZCAxMDAgb2YgYSBHcm91cCBtaWdodCBnZXQgZmlyZWQgMTAgbWlsbGlzZWNvbmRzIGxhdGVyIHRoYW5cbiAgICAgICAgICAgIC8vIGl0cyBhY3R1YWwgc3RhcnRpbmcgcG9pbnQsIHNvIHR0aCBzdGFydEZyb20gd2lsbCBiZSAxMClcbiAgICAgICAgICAgIGlmIChwcm9wcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0RnJvbSA9IHByb3BzLnN0YXJ0RnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdzdGFydEZyb20nKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJlY3Rpb24gPT09IFwiZm9yd2FyZHNcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRGcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtIHN0YXJ0RnJvbSAvIHRoaXMuc3BlZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcCAtICh0aGlzLmR1cmF0aW9uIC0gc3RhcnRGcm9tKSAvIE1hdGguYWJzKHRoaXMuc3BlZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZm9ybUxpc3RlbmVycyA9IGZ1bmN0aW9uIGluZm9ybUxpc3RlbmVycyhwcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGF0Lmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdG5lciA9IHRoYXQubGlzdGVuZXJzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhwcm9ncmVzcy5taWxsaXNlY29uZHMgKyBsaXN0bmVyLmNhdmFEZWx0YSAtIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKSA+IGxpc3RuZXIudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0bmVyLmZ1bmN0KHByb2dyZXNzLm1pbGxpc2Vjb25kcywgdGltZXN0YW1wLCBoZWxwZXIucm91bmROdW1iZXJUbyhsaXN0bmVyLnJvdW5kVG8pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RuZXIuY2F2YURlbHRhID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RuZXIuY2F2YURlbHRhICs9IE1hdGguYWJzKHByb2dyZXNzLm1pbGxpc2Vjb25kcyAtIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dvdCBpbnRvIHN0ZXAgb24gJyArIHRoaXMuaWQpO1xuICAgICAgICAgICAgaWYgKHRoaXMucnVuVGltZUluZm8uc3RhdGUgIT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcHJvZ3Jlc3NTdGVwIGlzIHRoZSBwcm9ncmVzcyBtYWRlIGZyb20gcHJldmlvdXNUaW1lU3RhbXAgYm90aCBpbiBtaWxsaXNlY29uZHMgYW5kIGluIGZyYWN0aW9uIFswIHRvIDFdXG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBNYXRoLnJvdW5kKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICsgKHRpbWVzdGFtcCAtIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXApICogdGhpcy5zcGVlZCksXG4gICAgICAgICAgICAgICAgZnJhY3Rpb246ICh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCArICh0aW1lc3RhbXAgLSB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wKSAqIHRoaXMuc3BlZWQpIC8gdGhpcy5kdXJhdGlvblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5ub3RpY2UoYGNhbGN1bGF0aW9uIHByb3BlcnRpZXMgb2YgcHJvZ3Jlc3MgZm9yICR7dGhpcy5pZH1gKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kOiAke3RoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kfSwgdGltZXN0YW1wOiAke3RpbWVzdGFtcH0sIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXA6ICR7dGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcH1gKVxuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMuaWQsIHByb2dyZXNzKTtcblxuICAgICAgICAgICAgaWYgKHByb2dyZXNzLmZyYWN0aW9uID49IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MoMSwgdGhpcy5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgaW5mb3JtTGlzdGVuZXJzKHsgZnJhY3Rpb246IDEsIG1pbGxpc2Vjb25kczogdGhpcy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzcy5mcmFjdGlvbiA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MoMCwgMCk7XG4gICAgICAgICAgICAgICAgaW5mb3JtTGlzdGVuZXJzKHsgZnJhY3Rpb246IDAsIG1pbGxpc2Vjb25kczogMCB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb250VGVsbE1hbWFTdGF0ZUNoYW5nZSgnaWRsZScpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ3N0YXRlLWNoYW5nZScsIHsgb2xkU3RhdGU6IFwicGxheWluZ1wiLCBuZXdTdGF0ZTogXCJpZGxlXCIgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3MocHJvZ3Jlc3MuZnJhY3Rpb24sIHByb2dyZXNzLm1pbGxpc2Vjb25kcyk7XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5pZCk7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5pZCArICcgcHJvZ3Jlc3M6ICcsIHByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIGhhbmRsZSBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGluZm9ybUxpc3RlbmVycyhwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gcHJvZ3Jlc3MubWlsbGlzZWNvbmRzO1xuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IHRpbWVzdGFtcDtcblxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3RoaXMucnVudGltZUluZm8uc3RhdGUgb24gJyArIHRoaXMuaWQgKyAnID0gJyArIHRoaXMucnVuVGltZUluZm8uc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0QW5pbWFGcmFtZSh0aGF0LnN0ZXAuYmluZCh0aGF0KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKiBQVUIgU1VCICoqKioqKioqKioqXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgICAgICAvKiogU2NlbmUgaXMgcmVzcG9uc2libGUgZm9yIGtub3dpbmcgdGhlIHRpbWUgb2YgaXQgYXQgYW55IGdpdmVuIG1vbWVudC4gQWxzbyBpdCBhY3RzIGFzIHRoZSBzaW5nbGUgcGlwZWxpbmVcbiAgICAgICAgICB0aGF0IHRyYW5zZmVycyBwbGF5LCB3YWl0LCByZXN1bWUsIGdvdG8gcmVxdWVzdHMgZnJvbSB0byBpdHMgSW5jaWRlbnRzLlxuICAgICAgICAgIFNjZW5lIGlzIHJlc3BvbnNpYmxlIGZvciBkaXN0cmlidXRpbmcgdGhlIHRpbWUgaW5mb3JtYXRpb24gdG8gYW55IGludGVyZXN0ZWQgcGFydHlcbiAgICAgICAgICAgSW4gb3JkZXIgZm9yIGFueSBDbGFzcyAvIG1vZHVsZSB0byBiZSBhd2FyZSBhYm91dCB0aGUgdGltZSBvZiBhbnkgU2NlbmUgaXQgc2hvdWxkIHN1YnNjcmliZSB0byBpdHMgZGlzcGF0Y2ggZnVuY3Rpb25zXG4gICAgICAgICAgQnkgc3Vic2NyaWJpbmcgYSBtb2R1bGUgY2FuIGdldCBub3RpZmllZCBhYm91dCBjaGFuZ2VzIG9uIHRoZSBTY2VuZSdzIHRpbWVcbiAgICAgICAgICAgc3Vic2NyaWJlIG1ldGhvZCBzdWJzY3JpYmVzIGEgZnVuY3Rpb24gdG8gdGhlIHRpbWUgY2hhbmdlIGRpc3BhdGNoZXIuIEFzIFNjZW5lIHVzZXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciBpdHMgdGltaW5nXG4gICAgICAgICAgZWFjaCBjeXJjbGUgLyBzdGVwIGdldHMgdGhlIGN1cnJlbnQgdGltZSBhbmQgc3VidHJhY3RzIHRoZSBwcmV2aW91cyB0aW1lIHNvIGl0IGtub3cgaG93IG1hbnkgbWlsbGlzZWNvbmRzIGhhcyBlbGFwc2VkXG4gICAgICAgICAgc2luY2UgbGFzdCBzdGVwLiBTdWJzY3JpYmVycyBjYW4gc2V0IHRvIGdldCBpbmZvcm1lZCBhYm91dCB0aW1lIGNoYW5nZXMgb25seSBpZiB0aGUgZGVsdGEgaXMgZ3JlYXRlciB0aGFuIGEgZ2l2ZW5cbiAgICAgICAgICBudW1iZXIgKGUuZy4gZ3JlYXRlciB0aGFuIDMwMG1zKS4gVGhhdCBwcm9wZXJ0eSBpcyBwYXNzZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCBcInRocmVzaG9sZFwiLlxuICAgICAgICAgIEZpbmFsbHkgaWYgYW55IG9mIHRoZSBzdWJzY3JpYmVycyB3YW50IHRoZSBTY2VuZSB0byBwcm92aWRlIGJhY2sgYSByb3VuZGVkIG51bWJlciBvZiB0aGUgbWlsbGlzZWNvbmRzLiBPcHRpb25zOlxuICAgICAgICAgICAgLSAxIChyb3VuZCBpdCBvbiBpdHMgYWN0dWFsIHVuaXRzXG4gICAgICAgICAgIC0gMTAgKHJvdW5kIGl0IG9uIHRlbnRocylcbiAgICAgICAgICAgLSAxMDAgKHJvdW5kIGl0IG9uIGh1bmRyZWRzKVxuICAgICAgICAgICAtIDEwMDAgKHJvdW5kIGl0IG9uIHRob3VzYW5kcylcbiAgICAgICAgICAgdGhlIGZpcnN0IGFyZ3VtZW50IHByb3ZpZGVzIGFuIGlkIHRvIHRoZSBsaXN0ZW5lciBmb3IgZnV0dXJlIHJlZmVyZW5jZSAoZGVsZXRpb24gZXRjKVxuICAgICAgICAgIHRoZSBzZWNvbmQgYXJndW1lbnQgaXMgYSBmdW5jdGlvbiB0aGF0IHRha2VzIHR3byBhcmd1bWVudHM6IG1pbGxpc2Vjb25kLCBzdGF0ZSAoY3VycmVudCBtaWxsaXNlY29uZCBvZiB0aGUgU2NlbmVcbiAgICAgICAgICBhbmQgdGhlIHN0YXRlIG9mIGl0ICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlKGlkLCBmdW5jdCwgdGhyZXNob2xkLCByb3VuZFRvKSB7XG4gICAgICAgICAgICBpZiAoIXRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvdW5kVG8pIHtcbiAgICAgICAgICAgICAgICByb3VuZFRvID0gMTsgLy8gcm91bmQgc2Vjb25kIHRvIGl0cyB1bml0cywgbWVhbmluZyBsZWF2ZSBpdCBhcyBpdCBpc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5saXN0ZW5lcnNbaWRdID0ge1xuICAgICAgICAgICAgICAgIGZ1bmN0OiBmdW5jdCxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IHRocmVzaG9sZCxcbiAgICAgICAgICAgICAgICByb3VuZFRvOiByb3VuZFRvLFxuICAgICAgICAgICAgICAgIGNhdmFEZWx0YTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCdzICh3aGljaCBzaG91bGQgYmUgY2FsbGVkIHdoZW5ldmVyIGEgc2xpcCBlbmRzKSBwdXJwb3NlIGlzIHRvIGNhbGN1bGF0ZSBhbmQgc2V0XG4gICAgICAgICAqIHRoZSByaWdodCBzdGF0ZSBvZiB0aGUgSW5jaWRlbnQgYmFzZWQgb24gdGhlIHRhcmdldCBtaWxsaXNlY29uZC5cbiAgICAgICAgICogVGhlIHBhcmFtZXRlciBpdCB0YWtlcyBpcyByZWxhdGl2ZSB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBJbmNpZGVudCBpdHNlbGYgYW5kIGl0IG1pZ2h0IGJlIG5lZ2F0aXZlXG4gICAgICAgICAqIE5lZ2F0aXZlIHRhcmdldE1pbGxpc2Vjb25kIG1lYW5zIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgaXMgTiBtaWxsaXNlY29uZHMgQkVGT1JFIHRoZSBzdGFydCBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgLSB0aGUgZGVsdGEgb2YgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBjb21wYXJlZCB0byB0aGUgSW5jaWRlbnQgc3RhcnRcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlY2FsY1N0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY1N0YXRlKCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmICh0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZygncmVjYWxjdWxhdGluZyBzdGF0ZSBmb3IgSW5jaWRlbnQ6ICcgKyB0aGlzLmlkLCB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0KTtcbiAgICAgICAgICAgIGlmICh0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0ID49IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBlbmRzIGJlZm9yZSB0aGUgdGFyZ2V0TWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdjb21wbGV0ZXMnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSBcImNvbXBsZXRlZFwiO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb250VGVsbE1hbWFTdGF0ZUNoYW5nZSgnY29tcGxldGVkJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPD0gdGhpcy5kdXJhdGlvbiAmJiB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSB0YXJnZXRNaWxsaXNlY29uZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGl0XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9IFwicGxheWluZ1wiO1xuICAgICAgICAgICAgICAgIHRoaXMuYXJtKHsgdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydDogdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGJlZW4gY29tcGxldGVkIG9uIHRhcmdldE1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygncmVzZXRzIHRvIGlkbGUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSBcImlkbGVcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ2lkbGUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgY2FsbGVkIG9uIHByb2dyZXNzIG9mIHRoZSB0aW1lZCBpbmNpZGVudC5cbiAgICAgICAgICogQHBhcmFtIHtmbG9hdH0gZnJhY3Rpb24gLSBhIG51bWJlciBmcm9tIDAgdG8gMSByZXByZXNlbnRpbmcgdGhlIGZyYWN0aW9uIG9mIGR1cmF0aW9uIGNvdmVyZWRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kcyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHBhc3NlZCBmcm9tIHN0YXJ0IG9mIHRoZSBpbmNpZGVudFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblByb2dyZXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoZnJhY3Rpb24sIG1pbGxpc2Vjb25kcykge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2JlT24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYmVPbihtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGJlT25SZXN1bHQgPSBfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAnYmVPbicsIHRoaXMpLmNhbGwodGhpcywgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgaWYgKGJlT25SZXN1bHQucHJldmlvdXNTdGF0ZSA9PT0gXCJwbGF5aW5nXCIgJiYgYmVPblJlc3VsdC5uZXdTdGF0ZSA9PT0gXCJ3YWl0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIGJlT25SZXN1bHQubmV3U3RhdGUgPSBcInBsYXlpbmdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiZU9uUmVzdWx0O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkdXJhdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuZHVyYXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIFRpbWVkSW5jaWRlbnRzIG11c3QgaW1wbGVtZW50IHRoZSBkdXJhdGlvbiBzZXR0ZXIgbWV0aG9kXG4gICAgICAgICoqL1xuICAgICAgICAsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGR1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVGltZWRJbmNpZGVudDtcbn0oSW5jaWRlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVkSW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Channel = function () {\n    function Channel(props) {\n        _classCallCheck(this, Channel);\n\n        this.runTimeInfo = props.runTimeInfo;\n        this.context = props.context;\n        this.onInitialise();\n        // this.type = \"plain\";\n    }\n\n    _createClass(Channel, [{\n        key: 'onInitialise',\n        value: function onInitialise() {\n            ;\n        }\n    }, {\n        key: '_resize',\n        value: function _resize() {\n            helper.log('Please overwite the _resize method of the Channel');\n        }\n\n        /**\n         * @param {array} incidents - A collection of Incidents in the form:\n         * {\n         *  millisecond\n         *  incident\n         *  id\n         * }\n         * @returns either:\n         *   {\n         *       result:true,\n         *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n         *   }\n         *   or\n         *   {\n         *       result: false,\n         *       errors\n         *   }\n        */\n\n    }, {\n        key: 'addIncidents',\n        value: function addIncidents(incidents) {\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkAddition(incidents);\n\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n         * that apply the change\n         * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]\n         * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n         * @returns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n        key: 'editIncidents',\n        value: function editIncidents(incidents, millisecondsDelta, instantiatedChannels) {\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkEdit(incidents, millisecondsDelta);\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * Method to remove incidents\n         * @param {array} incidents - the ids of the incidents to remove in an array format\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessaryi\n         * @retuns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n        key: 'removeIncidents',\n        value: function removeIncidents(incidents) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkDelete(incidents, props);\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentIds) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            var startFrom = this.runTimeInfo.currentMillisecond;\n            if (props.hasOwnProperty('previousStop')) {\n                startFrom = props.previousStop;\n            }\n\n            this.moveTo(startFrom, millisecond);\n        }\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            ;\n        }\n    }], [{\n        key: 'type',\n        get: function get() {\n            return \"plain\";\n        }\n    }]);\n\n    return Channel;\n}();\n\nmodule.exports = Channel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvQ2hhbm5lbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9DaGFubmVsLmpzP2U5MjgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIENoYW5uZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hhbm5lbCk7XG5cbiAgICAgICAgdGhpcy5ydW5UaW1lSW5mbyA9IHByb3BzLnJ1blRpbWVJbmZvO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBwcm9wcy5jb250ZXh0O1xuICAgICAgICB0aGlzLm9uSW5pdGlhbGlzZSgpO1xuICAgICAgICAvLyB0aGlzLnR5cGUgPSBcInBsYWluXCI7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENoYW5uZWwsIFt7XG4gICAgICAgIGtleTogJ29uSW5pdGlhbGlzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19yZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZSgpIHtcbiAgICAgICAgICAgIGhlbHBlci5sb2coJ1BsZWFzZSBvdmVyd2l0ZSB0aGUgX3Jlc2l6ZSBtZXRob2Qgb2YgdGhlIENoYW5uZWwnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBBIGNvbGxlY3Rpb24gb2YgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICBtaWxsaXNlY29uZFxuICAgICAgICAgKiAgaW5jaWRlbnRcbiAgICAgICAgICogIGlkXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQHJldHVybnMgZWl0aGVyOlxuICAgICAgICAgKiAgIHtcbiAgICAgICAgICogICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICogICB9XG4gICAgICAgICAqICAgb3JcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAqICAgICAgIGVycm9yc1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5jaWRlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIHRoZSBJbmNpZGVudHMgYWRkaXRpb24gZGlyZWN0bHkgdXNpbmcgdGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIG9mIHRoZSBjbGFzc1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tBZGRpdGlvbihpbmNpZGVudHMpO1xuXG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHJlc3VsdC5leGVjdXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdCBpbml0aWFsbHkgY2hlY2tzIGlmIHRoZSBlZGl0IGlzIGFsbG93ZWQgYW5kIGlmIGl0IGlzIGl0IHJldHVucyBhbiBhcnJheSBvZiBleGVjdXRhYmxlIGZ1bmN0aW9uc1xuICAgICAgICAgKiB0aGF0IGFwcGx5IHRoZSBjaGFuZ2VcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gdGhlIGxpc3Qgb2YgdGhlIGluY2lkZW50cyB0byBlZGl0IGluIGFuIGFycmF5IGZvcm1hdCBbb2JqZWN0LCBvYmplY3QsIC4uLl1cbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSB0byBhcHBseSB0byB0aGUgaW5jaWRlbnRzXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgICogZWl0aGVyOlxuICAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyIHRvIGFwcGx5IHRoZSBlZGl0XG4gICAgICAgICB9XG4gICAgICAgICBvclxuICAgICAgICAge1xuICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgZXJyb3JzOiAvLyBhbiBhcnJheSBpbmNsdWRpbmcgYWxsIHRoZSBlcnJvcnMgLyBjb25mbGljdHMgZm91bmQgb24gZWRpdFxuICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlZGl0SW5jaWRlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudHMoaW5jaWRlbnRzLCBtaWxsaXNlY29uZHNEZWx0YSwgaW5zdGFudGlhdGVkQ2hhbm5lbHMpIHtcbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIHRoZSBJbmNpZGVudHMgYWRkaXRpb24gZGlyZWN0bHkgdXNpbmcgdGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIG9mIHRoZSBjbGFzc1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tFZGl0KGluY2lkZW50cywgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiByZXN1bHQuZXJyb3JzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiByZXN1bHQuZXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHJlbW92ZSBpbmNpZGVudHNcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gdGhlIGlkcyBvZiB0aGUgaW5jaWRlbnRzIHRvIHJlbW92ZSBpbiBhbiBhcnJheSBmb3JtYXRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gaWYgcGFzc2VkIGl0IHN1cHBvcnRzIHRoZSBwcmV2ZW50U2xpcCBrZXkgd2hpY2ggaWYgZmFsc2UgdGhlIGNoYW5uZWwgc2hvdWxkIG5vdCBzbGlwLiBUaGlzIGNhc2UgaXMgZm9yIFxuICAgICAgICAgICAgZmxhc2hET00gb2YgRE9NQXdhcmVJbmNpZGVudHMgd2hlcmUgd2UgaGF2ZSBlbGVtZW50cyBkZWxldGVkIHNvIHNsaXBwaW5nIG9uIHRoZWlyIGxhbmVzIGlzIG5vdCB2YWxpZCBub3IgbmVjZXNzYXJ5aVxuICAgICAgICAgKiBAcmV0dW5zIHtvYmplY3R9IC1cbiAgICAgICAgICogZWl0aGVyOlxuICAgICAgICAge1xuICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgZXhlY3V0ZTogLy8gYXJyYXkgb2YgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGluIG9yZGVyIHRvIGFwcGx5IHRoZSBlZGl0XG4gICAgICAgICB9XG4gICAgICAgICBvclxuICAgICAgICAge1xuICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgZXJyb3JzOiAvLyBhbiBhcnJheSBpbmNsdWRpbmcgYWxsIHRoZSBlcnJvcnMgLyBjb25mbGljdHMgZm91bmQgb24gZWRpdFxuICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgdGhlIEluY2lkZW50cyBhZGRpdGlvbiBkaXJlY3RseSB1c2luZyB0aGUgY2hlY2tBZGRpdGlvbiBtZXRob2Qgb2YgdGhlIGNsYXNzXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jaGVja0RlbGV0ZShpbmNpZGVudHMsIHByb3BzKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogcmVzdWx0LmVycm9yc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogcmVzdWx0LmV4ZWN1dGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIHRoaXMgbWV0aG9kIHRoZSB1c2VyIGRlZmluZXMgdGhlIHNwZWNpZmljIHJ1bGVzIHRoYXQgYXBwbHkgb24gdGhlIHBsdWdpbiBpdHNlbGYgYW5kIG9uIHRoZSBJbmNpZGVudHMgb2YgdGhlIHBsdWdpbiBpdHNlbGZcbiAgICAgICAgICogVGhlIG1ldGhvZCBzaG91bGQgZWl0aGVyIHJldHVybiB7cmVzdWx0OiB0cnVlfSBvciB7cmVzdWx0OiBmYWxzZSwgZXJyb3JzOlt7ZXJyb3Itb2JqZWN0fV19LCB3aGVyZSBlcnJvci1vYmplY3QgaGFzIHRoZSBzdHJ1Y3R1cmU6XG4gICAgICAgICAqICB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IC8vIHJlZmVyZW5jZSB0byB0aGUgSW5jaWRlbnQgb2JqZWN0IHRoYXQgaGFzIGJlZSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgICBlcnJvcjogLy8gdGV4dFxuICAgICAgICAgICAgfVxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIGEgY29sbGVjaXRvbiBvZiBhbGwgaW5jaWRlbnRzIHRvIGJlIGFkZGVkIG9uIHRoZSBmb3JtOlxuICAgICAgICAqXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHJldHVybnMge29iamVjdH0gLVxuICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0FkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0VkaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFZGl0KGluY2lkZW50c0FycmF5LCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEZWxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEZWxldGUoaW5jaWRlbnRJZHMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrUmVzaXplZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnb1RvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvVG8obWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGRlY2lkZSB0aGUgbWlsbGlzZWNvbmQgd2Ugd2FudCB0byBnb1RvXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPT09IG51bGwgfHwgbWlsbGlzZWNvbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3JlbGF0aXZlVG8nKSkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kICs9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChwcm9wcy5yZWxhdGl2ZVRvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0YXJ0RnJvbSA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdwcmV2aW91c1N0b3AnKSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSA9IHByb3BzLnByZXZpb3VzU3RvcDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tb3ZlVG8oc3RhcnRGcm9tLCBtaWxsaXNlY29uZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vdmVUbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgIH1dLCBbe1xuICAgICAgICBrZXk6ICd0eXBlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJwbGFpblwiO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENoYW5uZWw7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbm5lbDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js":
/*!***********************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Channel = __webpack_require__(/*! ../Channel */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\n\nvar lanesHandler = __webpack_require__(/*! ./LanesHandler */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\");\n\nvar AttributeChannel = function (_Channel) {\n    _inherits(AttributeChannel, _Channel);\n\n    function AttributeChannel(props) {\n        _classCallCheck(this, AttributeChannel);\n\n        /*\n        comboAttributes are attributes of type object, holding a number of other attributes.\n        E.g. CSS \"transform\" attribute is a combo that holds a number of other attributes such as:\n        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs \n        in an object format keeping the value of each attribute at any given point.\n        Combo attributes are passed on the constructor of the Channel in the format:\n        props.comboAttributes: {\n            transition: ['translateX', 'translateY', ...],\n            <something_else>: ['<attrName1>', '<attrName2>', ...]\n        }\n        */\n        var _this = _possibleConstructorReturn(this, (AttributeChannel.__proto__ || Object.getPrototypeOf(AttributeChannel)).call(this, props));\n\n        _this.comboAttributes = {};\n\n        /**\n         * For incidents that do not have animatedAttrs there should be only one lane per element. \n         * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends\n         * up with just one lane per element: <element_id>_<this.fixedAttributeName>\n        */\n        _this.fixedAttributeName = \"_\";\n\n        if (props.comboAttributes != null) {\n            _this.comboAttributes = props.comboAttributes;\n        }\n\n        _this.LanesHandler = new lanesHandler({ comboAttributes: _this.comboAttributes });\n        // this.type = \"attributes\";\n        return _this;\n    }\n\n    _createClass(AttributeChannel, [{\n        key: 'setComboAttributes',\n        value: function setComboAttributes(comboAttributes) {\n            this.comboAttributes = comboAttributes;\n            this.LanesHandler = new lanesHandler({ comboAttributes: this.comboAttributes });\n        }\n    }, {\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            this.LanesHandler._resize(durationFraction);\n        }\n\n        /**\n         * Checks whether the incident has animatedAttrs or not. \n        **/\n\n    }, {\n        key: '_incidentHasAnimatedAttrs',\n        value: function _incidentHasAnimatedAttrs(incident) {\n            if (incident.attrs.hasOwnProperty('animatedAttrs')) {\n                return true;\n            }\n            return false;\n        }\n\n        /* *******************************************************\n         DECISION METHODS\n         ********************************************************/\n\n        /**\n         * All of the incidents coming to this method are element-attribute incidents meaning that they only\n         * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs\n         * object\n         *\n         * @param {array} incidents - A collection of Incidents in the form:\n         * {\n         *  millisecond\n         *  incident\n         *  id\n         * }\n         * @param {string} type - can be either \"all-or-nothing\" (default) or \"keep-passing\". If type = \"all-or-nothing\"\n         *  the addition passes only if all incidents pass. If type = \"keep-passing\" the method will still return true\n         *  but will also include an errors array on its return and also will only include the success callbacks on \n         *  the execute key of its return\n         * @returns either:\n         *   {\n         *       result:true,\n         *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n         *   }\n         *   or\n         *   {\n         *       result: false,\n         *       errors\n         *   }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var _this2 = this;\n\n            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"all-or-nothing\";\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n            /* an array where we keep all affected lanes so we can slip on them at the end. \n            The format for each affected lane we keep is:\n            {\n                mcid: mcid,\n                attribute: attribute\n            }\n            */\n            var affectedLanes = [];\n\n            // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to\n            // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.\n            // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes\n            // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable\n            // functions retured by various LanesHandlerSanbox functions so it can execute them on success.\n            var onSuccessActions = [];\n\n            var conflicts = [];\n\n            var _loop = function _loop(i) {\n                var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not\n                var laneItem = incidents[i];\n                var incident = laneItem.incident;\n\n                var mcid = _this2.context.getMCID(incident.element);\n\n                // console.log(\"the incident\",incident)\n                var attribute = _this2.fixedAttributeName;\n                if (_this2._incidentHasAnimatedAttrs(incident)) {\n                    attribute = Object.keys(incident.attrs.animatedAttrs)[0];\n                }\n\n                LanesHandlerSandbox.laneExists(mcid, attribute, true); // create the lane if it doesn't exist already\n\n                affectedLanes.push({\n                    mcid: mcid,\n                    attribute: attribute\n                });\n\n                if (LanesHandlerSandbox.animationIDExists(mcid, attribute, incident.id)) {\n                    incidentConflicts = true;\n                    conflicts.push({\n                        type: 'duplicate Animation id',\n                        meta: {\n                            id: incident.id\n                        }\n                    });\n                }\n\n                // **** if the lane did exist before the new addition check for conflicts\n                var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute);\n\n                // helper.log(overlappingAnim)\n                if (overlappingAnims.length > 0) {\n                    incidentConflicts = true;\n                    conflicts.push({\n                        type: 'unauthorised, overlapping incidents on the same element',\n                        meta: {\n                            element_mcid: mcid,\n                            attribute: attribute,\n                            incident: laneItem,\n                            overlappingAnims: overlappingAnims\n                        }\n                    });\n                }\n\n                if (!incidentConflicts) {\n                    onSuccessActions.push(function () {\n                        LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);\n                        incident._onGetContextOnce();\n                    });\n                }\n            };\n\n            for (var i = 0; i < incidents.length; i++) {\n                _loop(i);\n            } // end for each incident\n\n            // if we have conflicts and the type = \"all-or-nothing\"\n            if (conflicts.length > 0 && type === \"all-or-nothing\") {\n                return {\n                    result: false,\n                    errors: conflicts\n                };\n            } else {\n                // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.\n                // This callback will apply all passing additions.\n\n                // success message\n                var that = this;\n                var exec = function exec() {\n                    that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);\n                    for (var i = 0; i < onSuccessActions.length; i++) {\n                        onSuccessActions[i]();\n                    }\n\n                    // TODO how exactly are we handling slipping?\n                    for (var _i = 0; _i < affectedLanes.length; _i++) {\n                        var affectedLane = affectedLanes[_i];\n                        that.slipIntoLaneForwards(that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute), affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                };\n\n                return {\n                    result: true,\n                    errors: conflicts,\n                    execute: exec\n                };\n            }\n        }\n\n        /**\n        * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n        * that apply the change\n        * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]\n        * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n        * @returns {object} -\n        * either:\n        {\n           result: true,\n           execute: // array of functions to be executed in order to apply the edit\n        }\n        or\n        {\n            result: false,\n            errors: // an array including all the errors / conflicts found on edit\n        }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidents, millisecondsDelta) {\n\n            var affectedIncidentIds = [];\n            for (var i = 0; i < incidents.length; i++) {\n                affectedIncidentIds.push(incidents[i].id);\n            }\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n\n            var conflicts = [];\n            var affectedLanes = [];\n\n            // for each of the affectedAnimations\n            for (var _i2 = 0; _i2 < incidents.length; _i2++) {\n                var _incident = incidents[_i2].incident;\n                var incidentId = _incident.id;\n                var _mcid = this.context.getMCID(_incident.element);\n                var _attribute = this.fixedAttributeName;\n                if (this._incidentHasAnimatedAttrs(_incident)) {\n                    _attribute = Object.keys(_incident.attrs.animatedAttrs)[0];\n                }\n                var lane = LanesHandlerSandbox.getLane(_mcid, _attribute);\n                var laneAttrs = {\n                    mcid: _mcid,\n                    attribute: _attribute\n\n                    // check for conflicts and edit lane items millisecond\n                };for (var k = 0; k < lane.length; k++) {\n                    if (lane[k].incident.id === incidentId) {\n                        affectedLanes.push(laneAttrs);\n                        var affectedAnim = lane[k];\n                        var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                        testLaneElement.millisecond += millisecondsDelta;\n                        var _overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, _mcid, _attribute, affectedIncidentIds);\n\n                        if (_overlappingAnims.length > 0) {\n                            conflicts.push({\n                                type: 'anauthorised, overlapping animations on the same element',\n                                meta: {\n                                    element_mcid: _mcid,\n                                    attribute: _attribute,\n                                    newAnimation: testLaneElement,\n                                    overlappingAnims: _overlappingAnims\n                                }\n                            });\n                        }\n\n                        break;\n                    } // end of if we found the specific animation on the lane's sequence\n                } // end of each lane's item\n\n            } // end for each affected animation's id\n\n            if (conflicts.length > 0) {\n                return {\n                    result: false,\n                    errors: conflicts\n                };\n            } else {\n                var that = this;\n                var exec = function exec() {\n                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n                    // success message\n                    that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);\n\n                    for (var _i3 = 0; _i3 < affectedLanes.length; _i3++) {\n                        var affectedLane = affectedLanes[_i3];\n                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);\n                        that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                };\n                return {\n                    result: true,\n                    execute: exec\n                };\n            }\n        }\n\n        /**\n         * @param {array} affectedAnimations - [{id, start, end, startDelta}]\n         * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in\n         *  that case no checks should be actually perfomed nor the projected candidate should be applied directly\n        **/\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(affectedAnimations) {\n            var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            var excludeIdsFromCheck = [];\n            for (var i = 0; i < affectedAnimations.length; i++) {\n                excludeIdsFromCheck.push(affectedAnimations[i].id);\n            }\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n\n            var conflicts = [];\n            var affectedLanes = [];\n\n            // for each of the affectedAnimations\n            for (var _i4 = 0; _i4 < affectedAnimations.length; _i4++) {\n                var belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId[affectedAnimations[_i4].id];\n                var testDuration = affectedAnimations[_i4].end - affectedAnimations[_i4].start;\n\n                // for each lane the affected Animation appears in\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var lane = LanesHandlerSandbox.lanes[belongingLanes[j]];\n                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n                    // check for conflicts and edit lane items millisecond\n                    for (var k = 0; k < lane.length; k++) {\n                        if (lane[k].incident.id === affectedAnimations[_i4].id) {\n                            affectedLanes.push(laneData);\n                            if (fullChannelResize === false) {\n                                var affectedAnim = lane[k];\n                                var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                                testLaneElement.millisecond += affectedAnimations[_i4].startDelta;\n                                var _overlappingAnims2 = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, excludeIdsFromCheck, testDuration);\n\n                                if (_overlappingAnims2.length > 0) {\n                                    conflicts.push({\n                                        type: 'anauthorised overlapping animations on the same element',\n                                        meta: {\n                                            element_mcid: laneData.mcid,\n                                            attribute: laneData.attribute,\n                                            newAnimation: testLaneElement,\n                                            overlappingAnims: _overlappingAnims2\n                                        }\n                                    });\n                                }\n                            }\n\n                            break;\n                        } // end of if we found the specific animation on the lane's sequence\n                    } // end of each lane's item\n\n                } // end of each belonging lane\n            } // end for each affected animation's id\n\n            if (conflicts.length > 0) {\n                return {\n                    result: false,\n                    conflicts: conflicts\n                };\n            } else {\n                // unlike the case of editing the start millisecond of a Scene / Incident on editing the duration of a Scene\n                // or an Incident slipping to lanes should occur depends not only on the positioning of the Animations on\n                // the lanes but also on their duration. Editing the duration occurs on the Scene that received the editDuration\n                // command and thus at that point the HTMLChannel (and its LanesHaldler) is not ready to slip as the affected\n                // Animations still have the old (un-edited) duration.\n                // For this reason and only on the case of duration edit slip to lanes will take place not here and not now\n                // but on the scope of the Scene that got the command, at the point it receives the success ({result:true}).\n                // For this we will create a callback function which holds the slipping to lanes commands and pass it on the\n                // \"callback\" key of the result object ({success:true, callback:function(){that slips into lanes}})\n                var that = this;\n\n                var exec = function exec() {\n                    var slippingCommands = []; // an array that will hold all of the slipping commands in all of the affected lanes\n\n                    // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)\n                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n                    // success message\n                    for (var _i5 = 0; _i5 < affectedAnimations.length; _i5++) {\n                        that.LanesHandler.updateLane([affectedAnimations[_i5].id], affectedAnimations[_i5].startDelta);\n                    }\n\n                    var _loop2 = function _loop2(_i6) {\n                        var affectedLane = affectedLanes[_i6];\n                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);\n                        // put the slip command on the slippingCommands array\n                        slippingCommands.push(function () {\n                            that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                        });\n                    };\n\n                    for (var _i6 = 0; _i6 < affectedLanes.length; _i6++) {\n                        _loop2(_i6);\n                    }\n\n                    for (var _i7 = 0; _i7 < slippingCommands.length; _i7++) {\n                        slippingCommands[_i7]();\n                    }\n                };\n\n                return {\n                    execute: exec,\n                    result: true\n                };\n            }\n        }\n\n        /**\n         * \n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(removedAnimations) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var removedAnimationIds = [];\n            for (var i = 0; i < removedAnimations.length; i++) {\n                removedAnimationIds.push(removedAnimations[i].id);\n            }\n\n            // no slipping is needed as on deletion the Animations set their elements to their initial values\n            var that = this;\n            var exec = function exec() {\n                var affectedLanes = that.LanesHandler.deleteAnimations(removedAnimationIds, that.runTimeInfo.currentMillisecond);\n                for (var laneKey in affectedLanes) {\n                    var _affectedLane = affectedLanes[laneKey];\n                    var _theActualLane = that.LanesHandler.getLane(_affectedLane.mcid, _affectedLane.attribute);\n                    if (props.preventSlip != true) {\n                        that.slipIntoLaneForwards(_theActualLane, _affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            return {\n                result: true,\n                execute: exec\n            };\n        }\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n         * @param {array} ids - (optional) if provided it only checks resizes on the given ids (not all incidents have been re)\n        **/\n\n    }, {\n        key: 'checkDurationEdit',\n        value: function checkDurationEdit(durationFraction) {\n            var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            // using ProjectionsHanlder it will create the candidates and the projections to pass up to the parent\n            // returned object keys: candidateOwnProjectedAnimations, affectedAnimations\n            var projectedAnimations = this.projectionsHandler.systoleDiastoleProjections(durationFraction, ids);\n            // once it gets the porojectedAnimations from its projections hanlder it will pass it up for check\n\n            // if the ids array is provided that means the checkDurationEdit is been used by an Animation directly\n            // belonging to the html channel, so it's not a full channel resize\n            var check = this.checkResizedAnimations(projectedAnimations.affectedAnimations, ids.length === 0 ? true : false);\n\n            return check;\n        }\n\n        /**\n         * Method that is invoked by Animation objects when one of their attributes value is edited\n         * The purpose of this method here on the HTMLChannel is to update the lanes accordingly and slip into the\n         * corresponding lanes\n         * @param {string} animationId - the id of the Animation object that has been edited\n         * @param {string} attr - the name of the attribute that has been edited\n         * @param {string} value - the new value of the edited attribute\n        */\n\n    }, {\n        key: 'animationAttributeValueChange',\n        value: function animationAttributeValueChange(animationId, attr, value) {\n            var affectedLanes = this.LanesHandler.updateAttributeOnLanes(animationId, attr, value);\n            for (var i = 0; i < affectedLanes.length; i++) {\n                var _affectedLane2 = affectedLanes[i];\n                var _theActualLane2 = this.LanesHandler.getLane(_affectedLane2.mcid, _affectedLane2.attribute);\n                this.slipIntoLaneForwards(_theActualLane2, _affectedLane2, 0, this.runTimeInfo.currentMillisecond);\n            }\n        }\n\n        /**\n         * Slips to just one lane forwards\n         * @param {array} lane - the lane to slip into\n         * @param {object} laneData - an object with keys: attribute & mcid\n         * @param {int} currentMillisecond - the millisecond the slip starts from\n         * @param {int} millisecond - the target millisecond of the slip\n         */\n\n    }, {\n        key: 'slipIntoLaneForwards',\n        value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond) {\n            // helper.log(lane, currentMillisecond, millisecond);\n            var participatingAnims = _filter(lane, function (laneItem) {\n                return laneItem.millisecond + laneItem.incident.duration >= currentMillisecond && laneItem.millisecond + laneItem.incident.duration <= millisecond || // it ends after currentMillisecond and before target millisecond\n                laneItem.incident.duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond; // or it ends after the target millisecond but also starts before it\n            });\n\n            if (participatingAnims.length == 0) {\n                return true;\n            }\n\n            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n                return laneItem.millisecond;\n            }]);\n\n            // now we have all participatingAnims of the slip action in chronological order\n            // our first job is to create a variable that will hold the last known value of the lane\n            var lastValue = null;\n            for (var i = 0; i < participatingAnims.length; i++) {\n                var participatingAnim = participatingAnims[i].incident;\n                var startMillisecond = participatingAnims[i].millisecond;\n\n                // if the animation has no start values go ahead and calculated them now\n                if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue === null) {\n                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, 'calculated');\n                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute);\n                } else if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue != null) {\n                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, lastValue);\n                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute, lastValue);\n                }\n\n                // if the animation ends before the target millisecond\n                // helper.log('participatingAnim.duration + startMillisecond', participatingAnim.duration + startMillisecond, millisecond);\\\n\n                if (participatingAnim.duration + startMillisecond <= millisecond) {\n                    // helper.log('ends before target')\n                    lastValue = participatingAnim.attrs.animatedAttrs[laneData.attribute];\n                    if (i === participatingAnims.length - 1) {\n                        participatingAnim.onProgress(1, participatingAnim.duration);\n                    }\n                } else {\n                    // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n                    // and store this info somewhere\n                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n                    participatingAnim.onProgress(percentageComplete, millisecond);\n                }\n            }\n        }\n\n        /**\n         * Slips to just one lane backwards\n         * @param {array} lane - the lane to slip into\n         * @param {object} laneData - an object with keys: attribute & mcid\n         * @param {int} currentMillisecond - the millisecond the slip starts from\n         * @parama {int} millisecond - the target millisecond of the slip\n         */\n\n    }, {\n        key: 'slipToLaneBackwards',\n        value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond) {\n            // we take all Animations that are either currently running or\n            // they end after the destination point\n            // helper.log('<------');\n            var participatingAnims = _filter(lane, function (laneItem) {\n                var laneItemEnd = laneItem.incident.duration + laneItem.millisecond;\n                return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area\n                laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area\n                laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area\n            });\n\n            if (participatingAnims.length == 0) {\n                return true;\n            }\n\n            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n                return laneItem.millisecond;\n            }]);\n\n            var lastValue = null;\n            for (var i = participatingAnims.length - 1; i >= 0; i--) {\n                var participatingAnim = participatingAnims[i].incident;\n                var startMillisecond = participatingAnims[i].millisecond;\n                if (startMillisecond >= millisecond) {\n                    participatingAnim.onProgress(0, 0);\n                } else {\n                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n\n                    participatingAnim.onProgress(percentageComplete, millisecond);\n                }\n            }\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            // step 1: iterate through all lanes\n            for (var laneid in this.lanes) {\n                var lane = this.lanes[laneid];\n                var laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);\n                if (from < to) {\n                    // helper.log(laneid);\n                    this.slipIntoLaneForwards(lane, laneData, from, to);\n                } else if (from >= to) {\n                    this.slipToLaneBackwards(lane, laneData, from, to);\n                }\n            }\n        }\n    }, {\n        key: 'lanes',\n        get: function get() {\n            return this.LanesHandler.lanes;\n        }\n    }], [{\n        key: 'type',\n        get: function get() {\n            return \"attributes\";\n        }\n    }]);\n\n    return AttributeChannel;\n}(Channel);\n\nmodule.exports = AttributeChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvX0F0dHJpYnV0ZS9BdHRyaWJ1dGVDaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvQXR0cmlidXRlQ2hhbm5lbC5qcz80YzU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uL0NoYW5uZWwnKTtcbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4Jyk7XG52YXIgX3NvcnRCeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4Jyk7XG5cbnZhciBsYW5lc0hhbmRsZXIgPSByZXF1aXJlKCcuL0xhbmVzSGFuZGxlcicpO1xuXG52YXIgQXR0cmlidXRlQ2hhbm5lbCA9IGZ1bmN0aW9uIChfQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhBdHRyaWJ1dGVDaGFubmVsLCBfQ2hhbm5lbCk7XG5cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVDaGFubmVsKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdHRyaWJ1dGVDaGFubmVsKTtcblxuICAgICAgICAvKlxuICAgICAgICBjb21ib0F0dHJpYnV0ZXMgYXJlIGF0dHJpYnV0ZXMgb2YgdHlwZSBvYmplY3QsIGhvbGRpbmcgYSBudW1iZXIgb2Ygb3RoZXIgYXR0cmlidXRlcy5cbiAgICAgICAgRS5nLiBDU1MgXCJ0cmFuc2Zvcm1cIiBhdHRyaWJ1dGUgaXMgYSBjb21ibyB0aGF0IGhvbGRzIGEgbnVtYmVyIG9mIG90aGVyIGF0dHJpYnV0ZXMgc3VjaCBhczpcbiAgICAgICAgdHJhbnNsYXRlWCwgdHJhbnNsYXRlWSwgZXRjLiBUaGUgbGFuZXMgaGFuZGxlciBrZWVwcyBqdXN0IG9uZSBsYW5lIGZvciB0aGUgY29tYm8gYXR0cnMgXG4gICAgICAgIGluIGFuIG9iamVjdCBmb3JtYXQga2VlcGluZyB0aGUgdmFsdWUgb2YgZWFjaCBhdHRyaWJ1dGUgYXQgYW55IGdpdmVuIHBvaW50LlxuICAgICAgICBDb21ibyBhdHRyaWJ1dGVzIGFyZSBwYXNzZWQgb24gdGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBDaGFubmVsIGluIHRoZSBmb3JtYXQ6XG4gICAgICAgIHByb3BzLmNvbWJvQXR0cmlidXRlczoge1xuICAgICAgICAgICAgdHJhbnNpdGlvbjogWyd0cmFuc2xhdGVYJywgJ3RyYW5zbGF0ZVknLCAuLi5dLFxuICAgICAgICAgICAgPHNvbWV0aGluZ19lbHNlPjogWyc8YXR0ck5hbWUxPicsICc8YXR0ck5hbWUyPicsIC4uLl1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoQXR0cmlidXRlQ2hhbm5lbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF0dHJpYnV0ZUNoYW5uZWwpKS5jYWxsKHRoaXMsIHByb3BzKSk7XG5cbiAgICAgICAgX3RoaXMuY29tYm9BdHRyaWJ1dGVzID0ge307XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBpbmNpZGVudHMgdGhhdCBkbyBub3QgaGF2ZSBhbmltYXRlZEF0dHJzIHRoZXJlIHNob3VsZCBiZSBvbmx5IG9uZSBsYW5lIHBlciBlbGVtZW50LiBcbiAgICAgICAgICogVGhlIGF0dHJpYnV0ZXMgQ2hhbm5lbCB3aWxsIHVzZSBhIGRlZmF1bHQgKGZha2UpLCBmaXhlZCBhdHRyaWJ1dGUgZm9yIHRoaXMgY2FzZXMgc28gaXQgYWx3YXlzIGVuZHNcbiAgICAgICAgICogdXAgd2l0aCBqdXN0IG9uZSBsYW5lIHBlciBlbGVtZW50OiA8ZWxlbWVudF9pZD5fPHRoaXMuZml4ZWRBdHRyaWJ1dGVOYW1lPlxuICAgICAgICAqL1xuICAgICAgICBfdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWUgPSBcIl9cIjtcblxuICAgICAgICBpZiAocHJvcHMuY29tYm9BdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLmNvbWJvQXR0cmlidXRlcyA9IHByb3BzLmNvbWJvQXR0cmlidXRlcztcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzLkxhbmVzSGFuZGxlciA9IG5ldyBsYW5lc0hhbmRsZXIoeyBjb21ib0F0dHJpYnV0ZXM6IF90aGlzLmNvbWJvQXR0cmlidXRlcyB9KTtcbiAgICAgICAgLy8gdGhpcy50eXBlID0gXCJhdHRyaWJ1dGVzXCI7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXR0cmlidXRlQ2hhbm5lbCwgW3tcbiAgICAgICAga2V5OiAnc2V0Q29tYm9BdHRyaWJ1dGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldENvbWJvQXR0cmlidXRlcyhjb21ib0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0gY29tYm9BdHRyaWJ1dGVzO1xuICAgICAgICAgICAgdGhpcy5MYW5lc0hhbmRsZXIgPSBuZXcgbGFuZXNIYW5kbGVyKHsgY29tYm9BdHRyaWJ1dGVzOiB0aGlzLmNvbWJvQXR0cmlidXRlcyB9KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Jlc2l6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuTGFuZXNIYW5kbGVyLl9yZXNpemUoZHVyYXRpb25GcmFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGluY2lkZW50IGhhcyBhbmltYXRlZEF0dHJzIG9yIG5vdC4gXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfaW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmNpZGVudEhhc0FuaW1hdGVkQXR0cnMoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmNpZGVudC5hdHRycy5oYXNPd25Qcm9wZXJ0eSgnYW5pbWF0ZWRBdHRycycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICBERUNJU0lPTiBNRVRIT0RTXG4gICAgICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG9mIHRoZSBpbmNpZGVudHMgY29taW5nIHRvIHRoaXMgbWV0aG9kIGFyZSBlbGVtZW50LWF0dHJpYnV0ZSBpbmNpZGVudHMgbWVhbmluZyB0aGF0IHRoZXkgb25seVxuICAgICAgICAgKiB0YXJnZXQganVzdCBvbmUgZWxlbWVudCBhbmQgYWxzbyB0aGV5IGluY2x1ZGUganVzdCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gdGhlIGluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNcbiAgICAgICAgICogb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIEEgY29sbGVjdGlvbiBvZiBJbmNpZGVudHMgaW4gdGhlIGZvcm06XG4gICAgICAgICAqIHtcbiAgICAgICAgICogIG1pbGxpc2Vjb25kXG4gICAgICAgICAqICBpbmNpZGVudFxuICAgICAgICAgKiAgaWRcbiAgICAgICAgICogfVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIGNhbiBiZSBlaXRoZXIgXCJhbGwtb3Itbm90aGluZ1wiIChkZWZhdWx0KSBvciBcImtlZXAtcGFzc2luZ1wiLiBJZiB0eXBlID0gXCJhbGwtb3Itbm90aGluZ1wiXG4gICAgICAgICAqICB0aGUgYWRkaXRpb24gcGFzc2VzIG9ubHkgaWYgYWxsIGluY2lkZW50cyBwYXNzLiBJZiB0eXBlID0gXCJrZWVwLXBhc3NpbmdcIiB0aGUgbWV0aG9kIHdpbGwgc3RpbGwgcmV0dXJuIHRydWVcbiAgICAgICAgICogIGJ1dCB3aWxsIGFsc28gaW5jbHVkZSBhbiBlcnJvcnMgYXJyYXkgb24gaXRzIHJldHVybiBhbmQgYWxzbyB3aWxsIG9ubHkgaW5jbHVkZSB0aGUgc3VjY2VzcyBjYWxsYmFja3Mgb24gXG4gICAgICAgICAqICB0aGUgZXhlY3V0ZSBrZXkgb2YgaXRzIHJldHVyblxuICAgICAgICAgKiBAcmV0dXJucyBlaXRoZXI6XG4gICAgICAgICAqICAge1xuICAgICAgICAgKiAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICogICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgICogICBvclxuICAgICAgICAgKiAgIHtcbiAgICAgICAgICogICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICogICAgICAgZXJyb3JzXG4gICAgICAgICAqICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0FkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiYWxsLW9yLW5vdGhpbmdcIjtcblxuICAgICAgICAgICAgdmFyIExhbmVzSGFuZGxlclNhbmRib3ggPSB0aGlzLkxhbmVzSGFuZGxlci5jcmVhdGVUZXN0TGFuZXNTYW5ib3goKTtcbiAgICAgICAgICAgIC8qIGFuIGFycmF5IHdoZXJlIHdlIGtlZXAgYWxsIGFmZmVjdGVkIGxhbmVzIHNvIHdlIGNhbiBzbGlwIG9uIHRoZW0gYXQgdGhlIGVuZC4gXG4gICAgICAgICAgICBUaGUgZm9ybWF0IGZvciBlYWNoIGFmZmVjdGVkIGxhbmUgd2Uga2VlcCBpczpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtY2lkOiBtY2lkLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gd2hpbGUgdGhlIExhbmVzSGFuZGxlclNhbmJveCBhZGRzIGxhbmUgaXRlbXMgaXQgbWFrZXMgZGVjaXNpb25zIG9mIHdoaWNoIHBlcm1hbmVudCBjaGFuZ2VzIHNob3VsZCBiZSBtYWRlIHRvXG4gICAgICAgICAgICAvLyB0aGUgcGVybWFuZW50IGFuZCBwcmUtZXhpc3Rpbmcgb2JqZWN0cyBpdCBoYW5kbGVzLCBzdWNoIGFzIGNoYW5nZXMgb24gdGhlIGluaXRpYWwgdmFsdWVzIG9mIGV4aXN0aW5nIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAvLyBCZWNhdXNlIG9mIHRoZSBmYWN0IHRoZSBMYW5lc1NhbmRib3hIYW5kbGVyIGlzIG9ubHkgdGhlcmUgZm9yIHRlc3Rpbmcgd2UgZG9uJ3Qgd2FudCB0byBleGVjdXRlIHRoZXNlIGNoYW5nZXNcbiAgICAgICAgICAgIC8vIGR1cmluZyBjaGVja3MgYnV0IHN0aWxsIHdlIG5lZWQgdG8ga25vdyB0aGVtIG9uIHN1Y2Nlc3MuIEZvciB0aGlzLCB0aGUgb25TdWNjZXNzQWN0aW9ucyBhcnJheSBob2xkcyBhbGwgZXhlY3V0YWJsZVxuICAgICAgICAgICAgLy8gZnVuY3Rpb25zIHJldHVyZWQgYnkgdmFyaW91cyBMYW5lc0hhbmRsZXJTYW5ib3ggZnVuY3Rpb25zIHNvIGl0IGNhbiBleGVjdXRlIHRoZW0gb24gc3VjY2Vzcy5cbiAgICAgICAgICAgIHZhciBvblN1Y2Nlc3NBY3Rpb25zID0gW107XG5cbiAgICAgICAgICAgIHZhciBjb25mbGljdHMgPSBbXTtcblxuICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoaSkge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudENvbmZsaWN0cyA9IGZhbHNlOyAvLyBhIGJvb2xlYW4gdGhhdCBrZWVwcyB0aGUgaW5mb3JtYXRpb24gd2hldGhlciB0aGUgaW5jaWRlbnQgY29uZmxpY3RzIG9yIG5vdFxuICAgICAgICAgICAgICAgIHZhciBsYW5lSXRlbSA9IGluY2lkZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSBsYW5lSXRlbS5pbmNpZGVudDtcblxuICAgICAgICAgICAgICAgIHZhciBtY2lkID0gX3RoaXMyLmNvbnRleHQuZ2V0TUNJRChpbmNpZGVudC5lbGVtZW50KTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwidGhlIGluY2lkZW50XCIsaW5jaWRlbnQpXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZSA9IF90aGlzMi5maXhlZEF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzMi5faW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGluY2lkZW50KSkge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgPSBPYmplY3Qua2V5cyhpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzKVswXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBMYW5lc0hhbmRsZXJTYW5kYm94LmxhbmVFeGlzdHMobWNpZCwgYXR0cmlidXRlLCB0cnVlKTsgLy8gY3JlYXRlIHRoZSBsYW5lIGlmIGl0IGRvZXNuJ3QgZXhpc3QgYWxyZWFkeVxuXG4gICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWNpZDogbWNpZCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChMYW5lc0hhbmRsZXJTYW5kYm94LmFuaW1hdGlvbklERXhpc3RzKG1jaWQsIGF0dHJpYnV0ZSwgaW5jaWRlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50Q29uZmxpY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2R1cGxpY2F0ZSBBbmltYXRpb24gaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpbmNpZGVudC5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyAqKioqIGlmIHRoZSBsYW5lIGRpZCBleGlzdCBiZWZvcmUgdGhlIG5ldyBhZGRpdGlvbiBjaGVjayBmb3IgY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nQW5pbXMgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldE92ZXJsYXBwaW5nQW5pbXMobGFuZUl0ZW0sIG1jaWQsIGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKG92ZXJsYXBwaW5nQW5pbSlcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxhcHBpbmdBbmltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50Q29uZmxpY3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3VuYXV0aG9yaXNlZCwgb3ZlcmxhcHBpbmcgaW5jaWRlbnRzIG9uIHRoZSBzYW1lIGVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRfbWNpZDogbWNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudDogbGFuZUl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBbmltczogb3ZlcmxhcHBpbmdBbmltc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWluY2lkZW50Q29uZmxpY3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzc0FjdGlvbnMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBMYW5lc0hhbmRsZXJTYW5kYm94LmFkZEVsZW1lbnRUb0xhbmUobWNpZCwgYXR0cmlidXRlLCBsYW5lSXRlbS5taWxsaXNlY29uZCwgaW5jaWRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcChpKTtcbiAgICAgICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIGluY2lkZW50XG5cbiAgICAgICAgICAgIC8vIGlmIHdlIGhhdmUgY29uZmxpY3RzIGFuZCB0aGUgdHlwZSA9IFwiYWxsLW9yLW5vdGhpbmdcIlxuICAgICAgICAgICAgaWYgKGNvbmZsaWN0cy5sZW5ndGggPiAwICYmIHR5cGUgPT09IFwiYWxsLW9yLW5vdGhpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYXMgc29vbiBhcyB3ZSB3YW50IGFsbCBwYXNzaW5nIGFkZGl0aW9ucyB0byBnZXQgYXBwbGllZCB0aGUgTGFuZXMgSGFuZGxlciB3aWxsIGNyZWF0ZSBhIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNhbGxiYWNrIHdpbGwgYXBwbHkgYWxsIHBhc3NpbmcgYWRkaXRpb25zLlxuXG4gICAgICAgICAgICAgICAgLy8gc3VjY2VzcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5MYW5lc0hhbmRsZXIuYXBwbHlTYW5kYm94Q2hhbmdlcyhMYW5lc0hhbmRsZXJTYW5kYm94KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvblN1Y2Nlc3NBY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3NBY3Rpb25zW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGhvdyBleGFjdGx5IGFyZSB3ZSBoYW5kbGluZyBzbGlwcGluZz9cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFmZmVjdGVkTGFuZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lID0gYWZmZWN0ZWRMYW5lc1tfaV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNsaXBJbnRvTGFuZUZvcndhcmRzKHRoYXQuTGFuZXNIYW5kbGVyLmdldExhbmUoYWZmZWN0ZWRMYW5lLm1jaWQsIGFmZmVjdGVkTGFuZS5hdHRyaWJ1dGUpLCBhZmZlY3RlZExhbmUsIDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogY29uZmxpY3RzLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiBleGVjXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEl0IGluaXRpYWxseSBjaGVja3MgaWYgdGhlIGVkaXQgaXMgYWxsb3dlZCBhbmQgaWYgaXQgaXMgaXQgcmV0dW5zIGFuIGFycmF5IG9mIGV4ZWN1dGFibGUgZnVuY3Rpb25zXG4gICAgICAgICogdGhhdCBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gdGhlIGxpc3Qgb2YgdGhlIGxhbmUgaXRlbXMgdG8gZWRpdCBpbiBhbiBhcnJheSBmb3JtYXQgW29iamVjdCwgb2JqZWN0LCAuLi5dXG4gICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSB0byBhcHBseSB0byB0aGUgaW5jaWRlbnRzXG4gICAgICAgICogQHJldHVybnMge29iamVjdH0gLVxuICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAge1xuICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgIGV4ZWN1dGU6IC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZCBpbiBvcmRlciB0byBhcHBseSB0aGUgZWRpdFxuICAgICAgICB9XG4gICAgICAgIG9yXG4gICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcnM6IC8vIGFuIGFycmF5IGluY2x1ZGluZyBhbGwgdGhlIGVycm9ycyAvIGNvbmZsaWN0cyBmb3VuZCBvbiBlZGl0XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHMsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG5cbiAgICAgICAgICAgIHZhciBhZmZlY3RlZEluY2lkZW50SWRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkSW5jaWRlbnRJZHMucHVzaChpbmNpZGVudHNbaV0uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgTGFuZXNIYW5kbGVyU2FuZGJveCA9IHRoaXMuTGFuZXNIYW5kbGVyLmNyZWF0ZVRlc3RMYW5lc1NhbmJveCgpO1xuXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBvZiB0aGUgYWZmZWN0ZWRBbmltYXRpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNpZGVudHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgIHZhciBfaW5jaWRlbnQgPSBpbmNpZGVudHNbX2kyXS5pbmNpZGVudDtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRJZCA9IF9pbmNpZGVudC5pZDtcbiAgICAgICAgICAgICAgICB2YXIgX21jaWQgPSB0aGlzLmNvbnRleHQuZ2V0TUNJRChfaW5jaWRlbnQuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIF9hdHRyaWJ1dGUgPSB0aGlzLmZpeGVkQXR0cmlidXRlTmFtZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKF9pbmNpZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgX2F0dHJpYnV0ZSA9IE9iamVjdC5rZXlzKF9pbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzKVswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmUoX21jaWQsIF9hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lQXR0cnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1jaWQ6IF9tY2lkLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IF9hdHRyaWJ1dGVcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY29uZmxpY3RzIGFuZCBlZGl0IGxhbmUgaXRlbXMgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICB9O2ZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZVtrXS5pbmNpZGVudC5pZCA9PT0gaW5jaWRlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lcy5wdXNoKGxhbmVBdHRycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRBbmltID0gbGFuZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0TGFuZUVsZW1lbnQgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmVFbGVtZW50c0Nsb25lKGFmZmVjdGVkQW5pbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXN0TGFuZUVsZW1lbnQubWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzRGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX292ZXJsYXBwaW5nQW5pbXMgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldE92ZXJsYXBwaW5nQW5pbXModGVzdExhbmVFbGVtZW50LCBfbWNpZCwgX2F0dHJpYnV0ZSwgYWZmZWN0ZWRJbmNpZGVudElkcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfb3ZlcmxhcHBpbmdBbmltcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYW5hdXRob3Jpc2VkLCBvdmVybGFwcGluZyBhbmltYXRpb25zIG9uIHRoZSBzYW1lIGVsZW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IF9tY2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBfYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3QW5pbWF0aW9uOiB0ZXN0TGFuZUVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FuaW1zOiBfb3ZlcmxhcHBpbmdBbmltc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIGVuZCBvZiBpZiB3ZSBmb3VuZCB0aGUgc3BlY2lmaWMgYW5pbWF0aW9uIG9uIHRoZSBsYW5lJ3Mgc2VxdWVuY2VcbiAgICAgICAgICAgICAgICB9IC8vIGVuZCBvZiBlYWNoIGxhbmUncyBpdGVtXG5cbiAgICAgICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIGFmZmVjdGVkIGFuaW1hdGlvbidzIGlkXG5cbiAgICAgICAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgc29vbiBhcyB0aGVyZSBhcmUgbm8gY29uZmxpY3RzIHRoZSBMYW5lcyBIYW5kbGVyIGFwcGxpZXMgdGhlIGNoYW5nZXMgYmVmb3JlIHNlbmRpbmcgb3ZlciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2VzcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLnVwZGF0ZUxhbmUoYWZmZWN0ZWRJbmNpZGVudElkcywgbWlsbGlzZWNvbmRzRGVsdGEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGFmZmVjdGVkTGFuZXMubGVuZ3RoOyBfaTMrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbX2kzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVBY3R1YWxMYW5lID0gdGhhdC5MYW5lc0hhbmRsZXIuZ2V0TGFuZShhZmZlY3RlZExhbmUubWNpZCwgYWZmZWN0ZWRMYW5lLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNsaXBJbnRvTGFuZUZvcndhcmRzKHRoZUFjdHVhbExhbmUsIGFmZmVjdGVkTGFuZSwgMCwgdGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGFmZmVjdGVkQW5pbWF0aW9ucyAtIFt7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XVxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZ1bGxDaGFubmVsUmVzaXplIC0gaWYgc2V0IHRvIHRydWUgdGhlbiB0aGUgZnVsbCBodG1sIGNoYW5uZWwgaXMgcmVzaXppbmcuIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgYXMgaW5cbiAgICAgICAgICogIHRoYXQgY2FzZSBubyBjaGVja3Mgc2hvdWxkIGJlIGFjdHVhbGx5IHBlcmZvbWVkIG5vciB0aGUgcHJvamVjdGVkIGNhbmRpZGF0ZSBzaG91bGQgYmUgYXBwbGllZCBkaXJlY3RseVxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tSZXNpemVkSW5jaWRlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVzaXplZEluY2lkZW50cyhhZmZlY3RlZEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBmdWxsQ2hhbm5lbFJlc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBleGNsdWRlSWRzRnJvbUNoZWNrID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFmZmVjdGVkQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGV4Y2x1ZGVJZHNGcm9tQ2hlY2sucHVzaChhZmZlY3RlZEFuaW1hdGlvbnNbaV0uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgTGFuZXNIYW5kbGVyU2FuZGJveCA9IHRoaXMuTGFuZXNIYW5kbGVyLmNyZWF0ZVRlc3RMYW5lc1NhbmJveCgpO1xuXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBmb3IgZWFjaCBvZiB0aGUgYWZmZWN0ZWRBbmltYXRpb25zXG4gICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBhZmZlY3RlZEFuaW1hdGlvbnMubGVuZ3RoOyBfaTQrKykge1xuICAgICAgICAgICAgICAgIHZhciBiZWxvbmdpbmdMYW5lcyA9IExhbmVzSGFuZGxlclNhbmRib3guYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkW2FmZmVjdGVkQW5pbWF0aW9uc1tfaTRdLmlkXTtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdER1cmF0aW9uID0gYWZmZWN0ZWRBbmltYXRpb25zW19pNF0uZW5kIC0gYWZmZWN0ZWRBbmltYXRpb25zW19pNF0uc3RhcnQ7XG5cbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBsYW5lIHRoZSBhZmZlY3RlZCBBbmltYXRpb24gYXBwZWFycyBpblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmxhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2pdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgY29uZmxpY3RzIGFuZCBlZGl0IGxhbmUgaXRlbXMgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZVtrXS5pbmNpZGVudC5pZCA9PT0gYWZmZWN0ZWRBbmltYXRpb25zW19pNF0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZExhbmVzLnB1c2gobGFuZURhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmdWxsQ2hhbm5lbFJlc2l6ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkQW5pbSA9IGxhbmVba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0TGFuZUVsZW1lbnQgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmdldExhbmVFbGVtZW50c0Nsb25lKGFmZmVjdGVkQW5pbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlc3RMYW5lRWxlbWVudC5taWxsaXNlY29uZCArPSBhZmZlY3RlZEFuaW1hdGlvbnNbX2k0XS5zdGFydERlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX292ZXJsYXBwaW5nQW5pbXMyID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKHRlc3RMYW5lRWxlbWVudCwgbGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlLCBleGNsdWRlSWRzRnJvbUNoZWNrLCB0ZXN0RHVyYXRpb24pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfb3ZlcmxhcHBpbmdBbmltczIubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhbmF1dGhvcmlzZWQgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRfbWNpZDogbGFuZURhdGEubWNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBsYW5lRGF0YS5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbjogdGVzdExhbmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwcGluZ0FuaW1zOiBfb3ZlcmxhcHBpbmdBbmltczJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgaWYgd2UgZm91bmQgdGhlIHNwZWNpZmljIGFuaW1hdGlvbiBvbiB0aGUgbGFuZSdzIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgICAgIH0gLy8gZW5kIG9mIGVhY2ggbGFuZSdzIGl0ZW1cblxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIG9mIGVhY2ggYmVsb25naW5nIGxhbmVcbiAgICAgICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIGFmZmVjdGVkIGFuaW1hdGlvbidzIGlkXG5cbiAgICAgICAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogY29uZmxpY3RzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5saWtlIHRoZSBjYXNlIG9mIGVkaXRpbmcgdGhlIHN0YXJ0IG1pbGxpc2Vjb25kIG9mIGEgU2NlbmUgLyBJbmNpZGVudCBvbiBlZGl0aW5nIHRoZSBkdXJhdGlvbiBvZiBhIFNjZW5lXG4gICAgICAgICAgICAgICAgLy8gb3IgYW4gSW5jaWRlbnQgc2xpcHBpbmcgdG8gbGFuZXMgc2hvdWxkIG9jY3VyIGRlcGVuZHMgbm90IG9ubHkgb24gdGhlIHBvc2l0aW9uaW5nIG9mIHRoZSBBbmltYXRpb25zIG9uXG4gICAgICAgICAgICAgICAgLy8gdGhlIGxhbmVzIGJ1dCBhbHNvIG9uIHRoZWlyIGR1cmF0aW9uLiBFZGl0aW5nIHRoZSBkdXJhdGlvbiBvY2N1cnMgb24gdGhlIFNjZW5lIHRoYXQgcmVjZWl2ZWQgdGhlIGVkaXREdXJhdGlvblxuICAgICAgICAgICAgICAgIC8vIGNvbW1hbmQgYW5kIHRodXMgYXQgdGhhdCBwb2ludCB0aGUgSFRNTENoYW5uZWwgKGFuZCBpdHMgTGFuZXNIYWxkbGVyKSBpcyBub3QgcmVhZHkgdG8gc2xpcCBhcyB0aGUgYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAvLyBBbmltYXRpb25zIHN0aWxsIGhhdmUgdGhlIG9sZCAodW4tZWRpdGVkKSBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhpcyByZWFzb24gYW5kIG9ubHkgb24gdGhlIGNhc2Ugb2YgZHVyYXRpb24gZWRpdCBzbGlwIHRvIGxhbmVzIHdpbGwgdGFrZSBwbGFjZSBub3QgaGVyZSBhbmQgbm90IG5vd1xuICAgICAgICAgICAgICAgIC8vIGJ1dCBvbiB0aGUgc2NvcGUgb2YgdGhlIFNjZW5lIHRoYXQgZ290IHRoZSBjb21tYW5kLCBhdCB0aGUgcG9pbnQgaXQgcmVjZWl2ZXMgdGhlIHN1Y2Nlc3MgKHtyZXN1bHQ6dHJ1ZX0pLlxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGlzIHdlIHdpbGwgY3JlYXRlIGEgY2FsbGJhY2sgZnVuY3Rpb24gd2hpY2ggaG9sZHMgdGhlIHNsaXBwaW5nIHRvIGxhbmVzIGNvbW1hbmRzIGFuZCBwYXNzIGl0IG9uIHRoZVxuICAgICAgICAgICAgICAgIC8vIFwiY2FsbGJhY2tcIiBrZXkgb2YgdGhlIHJlc3VsdCBvYmplY3QgKHtzdWNjZXNzOnRydWUsIGNhbGxiYWNrOmZ1bmN0aW9uKCl7dGhhdCBzbGlwcyBpbnRvIGxhbmVzfX0pXG4gICAgICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2xpcHBpbmdDb21tYW5kcyA9IFtdOyAvLyBhbiBhcnJheSB0aGF0IHdpbGwgaG9sZCBhbGwgb2YgdGhlIHNsaXBwaW5nIGNvbW1hbmRzIGluIGFsbCBvZiB0aGUgYWZmZWN0ZWQgbGFuZXNcblxuICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVMYW5lcyAob25seSB0aGlzIHRpbWUgYW5pbWF0aW9uIGJ5IGFuaW1hdGlvbiBhcyB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIGlzIG5vdCBzdGFuZGFyZCBmb3IgYWxsKVxuICAgICAgICAgICAgICAgICAgICAvLyBhcyBzb29uIGFzIHRoZXJlIGFyZSBubyBjb25mbGljdHMgdGhlIExhbmVzIEhhbmRsZXIgYXBwbGllcyB0aGUgY2hhbmdlcyBiZWZvcmUgc2VuZGluZyBvdmVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdWNjZXNzIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMDsgX2k1IDwgYWZmZWN0ZWRBbmltYXRpb25zLmxlbmd0aDsgX2k1KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLnVwZGF0ZUxhbmUoW2FmZmVjdGVkQW5pbWF0aW9uc1tfaTVdLmlkXSwgYWZmZWN0ZWRBbmltYXRpb25zW19pNV0uc3RhcnREZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKF9pNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbX2k2XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGVBY3R1YWxMYW5lID0gdGhhdC5MYW5lc0hhbmRsZXIuZ2V0TGFuZShhZmZlY3RlZExhbmUubWNpZCwgYWZmZWN0ZWRMYW5lLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwdXQgdGhlIHNsaXAgY29tbWFuZCBvbiB0aGUgc2xpcHBpbmdDb21tYW5kcyBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpcHBpbmdDb21tYW5kcy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNsaXBJbnRvTGFuZUZvcndhcmRzKHRoZUFjdHVhbExhbmUsIGFmZmVjdGVkTGFuZSwgMCwgdGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k2ID0gMDsgX2k2IDwgYWZmZWN0ZWRMYW5lcy5sZW5ndGg7IF9pNisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfbG9vcDIoX2k2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNyA9IDA7IF9pNyA8IHNsaXBwaW5nQ29tbWFuZHMubGVuZ3RoOyBfaTcrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpcHBpbmdDb21tYW5kc1tfaTddKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogZXhlYyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEZWxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEZWxldGUocmVtb3ZlZEFuaW1hdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIHZhciByZW1vdmVkQW5pbWF0aW9uSWRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWRBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEFuaW1hdGlvbklkcy5wdXNoKHJlbW92ZWRBbmltYXRpb25zW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbm8gc2xpcHBpbmcgaXMgbmVlZGVkIGFzIG9uIGRlbGV0aW9uIHRoZSBBbmltYXRpb25zIHNldCB0aGVpciBlbGVtZW50cyB0byB0aGVpciBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmVzID0gdGhhdC5MYW5lc0hhbmRsZXIuZGVsZXRlQW5pbWF0aW9ucyhyZW1vdmVkQW5pbWF0aW9uSWRzLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGFuZUtleSBpbiBhZmZlY3RlZExhbmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYWZmZWN0ZWRMYW5lID0gYWZmZWN0ZWRMYW5lc1tsYW5lS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGVBY3R1YWxMYW5lID0gdGhhdC5MYW5lc0hhbmRsZXIuZ2V0TGFuZShfYWZmZWN0ZWRMYW5lLm1jaWQsIF9hZmZlY3RlZExhbmUuYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLnByZXZlbnRTbGlwICE9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2xpcEludG9MYW5lRm9yd2FyZHMoX3RoZUFjdHVhbExhbmUsIF9hZmZlY3RlZExhbmUsIDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IGV4ZWNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tzIGlmIGEgZHVyYXRpb24gZWRpdCBpcyBmZWFzaWJsZSBhbmQgZG9lc24ndCBjYXVzZSBjb25mbGljdHNcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGR1cmF0aW9uIC0gdGhlIG5ldyBkdXJhdGlvblxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpZHMgLSAob3B0aW9uYWwpIGlmIHByb3ZpZGVkIGl0IG9ubHkgY2hlY2tzIHJlc2l6ZXMgb24gdGhlIGdpdmVuIGlkcyAobm90IGFsbCBpbmNpZGVudHMgaGF2ZSBiZWVuIHJlKVxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEdXJhdGlvbkVkaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEdXJhdGlvbkVkaXQoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgICAgICAgdmFyIGlkcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG5cbiAgICAgICAgICAgIC8vIHVzaW5nIFByb2plY3Rpb25zSGFubGRlciBpdCB3aWxsIGNyZWF0ZSB0aGUgY2FuZGlkYXRlcyBhbmQgdGhlIHByb2plY3Rpb25zIHRvIHBhc3MgdXAgdG8gdGhlIHBhcmVudFxuICAgICAgICAgICAgLy8gcmV0dXJuZWQgb2JqZWN0IGtleXM6IGNhbmRpZGF0ZU93blByb2plY3RlZEFuaW1hdGlvbnMsIGFmZmVjdGVkQW5pbWF0aW9uc1xuICAgICAgICAgICAgdmFyIHByb2plY3RlZEFuaW1hdGlvbnMgPSB0aGlzLnByb2plY3Rpb25zSGFuZGxlci5zeXN0b2xlRGlhc3RvbGVQcm9qZWN0aW9ucyhkdXJhdGlvbkZyYWN0aW9uLCBpZHMpO1xuICAgICAgICAgICAgLy8gb25jZSBpdCBnZXRzIHRoZSBwb3JvamVjdGVkQW5pbWF0aW9ucyBmcm9tIGl0cyBwcm9qZWN0aW9ucyBoYW5sZGVyIGl0IHdpbGwgcGFzcyBpdCB1cCBmb3IgY2hlY2tcblxuICAgICAgICAgICAgLy8gaWYgdGhlIGlkcyBhcnJheSBpcyBwcm92aWRlZCB0aGF0IG1lYW5zIHRoZSBjaGVja0R1cmF0aW9uRWRpdCBpcyBiZWVuIHVzZWQgYnkgYW4gQW5pbWF0aW9uIGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBiZWxvbmdpbmcgdG8gdGhlIGh0bWwgY2hhbm5lbCwgc28gaXQncyBub3QgYSBmdWxsIGNoYW5uZWwgcmVzaXplXG4gICAgICAgICAgICB2YXIgY2hlY2sgPSB0aGlzLmNoZWNrUmVzaXplZEFuaW1hdGlvbnMocHJvamVjdGVkQW5pbWF0aW9ucy5hZmZlY3RlZEFuaW1hdGlvbnMsIGlkcy5sZW5ndGggPT09IDAgPyB0cnVlIDogZmFsc2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRoYXQgaXMgaW52b2tlZCBieSBBbmltYXRpb24gb2JqZWN0cyB3aGVuIG9uZSBvZiB0aGVpciBhdHRyaWJ1dGVzIHZhbHVlIGlzIGVkaXRlZFxuICAgICAgICAgKiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBoZXJlIG9uIHRoZSBIVE1MQ2hhbm5lbCBpcyB0byB1cGRhdGUgdGhlIGxhbmVzIGFjY29yZGluZ2x5IGFuZCBzbGlwIGludG8gdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgbGFuZXNcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbklkIC0gdGhlIGlkIG9mIHRoZSBBbmltYXRpb24gb2JqZWN0IHRoYXQgaGFzIGJlZW4gZWRpdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIC0gdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZSB0aGF0IGhhcyBiZWVuIGVkaXRlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgbmV3IHZhbHVlIG9mIHRoZSBlZGl0ZWQgYXR0cmlidXRlXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FuaW1hdGlvbkF0dHJpYnV0ZVZhbHVlQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGlvbkF0dHJpYnV0ZVZhbHVlQ2hhbmdlKGFuaW1hdGlvbklkLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB0aGlzLkxhbmVzSGFuZGxlci51cGRhdGVBdHRyaWJ1dGVPbkxhbmVzKGFuaW1hdGlvbklkLCBhdHRyLCB2YWx1ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFmZmVjdGVkTGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2FmZmVjdGVkTGFuZTIgPSBhZmZlY3RlZExhbmVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBfdGhlQWN0dWFsTGFuZTIgPSB0aGlzLkxhbmVzSGFuZGxlci5nZXRMYW5lKF9hZmZlY3RlZExhbmUyLm1jaWQsIF9hZmZlY3RlZExhbmUyLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGlwSW50b0xhbmVGb3J3YXJkcyhfdGhlQWN0dWFsTGFuZTIsIF9hZmZlY3RlZExhbmUyLCAwLCB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2xpcHMgdG8ganVzdCBvbmUgbGFuZSBmb3J3YXJkc1xuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBsYW5lIC0gdGhlIGxhbmUgdG8gc2xpcCBpbnRvXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsYW5lRGF0YSAtIGFuIG9iamVjdCB3aXRoIGtleXM6IGF0dHJpYnV0ZSAmIG1jaWRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGN1cnJlbnRNaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0aGUgc2xpcCBzdGFydHMgZnJvbVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmQgLSB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIG9mIHRoZSBzbGlwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbGlwSW50b0xhbmVGb3J3YXJkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwSW50b0xhbmVGb3J3YXJkcyhsYW5lLCBsYW5lRGF0YSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhsYW5lLCBjdXJyZW50TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIHZhciBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfZmlsdGVyKGxhbmUsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCArIGxhbmVJdGVtLmluY2lkZW50LmR1cmF0aW9uID49IGN1cnJlbnRNaWxsaXNlY29uZCAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCArIGxhbmVJdGVtLmluY2lkZW50LmR1cmF0aW9uIDw9IG1pbGxpc2Vjb25kIHx8IC8vIGl0IGVuZHMgYWZ0ZXIgY3VycmVudE1pbGxpc2Vjb25kIGFuZCBiZWZvcmUgdGFyZ2V0IG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgbGFuZUl0ZW0uaW5jaWRlbnQuZHVyYXRpb24gKyBsYW5lSXRlbS5taWxsaXNlY29uZCA+PSBtaWxsaXNlY29uZCAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZDsgLy8gb3IgaXQgZW5kcyBhZnRlciB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGJ1dCBhbHNvIHN0YXJ0cyBiZWZvcmUgaXRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltcyA9IF9zb3J0QnkocGFydGljaXBhdGluZ0FuaW1zLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICAvLyBub3cgd2UgaGF2ZSBhbGwgcGFydGljaXBhdGluZ0FuaW1zIG9mIHRoZSBzbGlwIGFjdGlvbiBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyXG4gICAgICAgICAgICAvLyBvdXIgZmlyc3Qgam9iIGlzIHRvIGNyZWF0ZSBhIHZhcmlhYmxlIHRoYXQgd2lsbCBob2xkIHRoZSBsYXN0IGtub3duIHZhbHVlIG9mIHRoZSBsYW5lXG4gICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbmdBbmltID0gcGFydGljaXBhdGluZ0FuaW1zW2ldLmluY2lkZW50O1xuICAgICAgICAgICAgICAgIHZhciBzdGFydE1pbGxpc2Vjb25kID0gcGFydGljaXBhdGluZ0FuaW1zW2ldLm1pbGxpc2Vjb25kO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBoYXMgbm8gc3RhcnQgdmFsdWVzIGdvIGFoZWFkIGFuZCBjYWxjdWxhdGVkIHRoZW0gbm93XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJ0aWNpcGF0aW5nQW5pbS5oYXNJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlKSAmJiBsYXN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnc2V0dGluZyBpbml0aWFsIHZhbHVlOiAnLCBsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUsICdjYWxjdWxhdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXBhcnRpY2lwYXRpbmdBbmltLmhhc0luaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUpICYmIGxhc3RWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3NldHRpbmcgaW5pdGlhbCB2YWx1ZTogJywgbGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlLCBsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlLCBsYXN0VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gZW5kcyBiZWZvcmUgdGhlIHRhcmdldCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3BhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uICsgc3RhcnRNaWxsaXNlY29uZCcsIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uICsgc3RhcnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQpO1xcXG5cbiAgICAgICAgICAgICAgICBpZiAocGFydGljaXBhdGluZ0FuaW0uZHVyYXRpb24gKyBzdGFydE1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2VuZHMgYmVmb3JlIHRhcmdldCcpXG4gICAgICAgICAgICAgICAgICAgIGxhc3RWYWx1ZSA9IHBhcnRpY2lwYXRpbmdBbmltLmF0dHJzLmFuaW1hdGVkQXR0cnNbbGFuZURhdGEuYXR0cmlidXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5vblByb2dyZXNzKDEsIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNsaXAgZm9yIHRoZSBzcGVjaWZpYyBlbGVtZW50IGFuZCB0aGUgc3BlY2lmaWMgYXR0cmlidXRlLiBTZXQgdGhlIEFuaW1hdGlvbiBhcyBwYXVzZWQgb3IgcGxheWluZyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBzdG9yZSB0aGlzIGluZm8gc29tZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlQ29tcGxldGUgPSAobWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKSAvIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5vblByb2dyZXNzKHBlcmNlbnRhZ2VDb21wbGV0ZSwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTbGlwcyB0byBqdXN0IG9uZSBsYW5lIGJhY2t3YXJkc1xuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBsYW5lIC0gdGhlIGxhbmUgdG8gc2xpcCBpbnRvXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBsYW5lRGF0YSAtIGFuIG9iamVjdCB3aXRoIGtleXM6IGF0dHJpYnV0ZSAmIG1jaWRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGN1cnJlbnRNaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0aGUgc2xpcCBzdGFydHMgZnJvbVxuICAgICAgICAgKiBAcGFyYW1hIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIHRhcmdldCBtaWxsaXNlY29uZCBvZiB0aGUgc2xpcFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xpcFRvTGFuZUJhY2t3YXJkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwVG9MYW5lQmFja3dhcmRzKGxhbmUsIGxhbmVEYXRhLCBjdXJyZW50TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICAvLyB3ZSB0YWtlIGFsbCBBbmltYXRpb25zIHRoYXQgYXJlIGVpdGhlciBjdXJyZW50bHkgcnVubmluZyBvclxuICAgICAgICAgICAgLy8gdGhleSBlbmQgYWZ0ZXIgdGhlIGRlc3RpbmF0aW9uIHBvaW50XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCc8LS0tLS0tJyk7XG4gICAgICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW1zID0gX2ZpbHRlcihsYW5lLCBmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZUl0ZW1FbmQgPSBsYW5lSXRlbS5pbmNpZGVudC5kdXJhdGlvbiArIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbUVuZCA8PSBtaWxsaXNlY29uZCAmJiBsYW5lSXRlbUVuZCA+PSBjdXJyZW50TWlsbGlzZWNvbmQgfHwgLy8gdGhleSBlbmQgaW4gdGhlIGhvdCBhcmVhXG4gICAgICAgICAgICAgICAgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPj0gY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kIHx8IC8vIHRoZXkgc3RhcnQgaW4gdGhlIGhvdCBhcmVhXG4gICAgICAgICAgICAgICAgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPCBjdXJyZW50TWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW1FbmQgPiBtaWxsaXNlY29uZDsgLy8gdGhleSBvdmVybGFwIHRoZSBob3QgYXJlYVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChwYXJ0aWNpcGF0aW5nQW5pbXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW1zID0gX3NvcnRCeShwYXJ0aWNpcGF0aW5nQW5pbXMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XSk7XG5cbiAgICAgICAgICAgIHZhciBsYXN0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0aWNpcGF0aW5nQW5pbSA9IHBhcnRpY2lwYXRpbmdBbmltc1tpXS5pbmNpZGVudDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRNaWxsaXNlY29uZCA9IHBhcnRpY2lwYXRpbmdBbmltc1tpXS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRNaWxsaXNlY29uZCA+PSBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5vblByb2dyZXNzKDAsIDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlQ29tcGxldGUgPSAobWlsbGlzZWNvbmQgLSBzdGFydE1pbGxpc2Vjb25kKSAvIHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltLm9uUHJvZ3Jlc3MocGVyY2VudGFnZUNvbXBsZXRlLCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBAcGFyYW0ge2ludH0gZnJvbSAtIHRoZSBtaWxsaXNlY29uZCB0byBzdGFydCBmcm9tXG4gICAgICAgICBAcGFyYW0ge2ludH0gdG8gLSB0aGUgbWlsbGlzZWNvbmQgdG8gZ28gdG9cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vdmVUbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogaXRlcmF0ZSB0aHJvdWdoIGFsbCBsYW5lc1xuICAgICAgICAgICAgZm9yICh2YXIgbGFuZWlkIGluIHRoaXMubGFuZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHRoaXMubGFuZXNbbGFuZWlkXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZURhdGEgPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkobGFuZWlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2cobGFuZWlkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlwSW50b0xhbmVGb3J3YXJkcyhsYW5lLCBsYW5lRGF0YSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbSA+PSB0bykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsaXBUb0xhbmVCYWNrd2FyZHMobGFuZSwgbGFuZURhdGEsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xhbmVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5MYW5lc0hhbmRsZXIubGFuZXM7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAndHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiYXR0cmlidXRlc1wiO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEF0dHJpYnV0ZUNoYW5uZWw7XG59KENoYW5uZWwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZUNoYW5uZWw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _cloneDeep = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.clonedeep/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _findIndex = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.findindex/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\");\nvar _find = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.find/index */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js\");\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar LanesHandler = function () {\n    function LanesHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, LanesHandler);\n\n        /*\n         * Keeps the lanes of the Channel in the form:\n         * {\n         *  <motorcortex-id>_<attribute>: [\n         *      {\n         *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n         *          incident: Animation (the animation object that holds the affecting animation\n         *      }\n         *  ]\n         * }\n         /** @type {{}}\n         */\n        this.lanes = {};\n        if (props.lanes) {\n            this.lanes = props.lanes;\n        }\n\n        this.comboAttributes = {};\n        if (props.comboAttributes != null) {\n            this.comboAttributes = props.comboAttributes;\n        }\n\n        /*\n        Keeps an indexing of the lanes each Animation belongs to. The form is the following:\n        belongingLaneKeysByAnimationId: {\n            <animation_id>: [laneKey1, laneKey2, ...],\n            <animation_id>: [laneKey2, laneKey3, ...],\n            ...\n        }\n         */\n        this.belongingLaneKeysByAnimationId = {};\n        if (props.belongingLaneKeysByAnimationId) {\n            this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;\n        }\n    }\n\n    /**\n     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.\n     * No checks are performed. \n     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to\n     * run.\n     * @param {float} durationFration: the fraction between the new duration and the current\n    */\n\n\n    _createClass(LanesHandler, [{\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            for (var key in this.lanes) {\n                var theLane = this.lanes[key];\n                for (var i = 0; i < theLane.length; i++) {\n                    theLane[i].millisecond = theLane[i].millisecond * durationFraction;\n                }\n            }\n        }\n\n        /**\n         * it creates a new LanesHandler that acts as a sanbox for testing changes\n        */\n\n    }, {\n        key: 'createTestLanesSanbox',\n        value: function createTestLanesSanbox() {\n            var lanesToPass = {};\n            for (var key in this.lanes) {\n                lanesToPass[key] = [];\n                for (var i = 0; i < this.lanes[key].length; i++) {\n                    lanesToPass[key].push({\n                        id: this.lanes[key][i].id,\n                        incident: this.lanes[key][i].incident,\n                        millisecond: this.lanes[key][i].millisecond * 1\n                    });\n                }\n            }\n            var props = {\n                lanes: lanesToPass,\n                belongingLaneKeysByAnimationId: _cloneDeep(JSON.parse(JSON.stringify(this.belongingLaneKeysByAnimationId)))\n            };\n\n            if (this.comboAttributes) {\n                props.comboAttributes = this.comboAttributes;\n            }\n\n            return new LanesHandler(props);\n        }\n    }, {\n        key: 'getLanesCopy',\n        value: function getLanesCopy(lane) {\n            var laneToReturn = [];\n            for (var i = 0; i < lane.length; i++) {\n                laneToReturn.push({\n                    id: lane[i].id,\n                    incident: lane[i].incident,\n                    millisecond: lane[i].millisecond * 1\n                });\n            }\n            return laneToReturn;\n        }\n    }, {\n        key: 'getLaneElementsClone',\n        value: function getLaneElementsClone(laneElement) {\n            // return _cloneDeep(laneElement);\n            return {\n                id: laneElement.id,\n                millisecond: laneElement.millisecond * 1,\n                incident: {\n                    duration: laneElement.incident.duration * 1,\n                    id: laneElement.incident.id\n                }\n                // return JSON.parse(JSON.stringify(laneElement));\n            };\n        }\n    }, {\n        key: 'applySandboxChanges',\n        value: function applySandboxChanges(SanboxObject) {\n            this.lanes = SanboxObject.lanes;\n            this.belongingLaneKeysByAnimationId = SanboxObject.belongingLaneKeysByAnimationId;\n        }\n    }, {\n        key: 'getLane',\n        value: function getLane(mcid, attr) {\n            return this.lanes[helper.getLaneKey(mcid, attr)];\n        }\n\n        /**\n         * Checks whether the incident has animatedAttrs or not. \n        **/\n\n    }, {\n        key: '_incidentHasAnimatedAttrs',\n        value: function _incidentHasAnimatedAttrs(incident) {\n            if (incident.attrs.hasOwnProperty('animatedAttrs')) {\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * return true if lane exists or false otherwise\n         * @param {String} mcid\n         * @param {String} attr\n         * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false\n        */\n\n    }, {\n        key: 'laneExists',\n        value: function laneExists(mcid, attr) {\n            var ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var laneKey = helper.getLaneKey(mcid, attr);\n            if (!this.lanes.hasOwnProperty(laneKey)) {\n                if (ifNotCreateIt) {\n                    this.lanes[laneKey] = [];\n                }\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }, {\n        key: 'animationIDExists',\n        value: function animationIDExists(mcid, attr, animationID) {\n            if (this.belongingLaneKeysByAnimationId.hasOwnProperty(animationID)) {\n                if (this.belongingLaneKeysByAnimationId[animationID].indexOf(helper.getLaneKey(mcid, attr)) >= 0) {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * @param {Object} newAnim - an object of the form of a lane item (with keys \"millisecond\" and \"incident\"\n         * @param {string} mcid\n         * @param {String} attr\n         * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This\n         *  parameter has been added for the edit checks where an animation might overlap another animation that participates on\n         *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all\n         *  of them together guarantees that there is going to be no conflict between them even after the edit\n         * @param {int} testDuration - optional. This parameter is used when the channel needs to check overlaps after duration\n         *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)\n         * @retuns {array} - a list of all overlapping animations of the lane\n        */\n\n    }, {\n        key: 'getOverlappingAnims',\n        value: function getOverlappingAnims(newAnim, mcid, attr) {\n            var excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n            var testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            var overlappingAnims = _filter(this.lanes[helper.getLaneKey(mcid, attr)], function (existingAnim) {\n                var durationToUseOnChecks = newAnim.incident.duration;\n                if (testDuration != null) {\n                    durationToUseOnChecks = testDuration;\n                }\n\n                return existingAnim.incident.id != newAnim.incident.id && excludeIdsFromCheck.indexOf(existingAnim.incident.id) < 0 && (\n                // existing anim starts within the new anim's extend\n                existingAnim.millisecond >= newAnim.millisecond && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond ||\n                // or ends within the new anim's extend\n                existingAnim.millisecond + existingAnim.incident.duration > newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration <= durationToUseOnChecks + newAnim.millisecond\n                // or it starts before and ends after the new anim's extend\n                || existingAnim.millisecond < newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration > durationToUseOnChecks + newAnim.millisecond);\n            });\n\n            return overlappingAnims;\n        }\n\n        /**\n         * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence\n         * No checks are performed, just execution.\n         * @param {String} mcid\n         * @param {String} attr\n         * @param {int} millisecond\n         * @param {Object} incident\n        */\n\n    }, {\n        key: 'addElementToLane',\n        value: function addElementToLane(mcid, attr, millisecond, incident) {\n\n            var laneKey = helper.getLaneKey(mcid, attr);\n            var theLane = this.lanes[laneKey];\n\n            var laneElement = {\n                millisecond: millisecond,\n                incident: incident,\n                id: incident.id\n            };\n\n            this.laneExists(mcid, attr, true);\n\n            theLane.push(laneElement);\n            theLane = _sortBy(theLane, ['millisecond']);\n\n            // indexing stuff\n            if (!this.belongingLaneKeysByAnimationId.hasOwnProperty(incident.id)) {\n                this.belongingLaneKeysByAnimationId[incident.id] = [];\n            }\n            this.belongingLaneKeysByAnimationId[incident.id].push(laneKey);\n            // indexing\n            var newAnimsIndex = _findIndex(theLane, function (item) {\n                return item.incident.id === incident.id;\n            });\n\n            /* if the incident has no animated attributes we don't need to work on start and final values */\n            if (!this._incidentHasAnimatedAttrs(incident)) {\n                return { onSuccessAction: function onSuccessAction() {} };\n            }\n\n            // helper.log(newAnimsIndex);\n            // step 1: set the intial values of the new Animation\n            if (newAnimsIndex === 0) {\n                // if the newly entered animation is the first of the lane\n                if (theLane.length > 1) {\n                    // and it has other animations too\n                    if (theLane[1].incident.hasInitialValue(attr)) {\n                        // if the initial value of the following animation\n                        // which used to be first is already calculated \"steal\" it\n                        incident.setInitialValue(attr, theLane[1].incident.getInitialValue(attr));\n                    }\n                } else {\n                    // else take it directly from the dom\n                    incident.setInitialValue(attr, incident.getScratchValue(mcid, attr));\n                }\n            } else {\n                incident.setInitialValue(attr, theLane[newAnimsIndex - 1].incident.attrs.animatedAttrs[attr]);\n            }\n\n            /* if the attribute of the lane is a compo attribute */\n            if (this.comboAttributes.hasOwnProperty(attr)) {\n                var incidentInitialValues = incident.getInitialValue(attr);\n                for (var key in incidentInitialValues) {\n                    if (!incident.attrs.animatedAttrs[attr].hasOwnProperty(key)) {\n                        incident.attrs.animatedAttrs[attr][key] = incidentInitialValues[key];\n                    }\n                }\n            }\n\n            var onSuccessAction = function onSuccessAction() {};\n            // step 2: set the inital values of the following Animation (if any)\n            if (newAnimsIndex + 1 < theLane.length) {\n                onSuccessAction = function onSuccessAction() {\n                    theLane[newAnimsIndex + 1].incident.setInitialValue(attr, incident.attrs.animatedAttrs[attr]);\n                };\n            }\n\n            return onSuccessAction;\n        }\n\n        /**\n         * it justs updates the lane\n         * No checks are performed, just execution\n         * @param {array} affectedAnimationsIds\n         * @param {String} attr\n         * @param {int} millisecondDelta\n        */\n\n    }, {\n        key: 'updateLane',\n        value: function updateLane(affectedAnimationsIds, millisecondsDelta) {\n            var _this = this;\n\n            // first we group the affected animations by lanes\n            var affectedLanes = {};\n            var that = this;\n            for (var i = 0; i < affectedAnimationsIds.length; i++) {\n                var belongingLanes = this.belongingLaneKeysByAnimationId[affectedAnimationsIds[i]];\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var laneKey = belongingLanes[j];\n                    if (!affectedLanes.hasOwnProperty(laneKey)) {\n                        affectedLanes[laneKey] = {\n                            animations: [],\n                            lane: that.lanes[laneKey],\n                            laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])\n                        };\n                    }\n                    affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);\n                }\n            }\n\n            // for each of the affected lanes\n            for (var _laneKey in affectedLanes) {\n                var affectedLane = affectedLanes[_laneKey];\n                var lane = affectedLane.lane;\n                var laneData = affectedLane.laneData;\n                var laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);\n\n                // edit lane items millisecond\n                for (var k = 0; k < lane.length; k++) {\n                    if (affectedLane.animations.indexOf(lane[k].incident.id) >= 0) {\n                        lane[k].millisecond += millisecondsDelta;\n                    }\n                } // end for searching for the animations within the lane\n\n                var sortedLane = _sortBy(lane, ['millisecond']);\n                this.lanes[_laneKey] = sortedLane;\n                lane = sortedLane;\n                // console.log(this);\n\n                var _loop = function _loop(_i) {\n                    var animationToCheck = affectedLane.animations[_i];\n                    var animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function (item) {\n                        return item.incident.id === animationToCheck;\n                    });\n                    var animationIndexAfterEdit = _findIndex(lane, function (item) {\n                        return item.incident.id === animationToCheck;\n                    });\n                    var animation = lane[animationIndexAfterEdit].incident;\n\n                    /**\n                     * if the first animation doesn't have animated attributes that means no one on this channel has. Brake\n                     * and exit the loop that handles start and end values\n                    */\n                    if (!_this._incidentHasAnimatedAttrs(animation)) {\n                        return 'break';\n                    }\n\n                    if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {\n                        if (animationIndexBeforeEdit + 1 < lane.length) {\n                            // if the animation was not the last animation on the lane before the edit\n                            // we should take care of the initial values of the animation's previous successor\n                            if (animationIndexBeforeEdit === 0) {\n                                // if the edited animation was the first one before the edit\n                                // if it has initial values, pass them to its previous successor as its new initial values\n                                if (animation.hasInitialValue(laneData.attribute) !== false) {\n                                    // get the initial value of the edited animation and set it as initial value of the new 0 index\n                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, animation.getInitialValue(laneData.mcid, laneData.attribute));\n                                } else {\n                                    // otherwise calculate the initial value on the fly, out of the dom and set it to the new 0\n                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[1].incident.getScratchValue(laneData.mcid, laneData.attribute));\n                                }\n                            } else {\n                                // else if the edited animation was not the first one before the edit\n                                // meaning its previous successor is not the first one on the lane after the edit\n                                // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value\n                                laneBeforeEdit[animationIndexBeforeEdit + 1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[animationIndexBeforeEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);\n                            }\n                        }\n\n                        // for the edited animation itself now:\n                        if (animationIndexAfterEdit === 0) {\n                            // is it the first one (after edit)?\n                            // does the previously zero index animation has initial value?\n                            if (laneBeforeEdit[0].incident.hasInitialValue(laneData.attribute)) {\n                                // get the initial values of the previously 0 indexed animation of the lane\n                                animation.setInitialValue(laneData.attribute, laneBeforeEdit[0].incident.getInitialValue(laneData.mcid, laneData.attribute));\n                            } else {\n                                // otherwise calculate the initial value on the fly, our of the dom\n                                animation.setInitialValue(laneData.mcid, laneData.attribute, animation.getScratchValue(laneData.mcid, laneData.attribute));\n                            }\n                        } else {\n                            // else if it is not the first one after edit\n                            // just grab the target value of the previous animation on the updated lane and set it as its initial value\n                            animation.setInitialValue(laneData.attribute, lane[animationIndexAfterEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);\n                        }\n\n                        // for its new next animation (if it has one)\n                        if (animationIndexAfterEdit + 1 < lane.length) {\n                            // set its initial value to equal the target value of the edited animation\n                            lane[animationIndexAfterEdit + 1].incident.setInitialValue(laneData.attribute, animation.attrs.animatedAttrs[laneData.attribute]);\n                        }\n                    }\n                };\n\n                for (var _i = 0; _i < affectedLane.animations.length; _i++) {\n                    var _ret = _loop(_i);\n\n                    if (_ret === 'break') break;\n                }\n            } // end for each of the belonging lanes of the animation\n        }\n\n        /**\n         * removes the list of animations as provided\n         * @param {array} removedAnimations - an array with the removed animations' ids\n        */\n\n    }, {\n        key: 'deleteAnimations',\n        value: function deleteAnimations(removedAnimations, currentMillisecond) {\n            var affectedLanes = {};\n\n            for (var i = 0; i < removedAnimations.length; i++) {\n                var id = removedAnimations[i];\n                // for each lane the affected Animation appears in\n                var belongingLanes = this.belongingLaneKeysByAnimationId[id];\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var lane = this.lanes[belongingLanes[j]];\n\n                    var _animationIndexBeforeEdit = -1;\n                    for (var k = 0; k < lane.length; k++) {\n                        if (lane[k].incident.id === id) {\n                            _animationIndexBeforeEdit = k;\n                            break;\n                        }\n                    }\n\n                    // helper.log(animationIndexBeforeEdit);\n                    var animationToDelete = Object.assign({}, lane[_animationIndexBeforeEdit]);\n                    var animationObjectToDelete = animationToDelete.incident;\n                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n                    // gets the lane without the removed animation\n                    var newLane = [];\n                    for (var _k = 0; _k < lane.length; _k++) {\n                        if (lane[_k].incident.id != id) {\n                            newLane.push(lane[_k]);\n                        }\n                    }\n                    this.lanes[belongingLanes[j]] = newLane;\n                    lane = this.lanes[belongingLanes[j]];\n\n                    if (lane.length === 0) {\n                        delete this.lanes[belongingLanes[j]];\n                        if (affectedLanes.hasOwnProperty(belongingLanes[j])) {\n                            delete affectedLanes[belongingLanes[j]];\n                        }\n                    } else {\n                        if (this._incidentHasAnimatedAttrs(animationToDelete.incident)) {\n                            affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n                            if (_animationIndexBeforeEdit < lane.length && animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute) !== false) {\n                                lane[_animationIndexBeforeEdit].incident.setInitialValue(laneData.attribute, animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute));\n                            }\n                        }\n                    }\n                }\n                delete this.belongingLaneKeysByAnimationId[removedAnimations[i]];\n            }\n            return affectedLanes;\n        }\n\n        /**\n         * This method handles edits on the final value of a specific attribute of a specific animation object\n         * @param {string} animationId - the id of the Animation object that has been edited\n         * @param {string} attr - the name of the attribute that has been edited\n         * @param {string} value - the new value of the edited attribute\n        */\n\n    }, {\n        key: 'updateAttributeOnLanes',\n        value: function updateAttributeOnLanes(animationId, attr, value) {\n            var belongingLanes = this.belongingLaneKeysByAnimationId[animationId];\n            var affectedLanes = [];\n            for (var i = 0; i < belongingLanes.length; i++) {\n                var lane = this.lanes[belongingLanes[i]];\n                var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[i]);\n\n                // get the index of the animation on the lane\n                var animationIndex = -1;\n                for (var k = 0; k < lane.length; k++) {\n                    if (lane[k].incident.id === animationId) {\n                        animationIndex = k;\n                        break;\n                    }\n                }\n\n                // if the animation is not the last one on the lane\n                if (lane.length - 1 != animationIndex) {\n                    lane[animationIndex + 1].incident.setInitialValue(laneData.mcid, laneData.attribute, value);\n                }\n\n                affectedLanes.push(laneData);\n            }\n\n            return affectedLanes;\n        }\n    }]);\n\n    return LanesHandler;\n}();\n\nmodule.exports = LanesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvX0F0dHJpYnV0ZS9MYW5lc0hhbmRsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvX0F0dHJpYnV0ZS9MYW5lc0hhbmRsZXIuanM/OTM1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBfY2xvbmVEZWVwID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5jbG9uZWRlZXAvaW5kZXgnKTtcbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maWx0ZXIvaW5kZXgnKTtcbnZhciBfc29ydEJ5ID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5zb3J0YnkvaW5kZXgnKTtcbnZhciBfZmluZEluZGV4ID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maW5kaW5kZXgvaW5kZXgnKTtcbnZhciBfZmluZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZC9pbmRleCcpO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBMYW5lc0hhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGFuZXNIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYW5lc0hhbmRsZXIpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEtlZXBzIHRoZSBsYW5lcyBvZiB0aGUgQ2hhbm5lbCBpbiB0aGUgZm9ybTpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgPG1vdG9yY29ydGV4LWlkPl88YXR0cmlidXRlPjogW1xuICAgICAgICAgKiAgICAgIHtcbiAgICAgICAgICogICAgICAgICAgbWlsbGlzZWNvbmQ6IHRoZSBtaWxsaXNlY29uZCBvZiB0aGUgY2hhbm5lbCB0aGlzIEFuaW1hdGlvbiAodGhhdCBhZmZlY3RzIHRoZSBzZWxlY3Rvci9hdHRyaWJ1dGUgcGFpcikgcnVuc1xuICAgICAgICAgKiAgICAgICAgICBpbmNpZGVudDogQW5pbWF0aW9uICh0aGUgYW5pbWF0aW9uIG9iamVjdCB0aGF0IGhvbGRzIHRoZSBhZmZlY3RpbmcgYW5pbWF0aW9uXG4gICAgICAgICAqICAgICAgfVxuICAgICAgICAgKiAgXVxuICAgICAgICAgKiB9XG4gICAgICAgICAvKiogQHR5cGUge3t9fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYW5lcyA9IHt9O1xuICAgICAgICBpZiAocHJvcHMubGFuZXMpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZXMgPSBwcm9wcy5sYW5lcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0ge307XG4gICAgICAgIGlmIChwcm9wcy5jb21ib0F0dHJpYnV0ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21ib0F0dHJpYnV0ZXMgPSBwcm9wcy5jb21ib0F0dHJpYnV0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICBLZWVwcyBhbiBpbmRleGluZyBvZiB0aGUgbGFuZXMgZWFjaCBBbmltYXRpb24gYmVsb25ncyB0by4gVGhlIGZvcm0gaXMgdGhlIGZvbGxvd2luZzpcbiAgICAgICAgYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkOiB7XG4gICAgICAgICAgICA8YW5pbWF0aW9uX2lkPjogW2xhbmVLZXkxLCBsYW5lS2V5MiwgLi4uXSxcbiAgICAgICAgICAgIDxhbmltYXRpb25faWQ+OiBbbGFuZUtleTIsIGxhbmVLZXkzLCAuLi5dLFxuICAgICAgICAgICAgLi4uXG4gICAgICAgIH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkID0ge307XG4gICAgICAgIGlmIChwcm9wcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQpIHtcbiAgICAgICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkID0gcHJvcHMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmVzaXplcyBhbGwgdGhlIGxhbmVzIG9mIHRoZSBMYW5lcyBIYW5kbGVyIGJ5IHRoZSBkdXJhdGlvbkZyYWN0aW9uIHByb3ZpZGVkLlxuICAgICAqIE5vIGNoZWNrcyBhcmUgcGVyZm9ybWVkLiBcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBiZWVuIGludm9rZWQgaW4gY2FzZXMgd2hlcmUgYSBmdWxsIENsaXAgZ2V0cyByZXNpemVkLCBzbyBubyBjb25mbGljdCBjaGVja3MgbmVlZCB0b1xuICAgICAqIHJ1bi5cbiAgICAgKiBAcGFyYW0ge2Zsb2F0fSBkdXJhdGlvbkZyYXRpb246IHRoZSBmcmFjdGlvbiBiZXR3ZWVuIHRoZSBuZXcgZHVyYXRpb24gYW5kIHRoZSBjdXJyZW50XG4gICAgKi9cblxuXG4gICAgX2NyZWF0ZUNsYXNzKExhbmVzSGFuZGxlciwgW3tcbiAgICAgICAga2V5OiAnX3Jlc2l6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRoZUxhbmUgPSB0aGlzLmxhbmVzW2tleV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGVMYW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUxhbmVbaV0ubWlsbGlzZWNvbmQgPSB0aGVMYW5lW2ldLm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXQgY3JlYXRlcyBhIG5ldyBMYW5lc0hhbmRsZXIgdGhhdCBhY3RzIGFzIGEgc2FuYm94IGZvciB0ZXN0aW5nIGNoYW5nZXNcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY3JlYXRlVGVzdExhbmVzU2FuYm94JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRlc3RMYW5lc1NhbmJveCgpIHtcbiAgICAgICAgICAgIHZhciBsYW5lc1RvUGFzcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMubGFuZXMpIHtcbiAgICAgICAgICAgICAgICBsYW5lc1RvUGFzc1trZXldID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxhbmVzW2tleV0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZXNUb1Bhc3Nba2V5XS5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmxhbmVzW2tleV1baV0uaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudDogdGhpcy5sYW5lc1trZXldW2ldLmluY2lkZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IHRoaXMubGFuZXNba2V5XVtpXS5taWxsaXNlY29uZCAqIDFcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgICAgIGxhbmVzOiBsYW5lc1RvUGFzcyxcbiAgICAgICAgICAgICAgICBiZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQ6IF9jbG9uZURlZXAoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCkpKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29tYm9BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuY29tYm9BdHRyaWJ1dGVzID0gdGhpcy5jb21ib0F0dHJpYnV0ZXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgTGFuZXNIYW5kbGVyKHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TGFuZXNDb3B5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhbmVzQ29weShsYW5lKSB7XG4gICAgICAgICAgICB2YXIgbGFuZVRvUmV0dXJuID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYW5lVG9SZXR1cm4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBsYW5lW2ldLmlkLFxuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudDogbGFuZVtpXS5pbmNpZGVudCxcbiAgICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IGxhbmVbaV0ubWlsbGlzZWNvbmQgKiAxXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbGFuZVRvUmV0dXJuO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRMYW5lRWxlbWVudHNDbG9uZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lRWxlbWVudHNDbG9uZShsYW5lRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gcmV0dXJuIF9jbG9uZURlZXAobGFuZUVsZW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpZDogbGFuZUVsZW1lbnQuaWQsXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IGxhbmVFbGVtZW50Lm1pbGxpc2Vjb25kICogMSxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDoge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogbGFuZUVsZW1lbnQuaW5jaWRlbnQuZHVyYXRpb24gKiAxLFxuICAgICAgICAgICAgICAgICAgICBpZDogbGFuZUVsZW1lbnQuaW5jaWRlbnQuaWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobGFuZUVsZW1lbnQpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FwcGx5U2FuZGJveENoYW5nZXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXBwbHlTYW5kYm94Q2hhbmdlcyhTYW5ib3hPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZXMgPSBTYW5ib3hPYmplY3QubGFuZXM7XG4gICAgICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCA9IFNhbmJveE9iamVjdC5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldExhbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZShtY2lkLCBhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYW5lc1toZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKV07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGluY2lkZW50IGhhcyBhbmltYXRlZEF0dHJzIG9yIG5vdC4gXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfaW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbmNpZGVudEhhc0FuaW1hdGVkQXR0cnMoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbmNpZGVudC5hdHRycy5oYXNPd25Qcm9wZXJ0eSgnYW5pbWF0ZWRBdHRycycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogcmV0dXJuIHRydWUgaWYgbGFuZSBleGlzdHMgb3IgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtY2lkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaWZOb3RDcmVhdGVJdCAtIGlmIGlzIHNldCB0byB0cnVlIGFuZCB0aGUgbGFuZSBkb2Vzbid0IGV4aXN0IGl0IGNyZWF0ZXMgaXQgYnV0IHN0aWxsIHJldHVybmluZyBmYWxzZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYW5lRXhpc3RzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhbmVFeGlzdHMobWNpZCwgYXR0cikge1xuICAgICAgICAgICAgdmFyIGlmTm90Q3JlYXRlSXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgbGFuZUtleSA9IGhlbHBlci5nZXRMYW5lS2V5KG1jaWQsIGF0dHIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxhbmVzLmhhc093blByb3BlcnR5KGxhbmVLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlmTm90Q3JlYXRlSXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYW5lc1tsYW5lS2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmltYXRpb25JREV4aXN0cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRpb25JREV4aXN0cyhtY2lkLCBhdHRyLCBhbmltYXRpb25JRCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLmhhc093blByb3BlcnR5KGFuaW1hdGlvbklEKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZFthbmltYXRpb25JRF0uaW5kZXhPZihoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3QW5pbSAtIGFuIG9iamVjdCBvZiB0aGUgZm9ybSBvZiBhIGxhbmUgaXRlbSAod2l0aCBrZXlzIFwibWlsbGlzZWNvbmRcIiBhbmQgXCJpbmNpZGVudFwiXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtY2lkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGV4Y2x1ZGVJZHNGcm9tQ2hlY2sgLSBvcHRpb25hbC4gSWYgZXhpc3RzIGl0IGV4Y2x1ZGVzIGFsbCB0aGUgaWRzIG9mIHRoaXMgYXJyYXkgZnJvbSBjaGVjay4gVGhpc1xuICAgICAgICAgKiAgcGFyYW1ldGVyIGhhcyBiZWVuIGFkZGVkIGZvciB0aGUgZWRpdCBjaGVja3Mgd2hlcmUgYW4gYW5pbWF0aW9uIG1pZ2h0IG92ZXJsYXAgYW5vdGhlciBhbmltYXRpb24gdGhhdCBwYXJ0aWNpcGF0ZXMgb25cbiAgICAgICAgICogIHRoZSBtb3ZlLCBzb21ldGhpbmcgdGhhdCBzaG91bGQgbm90IGhhcHBlbiBhcyB0aGUgZWRpdGVkIGFuaW1hdGlvbnMgcHJlLWV4aXN0ZWQgd2l0aG91dCBjb25mbGljdHMgYW5kIHRoZSBtb3ZlIG9mIGFsbFxuICAgICAgICAgKiAgb2YgdGhlbSB0b2dldGhlciBndWFyYW50ZWVzIHRoYXQgdGhlcmUgaXMgZ29pbmcgdG8gYmUgbm8gY29uZmxpY3QgYmV0d2VlbiB0aGVtIGV2ZW4gYWZ0ZXIgdGhlIGVkaXRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHRlc3REdXJhdGlvbiAtIG9wdGlvbmFsLiBUaGlzIHBhcmFtZXRlciBpcyB1c2VkIHdoZW4gdGhlIGNoYW5uZWwgbmVlZHMgdG8gY2hlY2sgb3ZlcmxhcHMgYWZ0ZXIgZHVyYXRpb25cbiAgICAgICAgICogIGVkaXRzLCBzbyB0aGUgdGVzdER1cmF0aW9uIGlzIHBhc3NlZCAod2UgZG9uJ3Qgd2FudCB0byBwb2x1dGUgdGhlIG9yaWdpbmFsIGFuaW1hdGlvbiBvYmplY3QgYXMgaXQgcmVmZXJzIHRvIHRoZSByZWFsIG9uZSlcbiAgICAgICAgICogQHJldHVucyB7YXJyYXl9IC0gYSBsaXN0IG9mIGFsbCBvdmVybGFwcGluZyBhbmltYXRpb25zIG9mIHRoZSBsYW5lXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldE92ZXJsYXBwaW5nQW5pbXMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3ZlcmxhcHBpbmdBbmltcyhuZXdBbmltLCBtY2lkLCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgZXhjbHVkZUlkc0Zyb21DaGVjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogW107XG4gICAgICAgICAgICB2YXIgdGVzdER1cmF0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBudWxsO1xuXG4gICAgICAgICAgICB2YXIgb3ZlcmxhcHBpbmdBbmltcyA9IF9maWx0ZXIodGhpcy5sYW5lc1toZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKV0sIGZ1bmN0aW9uIChleGlzdGluZ0FuaW0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZHVyYXRpb25Ub1VzZU9uQ2hlY2tzID0gbmV3QW5pbS5pbmNpZGVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodGVzdER1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25Ub1VzZU9uQ2hlY2tzID0gdGVzdER1cmF0aW9uO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0FuaW0uaW5jaWRlbnQuaWQgIT0gbmV3QW5pbS5pbmNpZGVudC5pZCAmJiBleGNsdWRlSWRzRnJvbUNoZWNrLmluZGV4T2YoZXhpc3RpbmdBbmltLmluY2lkZW50LmlkKSA8IDAgJiYgKFxuICAgICAgICAgICAgICAgIC8vIGV4aXN0aW5nIGFuaW0gc3RhcnRzIHdpdGhpbiB0aGUgbmV3IGFuaW0ncyBleHRlbmRcbiAgICAgICAgICAgICAgICBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgPj0gbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgPCBkdXJhdGlvblRvVXNlT25DaGVja3MgKyBuZXdBbmltLm1pbGxpc2Vjb25kIHx8XG4gICAgICAgICAgICAgICAgLy8gb3IgZW5kcyB3aXRoaW4gdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kICsgZXhpc3RpbmdBbmltLmluY2lkZW50LmR1cmF0aW9uID4gbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgKyBleGlzdGluZ0FuaW0uaW5jaWRlbnQuZHVyYXRpb24gPD0gZHVyYXRpb25Ub1VzZU9uQ2hlY2tzICsgbmV3QW5pbS5taWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIG9yIGl0IHN0YXJ0cyBiZWZvcmUgYW5kIGVuZHMgYWZ0ZXIgdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgICAgICAgICAgfHwgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kIDwgbmV3QW5pbS5taWxsaXNlY29uZCAmJiBleGlzdGluZ0FuaW0ubWlsbGlzZWNvbmQgKyBleGlzdGluZ0FuaW0uaW5jaWRlbnQuZHVyYXRpb24gPiBkdXJhdGlvblRvVXNlT25DaGVja3MgKyBuZXdBbmltLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gb3ZlcmxhcHBpbmdBbmltcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBqdXN0cyBhZGRzIHRoZSBsYW5lIGl0ZW0gdG8gdGhlIGxhbmUgYW5kIGFkanVzdHMgdGhlIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBBbmltcyBpbiBzZXF1ZW5jZVxuICAgICAgICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZCwganVzdCBleGVjdXRpb24uXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtY2lkXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkRWxlbWVudFRvTGFuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFbGVtZW50VG9MYW5lKG1jaWQsIGF0dHIsIG1pbGxpc2Vjb25kLCBpbmNpZGVudCkge1xuXG4gICAgICAgICAgICB2YXIgbGFuZUtleSA9IGhlbHBlci5nZXRMYW5lS2V5KG1jaWQsIGF0dHIpO1xuICAgICAgICAgICAgdmFyIHRoZUxhbmUgPSB0aGlzLmxhbmVzW2xhbmVLZXldO1xuXG4gICAgICAgICAgICB2YXIgbGFuZUVsZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQ6IG1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgICAgIGluY2lkZW50OiBpbmNpZGVudCxcbiAgICAgICAgICAgICAgICBpZDogaW5jaWRlbnQuaWRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMubGFuZUV4aXN0cyhtY2lkLCBhdHRyLCB0cnVlKTtcblxuICAgICAgICAgICAgdGhlTGFuZS5wdXNoKGxhbmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoZUxhbmUgPSBfc29ydEJ5KHRoZUxhbmUsIFsnbWlsbGlzZWNvbmQnXSk7XG5cbiAgICAgICAgICAgIC8vIGluZGV4aW5nIHN0dWZmXG4gICAgICAgICAgICBpZiAoIXRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkLmhhc093blByb3BlcnR5KGluY2lkZW50LmlkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkW2luY2lkZW50LmlkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWRbaW5jaWRlbnQuaWRdLnB1c2gobGFuZUtleSk7XG4gICAgICAgICAgICAvLyBpbmRleGluZ1xuICAgICAgICAgICAgdmFyIG5ld0FuaW1zSW5kZXggPSBfZmluZEluZGV4KHRoZUxhbmUsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5jaWRlbnQuaWQgPT09IGluY2lkZW50LmlkO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8qIGlmIHRoZSBpbmNpZGVudCBoYXMgbm8gYW5pbWF0ZWQgYXR0cmlidXRlcyB3ZSBkb24ndCBuZWVkIHRvIHdvcmsgb24gc3RhcnQgYW5kIGZpbmFsIHZhbHVlcyAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmNpZGVudEhhc0FuaW1hdGVkQXR0cnMoaW5jaWRlbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgb25TdWNjZXNzQWN0aW9uOiBmdW5jdGlvbiBvblN1Y2Nlc3NBY3Rpb24oKSB7fSB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKG5ld0FuaW1zSW5kZXgpO1xuICAgICAgICAgICAgLy8gc3RlcCAxOiBzZXQgdGhlIGludGlhbCB2YWx1ZXMgb2YgdGhlIG5ldyBBbmltYXRpb25cbiAgICAgICAgICAgIGlmIChuZXdBbmltc0luZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIG5ld2x5IGVudGVyZWQgYW5pbWF0aW9uIGlzIHRoZSBmaXJzdCBvZiB0aGUgbGFuZVxuICAgICAgICAgICAgICAgIGlmICh0aGVMYW5lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGl0IGhhcyBvdGhlciBhbmltYXRpb25zIHRvb1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhlTGFuZVsxXS5pbmNpZGVudC5oYXNJbml0aWFsVmFsdWUoYXR0cikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBmb2xsb3dpbmcgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGljaCB1c2VkIHRvIGJlIGZpcnN0IGlzIGFscmVhZHkgY2FsY3VsYXRlZCBcInN0ZWFsXCIgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCB0aGVMYW5lWzFdLmluY2lkZW50LmdldEluaXRpYWxWYWx1ZShhdHRyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIHRha2UgaXQgZGlyZWN0bHkgZnJvbSB0aGUgZG9tXG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCBpbmNpZGVudC5nZXRTY3JhdGNoVmFsdWUobWNpZCwgYXR0cikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGF0dHIsIHRoZUxhbmVbbmV3QW5pbXNJbmRleCAtIDFdLmluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cl0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKiBpZiB0aGUgYXR0cmlidXRlIG9mIHRoZSBsYW5lIGlzIGEgY29tcG8gYXR0cmlidXRlICovXG4gICAgICAgICAgICBpZiAodGhpcy5jb21ib0F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRJbml0aWFsVmFsdWVzID0gaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGF0dHIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudEluaXRpYWxWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJdLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cl1ba2V5XSA9IGluY2lkZW50SW5pdGlhbFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb25TdWNjZXNzQWN0aW9uID0gZnVuY3Rpb24gb25TdWNjZXNzQWN0aW9uKCkge307XG4gICAgICAgICAgICAvLyBzdGVwIDI6IHNldCB0aGUgaW5pdGFsIHZhbHVlcyBvZiB0aGUgZm9sbG93aW5nIEFuaW1hdGlvbiAoaWYgYW55KVxuICAgICAgICAgICAgaWYgKG5ld0FuaW1zSW5kZXggKyAxIDwgdGhlTGFuZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3NBY3Rpb24gPSBmdW5jdGlvbiBvblN1Y2Nlc3NBY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoZUxhbmVbbmV3QW5pbXNJbmRleCArIDFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCBpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJdKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb25TdWNjZXNzQWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGl0IGp1c3RzIHVwZGF0ZXMgdGhlIGxhbmVcbiAgICAgICAgICogTm8gY2hlY2tzIGFyZSBwZXJmb3JtZWQsIGp1c3QgZXhlY3V0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGFmZmVjdGVkQW5pbWF0aW9uc0lkc1xuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmREZWx0YVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1cGRhdGVMYW5lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUxhbmUoYWZmZWN0ZWRBbmltYXRpb25zSWRzLCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICAgICAgLy8gZmlyc3Qgd2UgZ3JvdXAgdGhlIGFmZmVjdGVkIGFuaW1hdGlvbnMgYnkgbGFuZXNcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmVzID0ge307XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFmZmVjdGVkQW5pbWF0aW9uc0lkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBiZWxvbmdpbmdMYW5lcyA9IHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkW2FmZmVjdGVkQW5pbWF0aW9uc0lkc1tpXV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZUtleSA9IGJlbG9uZ2luZ0xhbmVzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFmZmVjdGVkTGFuZXMuaGFzT3duUHJvcGVydHkobGFuZUtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXNbbGFuZUtleV0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZTogdGhhdC5sYW5lc1tsYW5lS2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5lRGF0YTogaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2pdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZExhbmVzW2xhbmVLZXldLmFuaW1hdGlvbnMucHVzaChhZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkIGxhbmVzXG4gICAgICAgICAgICBmb3IgKHZhciBfbGFuZUtleSBpbiBhZmZlY3RlZExhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbX2xhbmVLZXldO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gYWZmZWN0ZWRMYW5lLmxhbmU7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gYWZmZWN0ZWRMYW5lLmxhbmVEYXRhO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lQmVmb3JlRWRpdCA9IF9zb3J0QnkodGhpcy5nZXRMYW5lc0NvcHkobGFuZSksIFsnbWlsbGlzZWNvbmQnXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBlZGl0IGxhbmUgaXRlbXMgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFmZmVjdGVkTGFuZS5hbmltYXRpb25zLmluZGV4T2YobGFuZVtrXS5pbmNpZGVudC5pZCkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZVtrXS5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIGZvciBzZWFyY2hpbmcgZm9yIHRoZSBhbmltYXRpb25zIHdpdGhpbiB0aGUgbGFuZVxuXG4gICAgICAgICAgICAgICAgdmFyIHNvcnRlZExhbmUgPSBfc29ydEJ5KGxhbmUsIFsnbWlsbGlzZWNvbmQnXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5sYW5lc1tfbGFuZUtleV0gPSBzb3J0ZWRMYW5lO1xuICAgICAgICAgICAgICAgIGxhbmUgPSBzb3J0ZWRMYW5lO1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoX2kpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvblRvQ2hlY2sgPSBhZmZlY3RlZExhbmUuYW5pbWF0aW9uc1tfaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPSBfZmluZEluZGV4KGxhbmVCZWZvcmVFZGl0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5jaWRlbnQuaWQgPT09IGFuaW1hdGlvblRvQ2hlY2s7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgPSBfZmluZEluZGV4KGxhbmUsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS5pbmNpZGVudC5pZCA9PT0gYW5pbWF0aW9uVG9DaGVjaztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBsYW5lW2FuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0XS5pbmNpZGVudDtcblxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogaWYgdGhlIGZpcnN0IGFuaW1hdGlvbiBkb2Vzbid0IGhhdmUgYW5pbWF0ZWQgYXR0cmlidXRlcyB0aGF0IG1lYW5zIG5vIG9uZSBvbiB0aGlzIGNoYW5uZWwgaGFzLiBCcmFrZVxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgZXhpdCB0aGUgbG9vcCB0aGF0IGhhbmRsZXMgc3RhcnQgYW5kIGVuZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGFuaW1hdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnYnJlYWsnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCAhPT0gYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgfHwgYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ICsgMSA8IGxhbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiB3YXMgbm90IHRoZSBsYXN0IGFuaW1hdGlvbiBvbiB0aGUgbGFuZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgdGFrZSBjYXJlIG9mIHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgYW5pbWF0aW9uJ3MgcHJldmlvdXMgc3VjY2Vzc29yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWRpdGVkIGFuaW1hdGlvbiB3YXMgdGhlIGZpcnN0IG9uZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGluaXRpYWwgdmFsdWVzLCBwYXNzIHRoZW0gdG8gaXRzIHByZXZpb3VzIHN1Y2Nlc3NvciBhcyBpdHMgbmV3IGluaXRpYWwgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb24uaGFzSW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGVkaXRlZCBhbmltYXRpb24gYW5kIHNldCBpdCBhcyBpbml0aWFsIHZhbHVlIG9mIHRoZSBuZXcgMCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZUJlZm9yZUVkaXRbMV0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgYW5pbWF0aW9uLmdldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIGluaXRpYWwgdmFsdWUgb24gdGhlIGZseSwgb3V0IG9mIHRoZSBkb20gYW5kIHNldCBpdCB0byB0aGUgbmV3IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVCZWZvcmVFZGl0WzFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhbmVCZWZvcmVFZGl0WzFdLmluY2lkZW50LmdldFNjcmF0Y2hWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIGVkaXRlZCBhbmltYXRpb24gd2FzIG5vdCB0aGUgZmlyc3Qgb25lIGJlZm9yZSB0aGUgZWRpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZWFuaW5nIGl0cyBwcmV2aW91cyBzdWNjZXNzb3IgaXMgbm90IHRoZSBmaXJzdCBvbmUgb24gdGhlIGxhbmUgYWZ0ZXIgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBncmFiIHRoZSB0YXJnZXQgdmFsdWUgb2YgdGhlIG5ldyBwcmV2aW91cyBhbmltYXRpb24gb2YgdGhlIGFuaW1hdGlvbidzIHByZXZpb3VzIHN1Y2Nlc3NvciBhbmQgc2V0IGl0IGFzIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZUJlZm9yZUVkaXRbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ICsgMV0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgbGFuZUJlZm9yZUVkaXRbYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0IC0gMV0uaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRyc1tsYW5lRGF0YS5hdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgZWRpdGVkIGFuaW1hdGlvbiBpdHNlbGYgbm93OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXMgaXQgdGhlIGZpcnN0IG9uZSAoYWZ0ZXIgZWRpdCk/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9lcyB0aGUgcHJldmlvdXNseSB6ZXJvIGluZGV4IGFuaW1hdGlvbiBoYXMgaW5pdGlhbCB2YWx1ZT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZUJlZm9yZUVkaXRbMF0uaW5jaWRlbnQuaGFzSW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgcHJldmlvdXNseSAwIGluZGV4ZWQgYW5pbWF0aW9uIG9mIHRoZSBsYW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlLCBsYW5lQmVmb3JlRWRpdFswXS5pbmNpZGVudC5nZXRJbml0aWFsVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNhbGN1bGF0ZSB0aGUgaW5pdGlhbCB2YWx1ZSBvbiB0aGUgZmx5LCBvdXIgb2YgdGhlIGRvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgYW5pbWF0aW9uLmdldFNjcmF0Y2hWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgaXQgaXMgbm90IHRoZSBmaXJzdCBvbmUgYWZ0ZXIgZWRpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZ3JhYiB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBwcmV2aW91cyBhbmltYXRpb24gb24gdGhlIHVwZGF0ZWQgbGFuZSBhbmQgc2V0IGl0IGFzIGl0cyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhbmVbYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgLSAxXS5pbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2xhbmVEYXRhLmF0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgaXRzIG5ldyBuZXh0IGFuaW1hdGlvbiAoaWYgaXQgaGFzIG9uZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDEgPCBsYW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBpdHMgaW5pdGlhbCB2YWx1ZSB0byBlcXVhbCB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBlZGl0ZWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdCArIDFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGFuaW1hdGlvbi5hdHRycy5hbmltYXRlZEF0dHJzW2xhbmVEYXRhLmF0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhZmZlY3RlZExhbmUuYW5pbWF0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXQgPT09ICdicmVhaycpIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gLy8gZW5kIGZvciBlYWNoIG9mIHRoZSBiZWxvbmdpbmcgbGFuZXMgb2YgdGhlIGFuaW1hdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlbW92ZXMgdGhlIGxpc3Qgb2YgYW5pbWF0aW9ucyBhcyBwcm92aWRlZFxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSByZW1vdmVkQW5pbWF0aW9ucyAtIGFuIGFycmF5IHdpdGggdGhlIHJlbW92ZWQgYW5pbWF0aW9ucycgaWRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlbGV0ZUFuaW1hdGlvbnMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVsZXRlQW5pbWF0aW9ucyhyZW1vdmVkQW5pbWF0aW9ucywgY3VycmVudE1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlbW92ZWRBbmltYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gcmVtb3ZlZEFuaW1hdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggbGFuZSB0aGUgYWZmZWN0ZWQgQW5pbWF0aW9uIGFwcGVhcnMgaW5cbiAgICAgICAgICAgICAgICB2YXIgYmVsb25naW5nTGFuZXMgPSB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZFtpZF07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHRoaXMubGFuZXNbYmVsb25naW5nTGFuZXNbal1dO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVba10uaW5jaWRlbnQuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25Ub0RlbGV0ZSA9IE9iamVjdC5hc3NpZ24oe30sIGxhbmVbX2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdF0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT2JqZWN0VG9EZWxldGUgPSBhbmltYXRpb25Ub0RlbGV0ZS5pbmNpZGVudDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2pdKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBnZXRzIHRoZSBsYW5lIHdpdGhvdXQgdGhlIHJlbW92ZWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdMYW5lID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9rID0gMDsgX2sgPCBsYW5lLmxlbmd0aDsgX2srKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVbX2tdLmluY2lkZW50LmlkICE9IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGFuZS5wdXNoKGxhbmVbX2tdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXSA9IG5ld0xhbmU7XG4gICAgICAgICAgICAgICAgICAgIGxhbmUgPSB0aGlzLmxhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZmZlY3RlZExhbmVzLmhhc093blByb3BlcnR5KGJlbG9uZ2luZ0xhbmVzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhZmZlY3RlZExhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbmNpZGVudEhhc0FuaW1hdGVkQXR0cnMoYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV0gPSBoZWxwZXIuZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkoYmVsb25naW5nTGFuZXNbal0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0IDwgbGFuZS5sZW5ndGggJiYgYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVbX2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdF0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWRbcmVtb3ZlZEFuaW1hdGlvbnNbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFmZmVjdGVkTGFuZXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgaGFuZGxlcyBlZGl0cyBvbiB0aGUgZmluYWwgdmFsdWUgb2YgYSBzcGVjaWZpYyBhdHRyaWJ1dGUgb2YgYSBzcGVjaWZpYyBhbmltYXRpb24gb2JqZWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25JZCAtIHRoZSBpZCBvZiB0aGUgQW5pbWF0aW9uIG9iamVjdCB0aGF0IGhhcyBiZWVuIGVkaXRlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdGhhdCBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIG5ldyB2YWx1ZSBvZiB0aGUgZWRpdGVkIGF0dHJpYnV0ZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1cGRhdGVBdHRyaWJ1dGVPbkxhbmVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUF0dHJpYnV0ZU9uTGFuZXMoYW5pbWF0aW9uSWQsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgYmVsb25naW5nTGFuZXMgPSB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZFthbmltYXRpb25JZF07XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZWxvbmdpbmdMYW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gdGhpcy5sYW5lc1tiZWxvbmdpbmdMYW5lc1tpXV07XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2ldKTtcblxuICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGFuaW1hdGlvbiBvbiB0aGUgbGFuZVxuICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25JbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGFuZVtrXS5pbmNpZGVudC5pZCA9PT0gYW5pbWF0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkluZGV4ID0gaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGFuaW1hdGlvbiBpcyBub3QgdGhlIGxhc3Qgb25lIG9uIHRoZSBsYW5lXG4gICAgICAgICAgICAgICAgaWYgKGxhbmUubGVuZ3RoIC0gMSAhPSBhbmltYXRpb25JbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBsYW5lW2FuaW1hdGlvbkluZGV4ICsgMV0uaW5jaWRlbnQuc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaChsYW5lRGF0YSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhZmZlY3RlZExhbmVzO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExhbmVzSGFuZGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBMYW5lc0hhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js":
/*!***************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @classdesc Helper maintains a number of helpful functions in a single point  */\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Helper = function () {\n    function Helper(configuration) {\n        _classCallCheck(this, Helper);\n\n        var logLevel = 2;\n        if (configuration) {\n            if (configuration.hasOwnProperty('logLevel')) {\n                logLevel = configuration.logLevel;\n            }\n        }\n\n        this.lanesMCIDattrsSeperator = '___';\n\n        for (var i = 0; i < conf.logTypes.length; i++) {\n            var logType = conf.logTypes[i];\n            if (logLevel >= logType.level) this[logType.key] = window.console.log.bind(window.console, \"MotorCortex - %c%s\", logType.style);else this[logType.key] = function () {};\n        }\n\n        if (logLevel >= 3) this.log = window.console.log.bind(window.console, \"MotorCortex - \");else this.log = function () {};\n    }\n\n    _createClass(Helper, [{\n        key: 'renderTemplate',\n        value: function renderTemplate(templateString, templateVars) {\n            return new Function(\"return `\" + templateString + \"`;\").call(templateVars);\n        }\n\n        /**\n         * @returns {string} in the form \"1bc45f78-ab23-jl59\"\n         */\n\n    }, {\n        key: 'getAnId',\n        value: function getAnId() {\n            var underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var specialChar = '-';\n            if (underscore) {\n                specialChar = '_';\n            }\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n            }\n            return s4() + s4() + specialChar + s4() + specialChar + s4();\n        }\n    }, {\n        key: 'getLaneKey',\n        value: function getLaneKey(mcid, attribute) {\n            return mcid + this.lanesMCIDattrsSeperator + attribute;\n        }\n    }, {\n        key: 'getMCIDandAttrOutOfLaneKey',\n        value: function getMCIDandAttrOutOfLaneKey(laneKey) {\n            var laneArray = laneKey.split(this.lanesMCIDattrsSeperator);\n            return {\n                mcid: laneArray[0],\n                attribute: laneArray[1]\n            };\n        }\n    }, {\n        key: 'getElementByMCID',\n        value: function getElementByMCID(context, mcid) {\n            return context.document.querySelectorAll('[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]')[0];\n        }\n    }, {\n        key: 'getMCIDOfElement',\n        value: function getMCIDOfElement(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n\n        /**\n        subdivision might be rounding the number to its:\n        - units (subdivision = 1)\n        - tenths (subdivision = 10)\n        - hundreds (subdivision = 100)\n        - thousands (subdivision = 1000)\n         @param {string} int\n         @param {subdivision} int\n         @returns {int} the rounded number\n        */\n\n    }, {\n        key: 'roundNumberTo',\n        value: function roundNumberTo(number, subdivision) {\n            return Math.round(number / subdivision) * subdivision;\n        }\n    }, {\n        key: 'isInteger',\n        value: function isInteger(number) {\n            if (number === parseInt(number, 10)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'isString',\n        value: function isString(test) {\n            if (typeof test === 'string' || test instanceof String) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'isObject',\n        value: function isObject(test) {\n            return (typeof test === 'undefined' ? 'undefined' : _typeof(test)) === \"object\";\n        }\n    }, {\n        key: 'isArray',\n        value: function isArray(test) {\n            return Array.isArray(test);\n        }\n    }, {\n        key: 'isFunction',\n        value: function isFunction(functionToCheck) {\n            return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n        }\n    }, {\n        key: 'addClass',\n        value: function addClass(el, className) {\n            if (el.classList) el.classList.add(className);else el.className += ' ' + className;\n        }\n    }, {\n        key: 'removeClass',\n        value: function removeClass(el, className) {\n            if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n    }, {\n        key: 'addStyle',\n        value: function addStyle(el, style) {\n            for (var key in style) {\n                el.style[key] = style[key];\n            }\n        }\n\n        /**\n         * systole / diastole of the projections\n         * @param {float} fraction - the duration fraction of the parent Scene\n         * @returns {array} - collection of objects with keys: {id, start, end, startDelta}\n        **/\n\n    }, {\n        key: 'systoleDiastoleProjections',\n        value: function systoleDiastoleProjections(projections, durationFraction, adjustMillisecond) {\n            var alteredProjections = [];\n\n            for (var i = 0; i < projections.length; i++) {\n                var projectedIncident = projections[i];\n\n                if (durationFraction != 1) {\n                    alteredProjections.push({\n                        id: projectedIncident.incident.id,\n                        start: projectedIncident.millisecond * durationFraction + adjustMillisecond,\n                        end: projectedIncident.millisecond * durationFraction + projectedIncident.incident.duration * durationFraction + adjustMillisecond,\n                        startDelta: projectedIncident.millisecond * durationFraction - projectedIncident.millisecond\n                    });\n                }\n            }\n\n            return alteredProjections;\n        }\n    }]);\n\n    return Helper;\n}();\n\nmodule.exports = Helper;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fY29yZVV0aWxzL0hlbHBlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvSGVscGVyLmpzP2FhNjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKiBAY2xhc3NkZXNjIEhlbHBlciBtYWludGFpbnMgYSBudW1iZXIgb2YgaGVscGZ1bCBmdW5jdGlvbnMgaW4gYSBzaW5nbGUgcG9pbnQgICovXG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIEhlbHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIZWxwZXIoY29uZmlndXJhdGlvbikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSGVscGVyKTtcblxuICAgICAgICB2YXIgbG9nTGV2ZWwgPSAyO1xuICAgICAgICBpZiAoY29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24uaGFzT3duUHJvcGVydHkoJ2xvZ0xldmVsJykpIHtcbiAgICAgICAgICAgICAgICBsb2dMZXZlbCA9IGNvbmZpZ3VyYXRpb24ubG9nTGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhbmVzTUNJRGF0dHJzU2VwZXJhdG9yID0gJ19fXyc7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb25mLmxvZ1R5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9nVHlwZSA9IGNvbmYubG9nVHlwZXNbaV07XG4gICAgICAgICAgICBpZiAobG9nTGV2ZWwgPj0gbG9nVHlwZS5sZXZlbCkgdGhpc1tsb2dUeXBlLmtleV0gPSB3aW5kb3cuY29uc29sZS5sb2cuYmluZCh3aW5kb3cuY29uc29sZSwgXCJNb3RvckNvcnRleCAtICVjJXNcIiwgbG9nVHlwZS5zdHlsZSk7ZWxzZSB0aGlzW2xvZ1R5cGUua2V5XSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvZ0xldmVsID49IDMpIHRoaXMubG9nID0gd2luZG93LmNvbnNvbGUubG9nLmJpbmQod2luZG93LmNvbnNvbGUsIFwiTW90b3JDb3J0ZXggLSBcIik7ZWxzZSB0aGlzLmxvZyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhIZWxwZXIsIFt7XG4gICAgICAgIGtleTogJ3JlbmRlclRlbXBsYXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRlbXBsYXRlKHRlbXBsYXRlU3RyaW5nLCB0ZW1wbGF0ZVZhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gYFwiICsgdGVtcGxhdGVTdHJpbmcgKyBcImA7XCIpLmNhbGwodGVtcGxhdGVWYXJzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBpbiB0aGUgZm9ybSBcIjFiYzQ1Zjc4LWFiMjMtamw1OVwiXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRBbklkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuSWQoKSB7XG4gICAgICAgICAgICB2YXIgdW5kZXJzY29yZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBzcGVjaWFsQ2hhciA9ICctJztcbiAgICAgICAgICAgIGlmICh1bmRlcnNjb3JlKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lhbENoYXIgPSAnXyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBzNCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkudG9TdHJpbmcoMTYpLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzNCgpICsgczQoKSArIHNwZWNpYWxDaGFyICsgczQoKSArIHNwZWNpYWxDaGFyICsgczQoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TGFuZUtleScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lS2V5KG1jaWQsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1jaWQgKyB0aGlzLmxhbmVzTUNJRGF0dHJzU2VwZXJhdG9yICsgYXR0cmlidXRlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShsYW5lS2V5KSB7XG4gICAgICAgICAgICB2YXIgbGFuZUFycmF5ID0gbGFuZUtleS5zcGxpdCh0aGlzLmxhbmVzTUNJRGF0dHJzU2VwZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWNpZDogbGFuZUFycmF5WzBdLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogbGFuZUFycmF5WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50QnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRCeU1DSUQoY29udGV4dCwgbWNpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnWycgKyBjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUgKyAnPVwiJyArIG1jaWQgKyAnXCJdJylbMF07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldE1DSURPZkVsZW1lbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUNJRE9mRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICBzdWJkaXZpc2lvbiBtaWdodCBiZSByb3VuZGluZyB0aGUgbnVtYmVyIHRvIGl0czpcbiAgICAgICAgLSB1bml0cyAoc3ViZGl2aXNpb24gPSAxKVxuICAgICAgICAtIHRlbnRocyAoc3ViZGl2aXNpb24gPSAxMClcbiAgICAgICAgLSBodW5kcmVkcyAoc3ViZGl2aXNpb24gPSAxMDApXG4gICAgICAgIC0gdGhvdXNhbmRzIChzdWJkaXZpc2lvbiA9IDEwMDApXG4gICAgICAgICBAcGFyYW0ge3N0cmluZ30gaW50XG4gICAgICAgICBAcGFyYW0ge3N1YmRpdmlzaW9ufSBpbnRcbiAgICAgICAgIEByZXR1cm5zIHtpbnR9IHRoZSByb3VuZGVkIG51bWJlclxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyb3VuZE51bWJlclRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJvdW5kTnVtYmVyVG8obnVtYmVyLCBzdWJkaXZpc2lvbikge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyIC8gc3ViZGl2aXNpb24pICogc3ViZGl2aXNpb247XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzSW50ZWdlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0ludGVnZXIobnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAobnVtYmVyID09PSBwYXJzZUludChudW1iZXIsIDEwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzU3RyaW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3RyaW5nKHRlc3QpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGVzdCA9PT0gJ3N0cmluZycgfHwgdGVzdCBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzT2JqZWN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzT2JqZWN0KHRlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiAodHlwZW9mIHRlc3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRlc3QpKSA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNBcnJheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FycmF5KHRlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRlc3QpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0Z1bmN0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIHt9LnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkQ2xhc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCkgZWwuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpO2Vsc2UgZWwuY2xhc3NOYW1lICs9ICcgJyArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlQ2xhc3MnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlQ2xhc3MoZWwsIGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdCkgZWwuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO2Vsc2UgZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UobmV3IFJlZ0V4cCgnKF58XFxcXGIpJyArIGNsYXNzTmFtZS5zcGxpdCgnICcpLmpvaW4oJ3wnKSArICcoXFxcXGJ8JCknLCAnZ2knKSwgJyAnKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkU3R5bGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU3R5bGUoZWwsIHN0eWxlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gc3R5bGUpIHtcbiAgICAgICAgICAgICAgICBlbC5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzeXN0b2xlIC8gZGlhc3RvbGUgb2YgdGhlIHByb2plY3Rpb25zXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gdGhlIGR1cmF0aW9uIGZyYWN0aW9uIG9mIHRoZSBwYXJlbnQgU2NlbmVcbiAgICAgICAgICogQHJldHVybnMge2FycmF5fSAtIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyB3aXRoIGtleXM6IHtpZCwgc3RhcnQsIGVuZCwgc3RhcnREZWx0YX1cbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbGVEaWFzdG9sZVByb2plY3Rpb25zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbGVEaWFzdG9sZVByb2plY3Rpb25zKHByb2plY3Rpb25zLCBkdXJhdGlvbkZyYWN0aW9uLCBhZGp1c3RNaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGFsdGVyZWRQcm9qZWN0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2plY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2plY3RlZEluY2lkZW50ID0gcHJvamVjdGlvbnNbaV07XG5cbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb25GcmFjdGlvbiAhPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsdGVyZWRQcm9qZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwcm9qZWN0ZWRJbmNpZGVudC5pbmNpZGVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9qZWN0ZWRJbmNpZGVudC5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb24gKyBhZGp1c3RNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uICsgcHJvamVjdGVkSW5jaWRlbnQuaW5jaWRlbnQuZHVyYXRpb24gKiBkdXJhdGlvbkZyYWN0aW9uICsgYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydERlbHRhOiBwcm9qZWN0ZWRJbmNpZGVudC5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb24gLSBwcm9qZWN0ZWRJbmNpZGVudC5taWxsaXNlY29uZFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBhbHRlcmVkUHJvamVjdGlvbnM7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSGVscGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhlbHBlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js":
/*!********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar Journey = function () {\n    function Journey(props) {\n        _classCallCheck(this, Journey);\n\n        if (!props.hasOwnProperty('incident')) {\n            helper.error('Journey constructor expects an Incident on its properties on the key \"incident\"');\n            return false;\n        }\n\n        this.memory = props.calpuleMemory;\n        this.stations = [];\n\n        this.incident = props.incident;\n        this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;\n        this.startState = this.incident.state + \"\";\n        this.incident.stop();\n    }\n\n    _createClass(Journey, [{\n        key: 'station',\n        value: function station(millisecond) {\n            var props = {};\n            if (this.stations.length > 0) {\n                props.previousStop = this.stations[this.stations.length - 1];\n            }\n            this.stations.push(millisecond);\n            // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);\n            // helper.log(this.stations);\n            this.incident.goTo(millisecond, props);\n        }\n    }, {\n        key: 'destination',\n        value: function destination() {\n            var millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (millisecond != null) {\n                this.station(millisecond);\n            } else {\n                millisecond = this.stations[this.stations.length - 1];\n            }\n            this.incident.beOn(millisecond, false);\n            if (this.startState === 'playing') {\n                this.incident.resume();\n            }\n            this.memory.push(this.exportJourneyLog);\n        }\n    }, {\n        key: 'exportJourneyLog',\n        value: function exportJourneyLog() {\n            return {\n                startMillisecond: this.startMillisecond,\n                startState: this.startState,\n                incident: this.incident.exportState(),\n                stations: this.stations\n            };\n        }\n    }]);\n\n    return Journey;\n}();\n\nvar TimeCapsule = function () {\n    function TimeCapsule() {\n        _classCallCheck(this, TimeCapsule);\n\n        this.memory = [];\n    }\n\n    _createClass(TimeCapsule, [{\n        key: 'startJourney',\n        value: function startJourney(incident) {\n            if (!incident) {\n                helper.error('startJourney expects an Incident as an argument');\n                return false;\n            }\n\n            return new Journey({ incident: incident, calpuleMemory: this.memory });\n        }\n    }]);\n\n    return TimeCapsule;\n}();\n\nmodule.exports = TimeCapsule;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fY29yZVV0aWxzL1RpbWVDYXBzdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX2NvcmVVdGlscy9UaW1lQ2Fwc3VsZS5qcz9kNTRkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xuXG52YXIgSm91cm5leSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBKb3VybmV5KHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKb3VybmV5KTtcblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdpbmNpZGVudCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0pvdXJuZXkgY29uc3RydWN0b3IgZXhwZWN0cyBhbiBJbmNpZGVudCBvbiBpdHMgcHJvcGVydGllcyBvbiB0aGUga2V5IFwiaW5jaWRlbnRcIicpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tZW1vcnkgPSBwcm9wcy5jYWxwdWxlTWVtb3J5O1xuICAgICAgICB0aGlzLnN0YXRpb25zID0gW107XG5cbiAgICAgICAgdGhpcy5pbmNpZGVudCA9IHByb3BzLmluY2lkZW50O1xuICAgICAgICB0aGlzLnN0YXJ0TWlsbGlzZWNvbmQgPSB0aGlzLmluY2lkZW50LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAqIDE7XG4gICAgICAgIHRoaXMuc3RhcnRTdGF0ZSA9IHRoaXMuaW5jaWRlbnQuc3RhdGUgKyBcIlwiO1xuICAgICAgICB0aGlzLmluY2lkZW50LnN0b3AoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSm91cm5leSwgW3tcbiAgICAgICAga2V5OiAnc3RhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGF0aW9uKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5wcmV2aW91c1N0b3AgPSB0aGlzLnN0YXRpb25zW3RoaXMuc3RhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRpb25zLnB1c2gobWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgQ0FQU1VMRSBwYXNzZXMgYXMgcHJldmlvdXNTdG9wOiAke3Byb3BzLnByZXZpb3VzU3RvcH1gKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5zdGF0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50LmdvVG8obWlsbGlzZWNvbmQsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdGluYXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdGluYXRpb24oKSB7XG4gICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChtaWxsaXNlY29uZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0aW9uKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSB0aGlzLnN0YXRpb25zW3RoaXMuc3RhdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50LmJlT24obWlsbGlzZWNvbmQsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0U3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnQucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm1lbW9yeS5wdXNoKHRoaXMuZXhwb3J0Sm91cm5leUxvZyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydEpvdXJuZXlMb2cnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0Sm91cm5leUxvZygpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhcnRNaWxsaXNlY29uZDogdGhpcy5zdGFydE1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgICAgIHN0YXJ0U3RhdGU6IHRoaXMuc3RhcnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogdGhpcy5pbmNpZGVudC5leHBvcnRTdGF0ZSgpLFxuICAgICAgICAgICAgICAgIHN0YXRpb25zOiB0aGlzLnN0YXRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEpvdXJuZXk7XG59KCk7XG5cbnZhciBUaW1lQ2Fwc3VsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lQ2Fwc3VsZSgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbWVDYXBzdWxlKTtcblxuICAgICAgICB0aGlzLm1lbW9yeSA9IFtdO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUaW1lQ2Fwc3VsZSwgW3tcbiAgICAgICAga2V5OiAnc3RhcnRKb3VybmV5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0Sm91cm5leShpbmNpZGVudCkge1xuICAgICAgICAgICAgaWYgKCFpbmNpZGVudCkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignc3RhcnRKb3VybmV5IGV4cGVjdHMgYW4gSW5jaWRlbnQgYXMgYW4gYXJndW1lbnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgSm91cm5leSh7IGluY2lkZW50OiBpbmNpZGVudCwgY2FscHVsZU1lbW9yeTogdGhpcy5tZW1vcnkgfSk7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVGltZUNhcHN1bGU7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZUNhcHN1bGU7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar AttributesAwareIncident = function (_Group) {\n    _inherits(AttributesAwareIncident, _Group);\n\n    function AttributesAwareIncident(incident) {\n        _classCallCheck(this, AttributesAwareIncident);\n\n        var _this = _possibleConstructorReturn(this, (AttributesAwareIncident.__proto__ || Object.getPrototypeOf(AttributesAwareIncident)).call(this, incident.attrs, incident.props));\n\n        _this.setUp(incident);\n        return _this;\n    }\n\n    _createClass(AttributesAwareIncident, [{\n        key: 'setUp',\n        value: function setUp(incident) {\n            this.IncidentClass = incident.constructor;\n            this.toPassToElementIncidents = {\n                plugin_channel_class: incident.plugin_channel_class,\n                mc_plugin_npm_name: incident.mc_plugin_npm_name\n            };\n            this.attributeIncidentsByAttribute = {};\n            this.cleanProps = Object.assign({}, this.props);\n            this.cleanAttrs = Object.assign({}, this.attrs);\n            delete this.cleanProps.id;\n            this.cleanAttrs.animatedAttrs = {};\n\n            for (var attr in this.attrs.animatedAttrs) {\n                this._createAttributeIncident(attr);\n            }\n        }\n\n        /**\n        * attribute groups\n        Can have on their timeline:\n        - An incident\n        Can’t have on their timeline:\n        - A plain group\n        - A dom group\n        - Another attribute group\n        */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.hasIncidents) {\n                // if it is not a group\n                return incident;\n            } else {\n                helper.error(\"attribute groups can not accept groups on their timeline\");\n                return null;\n            }\n        }\n    }, {\n        key: '_createAttributeIncident',\n        value: function _createAttributeIncident(attribute) {\n            var propsToPass = Object.assign({}, this.cleanProps);\n            var attrsToPass = Object.assign({}, this.cleanAttrs);\n            attrsToPass.animatedAttrs = {};\n            if (_typeof(this.attrs.animatedAttrs[attribute]) === 'object' && !Array.isArray(this.attrs.animatedAttrs[attribute])) {\n                attrsToPass.animatedAttrs[attribute] = Object.assign({}, this.attrs.animatedAttrs[attribute]);\n            } else if (_typeof(this.attrs.animatedAttrs[attribute]) === 'object' && Array.isArray(this.attrs.animatedAttrs[attribute])) {\n                attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute].splice(0);\n            } else {\n                attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute];\n            }\n\n            propsToPass.id = this.id + '_' + attribute;\n\n            var attributeIncident = new this.IncidentClass(attrsToPass, propsToPass);\n            attributeIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;\n            attributeIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;\n            this.addIncident(attributeIncident, 0);\n            this.attributeIncidentsByAttribute[attribute] = attributeIncident;\n        }\n    }, {\n        key: 'attributesChange',\n        value: function attributesChange(newAttrs) {\n            for (var i = 0; i < this.incidents; i++) {\n                // TODO execute attribute change by passing down the command\n            }\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"attribute\";\n        }\n    }]);\n\n    return AttributesAwareIncident;\n}(Group);\n\nmodule.exports = AttributesAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvQXR0cmlidXRlQXdhcmVJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9BdHRyaWJ1dGVBd2FyZUluY2lkZW50LmpzP2JhZTUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEdyb3VwID0gcmVxdWlyZSgnLi4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50ID0gZnVuY3Rpb24gKF9Hcm91cCkge1xuICAgIF9pbmhlcml0cyhBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudCwgX0dyb3VwKTtcblxuICAgIGZ1bmN0aW9uIEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50KGluY2lkZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQpKS5jYWxsKHRoaXMsIGluY2lkZW50LmF0dHJzLCBpbmNpZGVudC5wcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnNldFVwKGluY2lkZW50KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudCwgW3tcbiAgICAgICAga2V5OiAnc2V0VXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXAoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuSW5jaWRlbnRDbGFzcyA9IGluY2lkZW50LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMgPSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luX2NoYW5uZWxfY2xhc3M6IGluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzLFxuICAgICAgICAgICAgICAgIG1jX3BsdWdpbl9ucG1fbmFtZTogaW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVJbmNpZGVudHNCeUF0dHJpYnV0ZSA9IHt9O1xuICAgICAgICAgICAgdGhpcy5jbGVhblByb3BzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFuQXR0cnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmF0dHJzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsZWFuUHJvcHMuaWQ7XG4gICAgICAgICAgICB0aGlzLmNsZWFuQXR0cnMuYW5pbWF0ZWRBdHRycyA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUF0dHJpYnV0ZUluY2lkZW50KGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogYXR0cmlidXRlIGdyb3Vwc1xuICAgICAgICBDYW4gaGF2ZSBvbiB0aGVpciB0aW1lbGluZTpcbiAgICAgICAgLSBBbiBpbmNpZGVudFxuICAgICAgICBDYW7igJl0IGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgIC0gQSBwbGFpbiBncm91cFxuICAgICAgICAtIEEgZG9tIGdyb3VwXG4gICAgICAgIC0gQW5vdGhlciBhdHRyaWJ1dGUgZ3JvdXBcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3ByZXBhcmVJbmljZGVudEZvckFkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbihpbmNpZGVudCkge1xuICAgICAgICAgICAgaWYgKCFpbmNpZGVudC5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyBub3QgYSBncm91cFxuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiYXR0cmlidXRlIGdyb3VwcyBjYW4gbm90IGFjY2VwdCBncm91cHMgb24gdGhlaXIgdGltZWxpbmVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19jcmVhdGVBdHRyaWJ1dGVJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQXR0cmlidXRlSW5jaWRlbnQoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHNUb1Bhc3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNsZWFuUHJvcHMpO1xuICAgICAgICAgICAgdmFyIGF0dHJzVG9QYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbGVhbkF0dHJzKTtcbiAgICAgICAgICAgIGF0dHJzVG9QYXNzLmFuaW1hdGVkQXR0cnMgPSB7fTtcbiAgICAgICAgICAgIGlmIChfdHlwZW9mKHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdKSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodGhpcy5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNUb1Bhc3MuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdKSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSh0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSkpIHtcbiAgICAgICAgICAgICAgICBhdHRyc1RvUGFzcy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0gPSB0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXS5zcGxpY2UoMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF0dHJzVG9QYXNzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSA9IHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wc1RvUGFzcy5pZCA9IHRoaXMuaWQgKyAnXycgKyBhdHRyaWJ1dGU7XG5cbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVJbmNpZGVudCA9IG5ldyB0aGlzLkluY2lkZW50Q2xhc3MoYXR0cnNUb1Bhc3MsIHByb3BzVG9QYXNzKTtcbiAgICAgICAgICAgIGF0dHJpYnV0ZUluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzID0gdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMucGx1Z2luX2NoYW5uZWxfY2xhc3M7XG4gICAgICAgICAgICBhdHRyaWJ1dGVJbmNpZGVudC5tY19wbHVnaW5fbnBtX25hbWUgPSB0aGlzLnRvUGFzc1RvRWxlbWVudEluY2lkZW50cy5tY19wbHVnaW5fbnBtX25hbWU7XG4gICAgICAgICAgICB0aGlzLmFkZEluY2lkZW50KGF0dHJpYnV0ZUluY2lkZW50LCAwKTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlSW5jaWRlbnRzQnlBdHRyaWJ1dGVbYXR0cmlidXRlXSA9IGF0dHJpYnV0ZUluY2lkZW50O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhdHRyaWJ1dGVzQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGF0dHJpYnV0ZXNDaGFuZ2UobmV3QXR0cnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHM7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gZXhlY3V0ZSBhdHRyaWJ1dGUgY2hhbmdlIGJ5IHBhc3NpbmcgZG93biB0aGUgY29tbWFuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdncm91cFR5cGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZVwiO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50O1xufShHcm91cCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js":
/*!******************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar DOMAwareIncident = function (_Group) {\n    _inherits(DOMAwareIncident, _Group);\n\n    function DOMAwareIncident(incident) {\n        _classCallCheck(this, DOMAwareIncident);\n\n        var _this = _possibleConstructorReturn(this, (DOMAwareIncident.__proto__ || Object.getPrototypeOf(DOMAwareIncident)).call(this, incident.attrs, incident.props));\n\n        _this.setUp(incident);\n        return _this;\n    }\n\n    _createClass(DOMAwareIncident, [{\n        key: 'setUp',\n\n\n        // props must have the elements collection and the millisecond\n        // id is also mandatory\n        value: function setUp(incident) {\n            this.originalIncident = incident;\n            this.IncidentClass = incident.constructor;\n            this.toPassToElementIncidents = {\n                plugin_channel_class: incident.plugin_channel_class,\n                mc_plugin_npm_name: incident.mc_plugin_npm_name\n            };\n            this.elementIncidentsByMCID = {};\n            this.cleanProps = Object.assign({}, this.props);\n            delete this.cleanProps.id;\n\n            if (this.context) {\n                var elements = Array.from(this.context.document.querySelectorAll(this.props.selector));\n                for (var i = 0; i < elements.length; i++) {\n                    var element = elements[i];\n                    this._createElementIncident(element);\n                }\n            }\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            _get(DOMAwareIncident.prototype.__proto__ || Object.getPrototypeOf(DOMAwareIncident.prototype), 'systolDiastole', this).call(this, durationFraction);\n            this.originalIncident.props.duration *= durationFraction;\n        }\n\n        /**\n         * dom groups\n            Can have on their timeline:\n            - An incident with no animatedAttrs \n            - An attribute group (this method should actually turn any incident with animatedAttrs to one)\n            Can’t have on their timeline:\n            - A plain group\n            - Another dom group\n         */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.attrs.hasOwnProperty('animatedAttrs') && !incident.hasIncidents) {\n                // if the incident is not a group and it has no animatedAttrs proceed normally\n                return incident;\n            } else if (incident.groupType === \"plain\") {\n                // if the Incident is a plain group proceed normally\n                helper.error(\"dom groups can not accept plain groups on their timeline\");\n                return null;\n            } else if (incident.groupType === \"dom\") {\n                helper.error(\"dom groups can not accept other dom groups on their timeline\");\n                return null;\n            }\n\n            // We need to turn the Incident to an AttrsAwareIncident\n            // before adding it to the group\n            var AttrsAwareIncident = __webpack_require__(/*! ./AttributeAwareIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\");\n            var theAttrsAwareIncident = new AttrsAwareIncident(incident);\n            return theAttrsAwareIncident;\n        }\n    }, {\n        key: '_createElementIncident',\n        value: function _createElementIncident(element) {\n            var mcid = this.context.getMCID(element);\n            if (!mcid) {\n                mcid = helper.getAnId(true);\n                this.context.setMCID(element, mcid);\n            }\n\n            var propsToPass = Object.assign({}, this.cleanProps);\n            propsToPass.selector = this.context.getElementSelectorByMCID(mcid); // '[data-motorocortext2-id=\"mcid1\"]' querySelectorAll()\n            propsToPass.id = this.id + '_' + mcid;\n            var elementIncident = new this.IncidentClass(this.attrs, propsToPass);\n            elementIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;\n            elementIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;\n            var result = this.addIncident(elementIncident, 0);\n            if (result.result === true) {\n                this.elementIncidentsByMCID[mcid] = elementIncident;\n            }\n            return result;\n        }\n\n        /**\n         * flashDOM method expects the new elements collection and:\n         * 1. Identifies which of the existing elementIncidents should go (the dom element does not participate on the DOMAwareGroup any more)\n         * 2. Identifies which elements are new and add their elementIncident on the DOMAwareGroup\n         * @returns {object} - with keys additions and deletions each of which hold an array of functions that must be\n         *  executed for adding the new element incidents and deleting the element incidents that do not apply any more\n        */\n\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            var _this2 = this;\n\n            var elements = this.context.getElements(this.props.selector);\n\n            // deletions and additions of elementIncidents that should take place according to the new elements\n            var deletions = [];\n            var additions = [];\n\n            var that = this;\n\n            // an array that will keep all new elements' keys to be used later for identifying deletions\n            var stayingElementIncidents = [];\n            // first identify additions\n\n            var _loop = function _loop(i) {\n                // for each of the new elements\n                var element = elements[i];\n                var mcid = _this2.context.getMCID(element); // take its mcid\n\n                if (!mcid) {\n                    // if the element does not have an mcid yet that means it's a new one\n                    var addition = function addition() {\n                        return that._createElementIncident(element);\n                    };\n                    additions.push(addition);\n                } else if (!_this2.elementIncidentsByMCID.hasOwnProperty(mcid)) {\n                    // else if the element has an mcid that doesn't already exist on the elementIncidents\n                    var _addition = function _addition() {\n                        return that._createElementIncident(element);\n                    };\n                    additions.push(_addition);\n                } else {\n                    stayingElementIncidents.push(mcid);\n                }\n            };\n\n            for (var i = 0; i < elements.length; i++) {\n                _loop(i);\n            }\n\n            // next step is to compare the elementIncidents with the existing elements key to see which \n            // are missing from the new set and put them for delete\n            var alreadyExistingElementsKeys = Object.keys(this.elementIncidentsByMCID);\n            var underDeletion = alreadyExistingElementsKeys.filter(function (key) {\n                return stayingElementIncidents.indexOf(key) < 0;\n            });\n\n            var _loop2 = function _loop2(i) {\n                var deletion = function deletion() {\n                    that.removeIncident(that.elementIncidentsByMCID[underDeletion[i]].id, { preventSlip: true });\n                    delete that.elementIncidentsByMCID[that.elementIncidentsByMCID[underDeletion[i]].id];\n                };\n                deletions.push(deletion);\n            };\n\n            for (var i = 0; i < underDeletion.length; i++) {\n                _loop2(i);\n            }\n\n            var failedAdditions = [];\n            for (var i = 0; i < additions.length; i++) {\n                var additionResult = additions[i]();\n                if (additionResult.result === false) {\n                    failedAdditions.push(additionResult);\n                }\n            }\n\n            for (var _i = 0; _i < deletions.length; _i++) {\n                deletions[_i]();\n            }\n\n            return {\n                failedAdditions: failedAdditions\n\n                // return {\n                //     additions: additions,\n                //     deletions: deletions\n                // }\n            };\n        }\n    }, {\n        key: 'attributesChange',\n        value: function attributesChange(newAttrs) {\n            for (var i = 0; i < this.incidents; i++) {\n                // TODO execute attribute change by passing down the command\n            }\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (props.hasOwnProperty('unprocessed')) {\n                if (props.unprocessed === true) {\n                    return this.originalIncident.exportState();\n                }\n            }\n            return _get(DOMAwareIncident.prototype.__proto__ || Object.getPrototypeOf(DOMAwareIncident.prototype), 'exportState', this).call(this, props);\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"dom\";\n        }\n    }]);\n\n    return DOMAwareIncident;\n}(Group);\n\nmodule.exports = DOMAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvRE9NQXdhcmVJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9ET01Bd2FyZUluY2lkZW50LmpzP2IyYWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChvYmplY3QsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgcmV0dXJuIGdldChwYXJlbnQsIHByb3BlcnR5LCByZWNlaXZlcik7IH0gfSBlbHNlIGlmIChcInZhbHVlXCIgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH07XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEdyb3VwID0gcmVxdWlyZSgnLi4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIERPTUF3YXJlSW5jaWRlbnQgPSBmdW5jdGlvbiAoX0dyb3VwKSB7XG4gICAgX2luaGVyaXRzKERPTUF3YXJlSW5jaWRlbnQsIF9Hcm91cCk7XG5cbiAgICBmdW5jdGlvbiBET01Bd2FyZUluY2lkZW50KGluY2lkZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBET01Bd2FyZUluY2lkZW50KTtcblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoRE9NQXdhcmVJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERPTUF3YXJlSW5jaWRlbnQpKS5jYWxsKHRoaXMsIGluY2lkZW50LmF0dHJzLCBpbmNpZGVudC5wcm9wcykpO1xuXG4gICAgICAgIF90aGlzLnNldFVwKGluY2lkZW50KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhET01Bd2FyZUluY2lkZW50LCBbe1xuICAgICAgICBrZXk6ICdzZXRVcCcsXG5cblxuICAgICAgICAvLyBwcm9wcyBtdXN0IGhhdmUgdGhlIGVsZW1lbnRzIGNvbGxlY3Rpb24gYW5kIHRoZSBtaWxsaXNlY29uZFxuICAgICAgICAvLyBpZCBpcyBhbHNvIG1hbmRhdG9yeVxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VXAoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxJbmNpZGVudCA9IGluY2lkZW50O1xuICAgICAgICAgICAgdGhpcy5JbmNpZGVudENsYXNzID0gaW5jaWRlbnQuY29uc3RydWN0b3I7XG4gICAgICAgICAgICB0aGlzLnRvUGFzc1RvRWxlbWVudEluY2lkZW50cyA9IHtcbiAgICAgICAgICAgICAgICBwbHVnaW5fY2hhbm5lbF9jbGFzczogaW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3MsXG4gICAgICAgICAgICAgICAgbWNfcGx1Z2luX25wbV9uYW1lOiBpbmNpZGVudC5tY19wbHVnaW5fbnBtX25hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRJbmNpZGVudHNCeU1DSUQgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5Qcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2xlYW5Qcm9wcy5pZDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IEFycmF5LmZyb20odGhpcy5jb250ZXh0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5wcm9wcy5zZWxlY3RvcikpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3JlYXRlRWxlbWVudEluY2lkZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3lzdG9sRGlhc3RvbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3lzdG9sRGlhc3RvbGUoZHVyYXRpb25GcmFjdGlvbikge1xuICAgICAgICAgICAgX2dldChET01Bd2FyZUluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERPTUF3YXJlSW5jaWRlbnQucHJvdG90eXBlKSwgJ3N5c3RvbERpYXN0b2xlJywgdGhpcykuY2FsbCh0aGlzLCBkdXJhdGlvbkZyYWN0aW9uKTtcbiAgICAgICAgICAgIHRoaXMub3JpZ2luYWxJbmNpZGVudC5wcm9wcy5kdXJhdGlvbiAqPSBkdXJhdGlvbkZyYWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGRvbSBncm91cHNcbiAgICAgICAgICAgIENhbiBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAgICAgLSBBbiBpbmNpZGVudCB3aXRoIG5vIGFuaW1hdGVkQXR0cnMgXG4gICAgICAgICAgICAtIEFuIGF0dHJpYnV0ZSBncm91cCAodGhpcyBtZXRob2Qgc2hvdWxkIGFjdHVhbGx5IHR1cm4gYW55IGluY2lkZW50IHdpdGggYW5pbWF0ZWRBdHRycyB0byBvbmUpXG4gICAgICAgICAgICBDYW7igJl0IGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgICAgICAtIEEgcGxhaW4gZ3JvdXBcbiAgICAgICAgICAgIC0gQW5vdGhlciBkb20gZ3JvdXBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24oaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQuYXR0cnMuaGFzT3duUHJvcGVydHkoJ2FuaW1hdGVkQXR0cnMnKSAmJiAhaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGluY2lkZW50IGlzIG5vdCBhIGdyb3VwIGFuZCBpdCBoYXMgbm8gYW5pbWF0ZWRBdHRycyBwcm9jZWVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmNpZGVudC5ncm91cFR5cGUgPT09IFwicGxhaW5cIikge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBJbmNpZGVudCBpcyBhIHBsYWluIGdyb3VwIHByb2NlZWQgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoXCJkb20gZ3JvdXBzIGNhbiBub3QgYWNjZXB0IHBsYWluIGdyb3VwcyBvbiB0aGVpciB0aW1lbGluZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnQuZ3JvdXBUeXBlID09PSBcImRvbVwiKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiZG9tIGdyb3VwcyBjYW4gbm90IGFjY2VwdCBvdGhlciBkb20gZ3JvdXBzIG9uIHRoZWlyIHRpbWVsaW5lXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHR1cm4gdGhlIEluY2lkZW50IHRvIGFuIEF0dHJzQXdhcmVJbmNpZGVudFxuICAgICAgICAgICAgLy8gYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgZ3JvdXBcbiAgICAgICAgICAgIHZhciBBdHRyc0F3YXJlSW5jaWRlbnQgPSByZXF1aXJlKCcuL0F0dHJpYnV0ZUF3YXJlSW5jaWRlbnQnKTtcbiAgICAgICAgICAgIHZhciB0aGVBdHRyc0F3YXJlSW5jaWRlbnQgPSBuZXcgQXR0cnNBd2FyZUluY2lkZW50KGluY2lkZW50KTtcbiAgICAgICAgICAgIHJldHVybiB0aGVBdHRyc0F3YXJlSW5jaWRlbnQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19jcmVhdGVFbGVtZW50SW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50KSB7XG4gICAgICAgICAgICB2YXIgbWNpZCA9IHRoaXMuY29udGV4dC5nZXRNQ0lEKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFtY2lkKSB7XG4gICAgICAgICAgICAgICAgbWNpZCA9IGhlbHBlci5nZXRBbklkKHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5zZXRNQ0lEKGVsZW1lbnQsIG1jaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvcHNUb1Bhc3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmNsZWFuUHJvcHMpO1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3Muc2VsZWN0b3IgPSB0aGlzLmNvbnRleHQuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpOyAvLyAnW2RhdGEtbW90b3JvY29ydGV4dDItaWQ9XCJtY2lkMVwiXScgcXVlcnlTZWxlY3RvckFsbCgpXG4gICAgICAgICAgICBwcm9wc1RvUGFzcy5pZCA9IHRoaXMuaWQgKyAnXycgKyBtY2lkO1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRJbmNpZGVudCA9IG5ldyB0aGlzLkluY2lkZW50Q2xhc3ModGhpcy5hdHRycywgcHJvcHNUb1Bhc3MpO1xuICAgICAgICAgICAgZWxlbWVudEluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzID0gdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMucGx1Z2luX2NoYW5uZWxfY2xhc3M7XG4gICAgICAgICAgICBlbGVtZW50SW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lID0gdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMubWNfcGx1Z2luX25wbV9uYW1lO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuYWRkSW5jaWRlbnQoZWxlbWVudEluY2lkZW50LCAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEW21jaWRdID0gZWxlbWVudEluY2lkZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBmbGFzaERPTSBtZXRob2QgZXhwZWN0cyB0aGUgbmV3IGVsZW1lbnRzIGNvbGxlY3Rpb24gYW5kOlxuICAgICAgICAgKiAxLiBJZGVudGlmaWVzIHdoaWNoIG9mIHRoZSBleGlzdGluZyBlbGVtZW50SW5jaWRlbnRzIHNob3VsZCBnbyAodGhlIGRvbSBlbGVtZW50IGRvZXMgbm90IHBhcnRpY2lwYXRlIG9uIHRoZSBET01Bd2FyZUdyb3VwIGFueSBtb3JlKVxuICAgICAgICAgKiAyLiBJZGVudGlmaWVzIHdoaWNoIGVsZW1lbnRzIGFyZSBuZXcgYW5kIGFkZCB0aGVpciBlbGVtZW50SW5jaWRlbnQgb24gdGhlIERPTUF3YXJlR3JvdXBcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gLSB3aXRoIGtleXMgYWRkaXRpb25zIGFuZCBkZWxldGlvbnMgZWFjaCBvZiB3aGljaCBob2xkIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IG11c3QgYmVcbiAgICAgICAgICogIGV4ZWN1dGVkIGZvciBhZGRpbmcgdGhlIG5ldyBlbGVtZW50IGluY2lkZW50cyBhbmQgZGVsZXRpbmcgdGhlIGVsZW1lbnQgaW5jaWRlbnRzIHRoYXQgZG8gbm90IGFwcGx5IGFueSBtb3JlXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZsYXNoRE9NJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXNoRE9NKCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuY29udGV4dC5nZXRFbGVtZW50cyh0aGlzLnByb3BzLnNlbGVjdG9yKTtcblxuICAgICAgICAgICAgLy8gZGVsZXRpb25zIGFuZCBhZGRpdGlvbnMgb2YgZWxlbWVudEluY2lkZW50cyB0aGF0IHNob3VsZCB0YWtlIHBsYWNlIGFjY29yZGluZyB0byB0aGUgbmV3IGVsZW1lbnRzXG4gICAgICAgICAgICB2YXIgZGVsZXRpb25zID0gW107XG4gICAgICAgICAgICB2YXIgYWRkaXRpb25zID0gW107XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gYW4gYXJyYXkgdGhhdCB3aWxsIGtlZXAgYWxsIG5ldyBlbGVtZW50cycga2V5cyB0byBiZSB1c2VkIGxhdGVyIGZvciBpZGVudGlmeWluZyBkZWxldGlvbnNcbiAgICAgICAgICAgIHZhciBzdGF5aW5nRWxlbWVudEluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgLy8gZmlyc3QgaWRlbnRpZnkgYWRkaXRpb25zXG5cbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgZWFjaCBvZiB0aGUgbmV3IGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgbWNpZCA9IF90aGlzMi5jb250ZXh0LmdldE1DSUQoZWxlbWVudCk7IC8vIHRha2UgaXRzIG1jaWRcblxuICAgICAgICAgICAgICAgIGlmICghbWNpZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBoYXZlIGFuIG1jaWQgeWV0IHRoYXQgbWVhbnMgaXQncyBhIG5ldyBvbmVcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uID0gZnVuY3Rpb24gYWRkaXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhhdC5fY3JlYXRlRWxlbWVudEluY2lkZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBhZGRpdGlvbnMucHVzaChhZGRpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghX3RoaXMyLmVsZW1lbnRJbmNpZGVudHNCeU1DSUQuaGFzT3duUHJvcGVydHkobWNpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYW4gbWNpZCB0aGF0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdCBvbiB0aGUgZWxlbWVudEluY2lkZW50c1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2FkZGl0aW9uID0gZnVuY3Rpb24gX2FkZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goX2FkZGl0aW9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF5aW5nRWxlbWVudEluY2lkZW50cy5wdXNoKG1jaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcChpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gbmV4dCBzdGVwIGlzIHRvIGNvbXBhcmUgdGhlIGVsZW1lbnRJbmNpZGVudHMgd2l0aCB0aGUgZXhpc3RpbmcgZWxlbWVudHMga2V5IHRvIHNlZSB3aGljaCBcbiAgICAgICAgICAgIC8vIGFyZSBtaXNzaW5nIGZyb20gdGhlIG5ldyBzZXQgYW5kIHB1dCB0aGVtIGZvciBkZWxldGVcbiAgICAgICAgICAgIHZhciBhbHJlYWR5RXhpc3RpbmdFbGVtZW50c0tleXMgPSBPYmplY3Qua2V5cyh0aGlzLmVsZW1lbnRJbmNpZGVudHNCeU1DSUQpO1xuICAgICAgICAgICAgdmFyIHVuZGVyRGVsZXRpb24gPSBhbHJlYWR5RXhpc3RpbmdFbGVtZW50c0tleXMuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RheWluZ0VsZW1lbnRJbmNpZGVudHMuaW5kZXhPZihrZXkpIDwgMDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AyID0gZnVuY3Rpb24gX2xvb3AyKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRpb24gPSBmdW5jdGlvbiBkZWxldGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZW1vdmVJbmNpZGVudCh0aGF0LmVsZW1lbnRJbmNpZGVudHNCeU1DSURbdW5kZXJEZWxldGlvbltpXV0uaWQsIHsgcHJldmVudFNsaXA6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0LmVsZW1lbnRJbmNpZGVudHNCeU1DSURbdGhhdC5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEW3VuZGVyRGVsZXRpb25baV1dLmlkXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRlbGV0aW9ucy5wdXNoKGRlbGV0aW9uKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5kZXJEZWxldGlvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF9sb29wMihpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZhaWxlZEFkZGl0aW9ucyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25SZXN1bHQgPSBhZGRpdGlvbnNbaV0oKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25SZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBmYWlsZWRBZGRpdGlvbnMucHVzaChhZGRpdGlvblJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZGVsZXRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGRlbGV0aW9uc1tfaV0oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmYWlsZWRBZGRpdGlvbnM6IGZhaWxlZEFkZGl0aW9uc1xuXG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgYWRkaXRpb25zOiBhZGRpdGlvbnMsXG4gICAgICAgICAgICAgICAgLy8gICAgIGRlbGV0aW9uczogZGVsZXRpb25zXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXR0cmlidXRlc0NoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzQ2hhbmdlKG5ld0F0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGV4ZWN1dGUgYXR0cmlidXRlIGNoYW5nZSBieSBwYXNzaW5nIGRvd24gdGhlIGNvbW1hbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhwb3J0U3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwb3J0U3RhdGUoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3VucHJvY2Vzc2VkJykpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHMudW5wcm9jZXNzZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JpZ2luYWxJbmNpZGVudC5leHBvcnRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfZ2V0KERPTUF3YXJlSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRE9NQXdhcmVJbmNpZGVudC5wcm90b3R5cGUpLCAnZXhwb3J0U3RhdGUnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ3JvdXBUeXBlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJkb21cIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBET01Bd2FyZUluY2lkZW50O1xufShHcm91cCk7XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NQXdhcmVJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js":
/*!*******************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar allowedStateChanges = {\n    // from which states an Incident can become one of the:\n\n    idle: {\n        forwards: ['transitional'], // only from transitional\n        backwards: ['transitional', 'playing']\n    },\n    transitional: {\n        forwards: ['idle', 'playing', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'completed', 'blocked'],\n        backwards: ['idle', 'playing', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'completed', 'blocked']\n    },\n    playing: {\n        forwards: ['idle', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked'],\n        backwards: ['completed', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked']\n    },\n    waiting: {\n        forwards: ['playing', 'blocked', 'transitional'],\n        backwards: ['playing', 'blocked', 'transitional']\n    },\n    sceneBlockingWaiting: {\n        forwards: ['playing', 'waiting', 'blocked'],\n        backwards: ['playing', 'waiting', 'blocked']\n    },\n    clipBlockingWaiting: {\n        forwards: ['playing', 'waiting', 'blocked'],\n        backwards: ['playing', 'waiting', 'blocked']\n    },\n    completed: {\n        forwards: ['transitional', 'playing'],\n        backwards: ['transitional']\n    },\n    blocked: {\n        forwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting'],\n        backwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting']\n    }\n};\n\nvar timePausingStates = ['blocked', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting'];\n\nvar checkTransition = function checkTransition(oldState, newState, direction) {\n    if (!allowedStateChanges.hasOwnProperty(oldState)) {\n        helper.error('The state ' + oldState + ' is not recognised as one of the supported Incident states');\n        return false;\n    } else if (!allowedStateChanges.hasOwnProperty(newState)) {\n        helper.error('The state ' + newState + ' is not recognised as one of the supported Incident states');\n        return false;\n    }\n\n    if (allowedStateChanges[newState][direction].indexOf(oldState) >= 0) {\n        return true;\n    } else {\n        // helper.error('The transition from ' + oldState + ' to ' + newState + ' is not allowed');\n        return false;\n    }\n};\n\nvar isTimePausingState = function isTimePausingState(state) {\n    return timePausingStates.indexOf(state) >= 0;\n};\n\nmodule.exports = { checkTransition: checkTransition, isTimePausingState: isTimePausingState };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb25maWd1cmF0aW9uL2FsbG93ZWRTdGF0ZUNoYW5nZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb25maWd1cmF0aW9uL2FsbG93ZWRTdGF0ZUNoYW5nZXMuanM/ZDZmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIGFsbG93ZWRTdGF0ZUNoYW5nZXMgPSB7XG4gICAgLy8gZnJvbSB3aGljaCBzdGF0ZXMgYW4gSW5jaWRlbnQgY2FuIGJlY29tZSBvbmUgb2YgdGhlOlxuXG4gICAgaWRsZToge1xuICAgICAgICBmb3J3YXJkczogWyd0cmFuc2l0aW9uYWwnXSwgLy8gb25seSBmcm9tIHRyYW5zaXRpb25hbFxuICAgICAgICBiYWNrd2FyZHM6IFsndHJhbnNpdGlvbmFsJywgJ3BsYXlpbmcnXVxuICAgIH0sXG4gICAgdHJhbnNpdGlvbmFsOiB7XG4gICAgICAgIGZvcndhcmRzOiBbJ2lkbGUnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJywgJ2NsaXBCbG9ja2luZ1dhaXRpbmcnLCAnY29tcGxldGVkJywgJ2Jsb2NrZWQnXSxcbiAgICAgICAgYmFja3dhcmRzOiBbJ2lkbGUnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJywgJ2NsaXBCbG9ja2luZ1dhaXRpbmcnLCAnY29tcGxldGVkJywgJ2Jsb2NrZWQnXVxuICAgIH0sXG4gICAgcGxheWluZzoge1xuICAgICAgICBmb3J3YXJkczogWydpZGxlJywgJ3dhaXRpbmcnLCAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnLCAnY2xpcEJsb2NraW5nV2FpdGluZycsICdibG9ja2VkJ10sXG4gICAgICAgIGJhY2t3YXJkczogWydjb21wbGV0ZWQnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJywgJ2Jsb2NrZWQnXVxuICAgIH0sXG4gICAgd2FpdGluZzoge1xuICAgICAgICBmb3J3YXJkczogWydwbGF5aW5nJywgJ2Jsb2NrZWQnLCAndHJhbnNpdGlvbmFsJ10sXG4gICAgICAgIGJhY2t3YXJkczogWydwbGF5aW5nJywgJ2Jsb2NrZWQnLCAndHJhbnNpdGlvbmFsJ11cbiAgICB9LFxuICAgIHNjZW5lQmxvY2tpbmdXYWl0aW5nOiB7XG4gICAgICAgIGZvcndhcmRzOiBbJ3BsYXlpbmcnLCAnd2FpdGluZycsICdibG9ja2VkJ10sXG4gICAgICAgIGJhY2t3YXJkczogWydwbGF5aW5nJywgJ3dhaXRpbmcnLCAnYmxvY2tlZCddXG4gICAgfSxcbiAgICBjbGlwQmxvY2tpbmdXYWl0aW5nOiB7XG4gICAgICAgIGZvcndhcmRzOiBbJ3BsYXlpbmcnLCAnd2FpdGluZycsICdibG9ja2VkJ10sXG4gICAgICAgIGJhY2t3YXJkczogWydwbGF5aW5nJywgJ3dhaXRpbmcnLCAnYmxvY2tlZCddXG4gICAgfSxcbiAgICBjb21wbGV0ZWQ6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsndHJhbnNpdGlvbmFsJywgJ3BsYXlpbmcnXSxcbiAgICAgICAgYmFja3dhcmRzOiBbJ3RyYW5zaXRpb25hbCddXG4gICAgfSxcbiAgICBibG9ja2VkOiB7XG4gICAgICAgIGZvcndhcmRzOiBbJ3RyYW5zaXRpb25hbCcsICdwbGF5aW5nJywgJ3dhaXRpbmcnLCAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnXSxcbiAgICAgICAgYmFja3dhcmRzOiBbJ3RyYW5zaXRpb25hbCcsICdwbGF5aW5nJywgJ3dhaXRpbmcnLCAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnXVxuICAgIH1cbn07XG5cbnZhciB0aW1lUGF1c2luZ1N0YXRlcyA9IFsnYmxvY2tlZCcsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJywgJ2NsaXBCbG9ja2luZ1dhaXRpbmcnXTtcblxudmFyIGNoZWNrVHJhbnNpdGlvbiA9IGZ1bmN0aW9uIGNoZWNrVHJhbnNpdGlvbihvbGRTdGF0ZSwgbmV3U3RhdGUsIGRpcmVjdGlvbikge1xuICAgIGlmICghYWxsb3dlZFN0YXRlQ2hhbmdlcy5oYXNPd25Qcm9wZXJ0eShvbGRTdGF0ZSkpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKCdUaGUgc3RhdGUgJyArIG9sZFN0YXRlICsgJyBpcyBub3QgcmVjb2duaXNlZCBhcyBvbmUgb2YgdGhlIHN1cHBvcnRlZCBJbmNpZGVudCBzdGF0ZXMnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoIWFsbG93ZWRTdGF0ZUNoYW5nZXMuaGFzT3duUHJvcGVydHkobmV3U3RhdGUpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignVGhlIHN0YXRlICcgKyBuZXdTdGF0ZSArICcgaXMgbm90IHJlY29nbmlzZWQgYXMgb25lIG9mIHRoZSBzdXBwb3J0ZWQgSW5jaWRlbnQgc3RhdGVzJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoYWxsb3dlZFN0YXRlQ2hhbmdlc1tuZXdTdGF0ZV1bZGlyZWN0aW9uXS5pbmRleE9mKG9sZFN0YXRlKSA+PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGhlbHBlci5lcnJvcignVGhlIHRyYW5zaXRpb24gZnJvbSAnICsgb2xkU3RhdGUgKyAnIHRvICcgKyBuZXdTdGF0ZSArICcgaXMgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cbnZhciBpc1RpbWVQYXVzaW5nU3RhdGUgPSBmdW5jdGlvbiBpc1RpbWVQYXVzaW5nU3RhdGUoc3RhdGUpIHtcbiAgICByZXR1cm4gdGltZVBhdXNpbmdTdGF0ZXMuaW5kZXhPZihzdGF0ZSkgPj0gMDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0geyBjaGVja1RyYW5zaXRpb246IGNoZWNrVHJhbnNpdGlvbiwgaXNUaW1lUGF1c2luZ1N0YXRlOiBpc1RpbWVQYXVzaW5nU3RhdGUgfTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js":
/*!***********************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\nknown events:\n- state-change / meta: the name of the new state\n- attribute-rejection / meta: animationID, attributes\n- animation-rejection / meta: animationID\n- conflicts-on-edit\n*/\n\nvar conf = {\n    keyframe_sec_key: 'sec_',\n    elements_data_attribute_name: 'data-motorcortex2-id',\n    selfContainedContextHandler: 'iframe',\n    getMillisecondFromKeyframeKey: function getMillisecondFromKeyframeKey(keyframeKey) {\n        return parseInt(keyframeKey.slice(conf.keyframe_sec_key.length));\n    },\n    logTypes: [{\n        key: 'info',\n        style: 'color: #666;',\n        level: 5\n    }, {\n        key: 'notice',\n        style: 'background: rgba(0, 0, 0, 0.8); color:white; padding:8px;',\n        level: 4\n    }, {\n        key: 'warning',\n        style: 'color: black; background: orange;',\n        level: 2\n    }, {\n        key: 'error',\n        style: 'color: black; background: red;',\n        level: 1\n    }]\n};\n\nmodule.exports = conf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZi5qcz8yNzYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLypcbmtub3duIGV2ZW50czpcbi0gc3RhdGUtY2hhbmdlIC8gbWV0YTogdGhlIG5hbWUgb2YgdGhlIG5ldyBzdGF0ZVxuLSBhdHRyaWJ1dGUtcmVqZWN0aW9uIC8gbWV0YTogYW5pbWF0aW9uSUQsIGF0dHJpYnV0ZXNcbi0gYW5pbWF0aW9uLXJlamVjdGlvbiAvIG1ldGE6IGFuaW1hdGlvbklEXG4tIGNvbmZsaWN0cy1vbi1lZGl0XG4qL1xuXG52YXIgY29uZiA9IHtcbiAgICBrZXlmcmFtZV9zZWNfa2V5OiAnc2VjXycsXG4gICAgZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZTogJ2RhdGEtbW90b3Jjb3J0ZXgyLWlkJyxcbiAgICBzZWxmQ29udGFpbmVkQ29udGV4dEhhbmRsZXI6ICdpZnJhbWUnLFxuICAgIGdldE1pbGxpc2Vjb25kRnJvbUtleWZyYW1lS2V5OiBmdW5jdGlvbiBnZXRNaWxsaXNlY29uZEZyb21LZXlmcmFtZUtleShrZXlmcmFtZUtleSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoa2V5ZnJhbWVLZXkuc2xpY2UoY29uZi5rZXlmcmFtZV9zZWNfa2V5Lmxlbmd0aCkpO1xuICAgIH0sXG4gICAgbG9nVHlwZXM6IFt7XG4gICAgICAgIGtleTogJ2luZm8nLFxuICAgICAgICBzdHlsZTogJ2NvbG9yOiAjNjY2OycsXG4gICAgICAgIGxldmVsOiA1XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdub3RpY2UnLFxuICAgICAgICBzdHlsZTogJ2JhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC44KTsgY29sb3I6d2hpdGU7IHBhZGRpbmc6OHB4OycsXG4gICAgICAgIGxldmVsOiA0XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3YXJuaW5nJyxcbiAgICAgICAgc3R5bGU6ICdjb2xvcjogYmxhY2s7IGJhY2tncm91bmQ6IG9yYW5nZTsnLFxuICAgICAgICBsZXZlbDogMlxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXJyb3InLFxuICAgICAgICBzdHlsZTogJ2NvbG9yOiBibGFjazsgYmFja2dyb3VuZDogcmVkOycsXG4gICAgICAgIGxldmVsOiAxXG4gICAgfV1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29uZjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js":
/*!***************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Channel = __webpack_require__(/*! ../../_Channels/Channel */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar PIChannel = function (_Channel) {\n    _inherits(PIChannel, _Channel);\n\n    function PIChannel() {\n        _classCallCheck(this, PIChannel);\n\n        return _possibleConstructorReturn(this, (PIChannel.__proto__ || Object.getPrototypeOf(PIChannel)).apply(this, arguments));\n    }\n\n    _createClass(PIChannel, [{\n        key: 'onInitialise',\n\n        /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n        value: function onInitialise() {\n            this.incidents = [];\n            this.incidentsById = {};\n        }\n    }, {\n        key: 'slipToLaneForwards',\n        value: function slipToLaneForwards(currentMillisecond, millisecond) {\n            var participatinIncidents = _filter(this.incidents, function (laneItem) {\n                return laneItem.millisecond > currentMillisecond && laneItem.millisecond <= millisecond;\n            });\n            // helper.log(`participating incidents: `, participatinIncidents);\n\n            for (var i = 0; i < participatinIncidents.length; i++) {\n                participatinIncidents[i].incident.command.forwards();\n            }\n\n            // this.runTimeInfo.currentMillisecond = millisecond;\n        }\n    }, {\n        key: 'slipToLaneBackwards',\n        value: function slipToLaneBackwards(currentMillisecond, millisecond) {\n            // helper.log(`participating incidents: `, participatinIncidents);\n            var participatinIncidents = _filter(this.incidents, function (laneItem) {\n                return laneItem.millisecond > millisecond && laneItem.millisecond <= currentMillisecond;\n            });\n\n            for (var i = participatinIncidents.length - 1; i >= 0; i--) {\n                participatinIncidents[i].incident.command.backwards();\n            }\n\n            // this.runTimeInfo.currentMillisecond = millisecond;\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var errors = [];\n            var candidateIncidentsById = {};\n\n            for (var i = 0; i < incidents.length; i++) {\n                candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {\n                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');\n                    errors.push({\n                        type: 'Already existing id',\n                        meta: {\n                            id: incidents[i].id\n                        }\n                    });\n                }\n            }\n\n            if (errors.length > 0) {\n                return {\n                    result: false,\n                    errors: errors\n                };\n            }\n\n            var that = this;\n            var exec = function exec() {\n                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n                that.incidents = that.incidents.concat(incidents);\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidentsArray.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidentsArray[i].id) {\n                            that.incidents[j].millisecond += millisecondsDelta;\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentsArray) {\n            var that = this;\n            var incidentIds = [];\n            for (var i = 0; i < incidentsArray.length; i++) {\n                incidentIds.push(incidentsArray[i].id);\n            }\n\n            var exec = function exec() {\n                var newIncidents = _filter(that.incidents, function (incident) {\n                    return incidentIds.indexOf(incident.id) === -1;\n                });\n\n                that.incidents = newIncidents;\n                for (var _i = 0; _i < incidentIds.length; _i++) {\n                    delete that.incidentsById[incidentIds[_i]];\n                }\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        * @param {array} incidents - [{id, start, end, startDelta}]\n        */\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidents.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidents[i].id) {\n                            that.incidents[j].millisecond += incidents[i].startDelta;\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            if (from < to) {\n                // helper.log(`slipping to lane frowards from ${from} to ${to}`);\n                this.slipToLaneForwards(from, to);\n            } else if (from >= to) {\n                // helper.log(`slipping to lane backwards from ${from} to ${to}`);\n                this.slipToLaneBackwards(from, to);\n            }\n        }\n    }]);\n\n    return PIChannel;\n}(Channel);\n\nmodule.exports = PIChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvQ2hhbm5lbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9DaGFubmVsLmpzP2ZiNDciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi8uLi9fQ2hhbm5lbHMvQ2hhbm5lbCcpO1xudmFyIF9zb3J0QnkgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcycpO1xudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleC5qcycpO1xuXG52YXIgUElDaGFubmVsID0gZnVuY3Rpb24gKF9DaGFubmVsKSB7XG4gICAgX2luaGVyaXRzKFBJQ2hhbm5lbCwgX0NoYW5uZWwpO1xuXG4gICAgZnVuY3Rpb24gUElDaGFubmVsKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUElDaGFubmVsKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBJQ2hhbm5lbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFBJQ2hhbm5lbCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhQSUNoYW5uZWwsIFt7XG4gICAgICAgIGtleTogJ29uSW5pdGlhbGlzZScsXG5cbiAgICAgICAgLypcbiAgICAgICAgdGhpcy5pbmNpZGVudHMgaXMgYSBjb2xsZWN0aW9uIG9mIHtpbmNpZGVudCwgaWQsIG1pbGxpc2Vjb25kfSBvYmplY3RzIGFsd2F5cyBrZXB0IGluIG9yZGVyXG4gICAgICAgICAgICBmcm9tIGxvd2VyIHRvIGhpZ2hlciBtaWxsaXNlY29uZFxuICAgICAgICB0aGlzLmluY2lkZXRuc0J5SWQgaXMgYW4gaW5kZXggb2YgdGhlIGluY2lkZW50cyBrZXB0IGJ5IGlkICh0aGlzLmluY2lkZW50c1tpbmNpZGVudC1pZF0gPSBJbmNpZGVudClcbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xpcFRvTGFuZUZvcndhcmRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsaXBUb0xhbmVGb3J3YXJkcyhjdXJyZW50TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgcGFydGljaXBhdGluSW5jaWRlbnRzID0gX2ZpbHRlcih0aGlzLmluY2lkZW50cywgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kID4gY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKGBwYXJ0aWNpcGF0aW5nIGluY2lkZW50czogYCwgcGFydGljaXBhdGluSW5jaWRlbnRzKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0aWNpcGF0aW5JbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5JbmNpZGVudHNbaV0uaW5jaWRlbnQuY29tbWFuZC5mb3J3YXJkcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzbGlwVG9MYW5lQmFja3dhcmRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNsaXBUb0xhbmVCYWNrd2FyZHMoY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgcGFydGljaXBhdGluZyBpbmNpZGVudHM6IGAsIHBhcnRpY2lwYXRpbkluY2lkZW50cyk7XG4gICAgICAgICAgICB2YXIgcGFydGljaXBhdGluSW5jaWRlbnRzID0gX2ZpbHRlcih0aGlzLmluY2lkZW50cywgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kID4gbWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPD0gY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwYXJ0aWNpcGF0aW5JbmNpZGVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5JbmNpZGVudHNbaV0uaW5jaWRlbnQuY29tbWFuZC5iYWNrd2FyZHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbiB0aGlzIG1ldGhvZCB0aGUgdXNlciBkZWZpbmVzIHRoZSBzcGVjaWZpYyBydWxlcyB0aGF0IGFwcGx5IG9uIHRoZSBwbHVnaW4gaXRzZWxmIGFuZCBvbiB0aGUgSW5jaWRlbnRzIG9mIHRoZSBwbHVnaW4gaXRzZWxmXG4gICAgICAgICAqIFRoZSBtZXRob2Qgc2hvdWxkIGVpdGhlciByZXR1cm4ge3Jlc3VsdDogdHJ1ZX0gb3Ige3Jlc3VsdDogZmFsc2UsIGVycm9yczpbe2Vycm9yLW9iamVjdH1dfSwgd2hlcmUgZXJyb3Itb2JqZWN0IGhhcyB0aGUgc3RydWN0dXJlOlxuICAgICAgICAgKiAge1xuICAgICAgICAgICAgICAgIGluY2lkZW50OiAvLyByZWZlcmVuY2UgdG8gdGhlIEluY2lkZW50IG9iamVjdCB0aGF0IGhhcyBiZWUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgZXJyb3I6IC8vIHRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAgICAgKlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYSBmdW5jdGlvbiB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZUluY2lkZW50c0J5SWQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVJbmNpZGVudHNCeUlkW2luY2lkZW50c1tpXS5pZF0gPSBpbmNpZGVudHNbaV0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZC5oYXNPd25Qcm9wZXJ0eShpbmNpZGVudHNbaV0uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignSW5jaWRlbnQgd2l0aCB0aGUgaWQgJyArIGluY2lkZW50c1tpXS5pZCArICcgYWxyZWFkeSBleGlzdHMuIEFkZGl0aW9uIGlzIHJlamVjdGVkLicpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQWxyZWFkeSBleGlzdGluZyBpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGluY2lkZW50c1tpXS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzQnlJZCA9IE9iamVjdC5hc3NpZ24odGhhdC5pbmNpZGVudHNCeUlkLCBjYW5kaWRhdGVJbmNpZGVudHNCeUlkKTtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IHRoYXQuaW5jaWRlbnRzLmNvbmNhdChpbmNpZGVudHMpO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgICAgIHRoYXQuc2xpcFRvTGFuZUZvcndhcmRzKDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50c0FycmF5IC0gQSBjb2xsZWN0aW9uIG9mIHRoZSBJbmNpZGV0bnMgdG8gZ2V0IGVkaXRlZCBpbiB0aGUgZm9ybTpcbiAgICAgICAge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICB9XG4gICAgICAgIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YS0gdGhlIGRlbHRhIG9mIHRoZSBzdGFyIHBvaW50IG9mIHRoZSBwcm92aWRlZCBpbmNpZGVudHNcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHNBcnJheSwgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzQXJyYXlbaV0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tqXS5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5zbGlwVG9MYW5lRm9yd2FyZHMoMCwgdGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBleGVjIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50c0FycmF5KSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRJZHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudElkcy5wdXNoKGluY2lkZW50c0FycmF5W2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdJbmNpZGVudHMgPSBfZmlsdGVyKHRoYXQuaW5jaWRlbnRzLCBmdW5jdGlvbiAoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50SWRzLmluZGV4T2YoaW5jaWRlbnQuaWQpID09PSAtMTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gbmV3SW5jaWRlbnRzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmNpZGVudElkcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoYXQuaW5jaWRlbnRzQnlJZFtpbmNpZGVudElkc1tfaV1dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuc2xpcFRvTGFuZUZvcndhcmRzKDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gW3tpZCwgc3RhcnQsIGVuZCwgc3RhcnREZWx0YX1dXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrUmVzaXplZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0LmluY2lkZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuaW5jaWRlbnRzW2pdLmlkID09PSBpbmNpZGVudHNbaV0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tqXS5taWxsaXNlY29uZCArPSBpbmNpZGVudHNbaV0uc3RhcnREZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5zbGlwVG9MYW5lRm9yd2FyZHMoMCwgdGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBleGVjIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgIEBwYXJhbSB7aW50fSBmcm9tIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHN0YXJ0IGZyb21cbiAgICAgICAgIEBwYXJhbSB7aW50fSB0byAtIHRoZSBtaWxsaXNlY29uZCB0byBnbyB0b1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZVRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhmcm9tLCB0bykge1xuICAgICAgICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHNsaXBwaW5nIHRvIGxhbmUgZnJvd2FyZHMgZnJvbSAke2Zyb219IHRvICR7dG99YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGlwVG9MYW5lRm9yd2FyZHMoZnJvbSwgdG8pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmcm9tID49IHRvKSB7XG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgc2xpcHBpbmcgdG8gbGFuZSBiYWNrd2FyZHMgZnJvbSAke2Zyb219IHRvICR7dG99YCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zbGlwVG9MYW5lQmFja3dhcmRzKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQSUNoYW5uZWw7XG59KENoYW5uZWwpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBJQ2hhbm5lbDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js":
/*!*********************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProgrammaticIncident = __webpack_require__(/*! ./ProgrammaticIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\");\n\nvar DummyIncident = function (_ProgrammaticIncident) {\n    _inherits(DummyIncident, _ProgrammaticIncident);\n\n    function DummyIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, DummyIncident);\n\n        return _possibleConstructorReturn(this, (DummyIncident.__proto__ || Object.getPrototypeOf(DummyIncident)).call(this, {\n            command: function command() {} }, {\n            id: props.id\n        }));\n    }\n\n    return DummyIncident;\n}(ProgrammaticIncident);\n\nmodule.exports = DummyIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvRHVtbXlJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9EdW1teUluY2lkZW50LmpzPzI3ZDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQcm9ncmFtbWF0aWNJbmNpZGVudCA9IHJlcXVpcmUoJy4vUHJvZ3JhbW1hdGljSW5jaWRlbnQnKTtcblxudmFyIER1bW15SW5jaWRlbnQgPSBmdW5jdGlvbiAoX1Byb2dyYW1tYXRpY0luY2lkZW50KSB7XG4gICAgX2luaGVyaXRzKER1bW15SW5jaWRlbnQsIF9Qcm9ncmFtbWF0aWNJbmNpZGVudCk7XG5cbiAgICBmdW5jdGlvbiBEdW1teUluY2lkZW50KCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEdW1teUluY2lkZW50KTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKER1bW15SW5jaWRlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihEdW1teUluY2lkZW50KSkuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBjb21tYW5kOiBmdW5jdGlvbiBjb21tYW5kKCkge30gfSwge1xuICAgICAgICAgICAgaWQ6IHByb3BzLmlkXG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRHVtbXlJbmNpZGVudDtcbn0oUHJvZ3JhbW1hdGljSW5jaWRlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1bW15SW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js":
/*!****************************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Incident = __webpack_require__(/*! ../../_BaseClasses/Incident */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\n\nvar ProgrammaticIncident = function (_Incident) {\n    _inherits(ProgrammaticIncident, _Incident);\n\n    function ProgrammaticIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, ProgrammaticIncident);\n\n        var _this = _possibleConstructorReturn(this, (ProgrammaticIncident.__proto__ || Object.getPrototypeOf(ProgrammaticIncident)).call(this, attrs, props));\n\n        _this.command = {\n            forwards: function forwards() {},\n            backwards: function backwards() {}\n        };\n\n        if (!attrs.hasOwnProperty('command')) {\n            var _ret;\n\n            helper.error('Programmatic Incidents must have the \"command\" included on the properties');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        } else {\n            // if the user passed an object as the command\n            if (helper.isObject(attrs.command)) {\n                // we expect to find two functions residing on the \"forwards\" and \"backwards\" keys\n                if (attrs.command.hasOwnProperty('forwards')) {\n                    if (helper.isFunction(attrs.command.forwards)) {\n                        _this.command.forwards = attrs.command.forwards;\n                    } else {\n                        var _ret2;\n\n                        helper.error('ProgrammaticIncident\\'s command.forwards key should hold a function. ' + _typeof(attrs.command.forwards) + ' passed');\n                        return _ret2 = false, _possibleConstructorReturn(_this, _ret2);\n                    }\n                }\n                if (attrs.command.hasOwnProperty('backwards')) {\n                    if (helper.isFunction(attrs.command.backwards)) {\n                        _this.command.backwards = attrs.command.backwards;\n                    } else {\n                        var _ret3;\n\n                        helper.error('ProgrammaticIncident\\'s command.backwards key should hold a function. ' + _typeof(attrs.command.backwards) + ' passed');\n                        return _ret3 = false, _possibleConstructorReturn(_this, _ret3);\n                    }\n                }\n            } else if (helper.isFunction(attrs.command)) {\n                // else if the passed argument is a function we only hold this as the forwards command\n                _this.command.forwards = attrs.command;\n            } else {\n                var _ret4;\n\n                // else if the passed argument is neither function nor object return false\n                helper.error('command key of ProgrammaticIncidents\\' construction properties must be either an object or a function. ' + _typeof(attrs.command) + ' passed');\n                return _ret4 = false, _possibleConstructorReturn(_this, _ret4);\n            }\n        }\n        return _this;\n    }\n\n    _createClass(ProgrammaticIncident, [{\n        key: 'onPlay',\n        value: function onPlay(props) {\n            if (this.speed > 0) {\n                this.command.forwards(props);\n            } else {\n                this.command.backwards(props);\n            }\n        }\n    }]);\n\n    return ProgrammaticIncident;\n}(Incident);\n\nmodule.exports = ProgrammaticIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvUHJvZ3JhbW1hdGljSW5jaWRlbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvUHJvZ3JhbW1hdGljSW5jaWRlbnQuanM/ZTIzYiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgSW5jaWRlbnQgPSByZXF1aXJlKCcuLi8uLi9fQmFzZUNsYXNzZXMvSW5jaWRlbnQnKTtcblxudmFyIFByb2dyYW1tYXRpY0luY2lkZW50ID0gZnVuY3Rpb24gKF9JbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhQcm9ncmFtbWF0aWNJbmNpZGVudCwgX0luY2lkZW50KTtcblxuICAgIGZ1bmN0aW9uIFByb2dyYW1tYXRpY0luY2lkZW50KCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmFtbWF0aWNJbmNpZGVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFByb2dyYW1tYXRpY0luY2lkZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUHJvZ3JhbW1hdGljSW5jaWRlbnQpKS5jYWxsKHRoaXMsIGF0dHJzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLmNvbW1hbmQgPSB7XG4gICAgICAgICAgICBmb3J3YXJkczogZnVuY3Rpb24gZm9yd2FyZHMoKSB7fSxcbiAgICAgICAgICAgIGJhY2t3YXJkczogZnVuY3Rpb24gYmFja3dhcmRzKCkge31cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoIWF0dHJzLmhhc093blByb3BlcnR5KCdjb21tYW5kJykpIHtcbiAgICAgICAgICAgIHZhciBfcmV0O1xuXG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1Byb2dyYW1tYXRpYyBJbmNpZGVudHMgbXVzdCBoYXZlIHRoZSBcImNvbW1hbmRcIiBpbmNsdWRlZCBvbiB0aGUgcHJvcGVydGllcycpO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXQgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHVzZXIgcGFzc2VkIGFuIG9iamVjdCBhcyB0aGUgY29tbWFuZFxuICAgICAgICAgICAgaWYgKGhlbHBlci5pc09iamVjdChhdHRycy5jb21tYW5kKSkge1xuICAgICAgICAgICAgICAgIC8vIHdlIGV4cGVjdCB0byBmaW5kIHR3byBmdW5jdGlvbnMgcmVzaWRpbmcgb24gdGhlIFwiZm9yd2FyZHNcIiBhbmQgXCJiYWNrd2FyZHNcIiBrZXlzXG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLmNvbW1hbmQuaGFzT3duUHJvcGVydHkoJ2ZvcndhcmRzJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhlbHBlci5pc0Z1bmN0aW9uKGF0dHJzLmNvbW1hbmQuZm9yd2FyZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21tYW5kLmZvcndhcmRzID0gYXR0cnMuY29tbWFuZC5mb3J3YXJkcztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmV0MjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdQcm9ncmFtbWF0aWNJbmNpZGVudFxcJ3MgY29tbWFuZC5mb3J3YXJkcyBrZXkgc2hvdWxkIGhvbGQgYSBmdW5jdGlvbi4gJyArIF90eXBlb2YoYXR0cnMuY29tbWFuZC5mb3J3YXJkcykgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZXQyID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0Mik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJzLmNvbW1hbmQuaGFzT3duUHJvcGVydHkoJ2JhY2t3YXJkcycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWxwZXIuaXNGdW5jdGlvbihhdHRycy5jb21tYW5kLmJhY2t3YXJkcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbW1hbmQuYmFja3dhcmRzID0gYXR0cnMuY29tbWFuZC5iYWNrd2FyZHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JldDM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignUHJvZ3JhbW1hdGljSW5jaWRlbnRcXCdzIGNvbW1hbmQuYmFja3dhcmRzIGtleSBzaG91bGQgaG9sZCBhIGZ1bmN0aW9uLiAnICsgX3R5cGVvZihhdHRycy5jb21tYW5kLmJhY2t3YXJkcykgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZXQzID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0Myk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhlbHBlci5pc0Z1bmN0aW9uKGF0dHJzLmNvbW1hbmQpKSB7XG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gd2Ugb25seSBob2xkIHRoaXMgYXMgdGhlIGZvcndhcmRzIGNvbW1hbmRcbiAgICAgICAgICAgICAgICBfdGhpcy5jb21tYW5kLmZvcndhcmRzID0gYXR0cnMuY29tbWFuZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZXQ0O1xuXG4gICAgICAgICAgICAgICAgLy8gZWxzZSBpZiB0aGUgcGFzc2VkIGFyZ3VtZW50IGlzIG5laXRoZXIgZnVuY3Rpb24gbm9yIG9iamVjdCByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ2NvbW1hbmQga2V5IG9mIFByb2dyYW1tYXRpY0luY2lkZW50c1xcJyBjb25zdHJ1Y3Rpb24gcHJvcGVydGllcyBtdXN0IGJlIGVpdGhlciBhbiBvYmplY3Qgb3IgYSBmdW5jdGlvbi4gJyArIF90eXBlb2YoYXR0cnMuY29tbWFuZCkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmV0NCA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUHJvZ3JhbW1hdGljSW5jaWRlbnQsIFt7XG4gICAgICAgIGtleTogJ29uUGxheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblBsYXkocHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZC5mb3J3YXJkcyhwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZC5iYWNrd2FyZHMocHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFByb2dyYW1tYXRpY0luY2lkZW50O1xufShJbmNpZGVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvZ3JhbW1hdGljSW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js":
/*!************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ProgrammaticIncident = __webpack_require__(/*! ./ProgrammaticIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\");\nvar DummyIncident = __webpack_require__(/*! ./DummyIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js\");\nvar PIChannel = __webpack_require__(/*! ./Channel */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js\");\n\nmodule.exports = {\n    npm_name: \"@kissmybutton/programmatic-incidents\",\n    incidents: [{\n        exportable: ProgrammaticIncident\n    }, {\n        exportable: DummyIncident\n    }],\n    channel: PIChannel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9tYWluLmpzP2M1ZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvZ3JhbW1hdGljSW5jaWRlbnQgPSByZXF1aXJlKCcuL1Byb2dyYW1tYXRpY0luY2lkZW50Jyk7XG52YXIgRHVtbXlJbmNpZGVudCA9IHJlcXVpcmUoJy4vRHVtbXlJbmNpZGVudCcpO1xudmFyIFBJQ2hhbm5lbCA9IHJlcXVpcmUoJy4vQ2hhbm5lbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBucG1fbmFtZTogXCJAa2lzc215YnV0dG9uL3Byb2dyYW1tYXRpYy1pbmNpZGVudHNcIixcbiAgICBpbmNpZGVudHM6IFt7XG4gICAgICAgIGV4cG9ydGFibGU6IFByb2dyYW1tYXRpY0luY2lkZW50XG4gICAgfSwge1xuICAgICAgICBleHBvcnRhYmxlOiBEdW1teUluY2lkZW50XG4gICAgfV0sXG4gICAgY2hhbm5lbDogUElDaGFubmVsXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js":
/*!***************************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Clip = __webpack_require__(/*! ./SCGroup */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\");\nvar Channel = __webpack_require__(/*! ./SCIChannel */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\n\nfunction ClipFromDefinition(definition) {\n    if (definition === null) {\n        helper.error('ClipFromDefinition expects the defintion parameter');\n        return false;\n    }\n\n    var clip = new Clip(definition.attrs, definition.props);\n    clip.plugin_channel_class = Channel;\n    clip.mc_plugin_npm_name = \"@kissmybutton/self-contained-incidents\";\n    constructIncidents(clip, definition);\n\n    return clip;\n}\n\nfunction constructIncidents(parentIncident, incidentDefinition) {\n    if (parentIncident.hasIncidents) {\n        for (var i = 0; i < incidentDefinition.incidents.length; i++) {\n            var incidentItem = incidentDefinition.incidents[i];\n            // incidentItem is an object:\n            /*\n            {\n                id\n                millisecond\n                incident\n            }\n            */\n\n            var theNewIncident = new incidentItem.incident.Incident(incidentItem.incident.attrs, incidentItem.incident.props);\n            theNewIncident.plugin_channel_class = incidentItem.incident.plugin_channel_class;\n            theNewIncident.mc_plugin_npm_name = incidentItem.incident.mc_plugin_npm_name;\n            parentIncident.addIncident(theNewIncident, incidentItem.millisecond);\n            constructIncidents(theNewIncident, incidentItem.incident);\n        }\n    }\n}\n\nmodule.exports = ClipFromDefinition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL0NsaXBGcm9tRGVmaW5pdGlvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvQ2xpcEZyb21EZWZpbml0aW9uLmpzP2Q0NmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgQ2xpcCA9IHJlcXVpcmUoJy4vU0NHcm91cCcpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuL1NDSUNoYW5uZWwnKTtcblxuZnVuY3Rpb24gQ2xpcEZyb21EZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICBpZiAoZGVmaW5pdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0NsaXBGcm9tRGVmaW5pdGlvbiBleHBlY3RzIHRoZSBkZWZpbnRpb24gcGFyYW1ldGVyJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpcCA9IG5ldyBDbGlwKGRlZmluaXRpb24uYXR0cnMsIGRlZmluaXRpb24ucHJvcHMpO1xuICAgIGNsaXAucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBDaGFubmVsO1xuICAgIGNsaXAubWNfcGx1Z2luX25wbV9uYW1lID0gXCJAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50c1wiO1xuICAgIGNvbnN0cnVjdEluY2lkZW50cyhjbGlwLCBkZWZpbml0aW9uKTtcblxuICAgIHJldHVybiBjbGlwO1xufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RJbmNpZGVudHMocGFyZW50SW5jaWRlbnQsIGluY2lkZW50RGVmaW5pdGlvbikge1xuICAgIGlmIChwYXJlbnRJbmNpZGVudC5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudERlZmluaXRpb24uaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRJdGVtID0gaW5jaWRlbnREZWZpbml0aW9uLmluY2lkZW50c1tpXTtcbiAgICAgICAgICAgIC8vIGluY2lkZW50SXRlbSBpcyBhbiBvYmplY3Q6XG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgdmFyIHRoZU5ld0luY2lkZW50ID0gbmV3IGluY2lkZW50SXRlbS5pbmNpZGVudC5JbmNpZGVudChpbmNpZGVudEl0ZW0uaW5jaWRlbnQuYXR0cnMsIGluY2lkZW50SXRlbS5pbmNpZGVudC5wcm9wcyk7XG4gICAgICAgICAgICB0aGVOZXdJbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IGluY2lkZW50SXRlbS5pbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcztcbiAgICAgICAgICAgIHRoZU5ld0luY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9IGluY2lkZW50SXRlbS5pbmNpZGVudC5tY19wbHVnaW5fbnBtX25hbWU7XG4gICAgICAgICAgICBwYXJlbnRJbmNpZGVudC5hZGRJbmNpZGVudCh0aGVOZXdJbmNpZGVudCwgaW5jaWRlbnRJdGVtLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIGNvbnN0cnVjdEluY2lkZW50cyh0aGVOZXdJbmNpZGVudCwgaW5jaWRlbnRJdGVtLmluY2lkZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDbGlwRnJvbURlZmluaXRpb247Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js":
/*!****************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Group = __webpack_require__(/*! ../../_BaseClasses/Group */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\n// context handlers\nvar IframeContextHandler = __webpack_require__(/*! ./helpers/IframeContextHandler */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js\");\nvar PlainContextHandler = __webpack_require__(/*! ./helpers/PlainContextHandler */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js\");\nvar OpenIframeContextHandler = __webpack_require__(/*! ./helpers/InheritStyleIframeContextHanlder */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js\");\n\nvar Clip = function (_Group) {\n    _inherits(Clip, _Group);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     * - type (optional, defaults to \"iframe\") the type of the Clip. It can be one of the:\n     *  - iframe \n     *  - plain\n    */\n    function Clip() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, Clip);\n\n        var attrsToPass = void 0,\n            propsToUse = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToUse = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToUse = oldProps;\n        }\n\n        if (!helper.isObject(propsToUse)) {\n            var _ret;\n\n            helper.error('Self Contained Incident expects an object on its second argument on the constructor. ' + (typeof propsToUse === 'undefined' ? 'undefined' : _typeof(propsToUse)) + ' passed');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        }\n\n        var clipType = conf.selfContainedContextHandler;\n        if (propsToUse.hasOwnProperty(\"type\")) {\n            clipType = propsToUse.type;\n        }\n\n        if (!propsToUse.hasOwnProperty('html') && (clipType === \"iframe\" || clipType === \"openiframe\")) {\n            var _ret2;\n\n            helper.error('Self Contained Incident expects the html key on its constructor properties which is missing');\n            return _ret2 = false, _possibleConstructorReturn(_this, _ret2);\n        }\n\n        if (!propsToUse.hasOwnProperty('css') && clipType === \"iframe\") {\n            var _ret3;\n\n            helper.error('Self Contained Incident expects the css key on its constructor properties which is missing');\n            return _ret3 = false, _possibleConstructorReturn(_this, _ret3);\n        }\n\n        if (!propsToUse.hasOwnProperty('host')) {\n            var _ret4;\n\n            helper.error('Self Contained Incident expects the host key on its constructor properties which is missing');\n            return _ret4 = false, _possibleConstructorReturn(_this, _ret4);\n        }\n\n        var ContextHanlder = null;\n        if (clipType === 'iframe') {\n            ContextHanlder = IframeContextHandler;\n        } else if (clipType === \"plain\") {\n            ContextHanlder = PlainContextHandler;\n        } else if (clipType === \"openiframe\") {\n            ContextHanlder = OpenIframeContextHandler;\n        } else {\n            var _ret5;\n\n            helper.error('Clip type ' + clipType + ' is not supported');\n            return _ret5 = false, _possibleConstructorReturn(_this, _ret5);\n        }\n\n        var contextHanlder = new ContextHanlder(propsToUse);\n\n        var _this = _possibleConstructorReturn(this, (Clip.__proto__ || Object.getPrototypeOf(Clip)).call(this, attrsToPass, propsToUse));\n\n        _this.ownContext = contextHanlder.context;\n        _this.isTheClip = true;\n        _this.onClipInitialise();\n        return _this;\n    }\n\n    _createClass(Clip, [{\n        key: 'onClipInitialise',\n        value: function onClipInitialise() {\n            // called when group gets initialised\n        }\n    }, {\n        key: '_getChannel',\n        value: function _getChannel(channelId) {\n            if (!this.instantiatedChannels.hasOwnProperty(channelId)) {\n                return null;\n            } else {\n                return this.instantiatedChannels[channelId];\n            }\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.speed > 0) {\n                if (!this.checkStateTransition('completed')) {\n                    return false;\n                }\n            } else {\n                if (!this.checkStateTransition('idle')) {\n                    return false;\n                }\n            }\n\n            this.onBeforeComplete(props);\n\n            if (this.speed > 0) {\n                if (this.checkParentScene()) {\n                    // if it has parent, so it's not the root Clip\n                    this.runTimeInfo.currentMillisecond = this.duration; // normal behaviour\n                } else {\n                    // if it is the root clip\n                    this.stop();\n                    this._setState('idle');\n                    this.setCurrentMillisecond(0);\n                }\n            } else {\n                this._setState('idle');\n            }\n\n            if (this.speed > 0) {\n                this.runTimeInfo.currentMillisecond = this.duration;\n            } else {\n                this.runTimeInfo.currentMillisecond = 0;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            this.ownContext.unmount();\n        }\n    }, {\n        key: 'renderHTML',\n        value: function renderHTML() {}\n    }, {\n        key: 'renderCSS',\n        value: function renderCSS() {}\n    }]);\n\n    return Clip;\n}(Group);\n\nmodule.exports = Clip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL1NDR3JvdXAuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL1NDR3JvdXAuanM/YmM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuLi8uLi9fQmFzZUNsYXNzZXMvR3JvdXAnKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xuXG4vLyBjb250ZXh0IGhhbmRsZXJzXG52YXIgSWZyYW1lQ29udGV4dEhhbmRsZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvSWZyYW1lQ29udGV4dEhhbmRsZXInKTtcbnZhciBQbGFpbkNvbnRleHRIYW5kbGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL1BsYWluQ29udGV4dEhhbmRsZXInKTtcbnZhciBPcGVuSWZyYW1lQ29udGV4dEhhbmRsZXIgPSByZXF1aXJlKCcuL2hlbHBlcnMvSW5oZXJpdFN0eWxlSWZyYW1lQ29udGV4dEhhbmxkZXInKTtcblxudmFyIENsaXAgPSBmdW5jdGlvbiAoX0dyb3VwKSB7XG4gICAgX2luaGVyaXRzKENsaXAsIF9Hcm91cCk7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgICAqIC0gY3NzICh0aGUgY3NzIHRlbXBsYXRlIG9mIHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGNvbnRhaW5lclBhcmFtcyAoYW4gb2JqZWN0IHRoYXQgaG9sZHMgcGFyYW1ldGVycyB0byBhZmZlY3QgdGhlIGNvbnRhaW5lciBvZiB0aGUgaXNvbGF0ZWQgdHJlZSwgZS5nLiB3aWR0aCwgaGVpZ2h0IGV0YylcbiAgICAgKiAtIHR5cGUgKG9wdGlvbmFsLCBkZWZhdWx0cyB0byBcImlmcmFtZVwiKSB0aGUgdHlwZSBvZiB0aGUgQ2xpcC4gSXQgY2FuIGJlIG9uZSBvZiB0aGU6XG4gICAgICogIC0gaWZyYW1lIFxuICAgICAqICAtIHBsYWluXG4gICAgKi9cbiAgICBmdW5jdGlvbiBDbGlwKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgb2xkUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsaXApO1xuXG4gICAgICAgIHZhciBhdHRyc1RvUGFzcyA9IHZvaWQgMCxcbiAgICAgICAgICAgIHByb3BzVG9Vc2UgPSB2b2lkIDA7XG5cbiAgICAgICAgLypcbiAgICAgICAgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIElmIHRoZSB1c2VyIGRvZXNuJ3QgcGFzcyBhIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IgdGhlbiB0aGlzIGlzIFxuICAgICAgICB0aGUgbmV3IHdheSBvZiBpbml0aWFsaXNpbmcgYSBHcm91cCAob25seSBwcm9wcykuXG4gICAgICAgICovXG4gICAgICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYXR0cnNUb1Bhc3MgPSB7fTtcbiAgICAgICAgICAgIHByb3BzVG9Vc2UgPSBwcm9wcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzVG9Vc2UgPSBvbGRQcm9wcztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVscGVyLmlzT2JqZWN0KHByb3BzVG9Vc2UpKSB7XG4gICAgICAgICAgICB2YXIgX3JldDtcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdTZWxmIENvbnRhaW5lZCBJbmNpZGVudCBleHBlY3RzIGFuIG9iamVjdCBvbiBpdHMgc2Vjb25kIGFyZ3VtZW50IG9uIHRoZSBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHNUb1VzZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcHNUb1VzZSkpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbGlwVHlwZSA9IGNvbmYuc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyO1xuICAgICAgICBpZiAocHJvcHNUb1VzZS5oYXNPd25Qcm9wZXJ0eShcInR5cGVcIikpIHtcbiAgICAgICAgICAgIGNsaXBUeXBlID0gcHJvcHNUb1VzZS50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wc1RvVXNlLmhhc093blByb3BlcnR5KCdodG1sJykgJiYgKGNsaXBUeXBlID09PSBcImlmcmFtZVwiIHx8IGNsaXBUeXBlID09PSBcIm9wZW5pZnJhbWVcIikpIHtcbiAgICAgICAgICAgIHZhciBfcmV0MjtcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdTZWxmIENvbnRhaW5lZCBJbmNpZGVudCBleHBlY3RzIHRoZSBodG1sIGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gX3JldDIgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHNUb1VzZS5oYXNPd25Qcm9wZXJ0eSgnY3NzJykgJiYgY2xpcFR5cGUgPT09IFwiaWZyYW1lXCIpIHtcbiAgICAgICAgICAgIHZhciBfcmV0MztcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdTZWxmIENvbnRhaW5lZCBJbmNpZGVudCBleHBlY3RzIHRoZSBjc3Mga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0MyA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wc1RvVXNlLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIHZhciBfcmV0NDtcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdTZWxmIENvbnRhaW5lZCBJbmNpZGVudCBleHBlY3RzIHRoZSBob3N0IGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gX3JldDQgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBDb250ZXh0SGFubGRlciA9IG51bGw7XG4gICAgICAgIGlmIChjbGlwVHlwZSA9PT0gJ2lmcmFtZScpIHtcbiAgICAgICAgICAgIENvbnRleHRIYW5sZGVyID0gSWZyYW1lQ29udGV4dEhhbmRsZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xpcFR5cGUgPT09IFwicGxhaW5cIikge1xuICAgICAgICAgICAgQ29udGV4dEhhbmxkZXIgPSBQbGFpbkNvbnRleHRIYW5kbGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGNsaXBUeXBlID09PSBcIm9wZW5pZnJhbWVcIikge1xuICAgICAgICAgICAgQ29udGV4dEhhbmxkZXIgPSBPcGVuSWZyYW1lQ29udGV4dEhhbmRsZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3JldDU7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ2xpcCB0eXBlICcgKyBjbGlwVHlwZSArICcgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXQ1ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0NSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dEhhbmxkZXIgPSBuZXcgQ29udGV4dEhhbmxkZXIocHJvcHNUb1VzZSk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENsaXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihDbGlwKSkuY2FsbCh0aGlzLCBhdHRyc1RvUGFzcywgcHJvcHNUb1VzZSkpO1xuXG4gICAgICAgIF90aGlzLm93bkNvbnRleHQgPSBjb250ZXh0SGFubGRlci5jb250ZXh0O1xuICAgICAgICBfdGhpcy5pc1RoZUNsaXAgPSB0cnVlO1xuICAgICAgICBfdGhpcy5vbkNsaXBJbml0aWFsaXNlKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQ2xpcCwgW3tcbiAgICAgICAga2V5OiAnb25DbGlwSW5pdGlhbGlzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNsaXBJbml0aWFsaXNlKCkge1xuICAgICAgICAgICAgLy8gY2FsbGVkIHdoZW4gZ3JvdXAgZ2V0cyBpbml0aWFsaXNlZFxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0Q2hhbm5lbCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q2hhbm5lbChjaGFubmVsSWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscy5oYXNPd25Qcm9wZXJ0eShjaGFubmVsSWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2NoYW5uZWxJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NvbXBsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBsZXRlKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdjb21wbGV0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ2lkbGUnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uQmVmb3JlQ29tcGxldGUocHJvcHMpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaGFzIHBhcmVudCwgc28gaXQncyBub3QgdGhlIHJvb3QgQ2xpcFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247IC8vIG5vcm1hbCBiZWhhdmlvdXJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBpdCBpcyB0aGUgcm9vdCBjbGlwXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaWxsaXNlY29uZCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdpZGxlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGFzdFdpc2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdFdpc2goKSB7XG4gICAgICAgICAgICB0aGlzLm93bkNvbnRleHQudW5tb3VudCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXJIVE1MJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhUTUwoKSB7fVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyQ1NTJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNTUygpIHt9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIENsaXA7XG59KEdyb3VwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGlwOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Channel = __webpack_require__(/*! ../../_Channels/Channel */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar SCIChannel = function (_Channel) {\n    _inherits(SCIChannel, _Channel);\n\n    function SCIChannel() {\n        _classCallCheck(this, SCIChannel);\n\n        return _possibleConstructorReturn(this, (SCIChannel.__proto__ || Object.getPrototypeOf(SCIChannel)).apply(this, arguments));\n    }\n\n    _createClass(SCIChannel, [{\n        key: 'onInitialise',\n\n        /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n        value: function onInitialise() {\n            this.incidents = [];\n            this.incidentsById = {};\n        }\n    }, {\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;\n            }\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        * \n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} - \n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var errors = [];\n            var candidateIncidentsById = {};\n\n            for (var i = 0; i < incidents.length; i++) {\n                candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {\n                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');\n                    errors.push({\n                        type: 'Already existing id',\n                        meta: {\n                            id: incidents[i].id\n                        }\n                    });\n                }\n            }\n\n            if (errors.length > 0) {\n                return {\n                    result: false,\n                    errors: errors\n                };\n            }\n\n            var that = this;\n            var exec = function exec() {\n                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n                that.incidents = that.incidents.concat(incidents);\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n                for (var _i = 0; _i < incidents.length; _i++) {\n                    incidents[_i].incident.goTo(that.runTimeInfo.currentMillisecond - incidents[_i].millisecond);\n                }\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidentsArray.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidentsArray[i].id) {\n                            that.incidents[j].millisecond += millisecondsDelta;\n                            that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n            };\n\n            return { result: true, execute: exec };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentsArray) {\n            var that = this;\n            var incidentIds = [];\n            for (var i = 0; i < incidentsArray.length; i++) {\n                incidentIds.push(incidentsArray[i].id);\n            }\n\n            var exec = function exec() {\n                var newIncidents = _filter(that.incidents, function (incident) {\n                    return incidentIds.indexOf(incident.id) === -1;\n                });\n\n                that.incidents = newIncidents;\n                for (var _i2 = 0; _i2 < incidentIds.length; _i2++) {\n                    delete that.incidentsById[incidentIds[_i2]];\n                }\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        * @param {array} incidents - [{id, start, end, startDelta}] \n        */\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidents.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidents[i].id) {\n                            that.incidents[j].millisecond += incidents[i].startDelta;\n                            that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.goTo(to - this.incidents[i].millisecond);\n            }\n        }\n    }]);\n\n    return SCIChannel;\n}(Channel);\n\nmodule.exports = SCIChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL1NDSUNoYW5uZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL1NDSUNoYW5uZWwuanM/ZmFjNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4uLy4uL19DaGFubmVscy9DaGFubmVsJyk7XG52YXIgX3NvcnRCeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4LmpzJyk7XG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4LmpzJyk7XG5cbnZhciBTQ0lDaGFubmVsID0gZnVuY3Rpb24gKF9DaGFubmVsKSB7XG4gICAgX2luaGVyaXRzKFNDSUNoYW5uZWwsIF9DaGFubmVsKTtcblxuICAgIGZ1bmN0aW9uIFNDSUNoYW5uZWwoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTQ0lDaGFubmVsKTtcblxuICAgICAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFNDSUNoYW5uZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihTQ0lDaGFubmVsKSkuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNDSUNoYW5uZWwsIFt7XG4gICAgICAgIGtleTogJ29uSW5pdGlhbGlzZScsXG5cbiAgICAgICAgLypcbiAgICAgICAgdGhpcy5pbmNpZGVudHMgaXMgYSBjb2xsZWN0aW9uIG9mIHtpbmNpZGVudCwgaWQsIG1pbGxpc2Vjb25kfSBvYmplY3RzIGFsd2F5cyBrZXB0IGluIG9yZGVyXG4gICAgICAgICAgICBmcm9tIGxvd2VyIHRvIGhpZ2hlciBtaWxsaXNlY29uZFxuICAgICAgICB0aGlzLmluY2lkZXRuc0J5SWQgaXMgYW4gaW5kZXggb2YgdGhlIGluY2lkZW50cyBrZXB0IGJ5IGlkICh0aGlzLmluY2lkZW50c1tpbmNpZGVudC1pZF0gPSBJbmNpZGVudClcbiAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzID0gW107XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Jlc2l6ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbiB0aGlzIG1ldGhvZCB0aGUgdXNlciBkZWZpbmVzIHRoZSBzcGVjaWZpYyBydWxlcyB0aGF0IGFwcGx5IG9uIHRoZSBwbHVnaW4gaXRzZWxmIGFuZCBvbiB0aGUgSW5jaWRlbnRzIG9mIHRoZSBwbHVnaW4gaXRzZWxmXG4gICAgICAgICAqIFRoZSBtZXRob2Qgc2hvdWxkIGVpdGhlciByZXR1cm4ge3Jlc3VsdDogdHJ1ZX0gb3Ige3Jlc3VsdDogZmFsc2UsIGVycm9yczpbe2Vycm9yLW9iamVjdH1dfSwgd2hlcmUgZXJyb3Itb2JqZWN0IGhhcyB0aGUgc3RydWN0dXJlOlxuICAgICAgICAgKiAge1xuICAgICAgICAgICAgICAgIGluY2lkZW50OiAvLyByZWZlcmVuY2UgdG8gdGhlIEluY2lkZW50IG9iamVjdCB0aGF0IGhhcyBiZWUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgZXJyb3I6IC8vIHRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAgICAgKiBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtIFxuICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6dHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiAvLyBhIGZ1bmN0aW9uIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0FkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gW107XG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZCA9IHt9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNhbmRpZGF0ZUluY2lkZW50c0J5SWRbaW5jaWRlbnRzW2ldLmlkXSA9IGluY2lkZW50c1tpXS5pbmNpZGVudDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNCeUlkLmhhc093blByb3BlcnR5KGluY2lkZW50c1tpXS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdJbmNpZGVudCB3aXRoIHRoZSBpZCAnICsgaW5jaWRlbnRzW2ldLmlkICsgJyBhbHJlYWR5IGV4aXN0cy4gQWRkaXRpb24gaXMgcmVqZWN0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBbHJlYWR5IGV4aXN0aW5nIGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaW5jaWRlbnRzW2ldLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNCeUlkID0gT2JqZWN0LmFzc2lnbih0aGF0LmluY2lkZW50c0J5SWQsIGNhbmRpZGF0ZUluY2lkZW50c0J5SWQpO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gdGhhdC5pbmNpZGVudHMuY29uY2F0KGluY2lkZW50cyk7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBfc29ydEJ5KHRoYXQuaW5jaWRlbnRzLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluY2lkZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRzW19pXS5pbmNpZGVudC5nb1RvKHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kIC0gaW5jaWRlbnRzW19pXS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBleGVjIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzQXJyYXkgLSBBIGNvbGxlY3Rpb24gb2YgdGhlIEluY2lkZXRucyB0byBnZXQgZWRpdGVkIGluIHRoZSBmb3JtOlxuICAgICAgICB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgIH1cbiAgICAgICAgQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhLSB0aGUgZGVsdGEgb2YgdGhlIHN0YXIgcG9pbnQgb2YgdGhlIHByb3ZpZGVkIGluY2lkZW50c1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0VkaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tFZGl0KGluY2lkZW50c0FycmF5LCBtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0LmluY2lkZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuaW5jaWRlbnRzW2pdLmlkID09PSBpbmNpZGVudHNBcnJheVtpXS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzW2pdLm1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kc0RlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzW2ldLmluY2lkZW50LmdvVG8odGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLSB0aGF0LmluY2lkZW50c1tpXS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0RlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShpbmNpZGVudHNBcnJheSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluY2lkZW50SWRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnRJZHMucHVzaChpbmNpZGVudHNBcnJheVtpXS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SW5jaWRlbnRzID0gX2ZpbHRlcih0aGF0LmluY2lkZW50cywgZnVuY3Rpb24gKGluY2lkZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudElkcy5pbmRleE9mKGluY2lkZW50LmlkKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IG5ld0luY2lkZW50cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbmNpZGVudElkcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0LmluY2lkZW50c0J5SWRbaW5jaWRlbnRJZHNbX2kyXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBleGVjIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBbe2lkLCBzdGFydCwgZW5kLCBzdGFydERlbHRhfV0gXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrUmVzaXplZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGF0LmluY2lkZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoYXQuaW5jaWRlbnRzW2pdLmlkID09PSBpbmNpZGVudHNbaV0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tqXS5taWxsaXNlY29uZCArPSBpbmNpZGVudHNbaV0uc3RhcnREZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tpXS5pbmNpZGVudC5nb1RvKHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kIC0gdGhhdC5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBfc29ydEJ5KHRoYXQuaW5jaWRlbnRzLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgQHBhcmFtIHtpbnR9IGZyb20gLSB0aGUgbWlsbGlzZWNvbmQgdG8gc3RhcnQgZnJvbVxuICAgICAgICAgQHBhcmFtIHtpbnR9IHRvIC0gdGhlIG1pbGxpc2Vjb25kIHRvIGdvIHRvXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZ29Ubyh0byAtIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBTQ0lDaGFubmVsO1xufShDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTQ0lDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js":
/*!*************************************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar IframeContextHandler = function () {\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n    */\n    function IframeContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, IframeContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('html')) {\n            helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('css')) {\n            helper.error('ContextHandler expects the css key on its constructor properties which is missing');\n            return false;\n        }\n\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        this.isDOM = true;\n\n        var ownerDocument = props.host.ownerDocument;\n\n        if (!ownerDocument.getElementById(\"@kissmybutton/motorcortex/iframeContextHandler/css\")) {\n            var seamlessCSS = '\\n            iframe[seamless]{\\n                background-color: transparent;\\n                border: 0px none transparent;\\n                padding: 0px;\\n                overflow: hidden;\\n            }\\n            ';\n            var iframesCSS = ownerDocument.createElement('style');\n            iframesCSS.id = \"@kissmybutton/motorcortex/iframeContextHandler/css\";\n            iframesCSS.type = 'text/css';\n            var Head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n            if (iframesCSS.styleSheet) {\n                iframesCSS.styleSheet.cssText = seamlessCSS;\n            } else {\n                iframesCSS.appendChild(ownerDocument.createTextNode(seamlessCSS));\n            }\n\n            Head.appendChild(iframesCSS);\n        }\n\n        // Create an iframe:\n        var iframe = ownerDocument.createElement('iframe');\n        props.host.appendChild(iframe);\n        iframe.setAttribute(\"seamless\", \"seamless\");\n        if (props.hasOwnProperty('containerParams')) {\n            if (props.containerParams.hasOwnProperty('width')) {\n                iframe.setAttribute('width', props.containerParams.width);\n            }\n            if (props.containerParams.hasOwnProperty('height')) {\n                iframe.setAttribute('height', props.containerParams.height);\n            }\n        }\n        // Initialise the iframe\n        iframe.src = '';\n        // Put it in the document (but hidden):\n        var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n        if (iframeDocument.document) {\n            iframeDocument = iframeDocument.document;\n        }\n\n        iframeDocument.write(helper.renderTemplate(props.html, { params: props.initParams }));\n\n        var bodyFixCSS = '\\n        body{\\n            padding:0;\\n            margin:0;\\n        }\\n        ';\n\n        var styleTag = iframeDocument.createElement('style');\n        styleTag.type = 'text/css';\n        if (styleTag.styleSheet) {\n            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: props.initParams }) + bodyFixCSS;\n        } else {\n            styleTag.appendChild(ownerDocument.createTextNode(props.css + bodyFixCSS));\n        }\n        var head = iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];\n        head.appendChild(styleTag);\n\n        this.context = {\n            document: iframeDocument,\n            window: iframe.contentWindow || iframe,\n            rootElement: iframeDocument.body,\n            unmount: function unmount() {\n                props.host.removeChild(iframe);\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this)\n        };\n\n        iframeDocument.close();\n    }\n\n    _createClass(IframeContextHandler, [{\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.document.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return IframeContextHandler;\n}();\n\nmodule.exports = IframeContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvSWZyYW1lQ29udGV4dEhhbmRsZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvSWZyYW1lQ29udGV4dEhhbmRsZXIuanM/Nzg1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbmlmcmFtZVtzZWFtbGVzc117XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiAwcHggbm9uZSB0cmFuc3BhcmVudDtcbiAgICBwYWRkaW5nOiAwcHg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxubWlnaHQgbmVlZCBtb3JlIHdvcmsgZm9yIElFLiBTZWUgaGVyZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI5MjA5MjQ4XG4qL1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIElmcmFtZUNvbnRleHRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGFuIG9iamVjdCB0aGF0IHNob3VsZCBjb250YWluIGFsbCBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogLSBodG1sICh0aGUgaHRtbCB0ZW1wbGF0ZSB0byByZW5kZXIpXG4gICAgICogLSBjc3MgKHRoZSBjc3MgdGVtcGxhdGUgb2YgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBpbml0UGFyYW1zIChvcHRpb25hbCAvIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXJlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIGJvdGggb24gdGhlIGNzcyBhbmQgdGhlIGh0bWwgdGVtcGxhdGVzIGluIG9yZGVyIHRvIHJlbmRlcilcbiAgICAgKiAtIGhvc3QgKGFuIEVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBob3N0IHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gY29udGFpbmVyUGFyYW1zIChhbiBvYmplY3QgdGhhdCBob2xkcyBwYXJhbWV0ZXJzIHRvIGFmZmVjdCB0aGUgY29udGFpbmVyIG9mIHRoZSBpc29sYXRlZCB0cmVlLCBlLmcuIHdpZHRoLCBoZWlnaHQgZXRjKVxuICAgICovXG4gICAgZnVuY3Rpb24gSWZyYW1lQ29udGV4dEhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElmcmFtZUNvbnRleHRIYW5kbGVyKTtcblxuICAgICAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyBhbiBvYmplY3Qgb24gaXRzIGNvbnN0cnVjdG9yLiAnICsgKHR5cGVvZiBwcm9wcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcHMpKSArICcgcGFzc2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdodG1sJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaHRtbCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY3NzJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgY3NzIGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5pdFBhcmFtcyA9IHByb3BzLmluaXRQYXJhbXM7XG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2luaXRQYXJhbXMnKSkge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ0NvbnRleHRIYW5kbGVyIGdvdCBudWxsIGluaXRQYXJhbXMnKTtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2hvc3QnKSkge1xuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdDb250ZXh0SGFuZGxlciBleHBlY3RzIHRoZSBob3N0IGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzRE9NID0gdHJ1ZTtcblxuICAgICAgICB2YXIgb3duZXJEb2N1bWVudCA9IHByb3BzLmhvc3Qub3duZXJEb2N1bWVudDtcblxuICAgICAgICBpZiAoIW93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2lmcmFtZUNvbnRleHRIYW5kbGVyL2Nzc1wiKSkge1xuICAgICAgICAgICAgdmFyIHNlYW1sZXNzQ1NTID0gJ1xcbiAgICAgICAgICAgIGlmcmFtZVtzZWFtbGVzc117XFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgICAgICAgICAgICAgICBib3JkZXI6IDBweCBub25lIHRyYW5zcGFyZW50O1xcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAwcHg7XFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiBoaWRkZW47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICc7XG4gICAgICAgICAgICB2YXIgaWZyYW1lc0NTUyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIGlmcmFtZXNDU1MuaWQgPSBcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvaWZyYW1lQ29udGV4dEhhbmRsZXIvY3NzXCI7XG4gICAgICAgICAgICBpZnJhbWVzQ1NTLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICAgICAgdmFyIEhlYWQgPSBvd25lckRvY3VtZW50LmhlYWQgfHwgb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICAgICAgaWYgKGlmcmFtZXNDU1Muc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgIGlmcmFtZXNDU1Muc3R5bGVTaGVldC5jc3NUZXh0ID0gc2VhbWxlc3NDU1M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmcmFtZXNDU1MuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzZWFtbGVzc0NTUykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBIZWFkLmFwcGVuZENoaWxkKGlmcmFtZXNDU1MpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGlmcmFtZTpcbiAgICAgICAgdmFyIGlmcmFtZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIHByb3BzLmhvc3QuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZShcInNlYW1sZXNzXCIsIFwic2VhbWxlc3NcIik7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY29udGFpbmVyUGFyYW1zJykpIHtcbiAgICAgICAgICAgIGlmIChwcm9wcy5jb250YWluZXJQYXJhbXMuaGFzT3duUHJvcGVydHkoJ3dpZHRoJykpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHByb3BzLmNvbnRhaW5lclBhcmFtcy53aWR0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMuY29udGFpbmVyUGFyYW1zLmhhc093blByb3BlcnR5KCdoZWlnaHQnKSkge1xuICAgICAgICAgICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGlmcmFtZVxuICAgICAgICBpZnJhbWUuc3JjID0gJyc7XG4gICAgICAgIC8vIFB1dCBpdCBpbiB0aGUgZG9jdW1lbnQgKGJ1dCBoaWRkZW4pOlxuICAgICAgICB2YXIgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdyB8fCBpZnJhbWUuY29udGVudERvY3VtZW50O1xuICAgICAgICBpZiAoaWZyYW1lRG9jdW1lbnQuZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lRG9jdW1lbnQuZG9jdW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZnJhbWVEb2N1bWVudC53cml0ZShoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuaHRtbCwgeyBwYXJhbXM6IHByb3BzLmluaXRQYXJhbXMgfSkpO1xuXG4gICAgICAgIHZhciBib2R5Rml4Q1NTID0gJ1xcbiAgICAgICAgYm9keXtcXG4gICAgICAgICAgICBwYWRkaW5nOjA7XFxuICAgICAgICAgICAgbWFyZ2luOjA7XFxuICAgICAgICB9XFxuICAgICAgICAnO1xuXG4gICAgICAgIHZhciBzdHlsZVRhZyA9IGlmcmFtZURvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgIHN0eWxlVGFnLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICBpZiAoc3R5bGVUYWcuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgc3R5bGVUYWcuc3R5bGVTaGVldC5jc3NUZXh0ID0gaGVscGVyLnJlbmRlclRlbXBsYXRlKHByb3BzLmNzcywgeyBwYXJhbXM6IHByb3BzLmluaXRQYXJhbXMgfSkgKyBib2R5Rml4Q1NTO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwcm9wcy5jc3MgKyBib2R5Rml4Q1NTKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhlYWQgPSBpZnJhbWVEb2N1bWVudC5oZWFkIHx8IGlmcmFtZURvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuXG4gICAgICAgIHRoaXMuY29udGV4dCA9IHtcbiAgICAgICAgICAgIGRvY3VtZW50OiBpZnJhbWVEb2N1bWVudCxcbiAgICAgICAgICAgIHdpbmRvdzogaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLFxuICAgICAgICAgICAgcm9vdEVsZW1lbnQ6IGlmcmFtZURvY3VtZW50LmJvZHksXG4gICAgICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgICAgICAgICAgIHByb3BzLmhvc3QucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFbGVtZW50czogdGhpcy5nZXRFbGVtZW50cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0TUNJRDogdGhpcy5nZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXRNQ0lEOiB0aGlzLnNldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRDogdGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKElmcmFtZUNvbnRleHRIYW5kbGVyLCBbe1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250ZXh0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBtY2lkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXSc7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSWZyYW1lQ29udGV4dEhhbmRsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lQ29udGV4dEhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js":
/*!*************************************************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js ***!
  \*************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar IframeContextHandler = function () {\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n    */\n    function IframeContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, IframeContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('html')) {\n            helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n            return false;\n        }\n\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        this.isDOM = true;\n\n        var ownerDocument = props.host.ownerDocument;\n\n        // Create an iframe:\n        var iframe = ownerDocument.createElement('iframe');\n        iframe.style.display = \"none\";\n        props.host.appendChild(iframe);\n        var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n        if (iframeDocument.document) {\n            iframeDocument = iframeDocument.document;\n        }\n        var rootElement = void 0;\n\n        iframe.onload = function () {\n            iframe.onload = null;\n\n            iframeDocument.write('<mc_iframe_root_element>');\n            rootElement = iframeDocument.querySelector('mc_iframe_root_element');\n            props.host.appendChild(rootElement);\n            var html = helper.renderTemplate(props.html, { params: props.initParams });\n            iframeDocument.write(html);\n            iframeDocument.write('</mc_iframe_root_element>');\n            iframeDocument.close();\n        };\n\n        // Initialise the iframe\n        iframe.src = '';\n\n        this.context = {\n            document: iframeDocument,\n            window: iframe.contentWindow || iframe,\n            rootElement: rootElement,\n            unmount: function unmount() {\n                props.host.removeChild(iframe);\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this)\n        };\n    }\n\n    _createClass(IframeContextHandler, [{\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.document.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return IframeContextHandler;\n}();\n\nmodule.exports = IframeContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvSW5oZXJpdFN0eWxlSWZyYW1lQ29udGV4dEhhbmxkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvSW5oZXJpdFN0eWxlSWZyYW1lQ29udGV4dEhhbmxkZXIuanM/NzQ1MCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLypcbmlmcmFtZVtzZWFtbGVzc117XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgYm9yZGVyOiAwcHggbm9uZSB0cmFuc3BhcmVudDtcbiAgICBwYWRkaW5nOiAwcHg7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxubWlnaHQgbmVlZCBtb3JlIHdvcmsgZm9yIElFLiBTZWUgaGVyZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI5MjA5MjQ4XG4qL1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIElmcmFtZUNvbnRleHRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGFuIG9iamVjdCB0aGF0IHNob3VsZCBjb250YWluIGFsbCBvZiB0aGUgZm9sbG93aW5nIGtleXM6XG4gICAgICogLSBodG1sICh0aGUgaHRtbCB0ZW1wbGF0ZSB0byByZW5kZXIpXG4gICAgICogLSBpbml0UGFyYW1zIChvcHRpb25hbCAvIHRoZSBpbml0aWFsaXNhdGlvbiBwYXJhbWV0ZXJlcyB0aGF0IHdpbGwgYmUgcGFzc2VkIGJvdGggb24gdGhlIGNzcyBhbmQgdGhlIGh0bWwgdGVtcGxhdGVzIGluIG9yZGVyIHRvIHJlbmRlcilcbiAgICAgKiAtIGhvc3QgKGFuIEVsZW1lbnQgb2JqZWN0IHRoYXQgd2lsbCBob3N0IHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICovXG4gICAgZnVuY3Rpb24gSWZyYW1lQ29udGV4dEhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIElmcmFtZUNvbnRleHRIYW5kbGVyKTtcblxuICAgICAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyBhbiBvYmplY3Qgb24gaXRzIGNvbnN0cnVjdG9yLiAnICsgKHR5cGVvZiBwcm9wcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcHMpKSArICcgcGFzc2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdodG1sJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaHRtbCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRQYXJhbXMgPSBwcm9wcy5pbml0UGFyYW1zO1xuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdpbml0UGFyYW1zJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdDb250ZXh0SGFuZGxlciBnb3QgbnVsbCBpbml0UGFyYW1zJyk7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0RPTSA9IHRydWU7XG5cbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBwcm9wcy5ob3N0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGFuIGlmcmFtZTpcbiAgICAgICAgdmFyIGlmcmFtZSA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHByb3BzLmhvc3QuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgaWYgKGlmcmFtZURvY3VtZW50LmRvY3VtZW50KSB7XG4gICAgICAgICAgICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZURvY3VtZW50LmRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciByb290RWxlbWVudCA9IHZvaWQgMDtcblxuICAgICAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmcmFtZURvY3VtZW50LndyaXRlKCc8bWNfaWZyYW1lX3Jvb3RfZWxlbWVudD4nKTtcbiAgICAgICAgICAgIHJvb3RFbGVtZW50ID0gaWZyYW1lRG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWNfaWZyYW1lX3Jvb3RfZWxlbWVudCcpO1xuICAgICAgICAgICAgcHJvcHMuaG9zdC5hcHBlbmRDaGlsZChyb290RWxlbWVudCk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5odG1sLCB7IHBhcmFtczogcHJvcHMuaW5pdFBhcmFtcyB9KTtcbiAgICAgICAgICAgIGlmcmFtZURvY3VtZW50LndyaXRlKGh0bWwpO1xuICAgICAgICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoJzwvbWNfaWZyYW1lX3Jvb3RfZWxlbWVudD4nKTtcbiAgICAgICAgICAgIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbGlzZSB0aGUgaWZyYW1lXG4gICAgICAgIGlmcmFtZS5zcmMgPSAnJztcblxuICAgICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgICAgICBkb2N1bWVudDogaWZyYW1lRG9jdW1lbnQsXG4gICAgICAgICAgICB3aW5kb3c6IGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZSxcbiAgICAgICAgICAgIHJvb3RFbGVtZW50OiByb290RWxlbWVudCxcbiAgICAgICAgICAgIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuaG9zdC5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRzOiB0aGlzLmdldEVsZW1lbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRNQ0lEOiB0aGlzLmdldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldE1DSUQ6IHRoaXMuc2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKElmcmFtZUNvbnRleHRIYW5kbGVyLCBbe1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb250ZXh0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNQ0lEKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldE1DSUQoZWxlbWVudCwgbWNpZCkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lLCBtY2lkKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXSc7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSWZyYW1lQ29udGV4dEhhbmRsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lQ29udGV4dEhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js":
/*!************************************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar PlainContextHandler = function () {\n    function PlainContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, PlainContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        var ownerDocument = props.host.ownerDocument;\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (props.hasOwnProperty('html')) {\n            props.host.innerHTML = helper.renderTemplate(props.html, { params: initParams });\n        }\n\n        if (props.hasOwnProperty('css')) {\n            var styleTag = ownerDocument.createElement('style');\n            styleTag.type = 'text/css';\n            if (styleTag.styleSheet) {\n                styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: initParams });\n            } else {\n                styleTag.appendChild(ownerDocument.createTextNode(props.css));\n            }\n            var head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n            head.appendChild(styleTag);\n        }\n\n        this.isDOM = true;\n\n        this.context = {\n            document: ownerDocument,\n            window: ownerDocument.defaultView,\n            rootElement: props.host,\n            unmount: function unmount() {\n                props.host.innerHTML = \"\";\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this)\n        };\n    }\n\n    _createClass(PlainContextHandler, [{\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.rootElement.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return PlainContextHandler;\n}();\n\nmodule.exports = PlainContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvUGxhaW5Db250ZXh0SGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9QbGFpbkNvbnRleHRIYW5kbGVyLmpzP2FmNjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xuXG52YXIgUGxhaW5Db250ZXh0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQbGFpbkNvbnRleHRIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQbGFpbkNvbnRleHRIYW5kbGVyKTtcblxuICAgICAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wcykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyBhbiBvYmplY3Qgb24gaXRzIGNvbnN0cnVjdG9yLiAnICsgKHR5cGVvZiBwcm9wcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcHMpKSArICcgcGFzc2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBwcm9wcy5ob3N0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIHZhciBpbml0UGFyYW1zID0gcHJvcHMuaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaW5pdFBhcmFtcycpKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnQ29udGV4dEhhbmRsZXIgZ290IG51bGwgaW5pdFBhcmFtcycpO1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdodG1sJykpIHtcbiAgICAgICAgICAgIHByb3BzLmhvc3QuaW5uZXJIVE1MID0gaGVscGVyLnJlbmRlclRlbXBsYXRlKHByb3BzLmh0bWwsIHsgcGFyYW1zOiBpbml0UGFyYW1zIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdjc3MnKSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlVGFnID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICAgICAgc3R5bGVUYWcudHlwZSA9ICd0ZXh0L2Nzcyc7XG4gICAgICAgICAgICBpZiAoc3R5bGVUYWcuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgICAgIHN0eWxlVGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5jc3MsIHsgcGFyYW1zOiBpbml0UGFyYW1zIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5hcHBlbmRDaGlsZChvd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHByb3BzLmNzcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhlYWQgPSBvd25lckRvY3VtZW50LmhlYWQgfHwgb3duZXJEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmlzRE9NID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgICAgICBkb2N1bWVudDogb3duZXJEb2N1bWVudCxcbiAgICAgICAgICAgIHdpbmRvdzogb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyxcbiAgICAgICAgICAgIHJvb3RFbGVtZW50OiBwcm9wcy5ob3N0LFxuICAgICAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5ob3N0LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWxlbWVudHM6IHRoaXMuZ2V0RWxlbWVudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldE1DSUQ6IHRoaXMuZ2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2V0TUNJRDogdGhpcy5zZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQ6IHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lELmJpbmQodGhpcylcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGxhaW5Db250ZXh0SGFuZGxlciwgW3tcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29udGV4dC5yb290RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldE1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUNJRChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNQ0lEKGVsZW1lbnQsIG1jaWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSwgbWNpZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRTZWxlY3RvckJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSArICc9XCInICsgbWNpZCArICdcIl0nO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBsYWluQ29udGV4dEhhbmRsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gUGxhaW5Db250ZXh0SGFuZGxlcjsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js":
/*!*************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js ***!
  \*************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Clip = __webpack_require__(/*! ./SCGroup */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\");\nvar Channel = __webpack_require__(/*! ./SCIChannel */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\nvar ClipFromDefinition = __webpack_require__(/*! ./ClipFromDefinition */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\");\n\nmodule.exports = {\n    npm_name: \"@kissmybutton/self-contained-incidents\",\n    incidents: [{\n        exportable: Clip\n    }],\n    channel: Channel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL21haW4uanM/OWFjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBDbGlwID0gcmVxdWlyZSgnLi9TQ0dyb3VwJyk7XG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4vU0NJQ2hhbm5lbCcpO1xudmFyIENsaXBGcm9tRGVmaW5pdGlvbiA9IHJlcXVpcmUoJy4vQ2xpcEZyb21EZWZpbml0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG5wbV9uYW1lOiBcIkBraXNzbXlidXR0b24vc2VsZi1jb250YWluZWQtaW5jaWRlbnRzXCIsXG4gICAgaW5jaWRlbnRzOiBbe1xuICAgICAgICBleHBvcnRhYmxlOiBDbGlwXG4gICAgfV0sXG4gICAgY2hhbm5lbDogQ2hhbm5lbFxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/main.js":
/*!**************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/main.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Channel = __webpack_require__(/*! ./_Channels/Channel */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar Group = __webpack_require__(/*! ./_BaseClasses/Group */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar Incident = __webpack_require__(/*! ./_BaseClasses/Incident */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\nvar TimedIncident = __webpack_require__(/*! ./_BaseClasses/TimedIncident */ \"../node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\");\nvar Helper = __webpack_require__(/*! ./_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");var helper = new Helper();\nvar AttributeChannel = __webpack_require__(/*! ./_Channels/_Attribute/AttributeChannel */ \"../node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\");\nvar ClipFromDefinition = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/ClipFromDefinition */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\");\n\nvar conf = __webpack_require__(/*! ./configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Timer = __webpack_require__(/*! ./utils/Timer */ \"../node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js\");\n\nvar checkPlugin = function checkPlugin(main) {\n    if (main.hasOwnProperty('default')) {\n        main = main.default;\n    }\n\n    var plugin_name = main.npm_name;\n    var check = true;\n\n    if (!main.hasOwnProperty('incidents')) {\n        helper.error('Error on plugin ' + plugin_name + '. A plugin must expose at least one Incident.\\n        Exposed plugin Incidents should be defined on the \"incidents\" key of the main.js file.');\n        check = false;\n    }\n\n    if (!helper.isArray(main.incidents)) {\n        helper.error('Error on plugin ' + plugin_name + '. thePlugin exposed Incidents are defined on the \"incidents\" key of the main.js file in array format.\\n        Please refer to the documentation');\n        check = false;\n    } else {\n        for (var i = 0; i < main.incidents.length; i++) {\n            var exposedIncidentDefinition = main.incidents[i];\n            if (_typeof(exposedIncidentDefinition.exportable) === \"object\") {\n                if (exposedIncidentDefinition.exportable.hasOwnProperty('default')) {\n                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;\n                }\n            }\n            if (!(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {\n                helper.error('Error on plugin ' + plugin_name + '. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\\'t.\\n                Please refer to documentation');\n                check = false;\n            }\n\n            if (!exposedIncidentDefinition.hasOwnProperty('propTypes')) {\n                helper.log('Warning on plugin ' + plugin_name + '.\\n                It\\'s always good for plugins to define the supported propTypes of their exposed Incidents\\' supported properties.\\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\\'t.\\n                Please refer to documentation', 'warning');\n            }\n        }\n    }\n\n    if (!main.hasOwnProperty('channel')) {\n        helper.error('Error on plugin ' + plugin_name + '. A plugin must always define its Channel on the \"channel\" key of the main.js file.\\n        It\\'s missing. Please refer to documentation');\n        check = false;\n    } else {\n        if (_typeof(main.channel) === \"object\") {\n            if (main.channel.hasOwnProperty('default')) {\n                main.channel = main.channel.default;\n            }\n        }\n    }\n\n    return check;\n};\n\n// plugin_name is the unique name of the plugin\nfunction loadPlugin(plugin) {\n    if (plugin.hasOwnProperty('default')) {\n        plugin = plugin.default;\n    }\n\n    if (!plugin.hasOwnProperty('npm_name')) {\n        plugin.npm_name = 'plugin_' + new Date().getTime();\n    }\n\n    if (!plugin.hasOwnProperty('channel')) {\n        plugin.channel = Channel;\n    }\n    if (!checkPlugin(plugin)) {\n        return false;\n    } else {\n        // thePlugin is the plugin object which will hold on its keys\n        // the names of the exposed Incidents of its. The keys of this object\n        // are going to be identical with the names of the classes exposed\n        var thePlugin = {};\n\n        if (plugin.hasOwnProperty('clip')) {\n            if (_typeof(plugin.clip) === \"object\") {\n                if (plugin.clip.hasOwnProperty('default')) {\n                    plugin.clip = plugin.clip.default;\n                }\n            }\n            thePlugin.Clip = plugin.clip;\n        }\n\n        // for each of the exposed Incidents\n\n        var _loop = function _loop(i) {\n            var incidentClass = plugin.incidents[i].exportable;\n\n            // TODO hanlde the different css style isolation versions through the cssIsolation parameter of the containerParams of the incident\n\n            // dynamically assign getters on the Incident's name key of the thePlugin object\n            Object.defineProperty(thePlugin, incidentClass.name, {\n                get: function get() {\n                    // the getter will construct a wrapper class which on the constructor will instantiate an object of the\n                    // exposed class, set to it the plugin name and channel class parameters and return\n                    // it from the constructor\n                    var WrapperClass = function WrapperClass(attrs, props) {\n                        _classCallCheck(this, WrapperClass);\n\n                        var instantiatedIncident = new incidentClass(attrs, props);\n                        instantiatedIncident.plugin_channel_class = plugin.channel;\n                        instantiatedIncident.mc_plugin_npm_name = plugin.npm_name;\n\n                        if (plugin.channel.type === \"attributes\" && (!props.hasOwnProperty('selector') || props.selector === null || props.selector === undefined)) {\n                            helper.error('You tried to instantiate an Incident of plugin ' + plugin.npm_name + ' without passing props.selector. This plugin uses the AttributeChannel and thus all of its incidents must \\n                                    be initialised with a valid props.selector.');\n                            return false;\n                        }\n\n                        // it's a good idea to both validate the props here before returning the new object\n                        // also is a good idea to create a Proxy for the instantiated Incident to prevent setting:\n                        // id, plugin_channel_class, mc_plugin_npm_name\n\n                        return instantiatedIncident;\n                    };\n\n                    ;\n\n                    return WrapperClass;\n                }\n            });\n        };\n\n        for (var i = 0; i < plugin.incidents.length; i++) {\n            _loop(i);\n        }\n        return thePlugin;\n    }\n}\n\nvar ProgrammaticIncidentPluginDefinition = __webpack_require__(/*! ./corePlugins/ProgrammaticIncidents/main.js */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js\");\nvar ProgrammaticIncidentPlugin = loadPlugin(ProgrammaticIncidentPluginDefinition);\n\nvar SelfContainedIncidentsPluginDefinition = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/main.js */ \"../node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js\");\nvar SelfContainedIncidentsPlugin = loadPlugin(SelfContainedIncidentsPluginDefinition);\n\nvar TimeCapsule = __webpack_require__(/*! ./_coreUtils/TimeCapsule */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\n\nmodule.exports = {\n    Channel: Channel,\n    Group: Group,\n    Clip: SelfContainedIncidentsPlugin.Clip,\n    ClipFromDefinition: ClipFromDefinition,\n    Incident: Incident,\n    ProgrammaticIncident: ProgrammaticIncidentPlugin.ProgrammaticIncident,\n    DummyIncident: ProgrammaticIncidentPlugin.DummyIncident,\n    TimedIncident: TimedIncident,\n\n    // channels\n    AttributeChannel: AttributeChannel,\n\n    TimeCapsule: TimeCapsule,\n\n    conf: conf,\n    Timer: Timer,\n\n    Helper: Helper,\n\n    loadPlugin: loadPlugin\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9tYWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvbWFpbi5qcz8zMjI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQ2hhbm5lbCA9IHJlcXVpcmUoJy4vX0NoYW5uZWxzL0NoYW5uZWwnKTtcbnZhciBHcm91cCA9IHJlcXVpcmUoJy4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG52YXIgSW5jaWRlbnQgPSByZXF1aXJlKCcuL19CYXNlQ2xhc3Nlcy9JbmNpZGVudCcpO1xudmFyIFRpbWVkSW5jaWRlbnQgPSByZXF1aXJlKCcuL19CYXNlQ2xhc3Nlcy9UaW1lZEluY2lkZW50Jyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi9fY29yZVV0aWxzL0hlbHBlcicpO3ZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgQXR0cmlidXRlQ2hhbm5lbCA9IHJlcXVpcmUoJy4vX0NoYW5uZWxzL19BdHRyaWJ1dGUvQXR0cmlidXRlQ2hhbm5lbCcpO1xudmFyIENsaXBGcm9tRGVmaW5pdGlvbiA9IHJlcXVpcmUoJy4vY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9DbGlwRnJvbURlZmluaXRpb24nKTtcblxudmFyIGNvbmYgPSByZXF1aXJlKCcuL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBUaW1lciA9IHJlcXVpcmUoJy4vdXRpbHMvVGltZXInKTtcblxudmFyIGNoZWNrUGx1Z2luID0gZnVuY3Rpb24gY2hlY2tQbHVnaW4obWFpbikge1xuICAgIGlmIChtYWluLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgbWFpbiA9IG1haW4uZGVmYXVsdDtcbiAgICB9XG5cbiAgICB2YXIgcGx1Z2luX25hbWUgPSBtYWluLm5wbV9uYW1lO1xuICAgIHZhciBjaGVjayA9IHRydWU7XG5cbiAgICBpZiAoIW1haW4uaGFzT3duUHJvcGVydHkoJ2luY2lkZW50cycpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignRXJyb3Igb24gcGx1Z2luICcgKyBwbHVnaW5fbmFtZSArICcuIEEgcGx1Z2luIG11c3QgZXhwb3NlIGF0IGxlYXN0IG9uZSBJbmNpZGVudC5cXG4gICAgICAgIEV4cG9zZWQgcGx1Z2luIEluY2lkZW50cyBzaG91bGQgYmUgZGVmaW5lZCBvbiB0aGUgXCJpbmNpZGVudHNcIiBrZXkgb2YgdGhlIG1haW4uanMgZmlsZS4nKTtcbiAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWhlbHBlci5pc0FycmF5KG1haW4uaW5jaWRlbnRzKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0Vycm9yIG9uIHBsdWdpbiAnICsgcGx1Z2luX25hbWUgKyAnLiB0aGVQbHVnaW4gZXhwb3NlZCBJbmNpZGVudHMgYXJlIGRlZmluZWQgb24gdGhlIFwiaW5jaWRlbnRzXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUgaW4gYXJyYXkgZm9ybWF0LlxcbiAgICAgICAgUGxlYXNlIHJlZmVyIHRvIHRoZSBkb2N1bWVudGF0aW9uJyk7XG4gICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYWluLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24gPSBtYWluLmluY2lkZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChfdHlwZW9mKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlID0gZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLnByb3RvdHlwZSBpbnN0YW5jZW9mIEluY2lkZW50KSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignRXJyb3Igb24gcGx1Z2luICcgKyBwbHVnaW5fbmFtZSArICcuIEV4cG9ydGFibGUgSW5jaWRlbnRzIGJ5IGFueSBwbHVnaW4gbXVzdCBleHRlbmQgb25lIG9mIHRoZSBiYXNlIGNsYXNzZXMgcHJvdmlkZWQgYnkgTW90b3JDb3J0ZXguXFxuICAgICAgICAgICAgICAgICcgKyBleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUuY29uc3RydWN0b3IubmFtZSArICcgZG9lc25cXCd0LlxcbiAgICAgICAgICAgICAgICBQbGVhc2UgcmVmZXIgdG8gZG9jdW1lbnRhdGlvbicpO1xuICAgICAgICAgICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5oYXNPd25Qcm9wZXJ0eSgncHJvcFR5cGVzJykpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIubG9nKCdXYXJuaW5nIG9uIHBsdWdpbiAnICsgcGx1Z2luX25hbWUgKyAnLlxcbiAgICAgICAgICAgICAgICBJdFxcJ3MgYWx3YXlzIGdvb2QgZm9yIHBsdWdpbnMgdG8gZGVmaW5lIHRoZSBzdXBwb3J0ZWQgcHJvcFR5cGVzIG9mIHRoZWlyIGV4cG9zZWQgSW5jaWRlbnRzXFwnIHN1cHBvcnRlZCBwcm9wZXJ0aWVzLlxcbiAgICAgICAgICAgICAgICAnICsgZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmNvbnN0cnVjdG9yLm5hbWUgKyAnIGRvZXNuXFwndC5cXG4gICAgICAgICAgICAgICAgUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb24nLCAnd2FybmluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFtYWluLmhhc093blByb3BlcnR5KCdjaGFubmVsJykpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKCdFcnJvciBvbiBwbHVnaW4gJyArIHBsdWdpbl9uYW1lICsgJy4gQSBwbHVnaW4gbXVzdCBhbHdheXMgZGVmaW5lIGl0cyBDaGFubmVsIG9uIHRoZSBcImNoYW5uZWxcIiBrZXkgb2YgdGhlIG1haW4uanMgZmlsZS5cXG4gICAgICAgIEl0XFwncyBtaXNzaW5nLiBQbGVhc2UgcmVmZXIgdG8gZG9jdW1lbnRhdGlvbicpO1xuICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfdHlwZW9mKG1haW4uY2hhbm5lbCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChtYWluLmNoYW5uZWwuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgIG1haW4uY2hhbm5lbCA9IG1haW4uY2hhbm5lbC5kZWZhdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoZWNrO1xufTtcblxuLy8gcGx1Z2luX25hbWUgaXMgdGhlIHVuaXF1ZSBuYW1lIG9mIHRoZSBwbHVnaW5cbmZ1bmN0aW9uIGxvYWRQbHVnaW4ocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSB7XG4gICAgICAgIHBsdWdpbiA9IHBsdWdpbi5kZWZhdWx0O1xuICAgIH1cblxuICAgIGlmICghcGx1Z2luLmhhc093blByb3BlcnR5KCducG1fbmFtZScpKSB7XG4gICAgICAgIHBsdWdpbi5ucG1fbmFtZSA9ICdwbHVnaW5fJyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH1cblxuICAgIGlmICghcGx1Z2luLmhhc093blByb3BlcnR5KCdjaGFubmVsJykpIHtcbiAgICAgICAgcGx1Z2luLmNoYW5uZWwgPSBDaGFubmVsO1xuICAgIH1cbiAgICBpZiAoIWNoZWNrUGx1Z2luKHBsdWdpbikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZVBsdWdpbiBpcyB0aGUgcGx1Z2luIG9iamVjdCB3aGljaCB3aWxsIGhvbGQgb24gaXRzIGtleXNcbiAgICAgICAgLy8gdGhlIG5hbWVzIG9mIHRoZSBleHBvc2VkIEluY2lkZW50cyBvZiBpdHMuIFRoZSBrZXlzIG9mIHRoaXMgb2JqZWN0XG4gICAgICAgIC8vIGFyZSBnb2luZyB0byBiZSBpZGVudGljYWwgd2l0aCB0aGUgbmFtZXMgb2YgdGhlIGNsYXNzZXMgZXhwb3NlZFxuICAgICAgICB2YXIgdGhlUGx1Z2luID0ge307XG5cbiAgICAgICAgaWYgKHBsdWdpbi5oYXNPd25Qcm9wZXJ0eSgnY2xpcCcpKSB7XG4gICAgICAgICAgICBpZiAoX3R5cGVvZihwbHVnaW4uY2xpcCkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLmNsaXAuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkge1xuICAgICAgICAgICAgICAgICAgICBwbHVnaW4uY2xpcCA9IHBsdWdpbi5jbGlwLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhlUGx1Z2luLkNsaXAgPSBwbHVnaW4uY2xpcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZvciBlYWNoIG9mIHRoZSBleHBvc2VkIEluY2lkZW50c1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICAgIHZhciBpbmNpZGVudENsYXNzID0gcGx1Z2luLmluY2lkZW50c1tpXS5leHBvcnRhYmxlO1xuXG4gICAgICAgICAgICAvLyBUT0RPIGhhbmxkZSB0aGUgZGlmZmVyZW50IGNzcyBzdHlsZSBpc29sYXRpb24gdmVyc2lvbnMgdGhyb3VnaCB0aGUgY3NzSXNvbGF0aW9uIHBhcmFtZXRlciBvZiB0aGUgY29udGFpbmVyUGFyYW1zIG9mIHRoZSBpbmNpZGVudFxuXG4gICAgICAgICAgICAvLyBkeW5hbWljYWxseSBhc3NpZ24gZ2V0dGVycyBvbiB0aGUgSW5jaWRlbnQncyBuYW1lIGtleSBvZiB0aGUgdGhlUGx1Z2luIG9iamVjdFxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoZVBsdWdpbiwgaW5jaWRlbnRDbGFzcy5uYW1lLCB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBnZXR0ZXIgd2lsbCBjb25zdHJ1Y3QgYSB3cmFwcGVyIGNsYXNzIHdoaWNoIG9uIHRoZSBjb25zdHJ1Y3RvciB3aWxsIGluc3RhbnRpYXRlIGFuIG9iamVjdCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXhwb3NlZCBjbGFzcywgc2V0IHRvIGl0IHRoZSBwbHVnaW4gbmFtZSBhbmQgY2hhbm5lbCBjbGFzcyBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIFdyYXBwZXJDbGFzcyA9IGZ1bmN0aW9uIFdyYXBwZXJDbGFzcyhhdHRycywgcHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXcmFwcGVyQ2xhc3MpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5zdGFudGlhdGVkSW5jaWRlbnQgPSBuZXcgaW5jaWRlbnRDbGFzcyhhdHRycywgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFudGlhdGVkSW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBwbHVnaW4uY2hhbm5lbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRpYXRlZEluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9IHBsdWdpbi5ucG1fbmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5jaGFubmVsLnR5cGUgPT09IFwiYXR0cmlidXRlc1wiICYmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ3NlbGVjdG9yJykgfHwgcHJvcHMuc2VsZWN0b3IgPT09IG51bGwgfHwgcHJvcHMuc2VsZWN0b3IgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1lvdSB0cmllZCB0byBpbnN0YW50aWF0ZSBhbiBJbmNpZGVudCBvZiBwbHVnaW4gJyArIHBsdWdpbi5ucG1fbmFtZSArICcgd2l0aG91dCBwYXNzaW5nIHByb3BzLnNlbGVjdG9yLiBUaGlzIHBsdWdpbiB1c2VzIHRoZSBBdHRyaWJ1dGVDaGFubmVsIGFuZCB0aHVzIGFsbCBvZiBpdHMgaW5jaWRlbnRzIG11c3QgXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmUgaW5pdGlhbGlzZWQgd2l0aCBhIHZhbGlkIHByb3BzLnNlbGVjdG9yLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBhIGdvb2QgaWRlYSB0byBib3RoIHZhbGlkYXRlIHRoZSBwcm9wcyBoZXJlIGJlZm9yZSByZXR1cm5pbmcgdGhlIG5ldyBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsc28gaXMgYSBnb29kIGlkZWEgdG8gY3JlYXRlIGEgUHJveHkgZm9yIHRoZSBpbnN0YW50aWF0ZWQgSW5jaWRlbnQgdG8gcHJldmVudCBzZXR0aW5nOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWQsIHBsdWdpbl9jaGFubmVsX2NsYXNzLCBtY19wbHVnaW5fbnBtX25hbWVcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbnRpYXRlZEluY2lkZW50O1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gV3JhcHBlckNsYXNzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2luLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoZVBsdWdpbjtcbiAgICB9XG59XG5cbnZhciBQcm9ncmFtbWF0aWNJbmNpZGVudFBsdWdpbkRlZmluaXRpb24gPSByZXF1aXJlKCcuL2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9tYWluLmpzJyk7XG52YXIgUHJvZ3JhbW1hdGljSW5jaWRlbnRQbHVnaW4gPSBsb2FkUGx1Z2luKFByb2dyYW1tYXRpY0luY2lkZW50UGx1Z2luRGVmaW5pdGlvbik7XG5cbnZhciBTZWxmQ29udGFpbmVkSW5jaWRlbnRzUGx1Z2luRGVmaW5pdGlvbiA9IHJlcXVpcmUoJy4vY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9tYWluLmpzJyk7XG52YXIgU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbiA9IGxvYWRQbHVnaW4oU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbkRlZmluaXRpb24pO1xuXG52YXIgVGltZUNhcHN1bGUgPSByZXF1aXJlKCcuL19jb3JlVXRpbHMvVGltZUNhcHN1bGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2hhbm5lbDogQ2hhbm5lbCxcbiAgICBHcm91cDogR3JvdXAsXG4gICAgQ2xpcDogU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbi5DbGlwLFxuICAgIENsaXBGcm9tRGVmaW5pdGlvbjogQ2xpcEZyb21EZWZpbml0aW9uLFxuICAgIEluY2lkZW50OiBJbmNpZGVudCxcbiAgICBQcm9ncmFtbWF0aWNJbmNpZGVudDogUHJvZ3JhbW1hdGljSW5jaWRlbnRQbHVnaW4uUHJvZ3JhbW1hdGljSW5jaWRlbnQsXG4gICAgRHVtbXlJbmNpZGVudDogUHJvZ3JhbW1hdGljSW5jaWRlbnRQbHVnaW4uRHVtbXlJbmNpZGVudCxcbiAgICBUaW1lZEluY2lkZW50OiBUaW1lZEluY2lkZW50LFxuXG4gICAgLy8gY2hhbm5lbHNcbiAgICBBdHRyaWJ1dGVDaGFubmVsOiBBdHRyaWJ1dGVDaGFubmVsLFxuXG4gICAgVGltZUNhcHN1bGU6IFRpbWVDYXBzdWxlLFxuXG4gICAgY29uZjogY29uZixcbiAgICBUaW1lcjogVGltZXIsXG5cbiAgICBIZWxwZXI6IEhlbHBlcixcblxuICAgIGxvYWRQbHVnaW46IGxvYWRQbHVnaW5cbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/main.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js":
/*!*********************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"../node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Draggabilly = __webpack_require__(/*! draggabilly */ \"../node_modules/draggabilly/draggabilly.js\");\nvar TimeCapsule = __webpack_require__(/*! ../_coreUtils/TimeCapsule */ \"../node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\nvar timeCapsule = new TimeCapsule();\nvar journey = null;\n\n/**\n * @classdesc\n * Timer's purpose is to provide an interface through which any TimedIncident (such as a Scene or a Clip)\n * can both privide info regarding their timing state but also provide an interface for interacting /\n * altering the timing of it\n */\n\nvar Timer = function () {\n    function Timer(props) {\n        _classCallCheck(this, Timer);\n\n        this.id = props.id || helper.getAnId();\n        this.cursor = document.getElementById('time-cursor');\n        this.leftSlot = document.getElementsByClassName('left-slot')[0];\n        this.rightSlot = document.getElementsByClassName('right-slot')[0];\n        this.playButton = document.getElementById('play-pause');\n        this.Incident = props.Incident;\n        this.subscribeToTimer();\n        this.subscribeToEvents();\n        this.afterRender();\n        this.previousTimestamp = 0;\n        this.previousIncidentState = 'idle';\n        this.width = props.width;\n        this.cursorWidth = props.cursorWidth || 10;\n    }\n\n    _createClass(Timer, [{\n        key: 'millisecondChange',\n        value: function millisecondChange(millisecond, state) {\n            // helper.log(millisecond);\n            this.cursor.style.left = 'calc(' + millisecond * 100 / this.Incident.duration + '% - ' + this.cursorWidth + 'px)';\n            this.leftSlot.innerHTML = millisecond;\n            this.rightSlot.innerHTML = this.Incident.duration - millisecond;\n        }\n    }, {\n        key: 'eventBroadcast',\n        value: function eventBroadcast(eventName, meta) {\n            if (eventName === 'state-change') {\n                if (meta.newState === 'waiting') {\n                    this.playButton.innerHTML = 'Resume';\n                } else if (meta.newState === 'playing') {\n                    this.playButton.innerHTML = 'Pause';\n                } else if (meta.newState === 'completed') {\n                    this.leftSlot.innerHTML = this.Incident.duration;\n                    this.rightSlot.innerHTML = 0;\n                    this.playButton.innerHTML = \"completed\";\n                    helper.log(this.Incident);\n                } else if (meta.newState === 'transitional') {\n                    this.playButton.innerHTML = \"transitioning\";\n                } else if (meta.newState === 'idle') {\n                    this.playButton.innerHTML = \"Play\";\n                }\n            } else if (eventName === 'attribute-rejection') {\n                helper.log('Attributes', meta.attributes, 'have been rejected from animation with id ' + meta.animationID);\n            } else if (eventName === 'animation-rejection') {\n                helper.log('Animation ' + meta.animationID + ' has been rejected as all attributes of it overlap on specific elements because of existing animations');\n            } else if (eventName === 'duration-change') {\n                this.millisecondChange(this.Incident.runTimeInfo.currentMillisecond, this.Incident.state);\n            }\n        }\n    }, {\n        key: 'subscribeToEvents',\n        value: function subscribeToEvents() {\n            // helper.error('Timer is subscirbing to the clips events');\n            this.Incident.subscribeToEvents(this.id, this.eventBroadcast.bind(this));\n        }\n    }, {\n        key: 'subscribeToTimer',\n        value: function subscribeToTimer() {\n            // helper.log('Timer is subscirbing to the clips timer', 'notice');\n            this.Incident.subscribe(this.id, this.millisecondChange.bind(this));\n        }\n    }, {\n        key: 'handleDragStart',\n        value: function handleDragStart(event, pointer) {\n            // helper.log('drag is starting', 'warning')\n            journey = timeCapsule.startJourney(this.Incident);\n        }\n    }, {\n        key: 'handleDrag',\n        value: function handleDrag(event, pointer, position) {\n            var millisecond = Math.round(this.Incident.duration * position.x / this.width);\n            if (millisecond < 0) {\n                millisecond = 0;\n            }\n            this.leftSlot.innerHTML = millisecond;\n            this.rightSlot.innerHTML = this.Incident.duration - millisecond;\n\n            journey.station(millisecond);\n        }\n    }, {\n        key: 'handleDragEnd',\n        value: function handleDragEnd(event, pointer) {\n            //  Velocity.defaults.speed=1;\n            // this.previousTimestamp is the target millisecond of the drag\n\n            journey.destination();\n\n            helper.log(this.Incident.exportState());\n        }\n    }, {\n        key: 'afterRender',\n        value: function afterRender() {\n            var that = this;\n\n            this.playButton.onclick = function (e) {\n                if (that.Incident.state === 'playing') {\n                    that.Incident.wait();\n                } else if (that.Incident.state === 'waiting') {\n                    that.Incident.resume();\n                } else if (that.Incident.state === 'idle') {\n                    that.Incident.play();\n                }\n            };\n\n            var elem = document.querySelector('#time-cursor');\n            var draggie = new Draggabilly(elem, {\n                axis: 'x',\n                containment: '.bar'\n            });\n\n            draggie.on('dragStart', this.handleDragStart.bind(this));\n            draggie.on('dragMove', function (event, pointer) {\n                that.handleDrag(event, pointer, draggie.position);\n            });\n            draggie.on('dragEnd', this.handleDragEnd.bind(this));\n        }\n    }, {\n        key: 'render',\n        value: function render(container) {}\n    }]);\n\n    return Timer;\n}();\n\nmodule.exports = Timer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC91dGlscy9UaW1lci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L3V0aWxzL1RpbWVyLmpzPzViOWIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBEcmFnZ2FiaWxseSA9IHJlcXVpcmUoJ2RyYWdnYWJpbGx5Jyk7XG52YXIgVGltZUNhcHN1bGUgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL1RpbWVDYXBzdWxlJyk7XG52YXIgdGltZUNhcHN1bGUgPSBuZXcgVGltZUNhcHN1bGUoKTtcbnZhciBqb3VybmV5ID0gbnVsbDtcblxuLyoqXG4gKiBAY2xhc3NkZXNjXG4gKiBUaW1lcidzIHB1cnBvc2UgaXMgdG8gcHJvdmlkZSBhbiBpbnRlcmZhY2UgdGhyb3VnaCB3aGljaCBhbnkgVGltZWRJbmNpZGVudCAoc3VjaCBhcyBhIFNjZW5lIG9yIGEgQ2xpcClcbiAqIGNhbiBib3RoIHByaXZpZGUgaW5mbyByZWdhcmRpbmcgdGhlaXIgdGltaW5nIHN0YXRlIGJ1dCBhbHNvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZyAvXG4gKiBhbHRlcmluZyB0aGUgdGltaW5nIG9mIGl0XG4gKi9cblxudmFyIFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRpbWVyKHByb3BzKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lcik7XG5cbiAgICAgICAgdGhpcy5pZCA9IHByb3BzLmlkIHx8IGhlbHBlci5nZXRBbklkKCk7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWUtY3Vyc29yJyk7XG4gICAgICAgIHRoaXMubGVmdFNsb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsZWZ0LXNsb3QnKVswXTtcbiAgICAgICAgdGhpcy5yaWdodFNsb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdyaWdodC1zbG90JylbMF07XG4gICAgICAgIHRoaXMucGxheUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwbGF5LXBhdXNlJyk7XG4gICAgICAgIHRoaXMuSW5jaWRlbnQgPSBwcm9wcy5JbmNpZGVudDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUb1RpbWVyKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9FdmVudHMoKTtcbiAgICAgICAgdGhpcy5hZnRlclJlbmRlcigpO1xuICAgICAgICB0aGlzLnByZXZpb3VzVGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5wcmV2aW91c0luY2lkZW50U3RhdGUgPSAnaWRsZSc7XG4gICAgICAgIHRoaXMud2lkdGggPSBwcm9wcy53aWR0aDtcbiAgICAgICAgdGhpcy5jdXJzb3JXaWR0aCA9IHByb3BzLmN1cnNvcldpZHRoIHx8IDEwO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhUaW1lciwgW3tcbiAgICAgICAga2V5OiAnbWlsbGlzZWNvbmRDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbWlsbGlzZWNvbmRDaGFuZ2UobWlsbGlzZWNvbmQsIHN0YXRlKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yLnN0eWxlLmxlZnQgPSAnY2FsYygnICsgbWlsbGlzZWNvbmQgKiAxMDAgLyB0aGlzLkluY2lkZW50LmR1cmF0aW9uICsgJyUgLSAnICsgdGhpcy5jdXJzb3JXaWR0aCArICdweCknO1xuICAgICAgICAgICAgdGhpcy5sZWZ0U2xvdC5pbm5lckhUTUwgPSBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgIHRoaXMucmlnaHRTbG90LmlubmVySFRNTCA9IHRoaXMuSW5jaWRlbnQuZHVyYXRpb24gLSBtaWxsaXNlY29uZDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXZlbnRCcm9hZGNhc3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXZlbnRCcm9hZGNhc3QoZXZlbnROYW1lLCBtZXRhKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAnc3RhdGUtY2hhbmdlJykge1xuICAgICAgICAgICAgICAgIGlmIChtZXRhLm5ld1N0YXRlID09PSAnd2FpdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlubmVySFRNTCA9ICdSZXN1bWUnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5pbm5lckhUTUwgPSAnUGF1c2UnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZWZ0U2xvdC5pbm5lckhUTUwgPSB0aGlzLkluY2lkZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0U2xvdC5pbm5lckhUTUwgPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5uZXJIVE1MID0gXCJjb21wbGV0ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLmxvZyh0aGlzLkluY2lkZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09ICd0cmFuc2l0aW9uYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5pbm5lckhUTUwgPSBcInRyYW5zaXRpb25pbmdcIjtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09ICdpZGxlJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5uZXJIVE1MID0gXCJQbGF5XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdhdHRyaWJ1dGUtcmVqZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhlbHBlci5sb2coJ0F0dHJpYnV0ZXMnLCBtZXRhLmF0dHJpYnV0ZXMsICdoYXZlIGJlZW4gcmVqZWN0ZWQgZnJvbSBhbmltYXRpb24gd2l0aCBpZCAnICsgbWV0YS5hbmltYXRpb25JRCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2FuaW1hdGlvbi1yZWplY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmxvZygnQW5pbWF0aW9uICcgKyBtZXRhLmFuaW1hdGlvbklEICsgJyBoYXMgYmVlbiByZWplY3RlZCBhcyBhbGwgYXR0cmlidXRlcyBvZiBpdCBvdmVybGFwIG9uIHNwZWNpZmljIGVsZW1lbnRzIGJlY2F1c2Ugb2YgZXhpc3RpbmcgYW5pbWF0aW9ucycpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdkdXJhdGlvbi1jaGFuZ2UnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taWxsaXNlY29uZENoYW5nZSh0aGlzLkluY2lkZW50LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCwgdGhpcy5JbmNpZGVudC5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N1YnNjcmliZVRvRXZlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvRXZlbnRzKCkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmVycm9yKCdUaW1lciBpcyBzdWJzY2lyYmluZyB0byB0aGUgY2xpcHMgZXZlbnRzJyk7XG4gICAgICAgICAgICB0aGlzLkluY2lkZW50LnN1YnNjcmliZVRvRXZlbnRzKHRoaXMuaWQsIHRoaXMuZXZlbnRCcm9hZGNhc3QuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N1YnNjcmliZVRvVGltZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlVG9UaW1lcigpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ1RpbWVyIGlzIHN1YnNjaXJiaW5nIHRvIHRoZSBjbGlwcyB0aW1lcicsICdub3RpY2UnKTtcbiAgICAgICAgICAgIHRoaXMuSW5jaWRlbnQuc3Vic2NyaWJlKHRoaXMuaWQsIHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZURyYWdTdGFydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnU3RhcnQoZXZlbnQsIHBvaW50ZXIpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2RyYWcgaXMgc3RhcnRpbmcnLCAnd2FybmluZycpXG4gICAgICAgICAgICBqb3VybmV5ID0gdGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KHRoaXMuSW5jaWRlbnQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVEcmFnJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURyYWcoZXZlbnQsIHBvaW50ZXIsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKHRoaXMuSW5jaWRlbnQuZHVyYXRpb24gKiBwb3NpdGlvbi54IC8gdGhpcy53aWR0aCk7XG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZWZ0U2xvdC5pbm5lckhUTUwgPSBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgIHRoaXMucmlnaHRTbG90LmlubmVySFRNTCA9IHRoaXMuSW5jaWRlbnQuZHVyYXRpb24gLSBtaWxsaXNlY29uZDtcblxuICAgICAgICAgICAgam91cm5leS5zdGF0aW9uKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlRHJhZ0VuZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnRW5kKGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICAgICAgICAvLyAgVmVsb2NpdHkuZGVmYXVsdHMuc3BlZWQ9MTtcbiAgICAgICAgICAgIC8vIHRoaXMucHJldmlvdXNUaW1lc3RhbXAgaXMgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBvZiB0aGUgZHJhZ1xuXG4gICAgICAgICAgICBqb3VybmV5LmRlc3RpbmF0aW9uKCk7XG5cbiAgICAgICAgICAgIGhlbHBlci5sb2codGhpcy5JbmNpZGVudC5leHBvcnRTdGF0ZSgpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWZ0ZXJSZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWZ0ZXJSZW5kZXIoKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5vbmNsaWNrID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5JbmNpZGVudC5zdGF0ZSA9PT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuSW5jaWRlbnQud2FpdCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5JbmNpZGVudC5zdGF0ZSA9PT0gJ3dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuSW5jaWRlbnQucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0LkluY2lkZW50LnN0YXRlID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5JbmNpZGVudC5wbGF5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGVsZW0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGltZS1jdXJzb3InKTtcbiAgICAgICAgICAgIHZhciBkcmFnZ2llID0gbmV3IERyYWdnYWJpbGx5KGVsZW0sIHtcbiAgICAgICAgICAgICAgICBheGlzOiAneCcsXG4gICAgICAgICAgICAgICAgY29udGFpbm1lbnQ6ICcuYmFyJ1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGRyYWdnaWUub24oJ2RyYWdTdGFydCcsIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgZHJhZ2dpZS5vbignZHJhZ01vdmUnLCBmdW5jdGlvbiAoZXZlbnQsIHBvaW50ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmhhbmRsZURyYWcoZXZlbnQsIHBvaW50ZXIsIGRyYWdnaWUucG9zaXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkcmFnZ2llLm9uKCdkcmFnRW5kJywgdGhpcy5oYW5kbGVEcmFnRW5kLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW5kZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKGNvbnRhaW5lcikge31cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gVGltZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gVGltZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap,\n    nodeIsSet = nodeUtil && nodeUtil.isSet,\n    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n\n    return result;\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5jbG9uZWRlZXAvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5jbG9uZWRlZXAvaW5kZXguanM/MmVjYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX0ZMQVRfRkxBRyA9IDIsXG4gICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBzdXBwb3J0ZWQgYnkgYF8uY2xvbmVgLiAqL1xudmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbmNsb25lYWJsZVRhZ3NbYXJnc1RhZ10gPSBjbG9uZWFibGVUYWdzW2FycmF5VGFnXSA9XG5jbG9uZWFibGVUYWdzW2FycmF5QnVmZmVyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZGF0YVZpZXdUYWddID1cbmNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbmNsb25lYWJsZVRhZ3NbZmxvYXQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW2Zsb2F0NjRUYWddID1cbmNsb25lYWJsZVRhZ3NbaW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDE2VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG5jbG9uZWFibGVUYWdzW251bWJlclRhZ10gPSBjbG9uZWFibGVUYWdzW29iamVjdFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tyZWdleHBUYWddID0gY2xvbmVhYmxlVGFnc1tzZXRUYWddID1cbmNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQ4VGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9XG5jbG9uZWFibGVUYWdzW3VpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbmNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgbm9kZUlzU2V0ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNTZXQsXG4gICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RWFjaChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpLFxuICAgIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUsXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGB2YWx1ZWAgdG8gYGtleWAgb2YgYG9iamVjdGAgaWYgdGhlIGV4aXN0aW5nIHZhbHVlIGlzIG5vdCBlcXVpdmFsZW50XG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpKSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbkluYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduSW4ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5c0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGFzc2lnblZhbHVlYCBhbmQgYGFzc2lnbk1lcmdlVmFsdWVgIHdpdGhvdXRcbiAqIHZhbHVlIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgPT0gJ19fcHJvdG9fXycgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgICAnZW51bWVyYWJsZSc6IHRydWUsXG4gICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICd3cml0YWJsZSc6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoaXNNYXAodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBrZXlzRnVuYyA9IGlzRnVsbFxuICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgOiAoaXNGbGF0ID8ga2V5c0luIDoga2V5cyk7XG5cbiAgdmFyIHByb3BzID0gaXNBcnIgPyB1bmRlZmluZWQgOiBrZXlzRnVuYyh2YWx1ZSk7XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWFwYCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBtYXBUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c0luYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzSW4ob2JqZWN0KTtcbiAgfVxuICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICByZXN1bHQgPSBbXTtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHJlZ2V4cC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgcmVnZXhwLmNvbnN0cnVjdG9yKHJlZ2V4cC5zb3VyY2UsIHJlRmxhZ3MuZXhlYyhyZWdleHApKTtcbiAgcmVzdWx0Lmxhc3RJbmRleCA9IHJlZ2V4cC5sYXN0SW5kZXg7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgb3duIGFuZCBpbmhlcml0ZWQgc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXNJbihvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzSW4gPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHdoaWxlIChvYmplY3QpIHtcbiAgICBhcnJheVB1c2gocmVzdWx0LCBnZXRTeW1ib2xzKG9iamVjdCkpO1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBNYXBgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIGBTZXRgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gIHZhciBDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVBcnJheUJ1ZmZlcihvYmplY3QpO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcblxuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICByZXR1cm4gY2xvbmVEYXRhVmlldyhvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIGZsb2F0MzJUYWc6IGNhc2UgZmxvYXQ2NFRhZzpcbiAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgY2FzZSB1aW50OFRhZzogY2FzZSB1aW50OENsYW1wZWRUYWc6IGNhc2UgdWludDE2VGFnOiBjYXNlIHVpbnQzMlRhZzpcbiAgICAgIHJldHVybiBjbG9uZVR5cGVkQXJyYXkob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcihvYmplY3QpO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZVxuICogW2BPYmplY3Qua2V5c2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBNYXBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG1hcCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTWFwKG5ldyBNYXApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNNYXAobmV3IFdlYWtNYXApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzTWFwID0gbm9kZUlzTWFwID8gYmFzZVVuYXJ5KG5vZGVJc01hcCkgOiBiYXNlSXNNYXA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU2V0KG5ldyBTZXQpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTZXQobmV3IFdlYWtTZXQpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXNJbihuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJywgJ2MnXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICovXG5mdW5jdGlvbiBrZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = filter;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maWx0ZXIvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maWx0ZXIvaW5kZXguanM/MmJlOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBiYXNlRm9yT3duYCB3aGljaCBpdGVyYXRlcyBvdmVyIGBvYmplY3RgXG4gKiBwcm9wZXJ0aWVzIHJldHVybmVkIGJ5IGBrZXlzRnVuY2AgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xudmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgYmFzZUZvcihvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gKiBgdW5kZWZpbmVkYCwgdGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGluIGl0cyBwbGFjZS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuNy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAqXG4gKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICogLy8gPT4gM1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAqIC8vID0+ICdkZWZhdWx0J1xuICovXG5mdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYS5iJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzSW4ob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js":
/*!*****************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = find;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maW5kL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZC9pbmRleC5qcz8zNjA1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTG9kYXNoIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBpbmNsdWRlPVwiZmlsdGVyLHNvcnRCeSxmaW5kSW5kZXgsZmluZCxmb3JFYWNoLGNsb25lRGVlcFwiIGV4cG9ydHM9XCJucG1cImBcbiAqIENvcHlyaWdodCBKUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanMuZm91bmRhdGlvbi8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBhcyB0aGUgbWF4aW11bSBtZW1vaXplIGNhY2hlIHNpemUuICovXG52YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgIE1BWF9JTlRFR0VSID0gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgsXG4gICAgTkFOID0gMCAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW0gPSAvXlxccyt8XFxzKyQvZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5maWx0ZXJgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlGaWx0ZXIoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXBwZW5kcyB0aGUgZWxlbWVudHMgb2YgYHZhbHVlc2AgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtvZmZzZXQgKyBpbmRleF0gPSB2YWx1ZXNbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maW5kSW5kZXhgIGFuZCBgXy5maW5kTGFzdEluZGV4YCB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4LCBmcm9tUmlnaHQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGluZGV4ID0gZnJvbUluZGV4ICsgKGZyb21SaWdodCA/IDEgOiAtMSk7XG5cbiAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5nZXRgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVmYXVsdCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IDAsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICB3aGlsZSAob2JqZWN0ICE9IG51bGwgJiYgaW5kZXggPCBsZW5ndGgpIHtcbiAgICBvYmplY3QgPSBvYmplY3RbdG9LZXkocGF0aFtpbmRleCsrXSldO1xuICB9XG4gIHJldHVybiAoaW5kZXggJiYgaW5kZXggPT0gbGVuZ3RoKSA/IG9iamVjdCA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0QWxsS2V5c2AgYW5kIGBnZXRBbGxLZXlzSW5gIHdoaWNoIHVzZXNcbiAqIGBrZXlzRnVuY2AgYW5kIGBzeW1ib2xzRnVuY2AgdG8gZ2V0IHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZFxuICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN5bWJvbHNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNGdW5jLCBzeW1ib2xzRnVuYykge1xuICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdCA6IGFycmF5UHVzaChyZXN1bHQsIHN5bWJvbHNGdW5jKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbERlZXAob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgb2JqSXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgb2JqVGFnID0gb2JqSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvYmplY3QpLFxuICAgICAgb3RoVGFnID0gb3RoSXNBcnIgPyBhcnJheVRhZyA6IGdldFRhZyhvdGhlcik7XG5cbiAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuXG4gIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICBpc1NhbWVUYWcgPSBvYmpUYWcgPT0gb3RoVGFnO1xuXG4gIGlmIChpc1NhbWVUYWcgJiYgaXNCdWZmZXIob2JqZWN0KSkge1xuICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICBvYmpJc09iaiA9IGZhbHNlO1xuICB9XG4gIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICByZXR1cm4gKG9iaklzQXJyIHx8IGlzVHlwZWRBcnJheShvYmplY3QpKVxuICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgOiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIG9ialRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gIH1cbiAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgIHZhciBvYmpJc1dyYXBwZWQgPSBvYmpJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgJ19fd3JhcHBlZF9fJyksXG4gICAgICAgIG90aElzV3JhcHBlZCA9IG90aElzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsICdfX3dyYXBwZWRfXycpO1xuXG4gICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgIHZhciBvYmpVbndyYXBwZWQgPSBvYmpJc1dyYXBwZWQgPyBvYmplY3QudmFsdWUoKSA6IG9iamVjdCxcbiAgICAgICAgICBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICByZXR1cm4gZXF1YWxGdW5jKG9ialVud3JhcHBlZCwgb3RoVW53cmFwcGVkLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICB9XG4gIGlmICghaXNTYW1lVGFnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHJldHVybiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXRjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0FycmF5fSBtYXRjaERhdGEgVGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBpbmRleCxcbiAgICAgIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuXG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiAhbGVuZ3RoO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dXG4gICAgICAgICAgOiAhKGRhdGFbMF0gaW4gb2JqZWN0KVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBkYXRhID0gbWF0Y2hEYXRhW2luZGV4XTtcbiAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgc3JjVmFsdWUgPSBkYXRhWzFdO1xuXG4gICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICBpZiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IFN0YWNrO1xuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICB9XG4gICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICAgICA6IHJlc3VsdFxuICAgICAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc05hdGl2ZWAgd2l0aG91dCBiYWQgc2hpbSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgaXNNYXNrZWQodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBwYXR0ZXJuID0gaXNGdW5jdGlvbih2YWx1ZSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNhc3RQYXRoKHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBpc0tleSh2YWx1ZSwgb2JqZWN0KSA/IFt2YWx1ZV0gOiBzdHJpbmdUb1BhdGgodG9TdHJpbmcodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYF8uZmluZGAgb3IgYF8uZmluZExhc3RgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmaW5kSW5kZXhGdW5jIFRoZSBmdW5jdGlvbiB0byBmaW5kIHRoZSBjb2xsZWN0aW9uIGluZGV4LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgIHZhciBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgcHJlZGljYXRlID0gZnVuY3Rpb24oa2V5KSB7IHJldHVybiBpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKTsgfTtcbiAgICB9XG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBpdGVyYWJsZVtpdGVyYXRlZSA/IGNvbGxlY3Rpb25baW5kZXhdIDogaW5kZXhdIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IGVsZW1lbnRcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hdGNoZWQgZWxlbWVudCwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmQodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiB0cnVlIH0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2ZyZWQnXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmQodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqL1xudmFyIGZpbmQgPSBjcmVhdGVGaW5kKGZpbmRJbmRleCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js":
/*!**********************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = findIndex;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maW5kaW5kZXgvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maW5kaW5kZXgvaW5kZXguanM/Y2EwMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIGtleSBpZiBpdCdzIG5vdCBhIHN0cmluZyBvciBzeW1ib2wuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7c3RyaW5nfHN5bWJvbH0gUmV0dXJucyB0aGUga2V5LlxuICovXG5mdW5jdGlvbiB0b0tleSh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb3VuZCBlbGVtZW50LCBlbHNlIGAtMWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ2Jhcm5leSc7IH0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgeyAndXNlcic6ICdmcmVkJywgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gMVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gMlxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgbWVtb2l6ZXMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuIElmIGByZXNvbHZlcmAgaXNcbiAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAqIGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBmaXJzdCBhcmd1bWVudFxuICogcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uIGlzIHVzZWQgYXMgdGhlIG1hcCBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICpcbiAqICoqTm90ZToqKiBUaGUgY2FjaGUgaXMgZXhwb3NlZCBhcyB0aGUgYGNhY2hlYCBwcm9wZXJ0eSBvbiB0aGUgbWVtb2l6ZWRcbiAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICogY29uc3RydWN0b3Igd2l0aCBvbmUgd2hvc2UgaW5zdGFuY2VzIGltcGxlbWVudCB0aGVcbiAqIFtgTWFwYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcHJvcGVydGllcy1vZi10aGUtbWFwLXByb3RvdHlwZS1vYmplY3QpXG4gKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZXNvbHZlcl0gVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgdGhlIGNhY2hlIGtleS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICpcbiAqIHZhciB2YWx1ZXMgPSBfLm1lbW9pemUoXy52YWx1ZXMpO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiB2YWx1ZXMob3RoZXIpO1xuICogLy8gPT4gWzMsIDRdXG4gKlxuICogb2JqZWN0LmEgPSAyO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiAvLyBNb2RpZnkgdGhlIHJlc3VsdCBjYWNoZS5cbiAqIHZhbHVlcy5jYWNoZS5zZXQob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWydhJywgJ2InXVxuICpcbiAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gKiBfLm1lbW9pemUuQ2FjaGUgPSBXZWFrTWFwO1xuICovXG5mdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nIHx8IChyZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSAnZnVuY3Rpb24nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgIGNhY2hlID0gbWVtb2l6ZWQuY2FjaGU7XG5cbiAgICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgcmV0dXJuIG1lbW9pemVkO1xufVxuXG4vLyBFeHBvc2UgYE1hcENhY2hlYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgZmluaXRlIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTIuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvRmluaXRlKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b0Zpbml0ZShJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9GaW5pdGUoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvRmluaXRlKHZhbHVlKSB7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gIH1cbiAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgIHZhciBzaWduID0gKHZhbHVlIDwgMCA/IC0xIDogMSk7XG4gICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgfVxuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlci5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0ludGVnZXJgXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9pbnRlZ2VyKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvSW50ZWdlcigzLjIpO1xuICogLy8gPT4gM1xuICpcbiAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gMFxuICpcbiAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0ludGVnZXIoJzMuMicpO1xuICogLy8gPT4gM1xuICovXG5mdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgdmFyIHJlc3VsdCA9IHRvRmluaXRlKHZhbHVlKSxcbiAgICAgIHJlbWFpbmRlciA9IHJlc3VsdCAlIDE7XG5cbiAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\n");

/***/ }),

/***/ "../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js":
/*!*******************************************************************************************************!*\
  !*** ../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js ***!
  \*******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = sortBy;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../../demo/node_modules/webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5zb3J0YnkvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5zb3J0YnkvaW5kZXguanM/YWE4YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICogc29ydCBvcmRlciBvZiBgYXJyYXlgIGFuZCByZXBsYWNlcyBjcml0ZXJpYSBvYmplY3RzIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZ1xuICogdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc29ydC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIGFycmF5LnNvcnQoY29tcGFyZXIpO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBhcnJheVtsZW5ndGhdID0gYXJyYXlbbGVuZ3RoXS52YWx1ZTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBmdW5jID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2RlZmluZVByb3BlcnR5Jyk7XG4gICAgZnVuYyh7fSwgJycsIHt9KTtcbiAgICByZXR1cm4gZnVuYztcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fE9iamVjdH0gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gKi9cbnZhciBiYXNlRWFjaCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd24pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZsYXR0ZW5gIHdpdGggc3VwcG9ydCBmb3IgcmVzdHJpY3RpbmcgZmxhdHRlbmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICogQHBhcmFtIHtib29sZWFufSBbcHJlZGljYXRlPWlzRmxhdHRlbmFibGVdIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1N0cmljdF0gUmVzdHJpY3QgdG8gdmFsdWVzIHRoYXQgcGFzcyBgcHJlZGljYXRlYCBjaGVja3MuXG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gIHJlc3VsdCB8fCAocmVzdWx0ID0gW10pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgaWYgKGRlcHRoID4gMSkge1xuICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBiYXNlRmxhdHRlbih2YWx1ZSwgZGVwdGggLSAxLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzU3RyaWN0KSB7XG4gICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5vcmRlckJ5YCB3aXRob3V0IHBhcmFtIGd1YXJkcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gb3JkZXJzIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTE7XG4gIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcy5sZW5ndGggPyBpdGVyYXRlZXMgOiBbaWRlbnRpdHldLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLm9yZGVyQnlgIHRvIGNvbXBhcmUgbXVsdGlwbGUgcHJvcGVydGllcyBvZiBhIHZhbHVlIHRvIGFub3RoZXJcbiAqIGFuZCBzdGFibGUgc29ydCB0aGVtLlxuICpcbiAqIElmIGBvcmRlcnNgIGlzIHVuc3BlY2lmaWVkLCBhbGwgdmFsdWVzIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsXG4gKiBzcGVjaWZ5IGFuIG9yZGVyIG9mIFwiZGVzY1wiIGZvciBkZXNjZW5kaW5nIG9yIFwiYXNjXCIgZm9yIGFzY2VuZGluZyBzb3J0IG9yZGVyXG4gKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFuW118c3RyaW5nW119IG9yZGVycyBUaGUgb3JkZXIgdG8gc29ydCBieSBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLFxuICAgICAgb3RoQ3JpdGVyaWEgPSBvdGhlci5jcml0ZXJpYSxcbiAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgaWYgKGluZGV4ID49IG9yZGVyc0xlbmd0aCkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICB9XG4gIH1cbiAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAvLyB0aGF0IGNhdXNlcyBpdCwgdW5kZXIgY2VydGFpbiBjaXJjdW1zdGFuY2VzLCB0byBwcm92aWRlIHRoZSBzYW1lIHZhbHVlIGZvclxuICAvLyBgb2JqZWN0YCBhbmQgYG90aGVyYC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9wdWxsLzEyNDdcbiAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGVuc3VyZXMgYSBzdGFibGUgc29ydCBpbiBWOCBhbmQgb3RoZXIgZW5naW5lcy5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gIHJldHVybiBvYmplY3QuaW5kZXggLSBvdGhlci5pbmRleDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgYXJyYXlgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEFycmF5cyhhcnJheSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IG90aGVyLmxlbmd0aDtcblxuICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgc2VlbiA9IChiaXRtYXNrICYgQ09NUEFSRV9VTk9SREVSRURfRkxBRykgPyBuZXcgU2V0Q2FjaGUgOiB1bmRlZmluZWQ7XG5cbiAgc3RhY2suc2V0KGFycmF5LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gIC8vIElnbm9yZSBub24taW5kZXggcHJvcGVydGllcy5cbiAgd2hpbGUgKCsraW5kZXggPCBhcnJMZW5ndGgpIHtcbiAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIGFyclZhbHVlLCBpbmRleCwgb3RoZXIsIGFycmF5LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKGFyclZhbHVlLCBvdGhWYWx1ZSwgaW5kZXgsIGFycmF5LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoc2Vlbikge1xuICAgICAgaWYgKCFhcnJheVNvbWUob3RoZXIsIGZ1bmN0aW9uKG90aFZhbHVlLCBvdGhJbmRleCkge1xuICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiZcbiAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlZW4ucHVzaChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgKG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IG9iamVjdC5idWZmZXI7XG4gICAgICBvdGhlciA9IG90aGVyLmJ1ZmZlcjtcblxuICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgIWVxdWFsRnVuYyhuZXcgVWludDhBcnJheShvYmplY3QpLCBuZXcgVWludDhBcnJheShvdGhlcikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgY2FzZSBib29sVGFnOlxuICAgIGNhc2UgZGF0ZVRhZzpcbiAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAvLyBJbnZhbGlkIGRhdGVzIGFyZSBjb2VyY2VkIHRvIGBOYU5gLlxuICAgICAgcmV0dXJuIGVxKCtvYmplY3QsICtvdGhlcik7XG5cbiAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgcmV0dXJuIG9iamVjdC5uYW1lID09IG90aGVyLm5hbWUgJiYgb2JqZWN0Lm1lc3NhZ2UgPT0gb3RoZXIubWVzc2FnZTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgLy8gQ29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyBhbmQgdHJlYXQgc3RyaW5ncywgcHJpbWl0aXZlcyBhbmQgb2JqZWN0cyxcbiAgICAgIC8vIGFzIGVxdWFsLiBTZWUgaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbiAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0ID09IChvdGhlciArICcnKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHO1xuICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mLmNhbGwob2JqZWN0KSA9PSBzeW1ib2xWYWx1ZU9mLmNhbGwob3RoZXIpO1xuICAgICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIG9iamVjdHMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgIG9ialByb3BzID0gZ2V0QWxsS2V5cyhvYmplY3QpLFxuICAgICAgb2JqTGVuZ3RoID0gb2JqUHJvcHMubGVuZ3RoLFxuICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgIG90aExlbmd0aCA9IG90aFByb3BzLmxlbmd0aDtcblxuICBpZiAob2JqTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBpbmRleCA9IG9iakxlbmd0aDtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIGlmICghKGlzUGFydGlhbCA/IGtleSBpbiBvdGhlciA6IGhhc093blByb3BlcnR5LmNhbGwob3RoZXIsIGtleSkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8vIEFzc3VtZSBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gIHN0YWNrLnNldChvdGhlciwgb2JqZWN0KTtcblxuICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2tleV07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICBpZiAoIShjb21wYXJlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICA6IGNvbXBhcmVkXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgfVxuICBpZiAocmVzdWx0ICYmICFza2lwQ3Rvcikge1xuICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICBvdGhDdG9yID0gb3RoZXIuY29uc3RydWN0b3I7XG5cbiAgICAvLyBOb24gYE9iamVjdGAgb2JqZWN0IGluc3RhbmNlcyB3aXRoIGRpZmZlcmVudCBjb25zdHJ1Y3RvcnMgYXJlIG5vdCBlcXVhbC5cbiAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICgnY29uc3RydWN0b3InIGluIG9iamVjdCAmJiAnY29uc3RydWN0b3InIGluIG90aGVyKSAmJlxuICAgICAgICAhKHR5cGVvZiBvYmpDdG9yID09ICdmdW5jdGlvbicgJiYgb2JqQ3RvciBpbnN0YW5jZW9mIG9iakN0b3IgJiZcbiAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3Mgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbWF0Y2ggZGF0YSBvZiBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hEYXRhKG9iamVjdCkge1xuICB2YXIgcmVzdWx0ID0ga2V5cyhvYmplY3QpLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICB2YXIga2V5ID0gcmVzdWx0W2xlbmd0aF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICByZXN1bHRbbGVuZ3RoXSA9IFtrZXksIHZhbHVlLCBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gYmFzZUdldFRhZyh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgaW5kZXg7XG4gIGlmICh0eXBlID09ICdudW1iZXInXG4gICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KVxuICAgICAgKSB7XG4gICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBgdG9TdHJpbmdgIG1ldGhvZCBvZiBgZnVuY2AgdG8gcmV0dXJuIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCA0MF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydEJ5O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\n");

/***/ }),

/***/ "../node_modules/draggabilly/draggabilly.js":
/*!**************************************************!*\
  !*** ../node_modules/draggabilly/draggabilly.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Draggabilly v2.2.0\n * Make that shiz draggable\n * https://draggabilly.desandro.com\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(/*! get-size/get-size */ \"../node_modules/get-size/get-size.js\"),\n        __webpack_require__(/*! unidragger/unidragger */ \"../node_modules/unidragger/unidragger.js\")\n      ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( getSize, Unidragger ) {\n        return factory( window, getSize, Unidragger );\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, getSize, Unidragger ) {\n\n'use strict';\n\n// -------------------------- helpers & variables -------------------------- //\n\n// extend objects\nfunction extend( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n}\n\nfunction noop() {}\n\nvar jQuery = window.jQuery;\n\n// --------------------------  -------------------------- //\n\nfunction Draggabilly( element, options ) {\n  // querySelector if string\n  this.element = typeof element == 'string' ?\n    document.querySelector( element ) : element;\n\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n\n  // options\n  this.options = extend( {}, this.constructor.defaults );\n  this.option( options );\n\n  this._create();\n}\n\n// inherit Unidragger methods\nvar proto = Draggabilly.prototype = Object.create( Unidragger.prototype );\n\nDraggabilly.defaults = {\n};\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  extend( this.options, opts );\n};\n\n// css position values that don't need to be set\nvar positionValues = {\n  relative: true,\n  absolute: true,\n  fixed: true\n};\n\nproto._create = function() {\n  // properties\n  this.position = {};\n  this._getPosition();\n\n  this.startPoint = { x: 0, y: 0 };\n  this.dragPoint = { x: 0, y: 0 };\n\n  this.startPosition = extend( {}, this.position );\n\n  // set relative positioning\n  var style = getComputedStyle( this.element );\n  if ( !positionValues[ style.position ] ) {\n    this.element.style.position = 'relative';\n  }\n\n  // events, bridge jQuery events from vanilla\n  this.on( 'pointerDown', this.onPointerDown );\n  this.on( 'pointerMove', this.onPointerMove );\n  this.on( 'pointerUp', this.onPointerUp );\n\n  this.enable();\n  this.setHandles();\n};\n\n/**\n * set this.handles and bind start events to 'em\n */\nproto.setHandles = function() {\n  this.handles = this.options.handle ?\n    this.element.querySelectorAll( this.options.handle ) : [ this.element ];\n\n  this.bindHandles();\n};\n\n/**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */\nproto.dispatchEvent = function( type, event, args ) {\n  var emitArgs = [ event ].concat( args );\n  this.emitEvent( type, emitArgs );\n  this.dispatchJQueryEvent( type, event, args );\n};\n\nproto.dispatchJQueryEvent = function( type, event, args ) {\n  var jQuery = window.jQuery;\n  // trigger jQuery event\n  if ( !jQuery || !this.$element ) {\n    return;\n  }\n  // create jQuery event\n  var $event = jQuery.Event( event );\n  $event.type = type;\n  this.$element.trigger( $event, args );\n};\n\n// -------------------------- position -------------------------- //\n\n// get x/y position from style\nproto._getPosition = function() {\n  var style = getComputedStyle( this.element );\n  var x = this._getPositionCoord( style.left, 'width' );\n  var y = this._getPositionCoord( style.top, 'height' );\n  // clean up 'auto' or other non-integer values\n  this.position.x = isNaN( x ) ? 0 : x;\n  this.position.y = isNaN( y ) ? 0 : y;\n\n  this._addTransformPosition( style );\n};\n\nproto._getPositionCoord = function( styleSide, measure ) {\n  if ( styleSide.indexOf('%') != -1 ) {\n    // convert percent into pixel for Safari, #75\n    var parentSize = getSize( this.element.parentNode );\n    // prevent not-in-DOM element throwing bug, #131\n    return !parentSize ? 0 :\n      ( parseFloat( styleSide ) / 100 ) * parentSize[ measure ];\n  }\n  return parseInt( styleSide, 10 );\n};\n\n// add transform: translate( x, y ) to position\nproto._addTransformPosition = function( style ) {\n  var transform = style.transform;\n  // bail out if value is 'none'\n  if ( transform.indexOf('matrix') !== 0 ) {\n    return;\n  }\n  // split matrix(1, 0, 0, 1, x, y)\n  var matrixValues = transform.split(',');\n  // translate X value is in 12th or 4th position\n  var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;\n  var translateX = parseInt( matrixValues[ xIndex ], 10 );\n  // translate Y value is in 13th or 5th position\n  var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );\n  this.position.x += translateX;\n  this.position.y += translateY;\n};\n\n// -------------------------- events -------------------------- //\n\nproto.onPointerDown = function( event, pointer ) {\n  this.element.classList.add('is-pointer-down');\n  this.dispatchJQueryEvent( 'pointerDown', event, [ pointer ] );\n};\n\n/**\n * drag start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragStart = function( event, pointer ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this._getPosition();\n  this.measureContainment();\n  // position _when_ drag began\n  this.startPosition.x = this.position.x;\n  this.startPosition.y = this.position.y;\n  // reset left/top style\n  this.setLeftTop();\n\n  this.dragPoint.x = 0;\n  this.dragPoint.y = 0;\n\n  this.element.classList.add('is-dragging');\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n  // start animation\n  this.animate();\n};\n\nproto.measureContainment = function() {\n  var container = this.getContainer();\n  if ( !container ) {\n    return;\n  }\n\n  var elemSize = getSize( this.element );\n  var containerSize = getSize( container );\n  var elemRect = this.element.getBoundingClientRect();\n  var containerRect = container.getBoundingClientRect();\n\n  var borderSizeX = containerSize.borderLeftWidth + containerSize.borderRightWidth;\n  var borderSizeY = containerSize.borderTopWidth + containerSize.borderBottomWidth;\n\n  var position = this.relativeStartPosition = {\n    x: elemRect.left - ( containerRect.left + containerSize.borderLeftWidth ),\n    y: elemRect.top - ( containerRect.top + containerSize.borderTopWidth )\n  };\n\n  this.containSize = {\n    width: ( containerSize.width - borderSizeX ) - position.x - elemSize.width,\n    height: ( containerSize.height - borderSizeY ) - position.y - elemSize.height\n  };\n};\n\nproto.getContainer = function() {\n  var containment = this.options.containment;\n  if ( !containment ) {\n    return;\n  }\n  var isElement = containment instanceof HTMLElement;\n  // use as element\n  if ( isElement ) {\n    return containment;\n  }\n  // querySelector if string\n  if ( typeof containment == 'string' ) {\n    return document.querySelector( containment );\n  }\n  // fallback to parent element\n  return this.element.parentNode;\n};\n\n// ----- move event ----- //\n\nproto.onPointerMove = function( event, pointer, moveVector ) {\n  this.dispatchJQueryEvent( 'pointerMove', event, [ pointer, moveVector ] );\n};\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragMove = function( event, pointer, moveVector ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  var dragX = moveVector.x;\n  var dragY = moveVector.y;\n\n  var grid = this.options.grid;\n  var gridX = grid && grid[0];\n  var gridY = grid && grid[1];\n\n  dragX = applyGrid( dragX, gridX );\n  dragY = applyGrid( dragY, gridY );\n\n  dragX = this.containDrag( 'x', dragX, gridX );\n  dragY = this.containDrag( 'y', dragY, gridY );\n\n  // constrain to axis\n  dragX = this.options.axis == 'y' ? 0 : dragX;\n  dragY = this.options.axis == 'x' ? 0 : dragY;\n\n  this.position.x = this.startPosition.x + dragX;\n  this.position.y = this.startPosition.y + dragY;\n  // set dragPoint properties\n  this.dragPoint.x = dragX;\n  this.dragPoint.y = dragY;\n\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nfunction applyGrid( value, grid, method ) {\n  method = method || 'round';\n  return grid ? Math[ method ]( value / grid ) * grid : value;\n}\n\nproto.containDrag = function( axis, drag, grid ) {\n  if ( !this.options.containment ) {\n    return drag;\n  }\n  var measure = axis == 'x' ? 'width' : 'height';\n\n  var rel = this.relativeStartPosition[ axis ];\n  var min = applyGrid( -rel, grid, 'ceil' );\n  var max = this.containSize[ measure ];\n  max = applyGrid( max, grid, 'floor' );\n  return  Math.max( min, Math.min( max, drag ) );\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.onPointerUp = function( event, pointer ) {\n  this.element.classList.remove('is-pointer-down');\n  this.dispatchJQueryEvent( 'pointerUp', event, [ pointer ] );\n};\n\n/**\n * drag end\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragEnd = function( event, pointer ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  // use top left position when complete\n  this.element.style.transform = '';\n  this.setLeftTop();\n  this.element.classList.remove('is-dragging');\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\n// -------------------------- animation -------------------------- //\n\nproto.animate = function() {\n  // only render and animate if dragging\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.positionDrag();\n\n  var _this = this;\n  requestAnimationFrame( function animateFrame() {\n    _this.animate();\n  });\n\n};\n\n// left/top positioning\nproto.setLeftTop = function() {\n  this.element.style.left = this.position.x + 'px';\n  this.element.style.top  = this.position.y + 'px';\n};\n\nproto.positionDrag = function() {\n  this.element.style.transform = 'translate3d( ' + this.dragPoint.x +\n    'px, ' + this.dragPoint.y + 'px, 0)';\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  this.dispatchEvent( 'staticClick', event, [ pointer ] );\n};\n\n// ----- methods ----- //\n\n/**\n * @param {Number} x\n * @param {Number} y\n */\nproto.setPosition = function( x, y ) {\n  this.position.x = x;\n  this.position.y = y;\n  this.setLeftTop();\n};\n\nproto.enable = function() {\n  this.isEnabled = true;\n};\n\nproto.disable = function() {\n  this.isEnabled = false;\n  if ( this.isDragging ) {\n    this.dragEnd();\n  }\n};\n\nproto.destroy = function() {\n  this.disable();\n  // reset styles\n  this.element.style.transform = '';\n  this.element.style.left = '';\n  this.element.style.top = '';\n  this.element.style.position = '';\n  // unbind handles\n  this.unbindHandles();\n  // remove jQuery data\n  if ( this.$element ) {\n    this.$element.removeData('draggabilly');\n  }\n};\n\n// ----- jQuery bridget ----- //\n\n// required for jQuery bridget\nproto._init = noop;\n\nif ( jQuery && jQuery.bridget ) {\n  jQuery.bridget( 'draggabilly', Draggabilly );\n}\n\n// -----  ----- //\n\nreturn Draggabilly;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2RyYWdnYWJpbGx5L2RyYWdnYWJpbGx5LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9kcmFnZ2FiaWxseS9kcmFnZ2FiaWxseS5qcz9kNTBhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRHJhZ2dhYmlsbHkgdjIuMi4wXG4gKiBNYWtlIHRoYXQgc2hpeiBkcmFnZ2FibGVcbiAqIGh0dHBzOi8vZHJhZ2dhYmlsbHkuZGVzYW5kcm8uY29tXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKmdsb2JhbHMgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICAgJ2dldC1zaXplL2dldC1zaXplJyxcbiAgICAgICAgJ3VuaWRyYWdnZXIvdW5pZHJhZ2dlcidcbiAgICAgIF0sXG4gICAgICBmdW5jdGlvbiggZ2V0U2l6ZSwgVW5pZHJhZ2dlciApIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgZ2V0U2l6ZSwgVW5pZHJhZ2dlciApO1xuICAgICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCdnZXQtc2l6ZScpLFxuICAgICAgcmVxdWlyZSgndW5pZHJhZ2dlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5EcmFnZ2FiaWxseSA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuZ2V0U2l6ZSxcbiAgICAgIHdpbmRvdy5VbmlkcmFnZ2VyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgZ2V0U2l6ZSwgVW5pZHJhZ2dlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzICYgdmFyaWFibGVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGV4dGVuZCBvYmplY3RzXG5mdW5jdGlvbiBleHRlbmQoIGEsIGIgKSB7XG4gIGZvciAoIHZhciBwcm9wIGluIGIgKSB7XG4gICAgYVsgcHJvcCBdID0gYlsgcHJvcCBdO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBEcmFnZ2FiaWxseSggZWxlbWVudCwgb3B0aW9ucyApIHtcbiAgLy8gcXVlcnlTZWxlY3RvciBpZiBzdHJpbmdcbiAgdGhpcy5lbGVtZW50ID0gdHlwZW9mIGVsZW1lbnQgPT0gJ3N0cmluZycgP1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW1lbnQgKSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCBqUXVlcnkgKSB7XG4gICAgdGhpcy4kZWxlbWVudCA9IGpRdWVyeSggdGhpcy5lbGVtZW50ICk7XG4gIH1cblxuICAvLyBvcHRpb25zXG4gIHRoaXMub3B0aW9ucyA9IGV4dGVuZCgge30sIHRoaXMuY29uc3RydWN0b3IuZGVmYXVsdHMgKTtcbiAgdGhpcy5vcHRpb24oIG9wdGlvbnMgKTtcblxuICB0aGlzLl9jcmVhdGUoKTtcbn1cblxuLy8gaW5oZXJpdCBVbmlkcmFnZ2VyIG1ldGhvZHNcbnZhciBwcm90byA9IERyYWdnYWJpbGx5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFVuaWRyYWdnZXIucHJvdG90eXBlICk7XG5cbkRyYWdnYWJpbGx5LmRlZmF1bHRzID0ge1xufTtcblxuLyoqXG4gKiBzZXQgb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xucHJvdG8ub3B0aW9uID0gZnVuY3Rpb24oIG9wdHMgKSB7XG4gIGV4dGVuZCggdGhpcy5vcHRpb25zLCBvcHRzICk7XG59O1xuXG4vLyBjc3MgcG9zaXRpb24gdmFsdWVzIHRoYXQgZG9uJ3QgbmVlZCB0byBiZSBzZXRcbnZhciBwb3NpdGlvblZhbHVlcyA9IHtcbiAgcmVsYXRpdmU6IHRydWUsXG4gIGFic29sdXRlOiB0cnVlLFxuICBmaXhlZDogdHJ1ZVxufTtcblxucHJvdG8uX2NyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBwcm9wZXJ0aWVzXG4gIHRoaXMucG9zaXRpb24gPSB7fTtcbiAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcblxuICB0aGlzLnN0YXJ0UG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbiAgdGhpcy5kcmFnUG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcblxuICB0aGlzLnN0YXJ0UG9zaXRpb24gPSBleHRlbmQoIHt9LCB0aGlzLnBvc2l0aW9uICk7XG5cbiAgLy8gc2V0IHJlbGF0aXZlIHBvc2l0aW9uaW5nXG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHRoaXMuZWxlbWVudCApO1xuICBpZiAoICFwb3NpdGlvblZhbHVlc1sgc3R5bGUucG9zaXRpb24gXSApIHtcbiAgICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICB9XG5cbiAgLy8gZXZlbnRzLCBicmlkZ2UgalF1ZXJ5IGV2ZW50cyBmcm9tIHZhbmlsbGFcbiAgdGhpcy5vbiggJ3BvaW50ZXJEb3duJywgdGhpcy5vblBvaW50ZXJEb3duICk7XG4gIHRoaXMub24oICdwb2ludGVyTW92ZScsIHRoaXMub25Qb2ludGVyTW92ZSApO1xuICB0aGlzLm9uKCAncG9pbnRlclVwJywgdGhpcy5vblBvaW50ZXJVcCApO1xuXG4gIHRoaXMuZW5hYmxlKCk7XG4gIHRoaXMuc2V0SGFuZGxlcygpO1xufTtcblxuLyoqXG4gKiBzZXQgdGhpcy5oYW5kbGVzIGFuZCBiaW5kIHN0YXJ0IGV2ZW50cyB0byAnZW1cbiAqL1xucHJvdG8uc2V0SGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmhhbmRsZXMgPSB0aGlzLm9wdGlvbnMuaGFuZGxlID9cbiAgICB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCggdGhpcy5vcHRpb25zLmhhbmRsZSApIDogWyB0aGlzLmVsZW1lbnQgXTtcblxuICB0aGlzLmJpbmRIYW5kbGVzKCk7XG59O1xuXG4vKipcbiAqIGVtaXRzIGV2ZW50cyB2aWEgRXZFbWl0dGVyIGFuZCBqUXVlcnkgZXZlbnRzXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIG5hbWUgb2YgZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gb3JpZ2luYWwgZXZlbnRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgLSBleHRyYSBhcmd1bWVudHNcbiAqL1xucHJvdG8uZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgYXJncyApIHtcbiAgdmFyIGVtaXRBcmdzID0gWyBldmVudCBdLmNvbmNhdCggYXJncyApO1xuICB0aGlzLmVtaXRFdmVudCggdHlwZSwgZW1pdEFyZ3MgKTtcbiAgdGhpcy5kaXNwYXRjaEpRdWVyeUV2ZW50KCB0eXBlLCBldmVudCwgYXJncyApO1xufTtcblxucHJvdG8uZGlzcGF0Y2hKUXVlcnlFdmVudCA9IGZ1bmN0aW9uKCB0eXBlLCBldmVudCwgYXJncyApIHtcbiAgdmFyIGpRdWVyeSA9IHdpbmRvdy5qUXVlcnk7XG4gIC8vIHRyaWdnZXIgalF1ZXJ5IGV2ZW50XG4gIGlmICggIWpRdWVyeSB8fCAhdGhpcy4kZWxlbWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gY3JlYXRlIGpRdWVyeSBldmVudFxuICB2YXIgJGV2ZW50ID0galF1ZXJ5LkV2ZW50KCBldmVudCApO1xuICAkZXZlbnQudHlwZSA9IHR5cGU7XG4gIHRoaXMuJGVsZW1lbnQudHJpZ2dlciggJGV2ZW50LCBhcmdzICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBwb3NpdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnZXQgeC95IHBvc2l0aW9uIGZyb20gc3R5bGVcbnByb3RvLl9nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgdmFyIHggPSB0aGlzLl9nZXRQb3NpdGlvbkNvb3JkKCBzdHlsZS5sZWZ0LCAnd2lkdGgnICk7XG4gIHZhciB5ID0gdGhpcy5fZ2V0UG9zaXRpb25Db29yZCggc3R5bGUudG9wLCAnaGVpZ2h0JyApO1xuICAvLyBjbGVhbiB1cCAnYXV0bycgb3Igb3RoZXIgbm9uLWludGVnZXIgdmFsdWVzXG4gIHRoaXMucG9zaXRpb24ueCA9IGlzTmFOKCB4ICkgPyAwIDogeDtcbiAgdGhpcy5wb3NpdGlvbi55ID0gaXNOYU4oIHkgKSA/IDAgOiB5O1xuXG4gIHRoaXMuX2FkZFRyYW5zZm9ybVBvc2l0aW9uKCBzdHlsZSApO1xufTtcblxucHJvdG8uX2dldFBvc2l0aW9uQ29vcmQgPSBmdW5jdGlvbiggc3R5bGVTaWRlLCBtZWFzdXJlICkge1xuICBpZiAoIHN0eWxlU2lkZS5pbmRleE9mKCclJykgIT0gLTEgKSB7XG4gICAgLy8gY29udmVydCBwZXJjZW50IGludG8gcGl4ZWwgZm9yIFNhZmFyaSwgIzc1XG4gICAgdmFyIHBhcmVudFNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSApO1xuICAgIC8vIHByZXZlbnQgbm90LWluLURPTSBlbGVtZW50IHRocm93aW5nIGJ1ZywgIzEzMVxuICAgIHJldHVybiAhcGFyZW50U2l6ZSA/IDAgOlxuICAgICAgKCBwYXJzZUZsb2F0KCBzdHlsZVNpZGUgKSAvIDEwMCApICogcGFyZW50U2l6ZVsgbWVhc3VyZSBdO1xuICB9XG4gIHJldHVybiBwYXJzZUludCggc3R5bGVTaWRlLCAxMCApO1xufTtcblxuLy8gYWRkIHRyYW5zZm9ybTogdHJhbnNsYXRlKCB4LCB5ICkgdG8gcG9zaXRpb25cbnByb3RvLl9hZGRUcmFuc2Zvcm1Qb3NpdGlvbiA9IGZ1bmN0aW9uKCBzdHlsZSApIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybTtcbiAgLy8gYmFpbCBvdXQgaWYgdmFsdWUgaXMgJ25vbmUnXG4gIGlmICggdHJhbnNmb3JtLmluZGV4T2YoJ21hdHJpeCcpICE9PSAwICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzcGxpdCBtYXRyaXgoMSwgMCwgMCwgMSwgeCwgeSlcbiAgdmFyIG1hdHJpeFZhbHVlcyA9IHRyYW5zZm9ybS5zcGxpdCgnLCcpO1xuICAvLyB0cmFuc2xhdGUgWCB2YWx1ZSBpcyBpbiAxMnRoIG9yIDR0aCBwb3NpdGlvblxuICB2YXIgeEluZGV4ID0gdHJhbnNmb3JtLmluZGV4T2YoJ21hdHJpeDNkJykgPT09IDAgPyAxMiA6IDQ7XG4gIHZhciB0cmFuc2xhdGVYID0gcGFyc2VJbnQoIG1hdHJpeFZhbHVlc1sgeEluZGV4IF0sIDEwICk7XG4gIC8vIHRyYW5zbGF0ZSBZIHZhbHVlIGlzIGluIDEzdGggb3IgNXRoIHBvc2l0aW9uXG4gIHZhciB0cmFuc2xhdGVZID0gcGFyc2VJbnQoIG1hdHJpeFZhbHVlc1sgeEluZGV4ICsgMSBdLCAxMCApO1xuICB0aGlzLnBvc2l0aW9uLnggKz0gdHJhbnNsYXRlWDtcbiAgdGhpcy5wb3NpdGlvbi55ICs9IHRyYW5zbGF0ZVk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBldmVudHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxucHJvdG8ub25Qb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLXBvaW50ZXItZG93bicpO1xuICB0aGlzLmRpc3BhdGNoSlF1ZXJ5RXZlbnQoICdwb2ludGVyRG93bicsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xufTtcblxuLyoqXG4gKiBkcmFnIHN0YXJ0XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5kcmFnU3RhcnQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIGlmICggIXRoaXMuaXNFbmFibGVkICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9nZXRQb3NpdGlvbigpO1xuICB0aGlzLm1lYXN1cmVDb250YWlubWVudCgpO1xuICAvLyBwb3NpdGlvbiBfd2hlbl8gZHJhZyBiZWdhblxuICB0aGlzLnN0YXJ0UG9zaXRpb24ueCA9IHRoaXMucG9zaXRpb24ueDtcbiAgdGhpcy5zdGFydFBvc2l0aW9uLnkgPSB0aGlzLnBvc2l0aW9uLnk7XG4gIC8vIHJlc2V0IGxlZnQvdG9wIHN0eWxlXG4gIHRoaXMuc2V0TGVmdFRvcCgpO1xuXG4gIHRoaXMuZHJhZ1BvaW50LnggPSAwO1xuICB0aGlzLmRyYWdQb2ludC55ID0gMDtcblxuICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaXMtZHJhZ2dpbmcnKTtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnZHJhZ1N0YXJ0JywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG4gIC8vIHN0YXJ0IGFuaW1hdGlvblxuICB0aGlzLmFuaW1hdGUoKTtcbn07XG5cbnByb3RvLm1lYXN1cmVDb250YWlubWVudCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIoKTtcbiAgaWYgKCAhY29udGFpbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBlbGVtU2l6ZSA9IGdldFNpemUoIHRoaXMuZWxlbWVudCApO1xuICB2YXIgY29udGFpbmVyU2l6ZSA9IGdldFNpemUoIGNvbnRhaW5lciApO1xuICB2YXIgZWxlbVJlY3QgPSB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gIHZhciBib3JkZXJTaXplWCA9IGNvbnRhaW5lclNpemUuYm9yZGVyTGVmdFdpZHRoICsgY29udGFpbmVyU2l6ZS5ib3JkZXJSaWdodFdpZHRoO1xuICB2YXIgYm9yZGVyU2l6ZVkgPSBjb250YWluZXJTaXplLmJvcmRlclRvcFdpZHRoICsgY29udGFpbmVyU2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcblxuICB2YXIgcG9zaXRpb24gPSB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvbiA9IHtcbiAgICB4OiBlbGVtUmVjdC5sZWZ0IC0gKCBjb250YWluZXJSZWN0LmxlZnQgKyBjb250YWluZXJTaXplLmJvcmRlckxlZnRXaWR0aCApLFxuICAgIHk6IGVsZW1SZWN0LnRvcCAtICggY29udGFpbmVyUmVjdC50b3AgKyBjb250YWluZXJTaXplLmJvcmRlclRvcFdpZHRoIClcbiAgfTtcblxuICB0aGlzLmNvbnRhaW5TaXplID0ge1xuICAgIHdpZHRoOiAoIGNvbnRhaW5lclNpemUud2lkdGggLSBib3JkZXJTaXplWCApIC0gcG9zaXRpb24ueCAtIGVsZW1TaXplLndpZHRoLFxuICAgIGhlaWdodDogKCBjb250YWluZXJTaXplLmhlaWdodCAtIGJvcmRlclNpemVZICkgLSBwb3NpdGlvbi55IC0gZWxlbVNpemUuaGVpZ2h0XG4gIH07XG59O1xuXG5wcm90by5nZXRDb250YWluZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRhaW5tZW50ID0gdGhpcy5vcHRpb25zLmNvbnRhaW5tZW50O1xuICBpZiAoICFjb250YWlubWVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlzRWxlbWVudCA9IGNvbnRhaW5tZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG4gIC8vIHVzZSBhcyBlbGVtZW50XG4gIGlmICggaXNFbGVtZW50ICkge1xuICAgIHJldHVybiBjb250YWlubWVudDtcbiAgfVxuICAvLyBxdWVyeVNlbGVjdG9yIGlmIHN0cmluZ1xuICBpZiAoIHR5cGVvZiBjb250YWlubWVudCA9PSAnc3RyaW5nJyApIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggY29udGFpbm1lbnQgKTtcbiAgfVxuICAvLyBmYWxsYmFjayB0byBwYXJlbnQgZWxlbWVudFxuICByZXR1cm4gdGhpcy5lbGVtZW50LnBhcmVudE5vZGU7XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLm9uUG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIHRoaXMuZGlzcGF0Y2hKUXVlcnlFdmVudCggJ3BvaW50ZXJNb3ZlJywgZXZlbnQsIFsgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XG59O1xuXG4vKipcbiAqIGRyYWcgbW92ZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8uZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIGlmICggIXRoaXMuaXNFbmFibGVkICkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgZHJhZ1ggPSBtb3ZlVmVjdG9yLng7XG4gIHZhciBkcmFnWSA9IG1vdmVWZWN0b3IueTtcblxuICB2YXIgZ3JpZCA9IHRoaXMub3B0aW9ucy5ncmlkO1xuICB2YXIgZ3JpZFggPSBncmlkICYmIGdyaWRbMF07XG4gIHZhciBncmlkWSA9IGdyaWQgJiYgZ3JpZFsxXTtcblxuICBkcmFnWCA9IGFwcGx5R3JpZCggZHJhZ1gsIGdyaWRYICk7XG4gIGRyYWdZID0gYXBwbHlHcmlkKCBkcmFnWSwgZ3JpZFkgKTtcblxuICBkcmFnWCA9IHRoaXMuY29udGFpbkRyYWcoICd4JywgZHJhZ1gsIGdyaWRYICk7XG4gIGRyYWdZID0gdGhpcy5jb250YWluRHJhZyggJ3knLCBkcmFnWSwgZ3JpZFkgKTtcblxuICAvLyBjb25zdHJhaW4gdG8gYXhpc1xuICBkcmFnWCA9IHRoaXMub3B0aW9ucy5heGlzID09ICd5JyA/IDAgOiBkcmFnWDtcbiAgZHJhZ1kgPSB0aGlzLm9wdGlvbnMuYXhpcyA9PSAneCcgPyAwIDogZHJhZ1k7XG5cbiAgdGhpcy5wb3NpdGlvbi54ID0gdGhpcy5zdGFydFBvc2l0aW9uLnggKyBkcmFnWDtcbiAgdGhpcy5wb3NpdGlvbi55ID0gdGhpcy5zdGFydFBvc2l0aW9uLnkgKyBkcmFnWTtcbiAgLy8gc2V0IGRyYWdQb2ludCBwcm9wZXJ0aWVzXG4gIHRoaXMuZHJhZ1BvaW50LnggPSBkcmFnWDtcbiAgdGhpcy5kcmFnUG9pbnQueSA9IGRyYWdZO1xuXG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdNb3ZlJywgZXZlbnQsIFsgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XG59O1xuXG5mdW5jdGlvbiBhcHBseUdyaWQoIHZhbHVlLCBncmlkLCBtZXRob2QgKSB7XG4gIG1ldGhvZCA9IG1ldGhvZCB8fCAncm91bmQnO1xuICByZXR1cm4gZ3JpZCA/IE1hdGhbIG1ldGhvZCBdKCB2YWx1ZSAvIGdyaWQgKSAqIGdyaWQgOiB2YWx1ZTtcbn1cblxucHJvdG8uY29udGFpbkRyYWcgPSBmdW5jdGlvbiggYXhpcywgZHJhZywgZ3JpZCApIHtcbiAgaWYgKCAhdGhpcy5vcHRpb25zLmNvbnRhaW5tZW50ICkge1xuICAgIHJldHVybiBkcmFnO1xuICB9XG4gIHZhciBtZWFzdXJlID0gYXhpcyA9PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgdmFyIHJlbCA9IHRoaXMucmVsYXRpdmVTdGFydFBvc2l0aW9uWyBheGlzIF07XG4gIHZhciBtaW4gPSBhcHBseUdyaWQoIC1yZWwsIGdyaWQsICdjZWlsJyApO1xuICB2YXIgbWF4ID0gdGhpcy5jb250YWluU2l6ZVsgbWVhc3VyZSBdO1xuICBtYXggPSBhcHBseUdyaWQoIG1heCwgZ3JpZCwgJ2Zsb29yJyApO1xuICByZXR1cm4gIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGRyYWcgKSApO1xufTtcblxuLy8gLS0tLS0gZW5kIGV2ZW50IC0tLS0tIC8vXG5cbi8qKlxuICogcG9pbnRlciB1cFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8ub25Qb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1wb2ludGVyLWRvd24nKTtcbiAgdGhpcy5kaXNwYXRjaEpRdWVyeUV2ZW50KCAncG9pbnRlclVwJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG4vKipcbiAqIGRyYWcgZW5kXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdXNlIHRvcCBsZWZ0IHBvc2l0aW9uIHdoZW4gY29tcGxldGVcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICB0aGlzLnNldExlZnRUb3AoKTtcbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2lzLWRyYWdnaW5nJyk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdFbmQnLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGFuaW1hdGlvbiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5wcm90by5hbmltYXRlID0gZnVuY3Rpb24oKSB7XG4gIC8vIG9ubHkgcmVuZGVyIGFuZCBhbmltYXRlIGlmIGRyYWdnaW5nXG4gIGlmICggIXRoaXMuaXNEcmFnZ2luZyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnBvc2l0aW9uRHJhZygpO1xuXG4gIHZhciBfdGhpcyA9IHRoaXM7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSggZnVuY3Rpb24gYW5pbWF0ZUZyYW1lKCkge1xuICAgIF90aGlzLmFuaW1hdGUoKTtcbiAgfSk7XG5cbn07XG5cbi8vIGxlZnQvdG9wIHBvc2l0aW9uaW5nXG5wcm90by5zZXRMZWZ0VG9wID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gdGhpcy5wb3NpdGlvbi54ICsgJ3B4JztcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCAgPSB0aGlzLnBvc2l0aW9uLnkgKyAncHgnO1xufTtcblxucHJvdG8ucG9zaXRpb25EcmFnID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoICcgKyB0aGlzLmRyYWdQb2ludC54ICtcbiAgICAncHgsICcgKyB0aGlzLmRyYWdQb2ludC55ICsgJ3B4LCAwKSc7XG59O1xuXG4vLyAtLS0tLSBzdGF0aWNDbGljayAtLS0tLSAvL1xuXG5wcm90by5zdGF0aWNDbGljayA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5kaXNwYXRjaEV2ZW50KCAnc3RhdGljQ2xpY2snLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIG1ldGhvZHMgLS0tLS0gLy9cblxuLyoqXG4gKiBAcGFyYW0ge051bWJlcn0geFxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqL1xucHJvdG8uc2V0UG9zaXRpb24gPSBmdW5jdGlvbiggeCwgeSApIHtcbiAgdGhpcy5wb3NpdGlvbi54ID0geDtcbiAgdGhpcy5wb3NpdGlvbi55ID0geTtcbiAgdGhpcy5zZXRMZWZ0VG9wKCk7XG59O1xuXG5wcm90by5lbmFibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0VuYWJsZWQgPSB0cnVlO1xufTtcblxucHJvdG8uZGlzYWJsZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmlzRW5hYmxlZCA9IGZhbHNlO1xuICBpZiAoIHRoaXMuaXNEcmFnZ2luZyApIHtcbiAgICB0aGlzLmRyYWdFbmQoKTtcbiAgfVxufTtcblxucHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmRpc2FibGUoKTtcbiAgLy8gcmVzZXQgc3R5bGVzXG4gIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgdGhpcy5lbGVtZW50LnN0eWxlLmxlZnQgPSAnJztcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9ICcnO1xuICB0aGlzLmVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgLy8gdW5iaW5kIGhhbmRsZXNcbiAgdGhpcy51bmJpbmRIYW5kbGVzKCk7XG4gIC8vIHJlbW92ZSBqUXVlcnkgZGF0YVxuICBpZiAoIHRoaXMuJGVsZW1lbnQgKSB7XG4gICAgdGhpcy4kZWxlbWVudC5yZW1vdmVEYXRhKCdkcmFnZ2FiaWxseScpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBqUXVlcnkgYnJpZGdldCAtLS0tLSAvL1xuXG4vLyByZXF1aXJlZCBmb3IgalF1ZXJ5IGJyaWRnZXRcbnByb3RvLl9pbml0ID0gbm9vcDtcblxuaWYgKCBqUXVlcnkgJiYgalF1ZXJ5LmJyaWRnZXQgKSB7XG4gIGpRdWVyeS5icmlkZ2V0KCAnZHJhZ2dhYmlsbHknLCBEcmFnZ2FiaWxseSApO1xufVxuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIERyYWdnYWJpbGx5O1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/draggabilly/draggabilly.js\n");

/***/ }),

/***/ "../node_modules/ev-emitter/ev-emitter.js":
/*!************************************************!*\
  !*** ../node_modules/ev-emitter/ev-emitter.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice(0);\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( var i=0; i < listeners.length; i++ ) {\n    var listener = listeners[i]\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n};\n\nreturn EvEmitter;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2V2LWVtaXR0ZXIvZXYtZW1pdHRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXYtZW1pdHRlci9ldi1lbWl0dGVyLmpzP2VkM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFdkVtaXR0ZXIgdjEuMS4wXG4gKiBMaWwnIGV2ZW50IGVtaXR0ZXJcbiAqIE1JVCBMaWNlbnNlXG4gKi9cblxuLyoganNoaW50IHVudXNlZDogdHJ1ZSwgdW5kZWY6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKiBqc2hpbnQgc3RyaWN0OiBmYWxzZSAqLyAvKiBnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCB3aW5kb3cgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTUQgLSBSZXF1aXJlSlNcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KUyAtIEJyb3dzZXJpZnksIFdlYnBhY2tcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBCcm93c2VyIGdsb2JhbHNcbiAgICBnbG9iYWwuRXZFbWl0dGVyID0gZmFjdG9yeSgpO1xuICB9XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbigpIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEV2RW1pdHRlcigpIHt9XG5cbnZhciBwcm90byA9IEV2RW1pdHRlci5wcm90b3R5cGU7XG5cbnByb3RvLm9uID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIGlmICggIWV2ZW50TmFtZSB8fCAhbGlzdGVuZXIgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNldCBldmVudHMgaGFzaFxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICAvLyBzZXQgbGlzdGVuZXJzIGFycmF5XG4gIHZhciBsaXN0ZW5lcnMgPSBldmVudHNbIGV2ZW50TmFtZSBdID0gZXZlbnRzWyBldmVudE5hbWUgXSB8fCBbXTtcbiAgLy8gb25seSBhZGQgb25jZVxuICBpZiAoIGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApID09IC0xICkge1xuICAgIGxpc3RlbmVycy5wdXNoKCBsaXN0ZW5lciApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vbmNlID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgbGlzdGVuZXIgKSB7XG4gIGlmICggIWV2ZW50TmFtZSB8fCAhbGlzdGVuZXIgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGFkZCBldmVudFxuICB0aGlzLm9uKCBldmVudE5hbWUsIGxpc3RlbmVyICk7XG4gIC8vIHNldCBvbmNlIGZsYWdcbiAgLy8gc2V0IG9uY2VFdmVudHMgaGFzaFxuICB2YXIgb25jZUV2ZW50cyA9IHRoaXMuX29uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzIHx8IHt9O1xuICAvLyBzZXQgb25jZUxpc3RlbmVycyBvYmplY3RcbiAgdmFyIG9uY2VMaXN0ZW5lcnMgPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSA9IG9uY2VFdmVudHNbIGV2ZW50TmFtZSBdIHx8IHt9O1xuICAvLyBzZXQgZmxhZ1xuICBvbmNlTGlzdGVuZXJzWyBsaXN0ZW5lciBdID0gdHJ1ZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLm9mZiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1sgZXZlbnROYW1lIF07XG4gIGlmICggIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YoIGxpc3RlbmVyICk7XG4gIGlmICggaW5kZXggIT0gLTEgKSB7XG4gICAgbGlzdGVuZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8uZW1pdEV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50TmFtZSwgYXJncyApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGNvcHkgb3ZlciB0byBhdm9pZCBpbnRlcmZlcmVuY2UgaWYgLm9mZigpIGluIGxpc3RlbmVyXG4gIGxpc3RlbmVycyA9IGxpc3RlbmVycy5zbGljZSgwKTtcbiAgYXJncyA9IGFyZ3MgfHwgW107XG4gIC8vIG9uY2Ugc3R1ZmZcbiAgdmFyIG9uY2VMaXN0ZW5lcnMgPSB0aGlzLl9vbmNlRXZlbnRzICYmIHRoaXMuX29uY2VFdmVudHNbIGV2ZW50TmFtZSBdO1xuXG4gIGZvciAoIHZhciBpPTA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldXG4gICAgdmFyIGlzT25jZSA9IG9uY2VMaXN0ZW5lcnMgJiYgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXTtcbiAgICBpZiAoIGlzT25jZSApIHtcbiAgICAgIC8vIHJlbW92ZSBsaXN0ZW5lclxuICAgICAgLy8gcmVtb3ZlIGJlZm9yZSB0cmlnZ2VyIHRvIHByZXZlbnQgcmVjdXJzaW9uXG4gICAgICB0aGlzLm9mZiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAgICAgLy8gdW5zZXQgb25jZSBmbGFnXG4gICAgICBkZWxldGUgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXTtcbiAgICB9XG4gICAgLy8gdHJpZ2dlciBsaXN0ZW5lclxuICAgIGxpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmdzICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmFsbE9mZiA9IGZ1bmN0aW9uKCkge1xuICBkZWxldGUgdGhpcy5fZXZlbnRzO1xuICBkZWxldGUgdGhpcy5fb25jZUV2ZW50cztcbn07XG5cbnJldHVybiBFdkVtaXR0ZXI7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsV0FNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/ev-emitter/ev-emitter.js\n");

/***/ }),

/***/ "../node_modules/get-size/get-size.js":
/*!********************************************!*\
  !*** ../node_modules/get-size/get-size.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n/* globals console: false */\n\n( function( window, factory ) {\n  /* jshint strict: false */ /* globals define, module */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})( window, function factory() {\n'use strict';\n\n// -------------------------- helpers -------------------------- //\n\n// get a number from a string, not a percentage\nfunction getStyleSize( value ) {\n  var num = parseFloat( value );\n  // not a percent like '100%', and a number\n  var isValid = value.indexOf('%') == -1 && !isNaN( num );\n  return isValid && num;\n}\n\nfunction noop() {}\n\nvar logError = typeof console == 'undefined' ? noop :\n  function( message ) {\n    console.error( message );\n  };\n\n// -------------------------- measurements -------------------------- //\n\nvar measurements = [\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'paddingBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopWidth',\n  'borderBottomWidth'\n];\n\nvar measurementsLength = measurements.length;\n\nfunction getZeroSize() {\n  var size = {\n    width: 0,\n    height: 0,\n    innerWidth: 0,\n    innerHeight: 0,\n    outerWidth: 0,\n    outerHeight: 0\n  };\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    size[ measurement ] = 0;\n  }\n  return size;\n}\n\n// -------------------------- getStyle -------------------------- //\n\n/**\n * getStyle, get style of element, check for Firefox bug\n * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\nfunction getStyle( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    logError( 'Style returned ' + style +\n      '. Are you running this code in a hidden iframe on Firefox? ' +\n      'See https://bit.ly/getsizebug1' );\n  }\n  return style;\n}\n\n// -------------------------- setup -------------------------- //\n\nvar isSetup = false;\n\nvar isBoxSizeOuter;\n\n/**\n * setup\n * check isBoxSizerOuter\n * do on first getSize() rather than on page load for Firefox bug\n */\nfunction setup() {\n  // setup once\n  if ( isSetup ) {\n    return;\n  }\n  isSetup = true;\n\n  // -------------------------- box sizing -------------------------- //\n\n  /**\n   * Chrome & Safari measure the outer-width on style.width on border-box elems\n   * IE11 & Firefox<29 measures the inner-width\n   */\n  var div = document.createElement('div');\n  div.style.width = '200px';\n  div.style.padding = '1px 2px 3px 4px';\n  div.style.borderStyle = 'solid';\n  div.style.borderWidth = '1px 2px 3px 4px';\n  div.style.boxSizing = 'border-box';\n\n  var body = document.body || document.documentElement;\n  body.appendChild( div );\n  var style = getStyle( div );\n  // round value for browser zoom. desandro/masonry#928\n  isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;\n  getSize.isBoxSizeOuter = isBoxSizeOuter;\n\n  body.removeChild( div );\n}\n\n// -------------------------- getSize -------------------------- //\n\nfunction getSize( elem ) {\n  setup();\n\n  // use querySeletor if elem is string\n  if ( typeof elem == 'string' ) {\n    elem = document.querySelector( elem );\n  }\n\n  // do not proceed on non-objects\n  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {\n    return;\n  }\n\n  var style = getStyle( elem );\n\n  // if hidden, everything is 0\n  if ( style.display == 'none' ) {\n    return getZeroSize();\n  }\n\n  var size = {};\n  size.width = elem.offsetWidth;\n  size.height = elem.offsetHeight;\n\n  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n  // get all measurements\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    var value = style[ measurement ];\n    var num = parseFloat( value );\n    // any 'auto', 'medium' value will be 0\n    size[ measurement ] = !isNaN( num ) ? num : 0;\n  }\n\n  var paddingWidth = size.paddingLeft + size.paddingRight;\n  var paddingHeight = size.paddingTop + size.paddingBottom;\n  var marginWidth = size.marginLeft + size.marginRight;\n  var marginHeight = size.marginTop + size.marginBottom;\n  var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n  var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n  // overwrite width and height if we can get it from style\n  var styleWidth = getStyleSize( style.width );\n  if ( styleWidth !== false ) {\n    size.width = styleWidth +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );\n  }\n\n  var styleHeight = getStyleSize( style.height );\n  if ( styleHeight !== false ) {\n    size.height = styleHeight +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );\n  }\n\n  size.innerWidth = size.width - ( paddingWidth + borderWidth );\n  size.innerHeight = size.height - ( paddingHeight + borderHeight );\n\n  size.outerWidth = size.width + marginWidth;\n  size.outerHeight = size.height + marginHeight;\n\n  return size;\n}\n\nreturn getSize;\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL2dldC1zaXplL2dldC1zaXplLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9nZXQtc2l6ZS9nZXQtc2l6ZS5qcz83MGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZ2V0U2l6ZSB2Mi4wLjNcbiAqIG1lYXN1cmUgc2l6ZSBvZiBlbGVtZW50c1xuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKiBqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgc3RyaWN0OiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlICovXG4vKiBnbG9iYWxzIGNvbnNvbGU6IGZhbHNlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSAqL1xuICBpZiAoIHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kICkge1xuICAgIC8vIEFNRFxuICAgIGRlZmluZSggZmFjdG9yeSApO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuZ2V0U2l6ZSA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCkge1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBoZWxwZXJzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGdldCBhIG51bWJlciBmcm9tIGEgc3RyaW5nLCBub3QgYSBwZXJjZW50YWdlXG5mdW5jdGlvbiBnZXRTdHlsZVNpemUoIHZhbHVlICkge1xuICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgLy8gbm90IGEgcGVyY2VudCBsaWtlICcxMDAlJywgYW5kIGEgbnVtYmVyXG4gIHZhciBpc1ZhbGlkID0gdmFsdWUuaW5kZXhPZignJScpID09IC0xICYmICFpc05hTiggbnVtICk7XG4gIHJldHVybiBpc1ZhbGlkICYmIG51bTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBsb2dFcnJvciA9IHR5cGVvZiBjb25zb2xlID09ICd1bmRlZmluZWQnID8gbm9vcCA6XG4gIGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuICAgIGNvbnNvbGUuZXJyb3IoIG1lc3NhZ2UgKTtcbiAgfTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gbWVhc3VyZW1lbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBtZWFzdXJlbWVudHMgPSBbXG4gICdwYWRkaW5nTGVmdCcsXG4gICdwYWRkaW5nUmlnaHQnLFxuICAncGFkZGluZ1RvcCcsXG4gICdwYWRkaW5nQm90dG9tJyxcbiAgJ21hcmdpbkxlZnQnLFxuICAnbWFyZ2luUmlnaHQnLFxuICAnbWFyZ2luVG9wJyxcbiAgJ21hcmdpbkJvdHRvbScsXG4gICdib3JkZXJMZWZ0V2lkdGgnLFxuICAnYm9yZGVyUmlnaHRXaWR0aCcsXG4gICdib3JkZXJUb3BXaWR0aCcsXG4gICdib3JkZXJCb3R0b21XaWR0aCdcbl07XG5cbnZhciBtZWFzdXJlbWVudHNMZW5ndGggPSBtZWFzdXJlbWVudHMubGVuZ3RoO1xuXG5mdW5jdGlvbiBnZXRaZXJvU2l6ZSgpIHtcbiAgdmFyIHNpemUgPSB7XG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwLFxuICAgIGlubmVyV2lkdGg6IDAsXG4gICAgaW5uZXJIZWlnaHQ6IDAsXG4gICAgb3V0ZXJXaWR0aDogMCxcbiAgICBvdXRlckhlaWdodDogMFxuICB9O1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgbWVhc3VyZW1lbnRzTGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHNpemVbIG1lYXN1cmVtZW50IF0gPSAwO1xuICB9XG4gIHJldHVybiBzaXplO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBnZXRTdHlsZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vKipcbiAqIGdldFN0eWxlLCBnZXQgc3R5bGUgb2YgZWxlbWVudCwgY2hlY2sgZm9yIEZpcmVmb3ggYnVnXG4gKiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD01NDgzOTdcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUoIGVsZW0gKSB7XG4gIHZhciBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIGVsZW0gKTtcbiAgaWYgKCAhc3R5bGUgKSB7XG4gICAgbG9nRXJyb3IoICdTdHlsZSByZXR1cm5lZCAnICsgc3R5bGUgK1xuICAgICAgJy4gQXJlIHlvdSBydW5uaW5nIHRoaXMgY29kZSBpbiBhIGhpZGRlbiBpZnJhbWUgb24gRmlyZWZveD8gJyArXG4gICAgICAnU2VlIGh0dHBzOi8vYml0Lmx5L2dldHNpemVidWcxJyApO1xuICB9XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxudmFyIGlzU2V0dXAgPSBmYWxzZTtcblxudmFyIGlzQm94U2l6ZU91dGVyO1xuXG4vKipcbiAqIHNldHVwXG4gKiBjaGVjayBpc0JveFNpemVyT3V0ZXJcbiAqIGRvIG9uIGZpcnN0IGdldFNpemUoKSByYXRoZXIgdGhhbiBvbiBwYWdlIGxvYWQgZm9yIEZpcmVmb3ggYnVnXG4gKi9cbmZ1bmN0aW9uIHNldHVwKCkge1xuICAvLyBzZXR1cCBvbmNlXG4gIGlmICggaXNTZXR1cCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaXNTZXR1cCA9IHRydWU7XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gYm94IHNpemluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4gIC8qKlxuICAgKiBDaHJvbWUgJiBTYWZhcmkgbWVhc3VyZSB0aGUgb3V0ZXItd2lkdGggb24gc3R5bGUud2lkdGggb24gYm9yZGVyLWJveCBlbGVtc1xuICAgKiBJRTExICYgRmlyZWZveDwyOSBtZWFzdXJlcyB0aGUgaW5uZXItd2lkdGhcbiAgICovXG4gIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LnN0eWxlLndpZHRoID0gJzIwMHB4JztcbiAgZGl2LnN0eWxlLnBhZGRpbmcgPSAnMXB4IDJweCAzcHggNHB4JztcbiAgZGl2LnN0eWxlLmJvcmRlclN0eWxlID0gJ3NvbGlkJztcbiAgZGl2LnN0eWxlLmJvcmRlcldpZHRoID0gJzFweCAycHggM3B4IDRweCc7XG4gIGRpdi5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgYm9keS5hcHBlbmRDaGlsZCggZGl2ICk7XG4gIHZhciBzdHlsZSA9IGdldFN0eWxlKCBkaXYgKTtcbiAgLy8gcm91bmQgdmFsdWUgZm9yIGJyb3dzZXIgem9vbS4gZGVzYW5kcm8vbWFzb25yeSM5MjhcbiAgaXNCb3hTaXplT3V0ZXIgPSBNYXRoLnJvdW5kKCBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICkgKSA9PSAyMDA7XG4gIGdldFNpemUuaXNCb3hTaXplT3V0ZXIgPSBpc0JveFNpemVPdXRlcjtcblxuICBib2R5LnJlbW92ZUNoaWxkKCBkaXYgKTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2V0U2l6ZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG5mdW5jdGlvbiBnZXRTaXplKCBlbGVtICkge1xuICBzZXR1cCgpO1xuXG4gIC8vIHVzZSBxdWVyeVNlbGV0b3IgaWYgZWxlbSBpcyBzdHJpbmdcbiAgaWYgKCB0eXBlb2YgZWxlbSA9PSAnc3RyaW5nJyApIHtcbiAgICBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvciggZWxlbSApO1xuICB9XG5cbiAgLy8gZG8gbm90IHByb2NlZWQgb24gbm9uLW9iamVjdHNcbiAgaWYgKCAhZWxlbSB8fCB0eXBlb2YgZWxlbSAhPSAnb2JqZWN0JyB8fCAhZWxlbS5ub2RlVHlwZSApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZWxlbSApO1xuXG4gIC8vIGlmIGhpZGRlbiwgZXZlcnl0aGluZyBpcyAwXG4gIGlmICggc3R5bGUuZGlzcGxheSA9PSAnbm9uZScgKSB7XG4gICAgcmV0dXJuIGdldFplcm9TaXplKCk7XG4gIH1cblxuICB2YXIgc2l6ZSA9IHt9O1xuICBzaXplLndpZHRoID0gZWxlbS5vZmZzZXRXaWR0aDtcbiAgc2l6ZS5oZWlnaHQgPSBlbGVtLm9mZnNldEhlaWdodDtcblxuICB2YXIgaXNCb3JkZXJCb3ggPSBzaXplLmlzQm9yZGVyQm94ID0gc3R5bGUuYm94U2l6aW5nID09ICdib3JkZXItYm94JztcblxuICAvLyBnZXQgYWxsIG1lYXN1cmVtZW50c1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgbWVhc3VyZW1lbnRzTGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHZhciB2YWx1ZSA9IHN0eWxlWyBtZWFzdXJlbWVudCBdO1xuICAgIHZhciBudW0gPSBwYXJzZUZsb2F0KCB2YWx1ZSApO1xuICAgIC8vIGFueSAnYXV0bycsICdtZWRpdW0nIHZhbHVlIHdpbGwgYmUgMFxuICAgIHNpemVbIG1lYXN1cmVtZW50IF0gPSAhaXNOYU4oIG51bSApID8gbnVtIDogMDtcbiAgfVxuXG4gIHZhciBwYWRkaW5nV2lkdGggPSBzaXplLnBhZGRpbmdMZWZ0ICsgc2l6ZS5wYWRkaW5nUmlnaHQ7XG4gIHZhciBwYWRkaW5nSGVpZ2h0ID0gc2l6ZS5wYWRkaW5nVG9wICsgc2l6ZS5wYWRkaW5nQm90dG9tO1xuICB2YXIgbWFyZ2luV2lkdGggPSBzaXplLm1hcmdpbkxlZnQgKyBzaXplLm1hcmdpblJpZ2h0O1xuICB2YXIgbWFyZ2luSGVpZ2h0ID0gc2l6ZS5tYXJnaW5Ub3AgKyBzaXplLm1hcmdpbkJvdHRvbTtcbiAgdmFyIGJvcmRlcldpZHRoID0gc2l6ZS5ib3JkZXJMZWZ0V2lkdGggKyBzaXplLmJvcmRlclJpZ2h0V2lkdGg7XG4gIHZhciBib3JkZXJIZWlnaHQgPSBzaXplLmJvcmRlclRvcFdpZHRoICsgc2l6ZS5ib3JkZXJCb3R0b21XaWR0aDtcblxuICB2YXIgaXNCb3JkZXJCb3hTaXplT3V0ZXIgPSBpc0JvcmRlckJveCAmJiBpc0JveFNpemVPdXRlcjtcblxuICAvLyBvdmVyd3JpdGUgd2lkdGggYW5kIGhlaWdodCBpZiB3ZSBjYW4gZ2V0IGl0IGZyb20gc3R5bGVcbiAgdmFyIHN0eWxlV2lkdGggPSBnZXRTdHlsZVNpemUoIHN0eWxlLndpZHRoICk7XG4gIGlmICggc3R5bGVXaWR0aCAhPT0gZmFsc2UgKSB7XG4gICAgc2l6ZS53aWR0aCA9IHN0eWxlV2lkdGggK1xuICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxuICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xuICB9XG5cbiAgdmFyIHN0eWxlSGVpZ2h0ID0gZ2V0U3R5bGVTaXplKCBzdHlsZS5oZWlnaHQgKTtcbiAgaWYgKCBzdHlsZUhlaWdodCAhPT0gZmFsc2UgKSB7XG4gICAgc2l6ZS5oZWlnaHQgPSBzdHlsZUhlaWdodCArXG4gICAgICAvLyBhZGQgcGFkZGluZyBhbmQgYm9yZGVyIHVubGVzcyBpdCdzIGFscmVhZHkgaW5jbHVkaW5nIGl0XG4gICAgICAoIGlzQm9yZGVyQm94U2l6ZU91dGVyID8gMCA6IHBhZGRpbmdIZWlnaHQgKyBib3JkZXJIZWlnaHQgKTtcbiAgfVxuXG4gIHNpemUuaW5uZXJXaWR0aCA9IHNpemUud2lkdGggLSAoIHBhZGRpbmdXaWR0aCArIGJvcmRlcldpZHRoICk7XG4gIHNpemUuaW5uZXJIZWlnaHQgPSBzaXplLmhlaWdodCAtICggcGFkZGluZ0hlaWdodCArIGJvcmRlckhlaWdodCApO1xuXG4gIHNpemUub3V0ZXJXaWR0aCA9IHNpemUud2lkdGggKyBtYXJnaW5XaWR0aDtcbiAgc2l6ZS5vdXRlckhlaWdodCA9IHNpemUuaGVpZ2h0ICsgbWFyZ2luSGVpZ2h0O1xuXG4gIHJldHVybiBzaXplO1xufVxuXG5yZXR1cm4gZ2V0U2l6ZTtcblxufSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../node_modules/get-size/get-size.js\n");

/***/ }),

/***/ "../node_modules/unidragger/unidragger.js":
/*!************************************************!*\
  !*** ../node_modules/unidragger/unidragger.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unidragger v2.3.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! unipointer/unipointer */ \"../node_modules/unipointer/unipointer.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Unipointer ) {\n      return factory( window, Unipointer );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// -------------------------- Unidragger -------------------------- //\n\nfunction Unidragger() {}\n\n// inherit Unipointer & EvEmitter\nvar proto = Unidragger.prototype = Object.create( Unipointer.prototype );\n\n// ----- bind start ----- //\n\nproto.bindHandles = function() {\n  this._bindHandles( true );\n};\n\nproto.unbindHandles = function() {\n  this._bindHandles( false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd\n */\nproto._bindHandles = function( isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  // bind each handle\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n  var touchAction = isAdd ? this._touchActionValue : '';\n  for ( var i=0; i < this.handles.length; i++ ) {\n    var handle = this.handles[i];\n    this._bindStartEvent( handle, isAdd );\n    handle[ bindMethod ]( 'click', this );\n    // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n    if ( window.PointerEvent ) {\n      handle.style.touchAction = touchAction;\n    }\n  }\n};\n\n// prototype so it can be overwriteable by Flickity\nproto._touchActionValue = 'none';\n\n// ----- start event ----- //\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerDown = function( event, pointer ) {\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n  // track start event position\n  this.pointerDownPointer = pointer;\n\n  event.preventDefault();\n  this.pointerDownBlur();\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// nodes that have text fields\nvar cursorNodes = {\n  TEXTAREA: true,\n  INPUT: true,\n  SELECT: true,\n  OPTION: true,\n};\n\n// input types that do not have text fields\nvar clickTypes = {\n  radio: true,\n  checkbox: true,\n  button: true,\n  submit: true,\n  image: true,\n  file: true,\n};\n\n// dismiss inputs with text fields. flickity#403, flickity#404\nproto.okayPointerDown = function( event ) {\n  var isCursorNode = cursorNodes[ event.target.nodeName ];\n  var isClickType = clickTypes[ event.target.type ];\n  var isOkay = !isCursorNode || isClickType;\n  if ( !isOkay ) {\n    this._pointerReset();\n  }\n  return isOkay;\n};\n\n// kludge to blur previously focused input\nproto.pointerDownBlur = function() {\n  var focused = document.activeElement;\n  // do not blur body for IE10, metafizzy/flickity#117\n  var canBlur = focused && focused.blur && focused != document.body;\n  if ( canBlur ) {\n    focused.blur();\n  }\n};\n\n// ----- move event ----- //\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\n// base pointer move logic\nproto._dragPointerMove = function( event, pointer ) {\n  var moveVector = {\n    x: pointer.pageX - this.pointerDownPointer.pageX,\n    y: pointer.pageY - this.pointerDownPointer.pageY\n  };\n  // start drag if pointer has moved far enough to start drag\n  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {\n    this._dragStart( event, pointer );\n  }\n  return moveVector;\n};\n\n// condition if pointer has moved far enough to start drag\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto._dragPointerUp = function( event, pointer ) {\n  if ( this.isDragging ) {\n    this._dragEnd( event, pointer );\n  } else {\n    // pointer didn't move enough for drag to start\n    this._staticClick( event, pointer );\n  }\n};\n\n// -------------------------- drag -------------------------- //\n\n// dragStart\nproto._dragStart = function( event, pointer ) {\n  this.isDragging = true;\n  // prevent clicks\n  this.isPreventingClicks = true;\n  this.dragStart( event, pointer );\n};\n\nproto.dragStart = function( event, pointer ) {\n  this.emitEvent( 'dragStart', [ event, pointer ] );\n};\n\n// dragMove\nproto._dragMove = function( event, pointer, moveVector ) {\n  // do not drag if not dragging yet\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  event.preventDefault();\n  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );\n};\n\n// dragEnd\nproto._dragEnd = function( event, pointer ) {\n  // set flags\n  this.isDragging = false;\n  // re-enable clicking async\n  setTimeout( function() {\n    delete this.isPreventingClicks;\n  }.bind( this ) );\n\n  this.dragEnd( event, pointer );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  this.emitEvent( 'dragEnd', [ event, pointer ] );\n};\n\n// ----- onclick ----- //\n\n// handle all clicks and prevent clicks when dragging\nproto.onclick = function( event ) {\n  if ( this.isPreventingClicks ) {\n    event.preventDefault();\n  }\n};\n\n// ----- staticClick ----- //\n\n// triggered after pointer down & up with no/tiny movement\nproto._staticClick = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  this.staticClick( event, pointer );\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    setTimeout( function() {\n      delete this.isIgnoringMouseUp;\n    }.bind( this ), 400 );\n  }\n};\n\nproto.staticClick = function( event, pointer ) {\n  this.emitEvent( 'staticClick', [ event, pointer ] );\n};\n\n// ----- utils ----- //\n\nUnidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n// -----  ----- //\n\nreturn Unidragger;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3VuaWRyYWdnZXIvdW5pZHJhZ2dlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdW5pZHJhZ2dlci91bmlkcmFnZ2VyLmpzPzhhYTkiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBVbmlkcmFnZ2VyIHYyLjMuMFxuICogRHJhZ2dhYmxlIGJhc2UgY2xhc3NcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW51c2VkOiB0cnVlLCB1bmRlZjogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qanNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG5cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICd1bmlwb2ludGVyL3VuaXBvaW50ZXInXG4gICAgXSwgZnVuY3Rpb24oIFVuaXBvaW50ZXIgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBVbmlwb2ludGVyICk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlNcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICByZXF1aXJlKCd1bmlwb2ludGVyJylcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LlVuaWRyYWdnZXIgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LlVuaXBvaW50ZXJcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBVbmlwb2ludGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFVuaWRyYWdnZXIgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gVW5pZHJhZ2dlcigpIHt9XG5cbi8vIGluaGVyaXQgVW5pcG9pbnRlciAmIEV2RW1pdHRlclxudmFyIHByb3RvID0gVW5pZHJhZ2dlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBVbmlwb2ludGVyLnByb3RvdHlwZSApO1xuXG4vLyAtLS0tLSBiaW5kIHN0YXJ0IC0tLS0tIC8vXG5cbnByb3RvLmJpbmRIYW5kbGVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2JpbmRIYW5kbGVzKCB0cnVlICk7XG59O1xuXG5wcm90by51bmJpbmRIYW5kbGVzID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2JpbmRIYW5kbGVzKCBmYWxzZSApO1xufTtcblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIHN0YXJ0IGV2ZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWRkXG4gKi9cbnByb3RvLl9iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCBpc0FkZCApIHtcbiAgLy8gbXVuZ2UgaXNBZGQsIGRlZmF1bHQgdG8gdHJ1ZVxuICBpc0FkZCA9IGlzQWRkID09PSB1bmRlZmluZWQgPyB0cnVlIDogaXNBZGQ7XG4gIC8vIGJpbmQgZWFjaCBoYW5kbGVcbiAgdmFyIGJpbmRNZXRob2QgPSBpc0FkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcbiAgdmFyIHRvdWNoQWN0aW9uID0gaXNBZGQgPyB0aGlzLl90b3VjaEFjdGlvblZhbHVlIDogJyc7XG4gIGZvciAoIHZhciBpPTA7IGkgPCB0aGlzLmhhbmRsZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuaGFuZGxlc1tpXTtcbiAgICB0aGlzLl9iaW5kU3RhcnRFdmVudCggaGFuZGxlLCBpc0FkZCApO1xuICAgIGhhbmRsZVsgYmluZE1ldGhvZCBdKCAnY2xpY2snLCB0aGlzICk7XG4gICAgLy8gdG91Y2gtYWN0aW9uOiBub25lIHRvIG92ZXJyaWRlIGJyb3dzZXIgdG91Y2ggZ2VzdHVyZXMuIG1ldGFmaXp6eS9mbGlja2l0eSM1NDBcbiAgICBpZiAoIHdpbmRvdy5Qb2ludGVyRXZlbnQgKSB7XG4gICAgICBoYW5kbGUuc3R5bGUudG91Y2hBY3Rpb24gPSB0b3VjaEFjdGlvbjtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHByb3RvdHlwZSBzbyBpdCBjYW4gYmUgb3ZlcndyaXRlYWJsZSBieSBGbGlja2l0eVxucHJvdG8uX3RvdWNoQWN0aW9uVmFsdWUgPSAnbm9uZSc7XG5cbi8vIC0tLS0tIHN0YXJ0IGV2ZW50IC0tLS0tIC8vXG5cbi8qKlxuICogcG9pbnRlciBzdGFydFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8ucG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHZhciBpc09rYXkgPSB0aGlzLm9rYXlQb2ludGVyRG93biggZXZlbnQgKTtcbiAgaWYgKCAhaXNPa2F5ICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB0cmFjayBzdGFydCBldmVudCBwb3NpdGlvblxuICB0aGlzLnBvaW50ZXJEb3duUG9pbnRlciA9IHBvaW50ZXI7XG5cbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5wb2ludGVyRG93bkJsdXIoKTtcbiAgLy8gYmluZCBtb3ZlIGFuZCBlbmQgZXZlbnRzXG4gIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIG5vZGVzIHRoYXQgaGF2ZSB0ZXh0IGZpZWxkc1xudmFyIGN1cnNvck5vZGVzID0ge1xuICBURVhUQVJFQTogdHJ1ZSxcbiAgSU5QVVQ6IHRydWUsXG4gIFNFTEVDVDogdHJ1ZSxcbiAgT1BUSU9OOiB0cnVlLFxufTtcblxuLy8gaW5wdXQgdHlwZXMgdGhhdCBkbyBub3QgaGF2ZSB0ZXh0IGZpZWxkc1xudmFyIGNsaWNrVHlwZXMgPSB7XG4gIHJhZGlvOiB0cnVlLFxuICBjaGVja2JveDogdHJ1ZSxcbiAgYnV0dG9uOiB0cnVlLFxuICBzdWJtaXQ6IHRydWUsXG4gIGltYWdlOiB0cnVlLFxuICBmaWxlOiB0cnVlLFxufTtcblxuLy8gZGlzbWlzcyBpbnB1dHMgd2l0aCB0ZXh0IGZpZWxkcy4gZmxpY2tpdHkjNDAzLCBmbGlja2l0eSM0MDRcbnByb3RvLm9rYXlQb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIGlzQ3Vyc29yTm9kZSA9IGN1cnNvck5vZGVzWyBldmVudC50YXJnZXQubm9kZU5hbWUgXTtcbiAgdmFyIGlzQ2xpY2tUeXBlID0gY2xpY2tUeXBlc1sgZXZlbnQudGFyZ2V0LnR5cGUgXTtcbiAgdmFyIGlzT2theSA9ICFpc0N1cnNvck5vZGUgfHwgaXNDbGlja1R5cGU7XG4gIGlmICggIWlzT2theSApIHtcbiAgICB0aGlzLl9wb2ludGVyUmVzZXQoKTtcbiAgfVxuICByZXR1cm4gaXNPa2F5O1xufTtcblxuLy8ga2x1ZGdlIHRvIGJsdXIgcHJldmlvdXNseSBmb2N1c2VkIGlucHV0XG5wcm90by5wb2ludGVyRG93bkJsdXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGZvY3VzZWQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAvLyBkbyBub3QgYmx1ciBib2R5IGZvciBJRTEwLCBtZXRhZml6enkvZmxpY2tpdHkjMTE3XG4gIHZhciBjYW5CbHVyID0gZm9jdXNlZCAmJiBmb2N1c2VkLmJsdXIgJiYgZm9jdXNlZCAhPSBkb2N1bWVudC5ib2R5O1xuICBpZiAoIGNhbkJsdXIgKSB7XG4gICAgZm9jdXNlZC5ibHVyKCk7XG4gIH1cbn07XG5cbi8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cblxuLyoqXG4gKiBkcmFnIG1vdmVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLnBvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB2YXIgbW92ZVZlY3RvciA9IHRoaXMuX2RyYWdQb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xuICB0aGlzLl9kcmFnTW92ZSggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKTtcbn07XG5cbi8vIGJhc2UgcG9pbnRlciBtb3ZlIGxvZ2ljXG5wcm90by5fZHJhZ1BvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB2YXIgbW92ZVZlY3RvciA9IHtcbiAgICB4OiBwb2ludGVyLnBhZ2VYIC0gdGhpcy5wb2ludGVyRG93blBvaW50ZXIucGFnZVgsXG4gICAgeTogcG9pbnRlci5wYWdlWSAtIHRoaXMucG9pbnRlckRvd25Qb2ludGVyLnBhZ2VZXG4gIH07XG4gIC8vIHN0YXJ0IGRyYWcgaWYgcG9pbnRlciBoYXMgbW92ZWQgZmFyIGVub3VnaCB0byBzdGFydCBkcmFnXG4gIGlmICggIXRoaXMuaXNEcmFnZ2luZyAmJiB0aGlzLmhhc0RyYWdTdGFydGVkKCBtb3ZlVmVjdG9yICkgKSB7XG4gICAgdGhpcy5fZHJhZ1N0YXJ0KCBldmVudCwgcG9pbnRlciApO1xuICB9XG4gIHJldHVybiBtb3ZlVmVjdG9yO1xufTtcblxuLy8gY29uZGl0aW9uIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xucHJvdG8uaGFzRHJhZ1N0YXJ0ZWQgPSBmdW5jdGlvbiggbW92ZVZlY3RvciApIHtcbiAgcmV0dXJuIE1hdGguYWJzKCBtb3ZlVmVjdG9yLnggKSA+IDMgfHwgTWF0aC5hYnMoIG1vdmVWZWN0b3IueSApID4gMztcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgdXBcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyVXAnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbiAgdGhpcy5fZHJhZ1BvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLl9kcmFnUG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoIHRoaXMuaXNEcmFnZ2luZyApIHtcbiAgICB0aGlzLl9kcmFnRW5kKCBldmVudCwgcG9pbnRlciApO1xuICB9IGVsc2Uge1xuICAgIC8vIHBvaW50ZXIgZGlkbid0IG1vdmUgZW5vdWdoIGZvciBkcmFnIHRvIHN0YXJ0XG4gICAgdGhpcy5fc3RhdGljQ2xpY2soIGV2ZW50LCBwb2ludGVyICk7XG4gIH1cbn07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGRyYWcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZHJhZ1N0YXJ0XG5wcm90by5fZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAvLyBwcmV2ZW50IGNsaWNrc1xuICB0aGlzLmlzUHJldmVudGluZ0NsaWNrcyA9IHRydWU7XG4gIHRoaXMuZHJhZ1N0YXJ0KCBldmVudCwgcG9pbnRlciApO1xufTtcblxucHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ2RyYWdTdGFydCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xufTtcblxuLy8gZHJhZ01vdmVcbnByb3RvLl9kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcbiAgLy8gZG8gbm90IGRyYWcgaWYgbm90IGRyYWdnaW5nIHlldFxuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5kcmFnTW92ZSggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKTtcbn07XG5cbnByb3RvLmRyYWdNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xuICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB0aGlzLmVtaXRFdmVudCggJ2RyYWdNb3ZlJywgWyBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciBdICk7XG59O1xuXG4vLyBkcmFnRW5kXG5wcm90by5fZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgLy8gc2V0IGZsYWdzXG4gIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAvLyByZS1lbmFibGUgY2xpY2tpbmcgYXN5bmNcbiAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgZGVsZXRlIHRoaXMuaXNQcmV2ZW50aW5nQ2xpY2tzO1xuICB9LmJpbmQoIHRoaXMgKSApO1xuXG4gIHRoaXMuZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLmRyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAnZHJhZ0VuZCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xufTtcblxuLy8gLS0tLS0gb25jbGljayAtLS0tLSAvL1xuXG4vLyBoYW5kbGUgYWxsIGNsaWNrcyBhbmQgcHJldmVudCBjbGlja3Mgd2hlbiBkcmFnZ2luZ1xucHJvdG8ub25jbGljayA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgaWYgKCB0aGlzLmlzUHJldmVudGluZ0NsaWNrcyApIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBzdGF0aWNDbGljayAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyZWQgYWZ0ZXIgcG9pbnRlciBkb3duICYgdXAgd2l0aCBuby90aW55IG1vdmVtZW50XG5wcm90by5fc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIC8vIGlnbm9yZSBlbXVsYXRlZCBtb3VzZSB1cCBjbGlja3NcbiAgaWYgKCB0aGlzLmlzSWdub3JpbmdNb3VzZVVwICYmIGV2ZW50LnR5cGUgPT0gJ21vdXNldXAnICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuc3RhdGljQ2xpY2soIGV2ZW50LCBwb2ludGVyICk7XG5cbiAgLy8gc2V0IGZsYWcgZm9yIGVtdWxhdGVkIGNsaWNrcyAzMDBtcyBhZnRlciB0b3VjaGVuZFxuICBpZiAoIGV2ZW50LnR5cGUgIT0gJ21vdXNldXAnICkge1xuICAgIHRoaXMuaXNJZ25vcmluZ01vdXNlVXAgPSB0cnVlO1xuICAgIC8vIHJlc2V0IGZsYWcgYWZ0ZXIgMzAwbXNcbiAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLmlzSWdub3JpbmdNb3VzZVVwO1xuICAgIH0uYmluZCggdGhpcyApLCA0MDAgKTtcbiAgfVxufTtcblxucHJvdG8uc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAnc3RhdGljQ2xpY2snLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIHV0aWxzIC0tLS0tIC8vXG5cblVuaWRyYWdnZXIuZ2V0UG9pbnRlclBvaW50ID0gVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQ7XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gVW5pZHJhZ2dlcjtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsV0FZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../node_modules/unidragger/unidragger.js\n");

/***/ }),

/***/ "../node_modules/unipointer/unipointer.js":
/*!************************************************!*\
  !*** ../node_modules/unipointer/unipointer.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unipointer v2.3.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"../node_modules/ev-emitter/ev-emitter.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter ) {\n      return factory( window, EvEmitter );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, EvEmitter ) {\n\n'use strict';\n\nfunction noop() {}\n\nfunction Unipointer() {}\n\n// inherit EvEmitter\nvar proto = Unipointer.prototype = Object.create( EvEmitter.prototype );\n\nproto.bindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd - remove if falsey\n */\nproto._bindStartEvent = function( elem, isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n\n  // default to mouse events\n  var startEvent = 'mousedown';\n  if ( window.PointerEvent ) {\n    // Pointer Events\n    startEvent = 'pointerdown';\n  } else if ( 'ontouchstart' in window ) {\n    // Touch Events. iOS Safari\n    startEvent = 'touchstart';\n  }\n  elem[ bindMethod ]( startEvent, this );\n};\n\n// trigger handler methods for events\nproto.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// returns the touch that we're keeping track of\nproto.getTouch = function( touches ) {\n  for ( var i=0; i < touches.length; i++ ) {\n    var touch = touches[i];\n    if ( touch.identifier == this.pointerIdentifier ) {\n      return touch;\n    }\n  }\n};\n\n// ----- start event ----- //\n\nproto.onmousedown = function( event ) {\n  // dismiss clicks from right or middle buttons\n  var button = event.button;\n  if ( button && ( button !== 0 && button !== 1 ) ) {\n    return;\n  }\n  this._pointerDown( event, event );\n};\n\nproto.ontouchstart = function( event ) {\n  this._pointerDown( event, event.changedTouches[0] );\n};\n\nproto.onpointerdown = function( event ) {\n  this._pointerDown( event, event );\n};\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto._pointerDown = function( event, pointer ) {\n  // dismiss right click and other pointers\n  // button = 0 is okay, 1-4 not\n  if ( event.button || this.isPointerDown ) {\n    return;\n  }\n\n  this.isPointerDown = true;\n  // save pointer identifier to match up touch events\n  this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n  this.pointerDown( event, pointer );\n};\n\nproto.pointerDown = function( event, pointer ) {\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// hash of events to be bound after start event\nvar postStartEvents = {\n  mousedown: [ 'mousemove', 'mouseup' ],\n  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],\n  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],\n};\n\nproto._bindPostStartEvents = function( event ) {\n  if ( !event ) {\n    return;\n  }\n  // get proper events to match start event\n  var events = postStartEvents[ event.type ];\n  // bind events to node\n  events.forEach( function( eventName ) {\n    window.addEventListener( eventName, this );\n  }, this );\n  // save these arguments\n  this._boundPointerEvents = events;\n};\n\nproto._unbindPostStartEvents = function() {\n  // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n  if ( !this._boundPointerEvents ) {\n    return;\n  }\n  this._boundPointerEvents.forEach( function( eventName ) {\n    window.removeEventListener( eventName, this );\n  }, this );\n\n  delete this._boundPointerEvents;\n};\n\n// ----- move event ----- //\n\nproto.onmousemove = function( event ) {\n  this._pointerMove( event, event );\n};\n\nproto.onpointermove = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerMove( event, event );\n  }\n};\n\nproto.ontouchmove = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerMove( event, touch );\n  }\n};\n\n/**\n * pointer move\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerMove = function( event, pointer ) {\n  this.pointerMove( event, pointer );\n};\n\n// public\nproto.pointerMove = function( event, pointer ) {\n  this.emitEvent( 'pointerMove', [ event, pointer ] );\n};\n\n// ----- end event ----- //\n\n\nproto.onmouseup = function( event ) {\n  this._pointerUp( event, event );\n};\n\nproto.onpointerup = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerUp( event, event );\n  }\n};\n\nproto.ontouchend = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerUp( event, touch );\n  }\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerUp = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerUp( event, pointer );\n};\n\n// public\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n};\n\n// ----- pointer done ----- //\n\n// triggered on pointer up & pointer cancel\nproto._pointerDone = function() {\n  this._pointerReset();\n  this._unbindPostStartEvents();\n  this.pointerDone();\n};\n\nproto._pointerReset = function() {\n  // reset properties\n  this.isPointerDown = false;\n  delete this.pointerIdentifier;\n};\n\nproto.pointerDone = noop;\n\n// ----- pointer cancel ----- //\n\nproto.onpointercancel = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerCancel( event, event );\n  }\n};\n\nproto.ontouchcancel = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerCancel( event, touch );\n  }\n};\n\n/**\n * pointer cancel\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerCancel = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerCancel( event, pointer );\n};\n\n// public\nproto.pointerCancel = function( event, pointer ) {\n  this.emitEvent( 'pointerCancel', [ event, pointer ] );\n};\n\n// -----  ----- //\n\n// utility function for getting x/y coords from event\nUnipointer.getPointerPoint = function( pointer ) {\n  return {\n    x: pointer.pageX,\n    y: pointer.pageY\n  };\n};\n\n// -----  ----- //\n\nreturn Unipointer;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vbm9kZV9tb2R1bGVzL3VuaXBvaW50ZXIvdW5pcG9pbnRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvdW5pcG9pbnRlci91bmlwb2ludGVyLmpzP2M1YzAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBVbmlwb2ludGVyIHYyLjMuMFxuICogYmFzZSBjbGFzcyBmb3IgZG9pbmcgb25lIHRoaW5nIHdpdGggcG9pbnRlciBldmVudFxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCB1bmRlZjogdHJ1ZSwgdW51c2VkOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWwgZGVmaW5lLCBtb2R1bGUsIHJlcXVpcmUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIFtcbiAgICAgICdldi1lbWl0dGVyL2V2LWVtaXR0ZXInXG4gICAgXSwgZnVuY3Rpb24oIEV2RW1pdHRlciApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIEV2RW1pdHRlciApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZXYtZW1pdHRlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5Vbmlwb2ludGVyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5FdkVtaXR0ZXJcbiAgICApO1xuICB9XG5cbn0oIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIFVuaXBvaW50ZXIoKSB7fVxuXG4vLyBpbmhlcml0IEV2RW1pdHRlclxudmFyIHByb3RvID0gVW5pcG9pbnRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFdkVtaXR0ZXIucHJvdG90eXBlICk7XG5cbnByb3RvLmJpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHRoaXMuX2JpbmRTdGFydEV2ZW50KCBlbGVtLCB0cnVlICk7XG59O1xuXG5wcm90by51bmJpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG4gIHRoaXMuX2JpbmRTdGFydEV2ZW50KCBlbGVtLCBmYWxzZSApO1xufTtcblxuLyoqXG4gKiBBZGQgb3IgcmVtb3ZlIHN0YXJ0IGV2ZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQWRkIC0gcmVtb3ZlIGlmIGZhbHNleVxuICovXG5wcm90by5fYmluZFN0YXJ0RXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgaXNBZGQgKSB7XG4gIC8vIG11bmdlIGlzQWRkLCBkZWZhdWx0IHRvIHRydWVcbiAgaXNBZGQgPSBpc0FkZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzQWRkO1xuICB2YXIgYmluZE1ldGhvZCA9IGlzQWRkID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuXG4gIC8vIGRlZmF1bHQgdG8gbW91c2UgZXZlbnRzXG4gIHZhciBzdGFydEV2ZW50ID0gJ21vdXNlZG93bic7XG4gIGlmICggd2luZG93LlBvaW50ZXJFdmVudCApIHtcbiAgICAvLyBQb2ludGVyIEV2ZW50c1xuICAgIHN0YXJ0RXZlbnQgPSAncG9pbnRlcmRvd24nO1xuICB9IGVsc2UgaWYgKCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgKSB7XG4gICAgLy8gVG91Y2ggRXZlbnRzLiBpT1MgU2FmYXJpXG4gICAgc3RhcnRFdmVudCA9ICd0b3VjaHN0YXJ0JztcbiAgfVxuICBlbGVtWyBiaW5kTWV0aG9kIF0oIHN0YXJ0RXZlbnQsIHRoaXMgKTtcbn07XG5cbi8vIHRyaWdnZXIgaGFuZGxlciBtZXRob2RzIGZvciBldmVudHNcbnByb3RvLmhhbmRsZUV2ZW50ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB2YXIgbWV0aG9kID0gJ29uJyArIGV2ZW50LnR5cGU7XG4gIGlmICggdGhpc1sgbWV0aG9kIF0gKSB7XG4gICAgdGhpc1sgbWV0aG9kIF0oIGV2ZW50ICk7XG4gIH1cbn07XG5cbi8vIHJldHVybnMgdGhlIHRvdWNoIHRoYXQgd2UncmUga2VlcGluZyB0cmFjayBvZlxucHJvdG8uZ2V0VG91Y2ggPSBmdW5jdGlvbiggdG91Y2hlcyApIHtcbiAgZm9yICggdmFyIGk9MDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICBpZiAoIHRvdWNoLmlkZW50aWZpZXIgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcbiAgICAgIHJldHVybiB0b3VjaDtcbiAgICB9XG4gIH1cbn07XG5cbi8vIC0tLS0tIHN0YXJ0IGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLm9ubW91c2Vkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICAvLyBkaXNtaXNzIGNsaWNrcyBmcm9tIHJpZ2h0IG9yIG1pZGRsZSBidXR0b25zXG4gIHZhciBidXR0b24gPSBldmVudC5idXR0b247XG4gIGlmICggYnV0dG9uICYmICggYnV0dG9uICE9PSAwICYmIGJ1dHRvbiAhPT0gMSApICkge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbnRvdWNoc3RhcnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0gKTtcbn07XG5cbnByb3RvLm9ucG9pbnRlcmRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMuX3BvaW50ZXJEb3duKCBldmVudCwgZXZlbnQgKTtcbn07XG5cbi8qKlxuICogcG9pbnRlciBzdGFydFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8uX3BvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyBkaXNtaXNzIHJpZ2h0IGNsaWNrIGFuZCBvdGhlciBwb2ludGVyc1xuICAvLyBidXR0b24gPSAwIGlzIG9rYXksIDEtNCBub3RcbiAgaWYgKCBldmVudC5idXR0b24gfHwgdGhpcy5pc1BvaW50ZXJEb3duICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuaXNQb2ludGVyRG93biA9IHRydWU7XG4gIC8vIHNhdmUgcG9pbnRlciBpZGVudGlmaWVyIHRvIG1hdGNoIHVwIHRvdWNoIGV2ZW50c1xuICB0aGlzLnBvaW50ZXJJZGVudGlmaWVyID0gcG9pbnRlci5wb2ludGVySWQgIT09IHVuZGVmaW5lZCA/XG4gICAgLy8gcG9pbnRlcklkIGZvciBwb2ludGVyIGV2ZW50cywgdG91Y2guaW5kZW50aWZpZXIgZm9yIHRvdWNoIGV2ZW50c1xuICAgIHBvaW50ZXIucG9pbnRlcklkIDogcG9pbnRlci5pZGVudGlmaWVyO1xuXG4gIHRoaXMucG9pbnRlckRvd24oIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fYmluZFBvc3RTdGFydEV2ZW50cyggZXZlbnQgKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyRG93bicsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xufTtcblxuLy8gaGFzaCBvZiBldmVudHMgdG8gYmUgYm91bmQgYWZ0ZXIgc3RhcnQgZXZlbnRcbnZhciBwb3N0U3RhcnRFdmVudHMgPSB7XG4gIG1vdXNlZG93bjogWyAnbW91c2Vtb3ZlJywgJ21vdXNldXAnIF0sXG4gIHRvdWNoc3RhcnQ6IFsgJ3RvdWNobW92ZScsICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcgXSxcbiAgcG9pbnRlcmRvd246IFsgJ3BvaW50ZXJtb3ZlJywgJ3BvaW50ZXJ1cCcsICdwb2ludGVyY2FuY2VsJyBdLFxufTtcblxucHJvdG8uX2JpbmRQb3N0U3RhcnRFdmVudHMgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggIWV2ZW50ICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBnZXQgcHJvcGVyIGV2ZW50cyB0byBtYXRjaCBzdGFydCBldmVudFxuICB2YXIgZXZlbnRzID0gcG9zdFN0YXJ0RXZlbnRzWyBldmVudC50eXBlIF07XG4gIC8vIGJpbmQgZXZlbnRzIHRvIG5vZGVcbiAgZXZlbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgdGhpcyApO1xuICB9LCB0aGlzICk7XG4gIC8vIHNhdmUgdGhlc2UgYXJndW1lbnRzXG4gIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cyA9IGV2ZW50cztcbn07XG5cbnByb3RvLl91bmJpbmRQb3N0U3RhcnRFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgLy8gY2hlY2sgZm9yIF9ib3VuZEV2ZW50cywgaW4gY2FzZSBkcmFnRW5kIHRyaWdnZXJlZCB0d2ljZSAob2xkIElFOCBidWcpXG4gIGlmICggIXRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cyApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fYm91bmRQb2ludGVyRXZlbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBldmVudE5hbWUgKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIGV2ZW50TmFtZSwgdGhpcyApO1xuICB9LCB0aGlzICk7XG5cbiAgZGVsZXRlIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cztcbn07XG5cbi8vIC0tLS0tIG1vdmUgZXZlbnQgLS0tLS0gLy9cblxucHJvdG8ub25tb3VzZW1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ucG9pbnRlcm1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCBldmVudCApO1xuICB9XG59O1xuXG5wcm90by5vbnRvdWNobW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIHRvdWNoID0gdGhpcy5nZXRUb3VjaCggZXZlbnQuY2hhbmdlZFRvdWNoZXMgKTtcbiAgaWYgKCB0b3VjaCApIHtcbiAgICB0aGlzLl9wb2ludGVyTW92ZSggZXZlbnQsIHRvdWNoICk7XG4gIH1cbn07XG5cbi8qKlxuICogcG9pbnRlciBtb3ZlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX3BvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLnBvaW50ZXJNb3ZlKCBldmVudCwgcG9pbnRlciApO1xufTtcblxuLy8gcHVibGljXG5wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xufTtcblxuLy8gLS0tLS0gZW5kIGV2ZW50IC0tLS0tIC8vXG5cblxucHJvdG8ub25tb3VzZXVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCBldmVudCApO1xufTtcblxucHJvdG8ub25wb2ludGVydXAgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8ub250b3VjaGVuZCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIHRvdWNoID0gdGhpcy5nZXRUb3VjaCggZXZlbnQuY2hhbmdlZFRvdWNoZXMgKTtcbiAgaWYgKCB0b3VjaCApIHtcbiAgICB0aGlzLl9wb2ludGVyVXAoIGV2ZW50LCB0b3VjaCApO1xuICB9XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgdXBcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fcG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLl9wb2ludGVyRG9uZSgpO1xuICB0aGlzLnBvaW50ZXJVcCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIHB1YmxpY1xucHJvdG8ucG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJVcCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xufTtcblxuLy8gLS0tLS0gcG9pbnRlciBkb25lIC0tLS0tIC8vXG5cbi8vIHRyaWdnZXJlZCBvbiBwb2ludGVyIHVwICYgcG9pbnRlciBjYW5jZWxcbnByb3RvLl9wb2ludGVyRG9uZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9wb2ludGVyUmVzZXQoKTtcbiAgdGhpcy5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzKCk7XG4gIHRoaXMucG9pbnRlckRvbmUoKTtcbn07XG5cbnByb3RvLl9wb2ludGVyUmVzZXQgPSBmdW5jdGlvbigpIHtcbiAgLy8gcmVzZXQgcHJvcGVydGllc1xuICB0aGlzLmlzUG9pbnRlckRvd24gPSBmYWxzZTtcbiAgZGVsZXRlIHRoaXMucG9pbnRlcklkZW50aWZpZXI7XG59O1xuXG5wcm90by5wb2ludGVyRG9uZSA9IG5vb3A7XG5cbi8vIC0tLS0tIHBvaW50ZXIgY2FuY2VsIC0tLS0tIC8vXG5cbnByb3RvLm9ucG9pbnRlcmNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgaWYgKCBldmVudC5wb2ludGVySWQgPT0gdGhpcy5wb2ludGVySWRlbnRpZmllciApIHtcbiAgICB0aGlzLl9wb2ludGVyQ2FuY2VsKCBldmVudCwgZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8ub250b3VjaGNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIHRvdWNoID0gdGhpcy5nZXRUb3VjaCggZXZlbnQuY2hhbmdlZFRvdWNoZXMgKTtcbiAgaWYgKCB0b3VjaCApIHtcbiAgICB0aGlzLl9wb2ludGVyQ2FuY2VsKCBldmVudCwgdG91Y2ggKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwb2ludGVyIGNhbmNlbFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLl9wb2ludGVyRG9uZSgpO1xuICB0aGlzLnBvaW50ZXJDYW5jZWwoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG4vLyBwdWJsaWNcbnByb3RvLnBvaW50ZXJDYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckNhbmNlbCcsIFsgZXZlbnQsIHBvaW50ZXIgXSApO1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbi8vIHV0aWxpdHkgZnVuY3Rpb24gZm9yIGdldHRpbmcgeC95IGNvb3JkcyBmcm9tIGV2ZW50XG5Vbmlwb2ludGVyLmdldFBvaW50ZXJQb2ludCA9IGZ1bmN0aW9uKCBwb2ludGVyICkge1xuICByZXR1cm4ge1xuICAgIHg6IHBvaW50ZXIucGFnZVgsXG4gICAgeTogcG9pbnRlci5wYWdlWVxuICB9O1xufTtcblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBVbmlwb2ludGVyO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0EsV0FZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../node_modules/unipointer/unipointer.js\n");

/***/ }),

/***/ "../src/Player.js":
/*!************************!*\
  !*** ../src/Player.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MC = __webpack_require__(/*! @kissmybutton/motorcortex */ \"../node_modules/@kissmybutton/motorcortex/dist/main.js\");\nvar helper = new MC.Helper();\nvar timeCapsule = new MC.TimeCapsule();\nvar hoverTimeCapsule = new MC.TimeCapsule();\nvar confThemes = __webpack_require__(/*! ./themes */ \"../src/themes.js\");\nvar confStyle = __webpack_require__(/*! ./style */ \"../src/style.js\");\nvar svg = __webpack_require__(/*! ./svg */ \"../src/svg.js\");\nvar playerHTML = __webpack_require__(/*! ./playerHTML */ \"../src/playerHTML.js\");\n/**\n * @classdesc\n * Timer's purpose is to provide an interface through which any TimedIncident (such as a Scene or a Clip)\n * can both privide info regarding their timing state but also provide an interface for interacting /\n * altering the timing of it\n */\n\nvar Player = function () {\n  function Player(options) {\n    _classCallCheck(this, Player);\n\n    console.log(\"in player\");\n    this.id = options.id || helper.getAnId(); // timer id\n    this.clip = options.clip; // host to apply the timer\n    this.clipClass = options.clipClass;\n    options.preview = options.preview || false;\n    // this.previewClip.props.host = elid()\n    this.speedValues = [-4, -2, -1, -0.5, 0, 0.5, 1, 2, 4];\n    this.requestingLoop = false;\n    this.loopLastPositionXPxls = 0;\n    this.playAfterResize = false;\n    this.loopLastPositionXPercentage = 0;\n    this.journey = null;\n    this.hoverJourney = null;\n    this.loopJourney = false;\n    this.needsUpdate = true;\n    this.loopStartMillisecond = 0;\n    this.loopEndMillisecond = this.clip.duration;\n    this.theme = options.theme || \"transparent on-top\";\n\n    // set clip position to relative\n    this.clip.props.host.style.position = \"relative\";\n    var clip = this.clip.props.host.getElementsByTagName(\"iframe\")[0];\n    clip.style.margin = \"0 auto\";\n    clip.style.display = \"block\";\n\n    // create the timer controls main div\n    this.mcPlayer = elcreate(\"div\");\n    this.mcPlayer.id = \"mc-player\";\n    this.mcPlayer.innerHTML = playerHTML({ svg: svg });\n    elid(this.clip.props.host.id).appendChild(this.mcPlayer);\n\n    this.totalBar = elid(\"mc-player-totalbar\");\n    this.loopBar = elid(\"mc-player-loopbar\");\n    this.runningBar = elid(\"mc-player-runningbar\");\n    this.speedBar = elid(\"mc-player-speed-value-bar\");\n    this.speedBarHelper = elid(\"mc-player-speed-value-helperbar\");\n    this.indicator = elid(\"mc-player-indicator\");\n    this.currentTime = elid(\"mc-player-time-current\");\n    this.timeSeparator = elid(\"mc-player-time-separator\");\n    this.timeDisplay = elid(\"mc-player-time-display\");\n    this.totalTime = elid(\"mc-player-time-total\");\n    this.statusButton = elid(\"mc-player-status-btn\");\n    this.settingsShowIndicator = elid(\"mc-player-settings-indicator\");\n    this.settingsButton = elid(\"mc-player-settings-btn\");\n    this.loopButton = elid(\"mc-player-loop-btn\");\n    this.settingsSpeedButtonShow = elid(\"mc-player-settings-speed-show\");\n    this.settingsSpeedButtonHide = elid(\"mc-player-settings-speed-hide\");\n    this.fullScreenButton = elid(\"mc-player-full-screen-btn\");\n    this.settingsPanel = elid(\"mc-player-settings-panel\");\n    this.settingsMainPanel = elid(\"mc-player-main-settings\");\n    this.settingsSpeedPanel = elid(\"mc-player-speed-settings\");\n    this.speedCurrent = elid(\"mc-player-speed-current\");\n    this.loopBarStart = elid(\"mc-player-loopbar-start\");\n    this.loopBarEnd = elid(\"mc-player-loopbar-end\");\n\n    this.currentTime.innerHTML = 0;\n    this.totalTime.innerHTML = this.clip.duration;\n    this.timeSeparator.innerHTML = \"/\";\n    this.settingsSpeedPanel.style.display = \"none\";\n    this.settingsPanel.classList.add(\"m-fadeOut\");\n    this.indicator.style.visibility = \"hidden\";\n    this.indicator.innerHTML = \"Idle\";\n\n    this.settingsSpeedPanel.getElementsByTagName(\"li\")[1].classList.add(\"no-hover\");\n\n    this.loopBarStart.style.left = \"0%\";\n    this.loopBarEnd.style.left = \"100%\";\n    this.loopBarStart.classList.add(\"m-fadeOut\");\n    this.loopBarEnd.classList.add(\"m-fadeOut\");\n    elid(\"mc-player-loop-time\").classList.add(\"m-fadeOut\");\n\n    elid(\"mc-player-hover-display\").classList.add(\"m-fadeOut\");\n\n    this.setSpeed();\n    this.setTheme();\n    this.subscribeToTimer();\n    this.subscribeToEvents();\n    this.addEventListeners();\n    if (options.preview) {\n      this.createHoverDisplay();\n    }\n  }\n\n  _createClass(Player, [{\n    key: \"millisecondChange\",\n    value: function millisecondChange(millisecond) {\n      var _this = this;\n\n      if (!this.needsUpdate) {\n        this.clip.wait();\n        return 1;\n      }\n      var duration = this.clip.duration;\n\n      // zero value if style.left is null\n      var loopBarLeftPercentage = parseFloat(this.loopBar.style.left) / 100 || 0;\n\n      var loopBarWidth = this.loopBar.offsetWidth;\n\n      var localMillisecond = millisecond - duration * loopBarLeftPercentage;\n\n      var localDuration = duration / this.totalBar.offsetWidth * loopBarWidth;\n      if (millisecond >= this.loopEndMillisecond && this.loopButton.className.includes(\"svg-selected\")) {\n        this.needsUpdate = false;\n        setTimeout(function () {\n          if (_this.clip.state === \"idle\") {\n            _this.clip.stop();\n            _this.journey = timeCapsule.startJourney(_this.clip);\n            _this.journey.station(_this.loopStartMillisecond + 1);\n            _this.journey.destination();\n            _this.clip.play();\n          } else if (_this.clip.state === \"completed\") {\n            _this.clip.stop();\n            _this.journey = timeCapsule.startJourney(_this.clip);\n            _this.journey.station(_this.loopStartMillisecond + 1);\n            _this.journey.destination();\n            _this.clip.play();\n          } else {\n            _this.journey = timeCapsule.startJourney(_this.clip);\n            _this.journey.station(_this.loopStartMillisecond + 1);\n            _this.journey.destination();\n            _this.clip.resume();\n          }\n          _this.needsUpdate = true;\n        }, 0);\n        return 1;\n      } else if (millisecond <= this.loopStartMillisecond && this.loopButton.className.includes(\"svg-selected\")) {\n        this.needsUpdate = false;\n        setTimeout(function () {\n          if (_this.clip.state === \"idle\") {\n            _this.clip.stop();\n            _this.journey = timeCapsule.startJourney(_this.clip);\n            _this.journey.station(_this.loopEndMillisecond - 1);\n            _this.journey.destination();\n            _this.clip.play();\n          } else if (_this.clip.state === \"completed\") {\n            _this.clip.stop();\n            _this.journey = timeCapsule.startJourney(_this.clip);\n            _this.journey.station(_this.loopEndMillisecond - 1);\n            _this.journey.destination();\n            _this.clip.play();\n          } else {\n            _this.journey = timeCapsule.startJourney(_this.clip);\n            _this.journey.station(_this.loopEndMillisecond - 1);\n            _this.journey.destination();\n            _this.clip.resume();\n          }\n          _this.needsUpdate = true;\n        }, 0);\n        return 1;\n      } else if (millisecond >= this.loopEndMillisecond) {\n        this.needsUpdate = false;\n        setTimeout(function () {\n          _this.journey = timeCapsule.startJourney(_this.clip);\n          _this.journey.station(_this.loopEndMillisecond);\n          _this.journey.destination();\n        }, 0);\n        this.runningBar.style.width = \"100%\";\n        this.currentTime.innerHTML = this.loopEndMillisecond;\n        return 1;\n      } else if (millisecond <= this.loopStartMillisecond) {\n        this.needsUpdate = false;\n        setTimeout(function () {\n          _this.journey = timeCapsule.startJourney(_this.clip);\n          _this.journey.station(_this.loopStartMillisecond);\n          _this.journey.destination();\n        }, 0);\n        this.runningBar.style.width = \"0%\";\n        this.currentTime.innerHTML = this.loopStartMillisecond;\n        return 1;\n      }\n\n      this.runningBar.style.width = localMillisecond / localDuration * 100 + \"%\";\n\n      this.currentTime.innerHTML = millisecond;\n    }\n  }, {\n    key: \"eventBroadcast\",\n    value: function eventBroadcast(eventName, meta) {\n      if (eventName === \"state-change\") {\n        if (meta.newState === \"waiting\") {\n          this.statusButton.innerHTML = svg.playSVG;\n          this.statusButton.appendChild(this.indicator);\n          this.indicator.innerHTML = \"Waiting\";\n        } else if (meta.newState === \"playing\") {\n          this.statusButton.innerHTML = svg.pauseSVG;\n          this.statusButton.appendChild(this.indicator);\n          this.indicator.innerHTML = \"Playing\";\n        } else if (meta.newState === \"completed\") {\n          this.currentTime.innerHTML = this.clip.duration;\n          this.statusButton.innerHTML = svg.replaySVG;\n          this.statusButton.appendChild(this.indicator);\n          this.indicator.innerHTML = \"Completed\";\n        } else if (meta.newState === \"transitional\") {\n          this.statusButton.innerHTML = svg.playSVG;\n          this.statusButton.appendChild(this.indicator);\n          this.indicator.innerHTML = \"Transitional\";\n        } else if (meta.newState === \"idle\") {\n          this.statusButton.innerHTML = svg.playSVG;\n          this.statusButton.appendChild(this.indicator);\n          this.indicator.innerHTML = \"Idle\";\n        }\n      } else if (eventName === \"attribute-rejection\") {\n        helper.log(\"Attributes\", meta.attributes, \"have been rejected from animation with id \" + meta.animationID);\n      } else if (eventName === \"animation-rejection\") {\n        helper.log(\"Animation \" + meta.animationID + \" has been rejected as all attributes of it overlap on specific elements because of existing animations\");\n      } else if (eventName === \"duration-change\" && this.needsUpdate) {\n        this.millisecondChange(this.clip.runTimeInfo.currentMillisecond, this.clip.state);\n      }\n    }\n  }, {\n    key: \"subscribeToEvents\",\n    value: function subscribeToEvents() {\n      this.clip.subscribeToEvents(this.id, this.eventBroadcast.bind(this));\n    }\n  }, {\n    key: \"subscribeToTimer\",\n    value: function subscribeToTimer() {\n      this.clip.subscribe(this.id, this.millisecondChange.bind(this));\n    }\n  }, {\n    key: \"handleDragStart\",\n    value: function handleDragStart() {\n      this.needsUpdate = true;\n      this.journey = timeCapsule.startJourney(this.clip);\n    }\n  }, {\n    key: \"handleDrag\",\n    value: function handleDrag(loopBarPositionX) {\n      if (!isFinite(loopBarPositionX)) {\n        loopBarPositionX = 0;\n      }\n      var duration = this.clip.duration;\n\n      var loopBarPercentageLeft = void 0;\n\n      if (this.loopBar.style.left.includes(\"px\")) {\n        loopBarPercentageLeft = parseFloat(this.loopBar.style.left) / this.totalBar.offsetWidth || 0;\n      } else {\n        loopBarPercentageLeft = parseFloat(this.loopBar.style.left) / 100 || 0;\n      }\n\n      var totalBarPositionX = loopBarPositionX + this.totalBar.offsetWidth * loopBarPercentageLeft;\n\n      var millisecond = Math.round(duration * totalBarPositionX / this.totalBar.offsetWidth);\n\n      this.currentTime.innerHTML = millisecond;\n\n      this.runningBar.style.width = loopBarPositionX / this.loopBar.offsetWidth * 100 + \"%\";\n\n      this.journey.station(millisecond);\n    }\n  }, {\n    key: \"handleDragEnd\",\n    value: function handleDragEnd() {\n      this.journey.destination();\n    }\n  }, {\n    key: \"addEventListeners\",\n    value: function addEventListeners() {\n      var _this2 = this;\n\n      /* \n      * Play - pause - replay interactions\n      */\n\n      this.statusButton.onclick = function (e) {\n        e.preventDefault();\n        if (_this2.clip.state === \"playing\") {\n          _this2.clip.wait();\n        } else if (_this2.clip.state === \"waiting\") {\n          _this2.clip.resume();\n        } else if (_this2.clip.state === \"idle\") {\n          if (_this2.clip.speed >= 0) {\n            _this2.clip.play();\n            _this2.needsUpdate = true;\n          } else {\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(_this2.loopEndMillisecond - 1);\n            _this2.journey.destination();\n            _this2.clip.play();\n            _this2.needsUpdate = true;\n          }\n        } else if (_this2.clip.state === \"completed\") {\n          if (_this2.clip.speed >= 0) {\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(0);\n            _this2.journey.destination();\n            _this2.clip.play();\n            _this2.needsUpdate = true;\n          } else {\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(_this2.loopEndMillisecond - 1);\n            _this2.journey.destination();\n            _this2.clip.play();\n            _this2.needsUpdate = true;\n          }\n        }\n      };\n\n      this.settingsShowIndicator.onclick = function (e) {\n        e.preventDefault();\n        var checkbox = elid(\"mc-player-show-indicator-checkbox\");\n        if (checkbox.checked) {\n          checkbox.checked = false;\n          _this2.indicator.style.visibility = \"hidden\";\n          _this2.statusButton.style.margin = \"10px 5px 5px 5px\";\n          _this2.statusButton.style.height = \"25px\";\n          _this2.statusButton.style.width = \"45px\";\n          _this2.timeDisplay.style.left = \"50px\";\n        } else {\n          checkbox.checked = true;\n          _this2.indicator.style.visibility = \"visible\";\n          _this2.statusButton.style.margin = \"10px 5px 12px 5px\";\n          _this2.statusButton.style.width = \"55px\";\n          _this2.timeDisplay.style.left = \"60px\";\n          _this2.statusButton.style.height = \"18px\";\n        }\n      };\n\n      this.settingsButton.onclick = function (e) {\n        e.preventDefault();\n\n        var showHideSettings = function showHideSettings(e) {\n          if (_this2.settingsPanel.contains(e.target)) {\n            return true;\n          }\n          _this2.settingsPanel.classList.toggle(\"m-fadeOut\");\n          _this2.settingsPanel.classList.toggle(\"m-fadeIn\");\n          if (_this2.settingsPanel.className.includes(\"m-fadeOut\")) {\n            removeListener(\"click\", showHideSettings, false);\n          }\n        };\n\n        if (_this2.settingsPanel.className.includes(\"m-fadeOut\")) {\n          addListener(\"click\", showHideSettings, false);\n        } else {\n          removeListener(\"click\", showHideSettings, false);\n        }\n      };\n      this.settingsSpeedButtonShow.onclick = this.settingsSpeedButtonHide.onclick = function (e) {\n        e.preventDefault();\n        _this2.settingsPanel.classList.toggle(\"mc-player-settings-speed-panel\");\n        var includesClass = _this2.settingsPanel.className.includes(\"mc-player-settings-speed-panel\");\n        if (includesClass) {\n          _this2.settingsMainPanel.style.display = \"none\";\n          _this2.settingsSpeedPanel.style.display = \"block\";\n        } else {\n          _this2.settingsSpeedPanel.style.display = \"none\";\n          _this2.settingsMainPanel.style.display = \"block\";\n        }\n      };\n\n      var onCursorMove = function onCursorMove(e) {\n        e.preventDefault();\n        var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n        var viewportOffset = _this2.loopBar.getBoundingClientRect();\n        var positionX = clientX - viewportOffset.left;\n        if (positionX < 0) {\n          positionX = 0;\n        } else if (_this2.loopBar.offsetWidth === _this2.totalBar.offsetWidth && positionX >= _this2.loopBar.offsetWidth) {\n          positionX = _this2.totalBar.offsetWidth;\n        } else if (positionX >= _this2.loopBar.offsetWidth) {\n          positionX = parseFloat(_this2.loopBar.style.width) / 100 * _this2.totalBar.offsetWidth;\n        }\n        _this2.handleDrag(positionX);\n      };\n\n      var onMouseUp = function onMouseUp(e) {\n        e.preventDefault();\n        removeListener(\"mouseup\", onMouseUp, false);\n        removeListener(\"touchend\", onMouseUp, false);\n        removeListener(\"mousemove\", onCursorMove, false);\n        removeListener(\"touchmove\", onCursorMove, false);\n        _this2.handleDragEnd();\n        if (_this2.playAfterResize) {\n          if (_this2.clip.state === \"idle\" && !_this2.loopButton.className.includes(\"svg-selected\")) {\n            _this2.clip.play();\n          } else if (_this2.clip.state === \"completed\" && !_this2.loopButton.className.includes(\"svg-selected\")) {\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(_this2.loopEndMillisecond - 1);\n            _this2.journey.destination();\n            _this2.clip.play();\n          } else if ((_this2.clip.state === \"completed\" || _this2.clip.state === \"idle\") && _this2.loopButton.className.includes(\"svg-selected\")) {\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.clip.speed >= 0 ? _this2.journey.station(_this2.loopStartMillisecond + 1) : _this2.journey.station(_this2.loopEndMillisecond - 1);\n            _this2.journey.destination();\n            _this2.clip.play();\n          } else {\n            _this2.clip.resume();\n          }\n          _this2.playAfterResize = false;\n        }\n      };\n      var onMouseDown = function onMouseDown(e) {\n        e.preventDefault();\n        if (_this2.clip.state === \"playing\") {\n          _this2.playAfterResize = true;\n        }\n        _this2.handleDragStart();\n        onCursorMove(e);\n        addListener(\"mouseup\", onMouseUp, false);\n        addListener(\"touchend\", onMouseUp, false);\n        addListener(\"mousemove\", onCursorMove, false);\n        addListener(\"touchmove\", onCursorMove, false);\n      };\n\n      this.loopBar.addEventListener(\"mousedown\", onMouseDown, false);\n      this.loopBar.addEventListener(\"touchstart\", onMouseDown, {\n        passive: true\n      }, false);\n\n      var onCursorMoveSpeedBar = function onCursorMoveSpeedBar(e) {\n        e.preventDefault();\n        var viewportOffset = _this2.speedBar.getBoundingClientRect();\n        var clientY = e.clientY || ((e.touches || [])[0] || {}).clientY;\n        var positionY = clientY - viewportOffset.top;\n        positionY -= 8;\n        if (positionY < 0) {\n          positionY = 0;\n        } else if (positionY > _this2.speedBar.offsetHeight - 15.5) {\n          positionY = _this2.speedBar.offsetHeight - 15.5;\n        }\n\n        // show speed\n        var percentage = (positionY / 128.5 - 1) * -1;\n        var step = 1 / 8;\n        var speed = _this2.calculateSpeed(step, _this2.speedValues, percentage);\n        elid(\"mc-player-speed-runtime\").innerHTML = speed + \"0\";\n        elid(\"mc-player-speed-cursor\").style.top = positionY + \"px\";\n        _this2.clip.executionSpeed = speed;\n      };\n\n      var onMouseUpSpeedBar = function onMouseUpSpeedBar(e) {\n        e.preventDefault();\n        removeListener(\"mouseup\", onMouseUpSpeedBar, false);\n        removeListener(\"touchend\", onMouseUpSpeedBar, false);\n        removeListener(\"mousemove\", onCursorMoveSpeedBar, false);\n        removeListener(\"touchmove\", onCursorMoveSpeedBar, false);\n        elid(\"mc-player-speed-runtime\").innerHTML = \"Speed\";\n        var speedDisplay = void 0;\n        _this2.clip.speed == 1 ? speedDisplay = \"Normal\" : speedDisplay = _this2.clip.speed;\n\n        _this2.speedCurrent.innerHTML = speedDisplay;\n      };\n      var onMouseDownSpeedBar = function onMouseDownSpeedBar(e) {\n        e.preventDefault();\n        onCursorMoveSpeedBar(e);\n        addListener(\"mouseup\", onMouseUpSpeedBar, false);\n        addListener(\"touchend\", onMouseUpSpeedBar, false);\n        addListener(\"mousemove\", onCursorMoveSpeedBar, false);\n        addListener(\"touchmove\", onCursorMoveSpeedBar, false);\n      };\n\n      this.speedBarHelper.addEventListener(\"mousedown\", onMouseDownSpeedBar, false);\n      this.speedBarHelper.addEventListener(\"touchstart\", onMouseDownSpeedBar, {\n        passive: true\n      }, false);\n\n      this.fullScreenButton.addEventListener(\"click\", function () {\n        var elFullScreen = _this2.clip.props.host.className.includes(\"full-screen\");\n        elFullScreen ? _this2.exitFullscreen() : _this2.launchIntoFullscreen(_this2.clip.props.host);\n        _this2.clip.props.host.classList.toggle(\"full-screen\");\n      });\n\n      this.loopButton.onclick = function () {\n        _this2.loopButton.classList.toggle(\"svg-selected\");\n        _this2.loopBarStart.classList.toggle(\"m-fadeOut\");\n        _this2.loopBarEnd.classList.toggle(\"m-fadeOut\");\n        _this2.loopBarStart.classList.toggle(\"m-fadeIn\");\n        _this2.loopBarEnd.classList.toggle(\"m-fadeIn\");\n        elid(\"mc-player-loop-time\").classList.toggle(\"m-fadeOut\");\n        elid(\"mc-player-loop-time\").classList.toggle(\"m-fadeIn\");\n\n        elid(\"mc-player-loopbar-end-time\").innerHTML = _this2.loopEndMillisecond;\n        elid(\"mc-player-loopbar-start-time\").innerHTML = _this2.loopStartMillisecond;\n        _this2.needsUpdate = true;\n\n        if (elid(\"mc-player-loop-time\").className.includes(\"m-fadeOut\")) {\n          _this2.loopBar.style.left = \"0px\";\n          _this2.loopBar.style.width = \"100%\";\n          _this2.loopStartMillisecond = 0;\n          _this2.loopEndMillisecond = _this2.clip.duration;\n          _this2.loopLastPositionXPxls = 0;\n          _this2.loopLastPositionXPercentage = 0;\n          _this2.runningBar.style.width = _this2.clip.runTimeInfo.currentMillisecond / _this2.clip.duration * 100 + \"%\";\n        }\n      };\n\n      elid(\"mc-player-controls\").onmouseover = function () {\n        if (!_this2.loopButton.className.includes(\"svg-selected\")) {\n          return;\n        }\n        _this2.loopBarStart.classList.remove(\"m-fadeOut\");\n        _this2.loopBarEnd.classList.remove(\"m-fadeOut\");\n        _this2.loopBarStart.classList.add(\"m-fadeIn\");\n        _this2.loopBarEnd.classList.add(\"m-fadeIn\");\n      };\n      elid(\"mc-player-controls\").onmouseout = function () {\n        if (!_this2.loopButton.className.includes(\"svg-selected\")) {\n          return;\n        }\n        _this2.loopBarStart.classList.add(\"m-fadeOut\");\n        _this2.loopBarEnd.classList.add(\"m-fadeOut\");\n        _this2.loopBarStart.classList.remove(\"m-fadeIn\");\n        _this2.loopBarEnd.classList.remove(\"m-fadeIn\");\n      };\n\n      var onCursorMoveLoopStart = function onCursorMoveLoopStart(e) {\n        e.preventDefault();\n        var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n        var viewportOffset = _this2.totalBar.getBoundingClientRect();\n        var positionX = clientX - viewportOffset.left;\n        if (positionX < 0) {\n          positionX = 0;\n        } else if (positionX > _this2.totalBar.offsetWidth) {\n          positionX = _this2.totalBar.offsetWidth;\n        }\n\n        var loopBarDeltaX = positionX - _this2.loopLastPositionXPxls || 0;\n        var runningBarWidthInPxls = _this2.runningBar.offsetWidth - loopBarDeltaX;\n\n        _this2.loopBar.style.left = positionX + \"px\";\n\n        if (parseFloat(_this2.loopBar.style.width) - loopBarDeltaX + positionX > _this2.totalBar.offsetWidth) {\n          _this2.loopBar.style.width = \"0px\";\n          _this2.runningBar.style.width = \"0px\";\n        } else {\n          _this2.loopBar.style.width = parseFloat(_this2.loopBar.style.width) - loopBarDeltaX + \"px\";\n          _this2.runningBar.style.width = runningBarWidthInPxls + \"px\";\n        }\n\n        _this2.loopLastPositionXPxls = positionX;\n\n        _this2.loopStartMillisecond = Math.round(_this2.clip.duration * parseFloat(_this2.loopBar.style.left) / _this2.totalBar.offsetWidth);\n\n        var newLoopEndMillisecond = Math.round(_this2.clip.duration * ((parseFloat(_this2.loopBar.style.left) || 0) + parseFloat(_this2.loopBar.style.width)) / _this2.totalBar.offsetWidth);\n\n        if (_this2.loopEndMillisecond < newLoopEndMillisecond) {\n          _this2.loopEndMillisecond = Math.round(_this2.clip.duration * ((parseFloat(_this2.loopBar.style.left) || 0) + parseFloat(_this2.loopBar.style.width)) / _this2.totalBar.offsetWidth);\n          _this2.loopJourney = true;\n        }\n\n        elid(\"mc-player-loopbar-end-time\").innerHTML = _this2.loopEndMillisecond;\n        elid(\"mc-player-loopbar-start-time\").innerHTML = _this2.loopStartMillisecond;\n      };\n\n      var onMouseUpLoopStart = function onMouseUpLoopStart(e) {\n        _this2.resizeLoop = false;\n\n        e.preventDefault();\n        if (_this2.loopJourney) {\n          _this2.handleDragStart();\n          _this2.handleDrag(_this2.runningBar.offsetWidth);\n          _this2.handleDragEnd();\n          _this2.loopJourney = false;\n        }\n\n        _this2.loopLastPositionXPercentage = _this2.loopLastPositionXPxls / _this2.loopBar.offsetWidth;\n\n        var runningBarWidthPercentage = _this2.runningBar.offsetWidth / _this2.loopBar.offsetWidth * 100 + \"%\";\n\n        _this2.loopBar.style.left = parseFloat(_this2.loopBar.style.left) / _this2.totalBar.offsetWidth * 100 + \"%\";\n\n        _this2.loopBar.style.width = parseFloat(_this2.loopBar.style.width) / _this2.totalBar.offsetWidth * 100 + \"%\";\n\n        _this2.loopStartMillisecond = Math.round(_this2.clip.duration * parseFloat(_this2.loopBar.style.left) / 100);\n\n        _this2.loopEndMillisecond = Math.round(_this2.clip.duration * ((parseFloat(_this2.loopBar.style.left) || 0) + parseFloat(_this2.loopBar.style.width)) / 100);\n\n        _this2.runningBar.style.width = runningBarWidthPercentage;\n        removeListener(\"mouseup\", onMouseUpLoopStart, false);\n        removeListener(\"touchend\", onMouseUpLoopStart, false);\n        removeListener(\"mousemove\", onCursorMoveLoopStart, false);\n        removeListener(\"touchmove\", onCursorMoveLoopStart, false);\n        _this2.loopBar.addEventListener(\"mousedown\", onMouseDown, false);\n        _this2.loopBar.addEventListener(\"touchstart\", onMouseDown, {\n          passive: true\n        }, false);\n\n        if (_this2.playAfterResize) {\n          if (_this2.clip.state === \"idle\") {\n            var loopms = void 0;\n            if (_this2.clip.speed >= 0) {\n              loopms = _this2.loopStartMillisecond + 1;\n            } else {\n              loopms = _this2.loopEndMillisecond - 1;\n            }\n            _this2.needsUpdate = true;\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(loopms);\n            _this2.journey.destination();\n            _this2.clip.play();\n          } else if (_this2.clip.state === \"completed\") {\n            var _loopms = void 0;\n            if (_this2.clip.speed >= 0) {\n              _loopms = _this2.loopStartMillisecond + 1;\n            } else {\n              _loopms = _this2.loopEndMillisecond - 1;\n            }\n            _this2.needsUpdate = true;\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(_loopms);\n            _this2.journey.destination();\n            _this2.clip.play();\n          } else {\n            _this2.clip.resume();\n          }\n          _this2.playAfterResize = false;\n        }\n      };\n\n      var onMouseDownLoopStart = function onMouseDownLoopStart(e) {\n        _this2.resizeLoop = true;\n\n        e.preventDefault();\n        _this2.needsUpdate = true;\n\n        if (_this2.clip.state === \"playing\") {\n          _this2.clip.wait();\n          _this2.playAfterResize = true;\n        }\n        _this2.loopBar.style.width = _this2.loopBar.offsetWidth + \"px\";\n\n        if (_this2.loopLastPositionXPxls - _this2.loopLastPositionXPercentage * _this2.loopBar.offsetWidth > 1 || _this2.loopLastPositionXPercentage * _this2.loopBar.offsetWidth - _this2.loopLastPositionXPxls > 1) {\n          _this2.loopLastPositionXPxls = _this2.loopLastPositionXPercentage * _this2.loopBar.offsetWidth;\n        }\n\n        _this2.loopBar.removeEventListener(\"mousedown\", onMouseDown, false);\n        _this2.loopBar.removeEventListener(\"touchstart\", onMouseDown, false);\n        onCursorMoveLoopStart(e);\n        addListener(\"mouseup\", onMouseUpLoopStart, false);\n        addListener(\"touchend\", onMouseUpLoopStart, false);\n        addListener(\"mousemove\", onCursorMoveLoopStart, false);\n        addListener(\"touchmove\", onCursorMoveLoopStart, false);\n      };\n\n      this.loopBarStart.addEventListener(\"mousedown\", onMouseDownLoopStart, false);\n      this.loopBarStart.addEventListener(\"touchstart\", onMouseDownLoopStart, {\n        passive: true\n      }, false);\n\n      var onCursorMoveLoopEnd = function onCursorMoveLoopEnd(e) {\n        e.preventDefault();\n\n        var clientX = e.clientX || ((e.touches || [])[0] || {}).clientX;\n        var viewportOffset = _this2.totalBar.getBoundingClientRect();\n        var positionX = clientX - viewportOffset.left;\n        if (positionX < 0) {\n          positionX = 0;\n        } else if (positionX > _this2.totalBar.offsetWidth) {\n          positionX = _this2.totalBar.offsetWidth;\n        }\n\n        if (_this2.runningBar.offsetWidth + (parseFloat(_this2.loopBar.style.left) || 0) > positionX) {\n          _this2.runningBar.style.width = positionX - parseFloat(_this2.loopBar.style.left) + \"px\";\n        }\n\n        if (_this2.loopLastPositionXPxls - positionX < 0) {\n          _this2.loopBar.style.width = Math.abs(_this2.loopLastPositionXPxls - positionX) + \"px\";\n        } else {\n          _this2.loopBar.style.left = positionX + \"px\";\n          _this2.loopLastPositionXPxls = positionX;\n        }\n\n        var newLoopStartMillisecond = Math.round(_this2.clip.duration * parseFloat(_this2.loopBar.style.left) / _this2.totalBar.offsetWidth);\n        if (_this2.loopStartMillisecond > newLoopStartMillisecond) {\n          _this2.loopStartMillisecond = newLoopStartMillisecond;\n          _this2.loopJourney = true;\n        }\n\n        _this2.loopEndMillisecond = Math.round(_this2.clip.duration * ((parseFloat(_this2.loopBar.style.left) || 0) + parseFloat(_this2.loopBar.style.width)) / _this2.totalBar.offsetWidth);\n\n        elid(\"mc-player-loopbar-end-time\").innerHTML = _this2.loopEndMillisecond;\n        elid(\"mc-player-loopbar-start-time\").innerHTML = _this2.loopStartMillisecond;\n      };\n\n      var onMouseUpLoopEnd = function onMouseUpLoopEnd(e) {\n        _this2.resizeLoop = false;\n        e.preventDefault();\n        _this2.runningBar.style.width = _this2.runningBar.offsetWidth / _this2.loopBar.offsetWidth * 100 + \"%\";\n\n        _this2.loopBar.style.left = (parseFloat(_this2.loopBar.style.left) || 0) / _this2.totalBar.offsetWidth * 100 + \"%\";\n\n        _this2.loopBar.style.width = parseFloat(_this2.loopBar.style.width) / _this2.totalBar.offsetWidth * 100 + \"%\";\n\n        _this2.loopLastPositionXPercentage = _this2.loopLastPositionXPxls / _this2.loopBar.offsetWidth;\n\n        _this2.loopStartMillisecond = Math.round(_this2.clip.duration * parseFloat(_this2.loopBar.style.left) / 100);\n\n        _this2.loopEndMillisecond = Math.round(_this2.clip.duration * ((parseFloat(_this2.loopBar.style.left) || 0) + parseFloat(_this2.loopBar.style.width)) / 100);\n\n        if (_this2.loopJourney) {\n          _this2.handleDragStart();\n          _this2.handleDrag(_this2.runningBar.offsetWidth);\n          _this2.handleDragEnd();\n          _this2.loopJourney = false;\n        }\n        removeListener(\"mouseup\", onMouseUpLoopEnd, false);\n        removeListener(\"touchend\", onMouseUpLoopEnd, false);\n        removeListener(\"mousemove\", onCursorMoveLoopEnd, false);\n        removeListener(\"touchmove\", onCursorMoveLoopEnd, false);\n        _this2.loopBar.addEventListener(\"mousedown\", onMouseDown, false);\n        _this2.loopBar.addEventListener(\"touchstart\", onMouseDown, {\n          passive: true\n        }, false);\n\n        if (_this2.playAfterResize) {\n          if (_this2.clip.state === \"idle\") {\n            var loopms = void 0;\n            if (_this2.clip.speed >= 0) {\n              loopms = _this2.loopStartMillisecond + 1;\n            } else {\n              loopms = _this2.loopEndMillisecond - 1;\n            }\n            _this2.needsUpdate = true;\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(loopms);\n            _this2.journey.destination();\n            _this2.clip.play();\n          } else if (_this2.clip.state === \"completed\") {\n            var _loopms2 = void 0;\n            if (_this2.clip.speed >= 0) {\n              _loopms2 = _this2.loopStartMillisecond + 1;\n            } else {\n              _loopms2 = _this2.loopEndMillisecond - 1;\n            }\n            _this2.needsUpdate = true;\n            _this2.clip.stop();\n            _this2.journey = timeCapsule.startJourney(_this2.clip);\n            _this2.journey.station(_loopms2);\n            _this2.journey.destination();\n            _this2.clip.play();\n          } else {\n            _this2.clip.resume();\n          }\n          _this2.playAfterResize = false;\n        }\n      };\n\n      var onMouseDownLoopEnd = function onMouseDownLoopEnd(e) {\n        _this2.resizeLoop = true;\n        _this2.needsUpdate = true;\n\n        if (_this2.clip.state === \"playing\") {\n          _this2.clip.wait();\n          _this2.playAfterResize = true;\n        }\n        e.preventDefault();\n        _this2.runningBar.style.width = _this2.runningBar.offsetWidth + \"px\";\n\n        _this2.loopBar.style.left = (parseFloat(_this2.loopBar.style.left) || 0) / 100 * _this2.totalBar.offsetWidth + \"px\";\n\n        if (_this2.loopLastPositionXPxls - _this2.loopLastPositionXPercentage * _this2.loopBar.offsetWidth > 1 || _this2.loopLastPositionXPercentage * _this2.loopBar.offsetWidth - _this2.loopLastPositionXPxls > 1) {\n          _this2.loopLastPositionXPxls = _this2.loopLastPositionXPercentage * _this2.loopBar.offsetWidth;\n        }\n\n        _this2.loopBar.style.width = _this2.loopBar.offsetWidth + \"px\";\n        _this2.loopBar.removeEventListener(\"mousedown\", onMouseDown, false);\n        _this2.loopBar.removeEventListener(\"touchstart\", onMouseDown, false);\n        onCursorMoveLoopEnd(e);\n        addListener(\"mouseup\", onMouseUpLoopEnd, false);\n        addListener(\"touchend\", onMouseUpLoopEnd, false);\n        addListener(\"mousemove\", onCursorMoveLoopEnd, false);\n        addListener(\"touchmove\", onCursorMoveLoopEnd, false);\n      };\n\n      this.loopBarEnd.addEventListener(\"mousedown\", onMouseDownLoopEnd, false);\n      this.loopBarEnd.addEventListener(\"touchstart\", onMouseDownLoopEnd, {\n        passive: true\n      }, false);\n\n      // only on desctop devices\n      if (!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {\n        var loopBarMouseInOut = function loopBarMouseInOut() {\n          elid(\"mc-player-hover-display\").classList.toggle(\"m-fadeOut\");\n          elid(\"mc-player-hover-display\").classList.toggle(\"m-fadeIn\");\n\n          if (elid(\"mc-player-hover-display\").className.includes(\"m-fadeIn\")) {\n            _this2.hoverJourney = hoverTimeCapsule.startJourney(_this2.previewClip);\n          } else {\n            _this2.hoverJourney.destination();\n          }\n          _this2.loopBar.onmousemove = _loopBarMouseMove;\n        };\n        var loopBarAddListeners = function loopBarAddListeners() {\n          loopBarMouseInOut();\n          _this2.loopBar.onmouseover = _this2.loopBar.onmouseout = loopBarMouseInOut;\n          _this2.loopBar.onmousemove = _loopBarMouseMove;\n          removeListener(\"mouseup\", loopBarAddListeners, false);\n          removeListener(\"touchend\", loopBarAddListeners, false);\n          removeListener(\"mousemove\", _loopBarMouseMove, false);\n          removeListener(\"touchmove\", _loopBarMouseMove, false);\n        };\n\n        this.loopBar.onmouseover = this.loopBar.onmouseout = loopBarMouseInOut;\n\n        this.loopBar.onmousedown = function () {\n          _this2.loopBar.onmouseover = _this2.loopBar.onmouseout = null;\n          _this2.loopBar.onmousemove = null;\n          addListener(\"mouseup\", loopBarAddListeners, false);\n          addListener(\"touchend\", loopBarAddListeners, false);\n          addListener(\"mousemove\", _loopBarMouseMove, false);\n          addListener(\"touchmove\", _loopBarMouseMove, false);\n        };\n        this.loopBar.onmouseup = function () {\n          removeListener(\"mouseup\", loopBarAddListeners, false);\n          removeListener(\"touchend\", loopBarAddListeners, false);\n          removeListener(\"mousemove\", _loopBarMouseMove, false);\n          removeListener(\"touchmove\", _loopBarMouseMove, false);\n          _this2.loopBar.onmouseover = _this2.loopBar.onmouseout = loopBarMouseInOut;\n          _this2.loopBar.onmousemove = _loopBarMouseMove;\n        };\n\n        var _loopBarMouseMove = function _loopBarMouseMove(e) {\n          var clientX = e.clientX;\n          var viewportOffset = _this2.loopBar.getBoundingClientRect();\n          if (clientX - viewportOffset.left + _this2.loopLastPositionXPxls > _this2.loopLastPositionXPxls + _this2.loopBar.offsetWidth && !_this2.resizeLoop) {\n            elid(\"mc-player-hover-millisecond\").innerHTML = _this2.loopEndMillisecond;\n            return;\n          } else if (clientX - viewportOffset.left < 0 && !_this2.resizeLoop) {\n            elid(\"mc-player-hover-millisecond\").innerHTML = _this2.loopStartMillisecond;\n            return;\n          }\n\n          var positionX = clientX - viewportOffset.left + _this2.loopLastPositionXPxls;\n\n          if (positionX < 0) {\n            positionX = 0;\n          }\n\n          var left = positionX - elid(\"mc-player-hover-display\").offsetWidth / 2;\n\n          if (left < 0) {\n            left = 0;\n          } else if (left + elid(\"mc-player-hover-display\").offsetWidth > _this2.totalBar.offsetWidth) {\n            left = _this2.totalBar.offsetWidth - elid(\"mc-player-hover-display\").offsetWidth;\n          }\n\n          var ms = Math.round(positionX / _this2.totalBar.offsetWidth * _this2.clip.duration);\n\n          _this2.hoverJourney.station(ms);\n\n          elid(\"mc-player-hover-millisecond\").innerHTML = ms;\n          elid(\"mc-player-hover-display\").style.left = left + \"px\";\n        };\n      }\n\n      el(\"body\")[0].addEventListener(\"click\", function (e) {\n        if (e.target.className === \"mc-player-speed-value\") {\n          var speedDisplay = e.target.dataset.speedValue - 0;\n          _this2.clip.executionSpeed = e.target.dataset.speedValue;\n          _this2.clip.speed == 1 ? speedDisplay = \"Normal\" : speedDisplay = _this2.clip.speed;\n          _this2.speedCurrent.innerHTML = speedDisplay;\n\n          var step = 1 / (_this2.speedValues.length - 1);\n\n          var positionY = (e.target.dataset.zone * step - 1) * -1 * 128.5;\n\n          elid(\"mc-player-speed-cursor\").style.top = positionY + \"px\";\n        }\n      });\n    }\n  }, {\n    key: \"calculateSpeed\",\n    value: function calculateSpeed(step, arrayOfValues, currentPercentage) {\n      var botLimitIndex = Math.floor(currentPercentage / step);\n\n      if (botLimitIndex === arrayOfValues.length - 1) {\n        return arrayOfValues[botLimitIndex].toFixed(1);\n      }\n\n      var limitZonePercentage = currentPercentage / step % 1;\n\n      var limitZoneLength = Math.abs(arrayOfValues[botLimitIndex] - arrayOfValues[botLimitIndex + 1]);\n\n      var realZoneSpeed = limitZonePercentage * limitZoneLength;\n\n      var realSpeed = (realZoneSpeed + arrayOfValues[botLimitIndex]).toFixed(1);\n\n      if (realSpeed == 0) {\n        return \"0.0\";\n      }\n      return realSpeed;\n    }\n  }, {\n    key: \"launchIntoFullscreen\",\n    value: function launchIntoFullscreen(element) {\n      this.mcPlayer.classList.toggle(\"full-screen\");\n      if (element.requestFullscreen) {\n        element.requestFullscreen();\n      } else if (element.mozRequestFullScreen) {\n        element.mozRequestFullScreen();\n      } else if (element.webkitRequestFullscreen) {\n        element.webkitRequestFullscreen();\n      } else if (element.msRequestFullscreen) {\n        element.msRequestFullscreen();\n      }\n    }\n  }, {\n    key: \"exitFullscreen\",\n    value: function exitFullscreen() {\n      this.mcPlayer.classList.toggle(\"full-screen\");\n      if (document.exitFullscreen) {\n        document.exitFullscreen();\n      } else if (document.mozCancelFullScreen) {\n        document.mozCancelFullScreen();\n      } else if (document.webkitExitFullscreen) {\n        document.webkitExitFullscreen();\n      }\n    }\n  }, {\n    key: \"setTheme\",\n    value: function setTheme() {\n      // replace multiple spaces with one space\n      this.theme.replace(/\\s\\s+/g, \" \");\n      this.theme.trim();\n\n      if (!this.theme.includes(\"on-top\") && !this.theme.includes(\"position-default\")) {\n        this.theme += \" position-default\";\n      }\n\n      var theme = {};\n      for (var i in this.theme.split(\" \")) {\n        var confTheme = confThemes(this.theme.split(\" \")[i]);\n        for (var q in confTheme || {}) {\n          theme[q] = confTheme[q];\n        }\n      }\n      var css = confStyle(theme);\n\n      var style = elcreate(\"style\");\n\n      style.styleSheet ? style.styleSheet.cssText = css : style.appendChild(document.createTextNode(css));\n\n      // append player style to document\n      eltag(\"head\")[0].appendChild(style);\n    }\n  }, {\n    key: \"setSpeed\",\n    value: function setSpeed() {\n      var _this3 = this;\n\n      var currentSpeed = void 0;\n      this.clip.speed == 1 ? currentSpeed = \"Normal\" : currentSpeed = this.clip.speed;\n      this.speedCurrent.innerHTML = currentSpeed;\n\n      var targetZone = function () {\n        for (var i = 0; i < _this3.speedValues.length - 1; i++) {\n          if (_this3.speedValues[i] <= _this3.clip.speed && _this3.speedValues[i + 1] > _this3.clip.speed) {\n            return i + Math.abs((_this3.clip.speed - _this3.speedValues[i]) / (_this3.speedValues[i] - _this3.speedValues[i + 1]));\n          }\n        }\n      }();\n\n      var step = 1 / 8;\n\n      var positionY = (targetZone * step - 1) * -1 * 128.5;\n\n      elid(\"mc-player-speed-cursor\").style.top = positionY + \"px\";\n    }\n  }, {\n    key: \"createHoverDisplay\",\n    value: function createHoverDisplay() {\n      var clip = this.clip.props.host.getElementsByTagName(\"iframe\")[0];\n\n      var definition = this.clip.exportState({ unprocessed: true });\n\n      definition.props.host = elid(\"mc-player-hover-display\");\n      this.previewClip = MC.ClipFromDefinition(definition, this.clipClass);\n      console.log(\"asdfsadfdsafsad\", this.clip, this.previewClip);\n\n      var previewClip = this.previewClip.props.host.getElementsByTagName(\"iframe\")[0];\n\n      previewClip.style.position = \"absolute\";\n\n      previewClip.style.zIndex = 1;\n\n      var clipWidth = clip.offsetWidth;\n\n      var clipHeight = clip.offsetHeight;\n\n      var previewRatio = 0.253125;\n\n      var previewWidth = Math.round(clipWidth * previewRatio);\n\n      // max width is 300\n      if (previewWidth > parseFloat(elid(\"mc-player-hover-display\").style.maxWidth)) {\n        previewWidth = parseFloat(elid(\"mc-player-hover-display\").style.maxWidth);\n      }\n\n      elid(\"mc-player-hover-display\").style.width = previewWidth + \"px\";\n\n      var previewHeight = Math.round(clipHeight / clipWidth * previewWidth);\n\n      elid(\"mc-player-hover-display\").style.height = previewHeight + \"px\";\n\n      var scaleY = previewHeight / clipHeight;\n      var scaleX = previewWidth / clipWidth;\n\n      previewClip.style.transform = \"scale(\" + scaleX + \",\" + scaleY + \")\";\n      previewClip.style.transformOrigin = \"center bottom\";\n\n      // check if width of iframe is percentage\n      if (this.clip.props.containerParams.width.includes(\"%\")) {\n        previewClip.style.width = 100 + 100 * previewRatio + parseFloat(this.clip.props.containerParams.width) / previewRatio + \"%\";\n      }\n\n      if (this.clip.props.containerParams.height.includes(\"%\")) {\n        previewClip.style.height = 100 + 100 * previewRatio + parseFloat(this.clip.props.containerParams.height) / previewRatio + \"%\";\n      }\n    }\n  }]);\n\n  return Player;\n}();\n\nvar el = function el(selector) {\n  return document.querySelectorAll(selector);\n};\nvar elid = function elid(id) {\n  return document.getElementById(id);\n};\nvar eltag = function eltag(tag) {\n  return document.getElementsByTagName(tag);\n};\nvar elcreate = function elcreate(tag) {\n  return document.createElement(tag);\n};\nvar addListener = function addListener() {\n  var _document;\n\n  return (_document = document).addEventListener.apply(_document, arguments);\n};\nvar removeListener = function removeListener() {\n  var _document2;\n\n  return (_document2 = document).removeEventListener.apply(_document2, arguments);\n};\n\nmodule.exports = Player;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL1BsYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvUGxheWVyLmpzPzY2ZDYiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgTUMgPSByZXF1aXJlKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleFwiKTtcbmNvbnN0IGhlbHBlciA9IG5ldyBNQy5IZWxwZXIoKTtcbmNvbnN0IHRpbWVDYXBzdWxlID0gbmV3IE1DLlRpbWVDYXBzdWxlKCk7XG5jb25zdCBob3ZlclRpbWVDYXBzdWxlID0gbmV3IE1DLlRpbWVDYXBzdWxlKCk7XG5jb25zdCBjb25mVGhlbWVzID0gcmVxdWlyZShcIi4vdGhlbWVzXCIpO1xuY29uc3QgY29uZlN0eWxlID0gcmVxdWlyZShcIi4vc3R5bGVcIik7XG5jb25zdCBzdmcgPSByZXF1aXJlKFwiLi9zdmdcIik7XG5jb25zdCBwbGF5ZXJIVE1MID0gcmVxdWlyZShcIi4vcGxheWVySFRNTFwiKTtcbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGltZXIncyBwdXJwb3NlIGlzIHRvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIHRocm91Z2ggd2hpY2ggYW55IFRpbWVkSW5jaWRlbnQgKHN1Y2ggYXMgYSBTY2VuZSBvciBhIENsaXApXG4gKiBjYW4gYm90aCBwcml2aWRlIGluZm8gcmVnYXJkaW5nIHRoZWlyIHRpbWluZyBzdGF0ZSBidXQgYWxzbyBwcm92aWRlIGFuIGludGVyZmFjZSBmb3IgaW50ZXJhY3RpbmcgL1xuICogYWx0ZXJpbmcgdGhlIHRpbWluZyBvZiBpdFxuICovXG5jbGFzcyBQbGF5ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc29sZS5sb2coXCJpbiBwbGF5ZXJcIilcbiAgICB0aGlzLmlkID0gb3B0aW9ucy5pZCB8fCBoZWxwZXIuZ2V0QW5JZCgpOyAvLyB0aW1lciBpZFxuICAgIHRoaXMuY2xpcCA9IG9wdGlvbnMuY2xpcDsgLy8gaG9zdCB0byBhcHBseSB0aGUgdGltZXJcbiAgICB0aGlzLmNsaXBDbGFzcyA9IG9wdGlvbnMuY2xpcENsYXNzO1xuICAgIG9wdGlvbnMucHJldmlldyA9IG9wdGlvbnMucHJldmlldyB8fCBmYWxzZSA7XG4gICAgLy8gdGhpcy5wcmV2aWV3Q2xpcC5wcm9wcy5ob3N0ID0gZWxpZCgpXG4gICAgdGhpcy5zcGVlZFZhbHVlcyA9IFstNCwgLTIsIC0xLCAtMC41LCAwLCAwLjUsIDEsIDIsIDRdO1xuICAgIHRoaXMucmVxdWVzdGluZ0xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA9IDA7XG4gICAgdGhpcy5wbGF5QWZ0ZXJSZXNpemUgPSBmYWxzZTtcbiAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSA9IDA7XG4gICAgdGhpcy5qb3VybmV5ID0gbnVsbDtcbiAgICB0aGlzLmhvdmVySm91cm5leSA9IG51bGw7XG4gICAgdGhpcy5sb29wSm91cm5leSA9IGZhbHNlO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIHRoaXMubG9vcFN0YXJ0TWlsbGlzZWNvbmQgPSAwO1xuICAgIHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kID0gdGhpcy5jbGlwLmR1cmF0aW9uO1xuICAgIHRoaXMudGhlbWUgPSBvcHRpb25zLnRoZW1lIHx8IFwidHJhbnNwYXJlbnQgb24tdG9wXCI7XG5cbiAgICAvLyBzZXQgY2xpcCBwb3NpdGlvbiB0byByZWxhdGl2ZVxuICAgIHRoaXMuY2xpcC5wcm9wcy5ob3N0LnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgIGNvbnN0IGNsaXAgPSB0aGlzLmNsaXAucHJvcHMuaG9zdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlmcmFtZVwiKVswXTtcbiAgICBjbGlwLnN0eWxlLm1hcmdpbiA9IFwiMCBhdXRvXCI7XG4gICAgY2xpcC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuXG4gICAgLy8gY3JlYXRlIHRoZSB0aW1lciBjb250cm9scyBtYWluIGRpdlxuICAgIHRoaXMubWNQbGF5ZXIgPSBlbGNyZWF0ZShcImRpdlwiKTtcbiAgICB0aGlzLm1jUGxheWVyLmlkID0gXCJtYy1wbGF5ZXJcIjtcbiAgICB0aGlzLm1jUGxheWVyLmlubmVySFRNTCA9IHBsYXllckhUTUwoeyBzdmcgfSk7XG4gICAgZWxpZCh0aGlzLmNsaXAucHJvcHMuaG9zdC5pZCkuYXBwZW5kQ2hpbGQodGhpcy5tY1BsYXllcik7XG5cbiAgICB0aGlzLnRvdGFsQmFyID0gZWxpZChcIm1jLXBsYXllci10b3RhbGJhclwiKTtcbiAgICB0aGlzLmxvb3BCYXIgPSBlbGlkKFwibWMtcGxheWVyLWxvb3BiYXJcIik7XG4gICAgdGhpcy5ydW5uaW5nQmFyID0gZWxpZChcIm1jLXBsYXllci1ydW5uaW5nYmFyXCIpO1xuICAgIHRoaXMuc3BlZWRCYXIgPSBlbGlkKFwibWMtcGxheWVyLXNwZWVkLXZhbHVlLWJhclwiKTtcbiAgICB0aGlzLnNwZWVkQmFySGVscGVyID0gZWxpZChcIm1jLXBsYXllci1zcGVlZC12YWx1ZS1oZWxwZXJiYXJcIik7XG4gICAgdGhpcy5pbmRpY2F0b3IgPSBlbGlkKFwibWMtcGxheWVyLWluZGljYXRvclwiKTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gZWxpZChcIm1jLXBsYXllci10aW1lLWN1cnJlbnRcIik7XG4gICAgdGhpcy50aW1lU2VwYXJhdG9yID0gZWxpZChcIm1jLXBsYXllci10aW1lLXNlcGFyYXRvclwiKTtcbiAgICB0aGlzLnRpbWVEaXNwbGF5ID0gZWxpZChcIm1jLXBsYXllci10aW1lLWRpc3BsYXlcIik7XG4gICAgdGhpcy50b3RhbFRpbWUgPSBlbGlkKFwibWMtcGxheWVyLXRpbWUtdG90YWxcIik7XG4gICAgdGhpcy5zdGF0dXNCdXR0b24gPSBlbGlkKFwibWMtcGxheWVyLXN0YXR1cy1idG5cIik7XG4gICAgdGhpcy5zZXR0aW5nc1Nob3dJbmRpY2F0b3IgPSBlbGlkKFwibWMtcGxheWVyLXNldHRpbmdzLWluZGljYXRvclwiKTtcbiAgICB0aGlzLnNldHRpbmdzQnV0dG9uID0gZWxpZChcIm1jLXBsYXllci1zZXR0aW5ncy1idG5cIik7XG4gICAgdGhpcy5sb29wQnV0dG9uID0gZWxpZChcIm1jLXBsYXllci1sb29wLWJ0blwiKTtcbiAgICB0aGlzLnNldHRpbmdzU3BlZWRCdXR0b25TaG93ID0gZWxpZChcIm1jLXBsYXllci1zZXR0aW5ncy1zcGVlZC1zaG93XCIpO1xuICAgIHRoaXMuc2V0dGluZ3NTcGVlZEJ1dHRvbkhpZGUgPSBlbGlkKFwibWMtcGxheWVyLXNldHRpbmdzLXNwZWVkLWhpZGVcIik7XG4gICAgdGhpcy5mdWxsU2NyZWVuQnV0dG9uID0gZWxpZChcIm1jLXBsYXllci1mdWxsLXNjcmVlbi1idG5cIik7XG4gICAgdGhpcy5zZXR0aW5nc1BhbmVsID0gZWxpZChcIm1jLXBsYXllci1zZXR0aW5ncy1wYW5lbFwiKTtcbiAgICB0aGlzLnNldHRpbmdzTWFpblBhbmVsID0gZWxpZChcIm1jLXBsYXllci1tYWluLXNldHRpbmdzXCIpO1xuICAgIHRoaXMuc2V0dGluZ3NTcGVlZFBhbmVsID0gZWxpZChcIm1jLXBsYXllci1zcGVlZC1zZXR0aW5nc1wiKTtcbiAgICB0aGlzLnNwZWVkQ3VycmVudCA9IGVsaWQoXCJtYy1wbGF5ZXItc3BlZWQtY3VycmVudFwiKTtcbiAgICB0aGlzLmxvb3BCYXJTdGFydCA9IGVsaWQoXCJtYy1wbGF5ZXItbG9vcGJhci1zdGFydFwiKTtcbiAgICB0aGlzLmxvb3BCYXJFbmQgPSBlbGlkKFwibWMtcGxheWVyLWxvb3BiYXItZW5kXCIpO1xuXG4gICAgdGhpcy5jdXJyZW50VGltZS5pbm5lckhUTUwgPSAwO1xuICAgIHRoaXMudG90YWxUaW1lLmlubmVySFRNTCA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcbiAgICB0aGlzLnRpbWVTZXBhcmF0b3IuaW5uZXJIVE1MID0gXCIvXCI7XG4gICAgdGhpcy5zZXR0aW5nc1NwZWVkUGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIHRoaXMuc2V0dGluZ3NQYW5lbC5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIpO1xuICAgIHRoaXMuaW5kaWNhdG9yLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgIHRoaXMuaW5kaWNhdG9yLmlubmVySFRNTCA9IFwiSWRsZVwiO1xuXG4gICAgdGhpcy5zZXR0aW5nc1NwZWVkUGFuZWxcbiAgICAgIC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpXCIpWzFdXG4gICAgICAuY2xhc3NMaXN0LmFkZChcIm5vLWhvdmVyXCIpO1xuXG4gICAgdGhpcy5sb29wQmFyU3RhcnQuc3R5bGUubGVmdCA9IFwiMCVcIjtcbiAgICB0aGlzLmxvb3BCYXJFbmQuc3R5bGUubGVmdCA9IFwiMTAwJVwiO1xuICAgIHRoaXMubG9vcEJhclN0YXJ0LmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIik7XG4gICAgdGhpcy5sb29wQmFyRW5kLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIik7XG4gICAgZWxpZChcIm1jLXBsYXllci1sb29wLXRpbWVcIikuY2xhc3NMaXN0LmFkZChcIm0tZmFkZU91dFwiKTtcblxuICAgIGVsaWQoXCJtYy1wbGF5ZXItaG92ZXItZGlzcGxheVwiKS5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIpO1xuXG4gICAgdGhpcy5zZXRTcGVlZCgpO1xuICAgIHRoaXMuc2V0VGhlbWUoKTtcbiAgICB0aGlzLnN1YnNjcmliZVRvVGltZXIoKTtcbiAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKCk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgIGlmIChvcHRpb25zLnByZXZpZXcpIHtcbiAgICAgIHRoaXMuY3JlYXRlSG92ZXJEaXNwbGF5KCk7XG4gICAgfVxuICB9XG5cbiAgbWlsbGlzZWNvbmRDaGFuZ2UobWlsbGlzZWNvbmQpIHtcbiAgICBpZiAoIXRoaXMubmVlZHNVcGRhdGUpIHtcbiAgICAgIHRoaXMuY2xpcC53YWl0KCk7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgY29uc3QgZHVyYXRpb24gPSB0aGlzLmNsaXAuZHVyYXRpb247XG5cbiAgICAvLyB6ZXJvIHZhbHVlIGlmIHN0eWxlLmxlZnQgaXMgbnVsbFxuICAgIGNvbnN0IGxvb3BCYXJMZWZ0UGVyY2VudGFnZSA9XG4gICAgICBwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSAvIDEwMCB8fCAwO1xuXG4gICAgY29uc3QgbG9vcEJhcldpZHRoID0gdGhpcy5sb29wQmFyLm9mZnNldFdpZHRoO1xuXG4gICAgY29uc3QgbG9jYWxNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kIC0gZHVyYXRpb24gKiBsb29wQmFyTGVmdFBlcmNlbnRhZ2U7XG5cbiAgICBjb25zdCBsb2NhbER1cmF0aW9uID0gKGR1cmF0aW9uIC8gdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aCkgKiBsb29wQmFyV2lkdGg7XG4gICAgaWYgKFxuICAgICAgbWlsbGlzZWNvbmQgPj0gdGhpcy5sb29wRW5kTWlsbGlzZWNvbmQgJiZcbiAgICAgIHRoaXMubG9vcEJ1dHRvbi5jbGFzc05hbWUuaW5jbHVkZXMoXCJzdmctc2VsZWN0ZWRcIilcbiAgICApIHtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5jbGlwLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICAgIHRoaXMuY2xpcC5zdG9wKCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5ID0gdGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KHRoaXMuY2xpcCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LnN0YXRpb24odGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCArIDEpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGlwLnN0YXRlID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbih0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMSk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbih0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMSk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5jbGlwLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfSwgMCk7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgbWlsbGlzZWNvbmQgPD0gdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCAmJlxuICAgICAgdGhpcy5sb29wQnV0dG9uLmNsYXNzTmFtZS5pbmNsdWRlcyhcInN2Zy1zZWxlY3RlZFwiKVxuICAgICkge1xuICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNsaXAuc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbih0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDEpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGlwLnN0YXRlID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbih0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDEpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5qb3VybmV5ID0gdGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KHRoaXMuY2xpcCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LnN0YXRpb24odGhpcy5sb29wRW5kTWlsbGlzZWNvbmQgLSAxKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuZGVzdGluYXRpb24oKTtcbiAgICAgICAgICB0aGlzLmNsaXAucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9LCAwKTtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmQgPj0gdGhpcy5sb29wRW5kTWlsbGlzZWNvbmQpIHtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgdGhpcy5qb3VybmV5LnN0YXRpb24odGhpcy5sb29wRW5kTWlsbGlzZWNvbmQpO1xuICAgICAgICB0aGlzLmpvdXJuZXkuZGVzdGluYXRpb24oKTtcbiAgICAgIH0sIDApO1xuICAgICAgdGhpcy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICB0aGlzLmN1cnJlbnRUaW1lLmlubmVySFRNTCA9IHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZCA8PSB0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kKSB7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5qb3VybmV5ID0gdGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KHRoaXMuY2xpcCk7XG4gICAgICAgIHRoaXMuam91cm5leS5zdGF0aW9uKHRoaXMubG9vcFN0YXJ0TWlsbGlzZWNvbmQpO1xuICAgICAgICB0aGlzLmpvdXJuZXkuZGVzdGluYXRpb24oKTtcbiAgICAgIH0sIDApO1xuICAgICAgdGhpcy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gXCIwJVwiO1xuICAgICAgdGhpcy5jdXJyZW50VGltZS5pbm5lckhUTUwgPSB0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kO1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgdGhpcy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID1cbiAgICAgIChsb2NhbE1pbGxpc2Vjb25kIC8gbG9jYWxEdXJhdGlvbikgKiAxMDAgKyBcIiVcIjtcblxuICAgIHRoaXMuY3VycmVudFRpbWUuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG4gIH1cblxuICBldmVudEJyb2FkY2FzdChldmVudE5hbWUsIG1ldGEpIHtcbiAgICBpZiAoZXZlbnROYW1lID09PSBcInN0YXRlLWNoYW5nZVwiKSB7XG4gICAgICBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gXCJ3YWl0aW5nXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uaW5uZXJIVE1MID0gc3ZnLnBsYXlTVkc7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLmFwcGVuZENoaWxkKHRoaXMuaW5kaWNhdG9yKTtcbiAgICAgICAgdGhpcy5pbmRpY2F0b3IuaW5uZXJIVE1MID0gXCJXYWl0aW5nXCI7XG4gICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLmlubmVySFRNTCA9IHN2Zy5wYXVzZVNWRztcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5pbmRpY2F0b3IpO1xuICAgICAgICB0aGlzLmluZGljYXRvci5pbm5lckhUTUwgPSBcIlBsYXlpbmdcIjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gXCJjb21wbGV0ZWRcIikge1xuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lLmlubmVySFRNTCA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uaW5uZXJIVE1MID0gc3ZnLnJlcGxheVNWRztcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uYXBwZW5kQ2hpbGQodGhpcy5pbmRpY2F0b3IpO1xuICAgICAgICB0aGlzLmluZGljYXRvci5pbm5lckhUTUwgPSBcIkNvbXBsZXRlZFwiO1xuICAgICAgfSBlbHNlIGlmIChtZXRhLm5ld1N0YXRlID09PSBcInRyYW5zaXRpb25hbFwiKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLmlubmVySFRNTCA9IHN2Zy5wbGF5U1ZHO1xuICAgICAgICB0aGlzLnN0YXR1c0J1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmluZGljYXRvcik7XG4gICAgICAgIHRoaXMuaW5kaWNhdG9yLmlubmVySFRNTCA9IFwiVHJhbnNpdGlvbmFsXCI7XG4gICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLmlubmVySFRNTCA9IHN2Zy5wbGF5U1ZHO1xuICAgICAgICB0aGlzLnN0YXR1c0J1dHRvbi5hcHBlbmRDaGlsZCh0aGlzLmluZGljYXRvcik7XG4gICAgICAgIHRoaXMuaW5kaWNhdG9yLmlubmVySFRNTCA9IFwiSWRsZVwiO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSBcImF0dHJpYnV0ZS1yZWplY3Rpb25cIikge1xuICAgICAgaGVscGVyLmxvZyhcbiAgICAgICAgXCJBdHRyaWJ1dGVzXCIsXG4gICAgICAgIG1ldGEuYXR0cmlidXRlcyxcbiAgICAgICAgXCJoYXZlIGJlZW4gcmVqZWN0ZWQgZnJvbSBhbmltYXRpb24gd2l0aCBpZCBcIiArIG1ldGEuYW5pbWF0aW9uSURcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09IFwiYW5pbWF0aW9uLXJlamVjdGlvblwiKSB7XG4gICAgICBoZWxwZXIubG9nKFxuICAgICAgICBcIkFuaW1hdGlvbiBcIiArXG4gICAgICAgICAgbWV0YS5hbmltYXRpb25JRCArXG4gICAgICAgICAgXCIgaGFzIGJlZW4gcmVqZWN0ZWQgYXMgYWxsIGF0dHJpYnV0ZXMgb2YgaXQgb3ZlcmxhcCBvbiBzcGVjaWZpYyBlbGVtZW50cyBiZWNhdXNlIG9mIGV4aXN0aW5nIGFuaW1hdGlvbnNcIlxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJkdXJhdGlvbi1jaGFuZ2VcIiAmJiB0aGlzLm5lZWRzVXBkYXRlKSB7XG4gICAgICB0aGlzLm1pbGxpc2Vjb25kQ2hhbmdlKFxuICAgICAgICB0aGlzLmNsaXAucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kLFxuICAgICAgICB0aGlzLmNsaXAuc3RhdGVcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc3Vic2NyaWJlVG9FdmVudHMoKSB7XG4gICAgdGhpcy5jbGlwLnN1YnNjcmliZVRvRXZlbnRzKHRoaXMuaWQsIHRoaXMuZXZlbnRCcm9hZGNhc3QuYmluZCh0aGlzKSk7XG4gIH1cblxuICBzdWJzY3JpYmVUb1RpbWVyKCkge1xuICAgIHRoaXMuY2xpcC5zdWJzY3JpYmUodGhpcy5pZCwgdGhpcy5taWxsaXNlY29uZENoYW5nZS5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIGhhbmRsZURyYWdTdGFydCgpIHtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgfVxuXG4gIGhhbmRsZURyYWcobG9vcEJhclBvc2l0aW9uWCkge1xuICAgIGlmICghaXNGaW5pdGUobG9vcEJhclBvc2l0aW9uWCkpIHtcbiAgICAgIGxvb3BCYXJQb3NpdGlvblggPSAwO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcblxuICAgIGxldCBsb29wQmFyUGVyY2VudGFnZUxlZnQ7XG5cbiAgICBpZiAodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQuaW5jbHVkZXMoXCJweFwiKSkge1xuICAgICAgbG9vcEJhclBlcmNlbnRhZ2VMZWZ0ID1cbiAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCkgLyB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoIHx8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvb3BCYXJQZXJjZW50YWdlTGVmdCA9IHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQpIC8gMTAwIHx8IDA7XG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxCYXJQb3NpdGlvblggPVxuICAgICAgbG9vcEJhclBvc2l0aW9uWCArIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGggKiBsb29wQmFyUGVyY2VudGFnZUxlZnQ7XG5cbiAgICBjb25zdCBtaWxsaXNlY29uZCA9IE1hdGgucm91bmQoXG4gICAgICAoZHVyYXRpb24gKiB0b3RhbEJhclBvc2l0aW9uWCkgLyB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoXG4gICAgKTtcblxuICAgIHRoaXMuY3VycmVudFRpbWUuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG5cbiAgICB0aGlzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPVxuICAgICAgKGxvb3BCYXJQb3NpdGlvblggLyB0aGlzLmxvb3BCYXIub2Zmc2V0V2lkdGgpICogMTAwICsgXCIlXCI7XG5cbiAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbihtaWxsaXNlY29uZCk7XG4gIH1cblxuICBoYW5kbGVEcmFnRW5kKCkge1xuICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgLyogXG4gICAgKiBQbGF5IC0gcGF1c2UgLSByZXBsYXkgaW50ZXJhY3Rpb25zXG4gICAgKi9cblxuICAgIHRoaXMuc3RhdHVzQnV0dG9uLm9uY2xpY2sgPSBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLmNsaXAuc3RhdGUgPT09IFwicGxheWluZ1wiKSB7XG4gICAgICAgIHRoaXMuY2xpcC53YWl0KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2xpcC5zdGF0ZSA9PT0gXCJ3YWl0aW5nXCIpIHtcbiAgICAgICAgdGhpcy5jbGlwLnJlc3VtZSgpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNsaXAuc3RhdGUgPT09IFwiaWRsZVwiKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbih0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDEpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGlwLnN0YXRlID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgIGlmICh0aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgIHRoaXMuY2xpcC5zdG9wKCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5ID0gdGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KHRoaXMuY2xpcCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LnN0YXRpb24oMCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsaXAuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLmNsaXApO1xuICAgICAgICAgIHRoaXMuam91cm5leS5zdGF0aW9uKHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kIC0gMSk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLnNldHRpbmdzU2hvd0luZGljYXRvci5vbmNsaWNrID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBjaGVja2JveCA9IGVsaWQoXCJtYy1wbGF5ZXItc2hvdy1pbmRpY2F0b3ItY2hlY2tib3hcIik7XG4gICAgICBpZiAoY2hlY2tib3guY2hlY2tlZCkge1xuICAgICAgICBjaGVja2JveC5jaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaW5kaWNhdG9yLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICB0aGlzLnN0YXR1c0J1dHRvbi5zdHlsZS5tYXJnaW4gPSBcIjEwcHggNXB4IDVweCA1cHhcIjtcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uc3R5bGUuaGVpZ2h0ID0gXCIyNXB4XCI7XG4gICAgICAgIHRoaXMuc3RhdHVzQnV0dG9uLnN0eWxlLndpZHRoID0gXCI0NXB4XCI7XG4gICAgICAgIHRoaXMudGltZURpc3BsYXkuc3R5bGUubGVmdCA9IFwiNTBweFwiO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5kaWNhdG9yLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIjtcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uc3R5bGUubWFyZ2luID0gXCIxMHB4IDVweCAxMnB4IDVweFwiO1xuICAgICAgICB0aGlzLnN0YXR1c0J1dHRvbi5zdHlsZS53aWR0aCA9IFwiNTVweFwiO1xuICAgICAgICB0aGlzLnRpbWVEaXNwbGF5LnN0eWxlLmxlZnQgPSBcIjYwcHhcIjtcbiAgICAgICAgdGhpcy5zdGF0dXNCdXR0b24uc3R5bGUuaGVpZ2h0ID0gXCIxOHB4XCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2V0dGluZ3NCdXR0b24ub25jbGljayA9IGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBjb25zdCBzaG93SGlkZVNldHRpbmdzID0gZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzUGFuZWwuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXR0aW5nc1BhbmVsLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVPdXRcIik7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NQYW5lbC5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlSW5cIik7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzUGFuZWwuY2xhc3NOYW1lLmluY2x1ZGVzKFwibS1mYWRlT3V0XCIpKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJjbGlja1wiLCBzaG93SGlkZVNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzUGFuZWwuY2xhc3NOYW1lLmluY2x1ZGVzKFwibS1mYWRlT3V0XCIpKSB7XG4gICAgICAgIGFkZExpc3RlbmVyKFwiY2xpY2tcIiwgc2hvd0hpZGVTZXR0aW5ncywgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJjbGlja1wiLCBzaG93SGlkZVNldHRpbmdzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLnNldHRpbmdzU3BlZWRCdXR0b25TaG93Lm9uY2xpY2sgPSB0aGlzLnNldHRpbmdzU3BlZWRCdXR0b25IaWRlLm9uY2xpY2sgPSBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuc2V0dGluZ3NQYW5lbC5jbGFzc0xpc3QudG9nZ2xlKFwibWMtcGxheWVyLXNldHRpbmdzLXNwZWVkLXBhbmVsXCIpO1xuICAgICAgY29uc3QgaW5jbHVkZXNDbGFzcyA9IHRoaXMuc2V0dGluZ3NQYW5lbC5jbGFzc05hbWUuaW5jbHVkZXMoXG4gICAgICAgIFwibWMtcGxheWVyLXNldHRpbmdzLXNwZWVkLXBhbmVsXCJcbiAgICAgICk7XG4gICAgICBpZiAoaW5jbHVkZXNDbGFzcykge1xuICAgICAgICB0aGlzLnNldHRpbmdzTWFpblBhbmVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1NwZWVkUGFuZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NTcGVlZFBhbmVsLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5zZXR0aW5nc01haW5QYW5lbC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvbkN1cnNvck1vdmUgPSBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGNsaWVudFggPSBlLmNsaWVudFggfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRYO1xuICAgICAgY29uc3Qgdmlld3BvcnRPZmZzZXQgPSB0aGlzLmxvb3BCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBsZXQgcG9zaXRpb25YID0gY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XG4gICAgICBpZiAocG9zaXRpb25YIDwgMCkge1xuICAgICAgICBwb3NpdGlvblggPSAwO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGhpcy5sb29wQmFyLm9mZnNldFdpZHRoID09PSB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoICYmXG4gICAgICAgIHBvc2l0aW9uWCA+PSB0aGlzLmxvb3BCYXIub2Zmc2V0V2lkdGhcbiAgICAgICkge1xuICAgICAgICBwb3NpdGlvblggPSB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvblggPj0gdGhpcy5sb29wQmFyLm9mZnNldFdpZHRoKSB7XG4gICAgICAgIHBvc2l0aW9uWCA9XG4gICAgICAgICAgKHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLndpZHRoKSAvIDEwMCkgKlxuICAgICAgICAgIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGg7XG4gICAgICB9XG4gICAgICB0aGlzLmhhbmRsZURyYWcocG9zaXRpb25YKTtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZVVwID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uTW91c2VVcCwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25DdXJzb3JNb3ZlLCBmYWxzZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbkN1cnNvck1vdmUsIGZhbHNlKTtcbiAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCgpO1xuICAgICAgaWYgKHRoaXMucGxheUFmdGVyUmVzaXplKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmNsaXAuc3RhdGUgPT09IFwiaWRsZVwiICYmXG4gICAgICAgICAgIXRoaXMubG9vcEJ1dHRvbi5jbGFzc05hbWUuaW5jbHVkZXMoXCJzdmctc2VsZWN0ZWRcIilcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICB0aGlzLmNsaXAuc3RhdGUgPT09IFwiY29tcGxldGVkXCIgJiZcbiAgICAgICAgICAhdGhpcy5sb29wQnV0dG9uLmNsYXNzTmFtZS5pbmNsdWRlcyhcInN2Zy1zZWxlY3RlZFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmNsaXAuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLmNsaXApO1xuICAgICAgICAgIHRoaXMuam91cm5leS5zdGF0aW9uKHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kIC0gMSk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAodGhpcy5jbGlwLnN0YXRlID09PSBcImNvbXBsZXRlZFwiIHx8IHRoaXMuY2xpcC5zdGF0ZSA9PT0gXCJpZGxlXCIpICYmXG4gICAgICAgICAgdGhpcy5sb29wQnV0dG9uLmNsYXNzTmFtZS5pbmNsdWRlcyhcInN2Zy1zZWxlY3RlZFwiKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aGlzLmNsaXAuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLmNsaXApO1xuICAgICAgICAgIHRoaXMuY2xpcC5zcGVlZCA+PSAwXG4gICAgICAgICAgICA/IHRoaXMuam91cm5leS5zdGF0aW9uKHRoaXMubG9vcFN0YXJ0TWlsbGlzZWNvbmQgKyAxKVxuICAgICAgICAgICAgOiB0aGlzLmpvdXJuZXkuc3RhdGlvbih0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDEpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheUFmdGVyUmVzaXplID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMuY2xpcC5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgdGhpcy5wbGF5QWZ0ZXJSZXNpemUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQoKTtcbiAgICAgIG9uQ3Vyc29yTW92ZShlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXAsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Nb3VzZVVwLCBmYWxzZSk7XG4gICAgICBhZGRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbkN1cnNvck1vdmUsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG9uQ3Vyc29yTW92ZSwgZmFsc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93biwgZmFsc2UpO1xuICAgIHRoaXMubG9vcEJhci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICBvbk1vdXNlRG93bixcbiAgICAgIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIGNvbnN0IG9uQ3Vyc29yTW92ZVNwZWVkQmFyID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB2aWV3cG9ydE9mZnNldCA9IHRoaXMuc3BlZWRCYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBjb25zdCBjbGllbnRZID0gZS5jbGllbnRZIHx8ICgoZS50b3VjaGVzIHx8IFtdKVswXSB8fCB7fSkuY2xpZW50WTtcbiAgICAgIGxldCBwb3NpdGlvblkgPSBjbGllbnRZIC0gdmlld3BvcnRPZmZzZXQudG9wO1xuICAgICAgcG9zaXRpb25ZIC09IDg7XG4gICAgICBpZiAocG9zaXRpb25ZIDwgMCkge1xuICAgICAgICBwb3NpdGlvblkgPSAwO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvblkgPiB0aGlzLnNwZWVkQmFyLm9mZnNldEhlaWdodCAtIDE1LjUpIHtcbiAgICAgICAgcG9zaXRpb25ZID0gdGhpcy5zcGVlZEJhci5vZmZzZXRIZWlnaHQgLSAxNS41O1xuICAgICAgfVxuXG4gICAgICAvLyBzaG93IHNwZWVkXG4gICAgICBjb25zdCBwZXJjZW50YWdlID0gKHBvc2l0aW9uWSAvIDEyOC41IC0gMSkgKiAtMTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAxIC8gODtcbiAgICAgIGNvbnN0IHNwZWVkID0gdGhpcy5jYWxjdWxhdGVTcGVlZChzdGVwLCB0aGlzLnNwZWVkVmFsdWVzLCBwZXJjZW50YWdlKTtcbiAgICAgIGVsaWQoXCJtYy1wbGF5ZXItc3BlZWQtcnVudGltZVwiKS5pbm5lckhUTUwgPSBzcGVlZCArIFwiMFwiO1xuICAgICAgZWxpZChcIm1jLXBsYXllci1zcGVlZC1jdXJzb3JcIikuc3R5bGUudG9wID0gcG9zaXRpb25ZICsgXCJweFwiO1xuICAgICAgdGhpcy5jbGlwLmV4ZWN1dGlvblNwZWVkID0gc3BlZWQ7XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VVcFNwZWVkQmFyID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwU3BlZWRCYXIsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Nb3VzZVVwU3BlZWRCYXIsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uQ3Vyc29yTW92ZVNwZWVkQmFyLCBmYWxzZSk7XG4gICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbkN1cnNvck1vdmVTcGVlZEJhciwgZmFsc2UpO1xuICAgICAgZWxpZChcIm1jLXBsYXllci1zcGVlZC1ydW50aW1lXCIpLmlubmVySFRNTCA9IFwiU3BlZWRcIjtcbiAgICAgIGxldCBzcGVlZERpc3BsYXk7XG4gICAgICB0aGlzLmNsaXAuc3BlZWQgPT0gMVxuICAgICAgICA/IChzcGVlZERpc3BsYXkgPSBcIk5vcm1hbFwiKVxuICAgICAgICA6IChzcGVlZERpc3BsYXkgPSB0aGlzLmNsaXAuc3BlZWQpO1xuXG4gICAgICB0aGlzLnNwZWVkQ3VycmVudC5pbm5lckhUTUwgPSBzcGVlZERpc3BsYXk7XG4gICAgfTtcbiAgICBjb25zdCBvbk1vdXNlRG93blNwZWVkQmFyID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBvbkN1cnNvck1vdmVTcGVlZEJhcihlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXBTcGVlZEJhciwgZmFsc2UpO1xuICAgICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvbk1vdXNlVXBTcGVlZEJhciwgZmFsc2UpO1xuICAgICAgYWRkTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25DdXJzb3JNb3ZlU3BlZWRCYXIsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG9uQ3Vyc29yTW92ZVNwZWVkQmFyLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIHRoaXMuc3BlZWRCYXJIZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICBvbk1vdXNlRG93blNwZWVkQmFyLFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMuc3BlZWRCYXJIZWxwZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgb25Nb3VzZURvd25TcGVlZEJhcixcbiAgICAgIHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGZhbHNlXG4gICAgKTtcblxuICAgIHRoaXMuZnVsbFNjcmVlbkJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgY29uc3QgZWxGdWxsU2NyZWVuID0gdGhpcy5jbGlwLnByb3BzLmhvc3QuY2xhc3NOYW1lLmluY2x1ZGVzKFxuICAgICAgICBcImZ1bGwtc2NyZWVuXCJcbiAgICAgICk7XG4gICAgICBlbEZ1bGxTY3JlZW5cbiAgICAgICAgPyB0aGlzLmV4aXRGdWxsc2NyZWVuKClcbiAgICAgICAgOiB0aGlzLmxhdW5jaEludG9GdWxsc2NyZWVuKHRoaXMuY2xpcC5wcm9wcy5ob3N0KTtcbiAgICAgIHRoaXMuY2xpcC5wcm9wcy5ob3N0LmNsYXNzTGlzdC50b2dnbGUoXCJmdWxsLXNjcmVlblwiKTtcbiAgICB9KTtcblxuICAgIHRoaXMubG9vcEJ1dHRvbi5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb29wQnV0dG9uLmNsYXNzTGlzdC50b2dnbGUoXCJzdmctc2VsZWN0ZWRcIik7XG4gICAgICB0aGlzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlT3V0XCIpO1xuICAgICAgdGhpcy5sb29wQmFyRW5kLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVPdXRcIik7XG4gICAgICB0aGlzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QudG9nZ2xlKFwibS1mYWRlSW5cIik7XG4gICAgICB0aGlzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZUluXCIpO1xuICAgICAgZWxpZChcIm1jLXBsYXllci1sb29wLXRpbWVcIikuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcbiAgICAgIGVsaWQoXCJtYy1wbGF5ZXItbG9vcC10aW1lXCIpLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVJblwiKTtcblxuICAgICAgZWxpZChcIm1jLXBsYXllci1sb29wYmFyLWVuZC10aW1lXCIpLmlubmVySFRNTCA9IHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgICAgZWxpZChcbiAgICAgICAgXCJtYy1wbGF5ZXItbG9vcGJhci1zdGFydC10aW1lXCJcbiAgICAgICkuaW5uZXJIVE1MID0gdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG4gICAgICBpZiAoZWxpZChcIm1jLXBsYXllci1sb29wLXRpbWVcIikuY2xhc3NOYW1lLmluY2x1ZGVzKFwibS1mYWRlT3V0XCIpKSB7XG4gICAgICAgIHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5sb29wQmFyLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgIHRoaXMubG9vcFN0YXJ0TWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICB0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCA9IHRoaXMuY2xpcC5kdXJhdGlvbjtcbiAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgPSAwO1xuICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSA9IDA7XG4gICAgICAgIHRoaXMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgKHRoaXMuY2xpcC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLyB0aGlzLmNsaXAuZHVyYXRpb24pICpcbiAgICAgICAgICAgIDEwMCArXG4gICAgICAgICAgXCIlXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGVsaWQoXCJtYy1wbGF5ZXItY29udHJvbHNcIikub25tb3VzZW92ZXIgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubG9vcEJ1dHRvbi5jbGFzc05hbWUuaW5jbHVkZXMoXCJzdmctc2VsZWN0ZWRcIikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LnJlbW92ZShcIm0tZmFkZU91dFwiKTtcbiAgICAgIHRoaXMubG9vcEJhckVuZC5jbGFzc0xpc3QucmVtb3ZlKFwibS1mYWRlT3V0XCIpO1xuICAgICAgdGhpcy5sb29wQmFyU3RhcnQuY2xhc3NMaXN0LmFkZChcIm0tZmFkZUluXCIpO1xuICAgICAgdGhpcy5sb29wQmFyRW5kLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVJblwiKTtcbiAgICB9O1xuICAgIGVsaWQoXCJtYy1wbGF5ZXItY29udHJvbHNcIikub25tb3VzZW91dCA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5sb29wQnV0dG9uLmNsYXNzTmFtZS5pbmNsdWRlcyhcInN2Zy1zZWxlY3RlZFwiKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QuYWRkKFwibS1mYWRlT3V0XCIpO1xuICAgICAgdGhpcy5sb29wQmFyRW5kLmNsYXNzTGlzdC5hZGQoXCJtLWZhZGVPdXRcIik7XG4gICAgICB0aGlzLmxvb3BCYXJTdGFydC5jbGFzc0xpc3QucmVtb3ZlKFwibS1mYWRlSW5cIik7XG4gICAgICB0aGlzLmxvb3BCYXJFbmQuY2xhc3NMaXN0LnJlbW92ZShcIm0tZmFkZUluXCIpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbkN1cnNvck1vdmVMb29wU3RhcnQgPSBlID0+IHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGNvbnN0IGNsaWVudFggPSBlLmNsaWVudFggfHwgKChlLnRvdWNoZXMgfHwgW10pWzBdIHx8IHt9KS5jbGllbnRYO1xuICAgICAgY29uc3Qgdmlld3BvcnRPZmZzZXQgPSB0aGlzLnRvdGFsQmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IHBvc2l0aW9uWCA9IGNsaWVudFggLSB2aWV3cG9ydE9mZnNldC5sZWZ0O1xuICAgICAgaWYgKHBvc2l0aW9uWCA8IDApIHtcbiAgICAgICAgcG9zaXRpb25YID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocG9zaXRpb25YID4gdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aCkge1xuICAgICAgICBwb3NpdGlvblggPSB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsb29wQmFyRGVsdGFYID0gcG9zaXRpb25YIC0gdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgfHwgMDtcbiAgICAgIGNvbnN0IHJ1bm5pbmdCYXJXaWR0aEluUHhscyA9IHRoaXMucnVubmluZ0Jhci5vZmZzZXRXaWR0aCAtIGxvb3BCYXJEZWx0YVg7XG5cbiAgICAgIHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0ID0gcG9zaXRpb25YICsgXCJweFwiO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLndpZHRoKSAtIGxvb3BCYXJEZWx0YVggKyBwb3NpdGlvblggPlxuICAgICAgICB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5sb29wQmFyLnN0eWxlLndpZHRoID0gXCIwcHhcIjtcbiAgICAgICAgdGhpcy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gXCIwcHhcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9vcEJhci5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUud2lkdGgpIC0gbG9vcEJhckRlbHRhWCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gcnVubmluZ0JhcldpZHRoSW5QeGxzICsgXCJweFwiO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA9IHBvc2l0aW9uWDtcblxuICAgICAgdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCA9IE1hdGgucm91bmQoXG4gICAgICAgICh0aGlzLmNsaXAuZHVyYXRpb24gKiBwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSkgL1xuICAgICAgICAgIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGhcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld0xvb3BFbmRNaWxsaXNlY29uZCA9IE1hdGgucm91bmQoXG4gICAgICAgICh0aGlzLmNsaXAuZHVyYXRpb24gKlxuICAgICAgICAgICgocGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCkgfHwgMCkgK1xuICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUud2lkdGgpKSkgL1xuICAgICAgICAgIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGhcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCA8IG5ld0xvb3BFbmRNaWxsaXNlY29uZCkge1xuICAgICAgICB0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCA9IE1hdGgucm91bmQoXG4gICAgICAgICAgKHRoaXMuY2xpcC5kdXJhdGlvbiAqXG4gICAgICAgICAgICAoKHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQpIHx8IDApICtcbiAgICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUud2lkdGgpKSkgL1xuICAgICAgICAgICAgdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aFxuICAgICAgICApO1xuICAgICAgICB0aGlzLmxvb3BKb3VybmV5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgZWxpZChcIm1jLXBsYXllci1sb29wYmFyLWVuZC10aW1lXCIpLmlubmVySFRNTCA9IHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgICAgZWxpZChcbiAgICAgICAgXCJtYy1wbGF5ZXItbG9vcGJhci1zdGFydC10aW1lXCJcbiAgICAgICkuaW5uZXJIVE1MID0gdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZDtcbiAgICB9O1xuXG4gICAgY29uc3Qgb25Nb3VzZVVwTG9vcFN0YXJ0ID0gZSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZUxvb3AgPSBmYWxzZTtcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgaWYgKHRoaXMubG9vcEpvdXJuZXkpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnU3RhcnQoKTtcbiAgICAgICAgdGhpcy5oYW5kbGVEcmFnKHRoaXMucnVubmluZ0Jhci5vZmZzZXRXaWR0aCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ0VuZCgpO1xuICAgICAgICB0aGlzLmxvb3BKb3VybmV5ID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9vcExhc3RQb3NpdGlvblhQZXJjZW50YWdlID1cbiAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgLyB0aGlzLmxvb3BCYXIub2Zmc2V0V2lkdGg7XG5cbiAgICAgIGNvbnN0IHJ1bm5pbmdCYXJXaWR0aFBlcmNlbnRhZ2UgPVxuICAgICAgICAodGhpcy5ydW5uaW5nQmFyLm9mZnNldFdpZHRoIC8gdGhpcy5sb29wQmFyLm9mZnNldFdpZHRoKSAqIDEwMCArIFwiJVwiO1xuXG4gICAgICB0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCA9XG4gICAgICAgIChwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSAvIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGgpICpcbiAgICAgICAgICAxMDAgK1xuICAgICAgICBcIiVcIjtcblxuICAgICAgdGhpcy5sb29wQmFyLnN0eWxlLndpZHRoID1cbiAgICAgICAgKHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLndpZHRoKSAvIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGgpICpcbiAgICAgICAgICAxMDAgK1xuICAgICAgICBcIiVcIjtcblxuICAgICAgdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCA9IE1hdGgucm91bmQoXG4gICAgICAgICh0aGlzLmNsaXAuZHVyYXRpb24gKiBwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSkgLyAxMDBcbiAgICAgICk7XG5cbiAgICAgIHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChcbiAgICAgICAgKHRoaXMuY2xpcC5kdXJhdGlvbiAqXG4gICAgICAgICAgKChwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSB8fCAwKSArXG4gICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS53aWR0aCkpKSAvXG4gICAgICAgICAgMTAwXG4gICAgICApO1xuXG4gICAgICB0aGlzLnJ1bm5pbmdCYXIuc3R5bGUud2lkdGggPSBydW5uaW5nQmFyV2lkdGhQZXJjZW50YWdlO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcExvb3BTdGFydCwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvbk1vdXNlVXBMb29wU3RhcnQsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uQ3Vyc29yTW92ZUxvb3BTdGFydCwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25DdXJzb3JNb3ZlTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgICB0aGlzLmxvb3BCYXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbk1vdXNlRG93biwgZmFsc2UpO1xuICAgICAgdGhpcy5sb29wQmFyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICBvbk1vdXNlRG93bixcbiAgICAgICAge1xuICAgICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLnBsYXlBZnRlclJlc2l6ZSkge1xuICAgICAgICBpZiAodGhpcy5jbGlwLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICAgIGxldCBsb29wbXM7XG4gICAgICAgICAgaWYgKHRoaXMuY2xpcC5zcGVlZCA+PSAwKSB7XG4gICAgICAgICAgICBsb29wbXMgPSB0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kICsgMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9vcG1zID0gdGhpcy5sb29wRW5kTWlsbGlzZWNvbmQgLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmNsaXAuc3RvcCgpO1xuICAgICAgICAgIHRoaXMuam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLmNsaXApO1xuICAgICAgICAgIHRoaXMuam91cm5leS5zdGF0aW9uKGxvb3Btcyk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LmRlc3RpbmF0aW9uKCk7XG4gICAgICAgICAgdGhpcy5jbGlwLnBsYXkoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNsaXAuc3RhdGUgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICBsZXQgbG9vcG1zO1xuICAgICAgICAgIGlmICh0aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgICAgbG9vcG1zID0gdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb3BtcyA9IHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5jbGlwLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbihsb29wbXMpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jbGlwLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGxheUFmdGVyUmVzaXplID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duTG9vcFN0YXJ0ID0gZSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZUxvb3AgPSB0cnVlO1xuXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuY2xpcC5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgdGhpcy5jbGlwLndhaXQoKTtcbiAgICAgICAgdGhpcy5wbGF5QWZ0ZXJSZXNpemUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5sb29wQmFyLnN0eWxlLndpZHRoID0gdGhpcy5sb29wQmFyLm9mZnNldFdpZHRoICsgXCJweFwiO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubG9vcExhc3RQb3NpdGlvblhQeGxzIC1cbiAgICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSAqIHRoaXMubG9vcEJhci5vZmZzZXRXaWR0aCA+XG4gICAgICAgICAgMSB8fFxuICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSAqIHRoaXMubG9vcEJhci5vZmZzZXRXaWR0aCAtXG4gICAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgPlxuICAgICAgICAgIDFcbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA9XG4gICAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFBlcmNlbnRhZ2UgKiB0aGlzLmxvb3BCYXIub2Zmc2V0V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9vcEJhci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICB0aGlzLmxvb3BCYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgIG9uQ3Vyc29yTW92ZUxvb3BTdGFydChlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBvbk1vdXNlVXBMb29wU3RhcnQsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Nb3VzZVVwTG9vcFN0YXJ0LCBmYWxzZSk7XG4gICAgICBhZGRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbkN1cnNvck1vdmVMb29wU3RhcnQsIGZhbHNlKTtcbiAgICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIG9uQ3Vyc29yTW92ZUxvb3BTdGFydCwgZmFsc2UpO1xuICAgIH07XG5cbiAgICB0aGlzLmxvb3BCYXJTdGFydC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgIG9uTW91c2VEb3duTG9vcFN0YXJ0LFxuICAgICAgZmFsc2VcbiAgICApO1xuICAgIHRoaXMubG9vcEJhclN0YXJ0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgIG9uTW91c2VEb3duTG9vcFN0YXJ0LFxuICAgICAge1xuICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgY29uc3Qgb25DdXJzb3JNb3ZlTG9vcEVuZCA9IGUgPT4ge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBjb25zdCBjbGllbnRYID0gZS5jbGllbnRYIHx8ICgoZS50b3VjaGVzIHx8IFtdKVswXSB8fCB7fSkuY2xpZW50WDtcbiAgICAgIGNvbnN0IHZpZXdwb3J0T2Zmc2V0ID0gdGhpcy50b3RhbEJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGxldCBwb3NpdGlvblggPSBjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdDtcbiAgICAgIGlmIChwb3NpdGlvblggPCAwKSB7XG4gICAgICAgIHBvc2l0aW9uWCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uWCA+IHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGgpIHtcbiAgICAgICAgcG9zaXRpb25YID0gdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGggK1xuICAgICAgICAgIChwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSB8fCAwKSA+XG4gICAgICAgIHBvc2l0aW9uWFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9XG4gICAgICAgICAgcG9zaXRpb25YIC0gcGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCkgKyBcInB4XCI7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyAtIHBvc2l0aW9uWCA8IDApIHtcbiAgICAgICAgdGhpcy5sb29wQmFyLnN0eWxlLndpZHRoID1cbiAgICAgICAgICBNYXRoLmFicyh0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyAtIHBvc2l0aW9uWCkgKyBcInB4XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCA9IHBvc2l0aW9uWCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgPSBwb3NpdGlvblg7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld0xvb3BTdGFydE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChcbiAgICAgICAgKHRoaXMuY2xpcC5kdXJhdGlvbiAqIHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQpKSAvXG4gICAgICAgICAgdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aFxuICAgICAgKTtcbiAgICAgIGlmICh0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kID4gbmV3TG9vcFN0YXJ0TWlsbGlzZWNvbmQpIHtcbiAgICAgICAgdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCA9IG5ld0xvb3BTdGFydE1pbGxpc2Vjb25kO1xuICAgICAgICB0aGlzLmxvb3BKb3VybmV5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb29wRW5kTWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKFxuICAgICAgICAodGhpcy5jbGlwLmR1cmF0aW9uICpcbiAgICAgICAgICAoKHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQpIHx8IDApICtcbiAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLndpZHRoKSkpIC9cbiAgICAgICAgICB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoXG4gICAgICApO1xuXG4gICAgICBlbGlkKFwibWMtcGxheWVyLWxvb3BiYXItZW5kLXRpbWVcIikuaW5uZXJIVE1MID0gdGhpcy5sb29wRW5kTWlsbGlzZWNvbmQ7XG4gICAgICBlbGlkKFxuICAgICAgICBcIm1jLXBsYXllci1sb29wYmFyLXN0YXJ0LXRpbWVcIlxuICAgICAgKS5pbm5lckhUTUwgPSB0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlVXBMb29wRW5kID0gZSA9PiB7XG4gICAgICB0aGlzLnJlc2l6ZUxvb3AgPSBmYWxzZTtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMucnVubmluZ0Jhci5zdHlsZS53aWR0aCA9XG4gICAgICAgICh0aGlzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGggLyB0aGlzLmxvb3BCYXIub2Zmc2V0V2lkdGgpICogMTAwICsgXCIlXCI7XG5cbiAgICAgIHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0ID1cbiAgICAgICAgKChwYXJzZUZsb2F0KHRoaXMubG9vcEJhci5zdHlsZS5sZWZ0KSB8fCAwKSAvXG4gICAgICAgICAgdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aCkgKlxuICAgICAgICAgIDEwMCArXG4gICAgICAgIFwiJVwiO1xuXG4gICAgICB0aGlzLmxvb3BCYXIuc3R5bGUud2lkdGggPVxuICAgICAgICAocGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUud2lkdGgpIC8gdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aCkgKlxuICAgICAgICAgIDEwMCArXG4gICAgICAgIFwiJVwiO1xuXG4gICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSA9XG4gICAgICAgIHRoaXMubG9vcExhc3RQb3NpdGlvblhQeGxzIC8gdGhpcy5sb29wQmFyLm9mZnNldFdpZHRoO1xuXG4gICAgICB0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZChcbiAgICAgICAgKHRoaXMuY2xpcC5kdXJhdGlvbiAqIHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQpKSAvIDEwMFxuICAgICAgKTtcblxuICAgICAgdGhpcy5sb29wRW5kTWlsbGlzZWNvbmQgPSBNYXRoLnJvdW5kKFxuICAgICAgICAodGhpcy5jbGlwLmR1cmF0aW9uICpcbiAgICAgICAgICAoKHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLmxlZnQpIHx8IDApICtcbiAgICAgICAgICAgIHBhcnNlRmxvYXQodGhpcy5sb29wQmFyLnN0eWxlLndpZHRoKSkpIC9cbiAgICAgICAgICAxMDBcbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLmxvb3BKb3VybmV5KSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZ1N0YXJ0KCk7XG4gICAgICAgIHRoaXMuaGFuZGxlRHJhZyh0aGlzLnJ1bm5pbmdCYXIub2Zmc2V0V2lkdGgpO1xuICAgICAgICB0aGlzLmhhbmRsZURyYWdFbmQoKTtcbiAgICAgICAgdGhpcy5sb29wSm91cm5leSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uTW91c2VVcExvb3BFbmQsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUxpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Nb3VzZVVwTG9vcEVuZCwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgb25DdXJzb3JNb3ZlTG9vcEVuZCwgZmFsc2UpO1xuICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgb25DdXJzb3JNb3ZlTG9vcEVuZCwgZmFsc2UpO1xuICAgICAgdGhpcy5sb29wQmFyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgIHRoaXMubG9vcEJhci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNoc3RhcnRcIixcbiAgICAgICAgb25Nb3VzZURvd24sXG4gICAgICAgIHtcbiAgICAgICAgICBwYXNzaXZlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5wbGF5QWZ0ZXJSZXNpemUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xpcC5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgICAgICBsZXQgbG9vcG1zO1xuICAgICAgICAgIGlmICh0aGlzLmNsaXAuc3BlZWQgPj0gMCkge1xuICAgICAgICAgICAgbG9vcG1zID0gdGhpcy5sb29wU3RhcnRNaWxsaXNlY29uZCArIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxvb3BtcyA9IHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kIC0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5jbGlwLnN0b3AoKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkgPSB0aW1lQ2Fwc3VsZS5zdGFydEpvdXJuZXkodGhpcy5jbGlwKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuc3RhdGlvbihsb29wbXMpO1xuICAgICAgICAgIHRoaXMuam91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICAgIHRoaXMuY2xpcC5wbGF5KCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jbGlwLnN0YXRlID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgbGV0IGxvb3BtcztcbiAgICAgICAgICBpZiAodGhpcy5jbGlwLnNwZWVkID49IDApIHtcbiAgICAgICAgICAgIGxvb3BtcyA9IHRoaXMubG9vcFN0YXJ0TWlsbGlzZWNvbmQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb29wbXMgPSB0aGlzLmxvb3BFbmRNaWxsaXNlY29uZCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuY2xpcC5zdG9wKCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5ID0gdGltZUNhcHN1bGUuc3RhcnRKb3VybmV5KHRoaXMuY2xpcCk7XG4gICAgICAgICAgdGhpcy5qb3VybmV5LnN0YXRpb24obG9vcG1zKTtcbiAgICAgICAgICB0aGlzLmpvdXJuZXkuZGVzdGluYXRpb24oKTtcbiAgICAgICAgICB0aGlzLmNsaXAucGxheSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY2xpcC5yZXN1bWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBsYXlBZnRlclJlc2l6ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlRG93bkxvb3BFbmQgPSBlID0+IHtcbiAgICAgIHRoaXMucmVzaXplTG9vcCA9IHRydWU7XG4gICAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuY2xpcC5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgdGhpcy5jbGlwLndhaXQoKTtcbiAgICAgICAgdGhpcy5wbGF5QWZ0ZXJSZXNpemUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5ydW5uaW5nQmFyLnN0eWxlLndpZHRoID0gdGhpcy5ydW5uaW5nQmFyLm9mZnNldFdpZHRoICsgXCJweFwiO1xuXG4gICAgICB0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCA9XG4gICAgICAgICgocGFyc2VGbG9hdCh0aGlzLmxvb3BCYXIuc3R5bGUubGVmdCkgfHwgMCkgLyAxMDApICpcbiAgICAgICAgICB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoICtcbiAgICAgICAgXCJweFwiO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMubG9vcExhc3RQb3NpdGlvblhQeGxzIC1cbiAgICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSAqIHRoaXMubG9vcEJhci5vZmZzZXRXaWR0aCA+XG4gICAgICAgICAgMSB8fFxuICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUGVyY2VudGFnZSAqIHRoaXMubG9vcEJhci5vZmZzZXRXaWR0aCAtXG4gICAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHMgPlxuICAgICAgICAgIDFcbiAgICAgICkge1xuICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA9XG4gICAgICAgICAgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFBlcmNlbnRhZ2UgKiB0aGlzLmxvb3BCYXIub2Zmc2V0V2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubG9vcEJhci5zdHlsZS53aWR0aCA9IHRoaXMubG9vcEJhci5vZmZzZXRXaWR0aCArIFwicHhcIjtcbiAgICAgIHRoaXMubG9vcEJhci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duLCBmYWxzZSk7XG4gICAgICB0aGlzLmxvb3BCYXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgb25Nb3VzZURvd24sIGZhbHNlKTtcbiAgICAgIG9uQ3Vyc29yTW92ZUxvb3BFbmQoZSk7XG4gICAgICBhZGRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Nb3VzZVVwTG9vcEVuZCwgZmFsc2UpO1xuICAgICAgYWRkTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBvbk1vdXNlVXBMb29wRW5kLCBmYWxzZSk7XG4gICAgICBhZGRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbkN1cnNvck1vdmVMb29wRW5kLCBmYWxzZSk7XG4gICAgICBhZGRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBvbkN1cnNvck1vdmVMb29wRW5kLCBmYWxzZSk7XG4gICAgfTtcblxuICAgIHRoaXMubG9vcEJhckVuZC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIG9uTW91c2VEb3duTG9vcEVuZCwgZmFsc2UpO1xuICAgIHRoaXMubG9vcEJhckVuZC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICBvbk1vdXNlRG93bkxvb3BFbmQsXG4gICAgICB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0sXG4gICAgICBmYWxzZVxuICAgICk7XG5cbiAgICAvLyBvbmx5IG9uIGRlc2N0b3AgZGV2aWNlc1xuICAgIGlmIChcbiAgICAgICEvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gICAgICAgIG5hdmlnYXRvci51c2VyQWdlbnRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIGNvbnN0IGxvb3BCYXJNb3VzZUluT3V0ID0gKCkgPT4ge1xuICAgICAgICBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIikuY2xhc3NMaXN0LnRvZ2dsZShcIm0tZmFkZU91dFwiKTtcbiAgICAgICAgZWxpZChcIm1jLXBsYXllci1ob3Zlci1kaXNwbGF5XCIpLmNsYXNzTGlzdC50b2dnbGUoXCJtLWZhZGVJblwiKTtcblxuICAgICAgICBpZiAoZWxpZChcIm1jLXBsYXllci1ob3Zlci1kaXNwbGF5XCIpLmNsYXNzTmFtZS5pbmNsdWRlcyhcIm0tZmFkZUluXCIpKSB7XG4gICAgICAgICAgdGhpcy5ob3ZlckpvdXJuZXkgPSBob3ZlclRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLnByZXZpZXdDbGlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmhvdmVySm91cm5leS5kZXN0aW5hdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9vcEJhci5vbm1vdXNlbW92ZSA9IGxvb3BCYXJNb3VzZU1vdmU7XG4gICAgICB9O1xuICAgICAgY29uc3QgbG9vcEJhckFkZExpc3RlbmVycyA9ICgpID0+IHtcbiAgICAgICAgbG9vcEJhck1vdXNlSW5PdXQoKTtcbiAgICAgICAgdGhpcy5sb29wQmFyLm9ubW91c2VvdmVyID0gdGhpcy5sb29wQmFyLm9ubW91c2VvdXQgPSBsb29wQmFyTW91c2VJbk91dDtcbiAgICAgICAgdGhpcy5sb29wQmFyLm9ubW91c2Vtb3ZlID0gbG9vcEJhck1vdXNlTW92ZTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZXVwXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBsb29wQmFyQWRkTGlzdGVuZXJzLCBmYWxzZSk7XG4gICAgICAgIHJlbW92ZUxpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5sb29wQmFyLm9ubW91c2VvdmVyID0gdGhpcy5sb29wQmFyLm9ubW91c2VvdXQgPSBsb29wQmFyTW91c2VJbk91dDtcblxuICAgICAgdGhpcy5sb29wQmFyLm9ubW91c2Vkb3duID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxvb3BCYXIub25tb3VzZW92ZXIgPSB0aGlzLmxvb3BCYXIub25tb3VzZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMubG9vcEJhci5vbm1vdXNlbW92ZSA9IG51bGw7XG4gICAgICAgIGFkZExpc3RlbmVyKFwibW91c2V1cFwiLCBsb29wQmFyQWRkTGlzdGVuZXJzLCBmYWxzZSk7XG4gICAgICAgIGFkZExpc3RlbmVyKFwidG91Y2hlbmRcIiwgbG9vcEJhckFkZExpc3RlbmVycywgZmFsc2UpO1xuICAgICAgICBhZGRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBsb29wQmFyTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIGFkZExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIGxvb3BCYXJNb3VzZU1vdmUsIGZhbHNlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmxvb3BCYXIub25tb3VzZXVwID0gKCkgPT4ge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihcIm1vdXNldXBcIiwgbG9vcEJhckFkZExpc3RlbmVycywgZmFsc2UpO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNoZW5kXCIsIGxvb3BCYXJBZGRMaXN0ZW5lcnMsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbG9vcEJhck1vdXNlTW92ZSwgZmFsc2UpO1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBsb29wQmFyTW91c2VNb3ZlLCBmYWxzZSk7XG4gICAgICAgIHRoaXMubG9vcEJhci5vbm1vdXNlb3ZlciA9IHRoaXMubG9vcEJhci5vbm1vdXNlb3V0ID0gbG9vcEJhck1vdXNlSW5PdXQ7XG4gICAgICAgIHRoaXMubG9vcEJhci5vbm1vdXNlbW92ZSA9IGxvb3BCYXJNb3VzZU1vdmU7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBsb29wQmFyTW91c2VNb3ZlID0gZSA9PiB7XG4gICAgICAgIGNvbnN0IGNsaWVudFggPSBlLmNsaWVudFg7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0T2Zmc2V0ID0gdGhpcy5sb29wQmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgY2xpZW50WCAtIHZpZXdwb3J0T2Zmc2V0LmxlZnQgKyB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyA+XG4gICAgICAgICAgICB0aGlzLmxvb3BMYXN0UG9zaXRpb25YUHhscyArIHRoaXMubG9vcEJhci5vZmZzZXRXaWR0aCAmJlxuICAgICAgICAgICF0aGlzLnJlc2l6ZUxvb3BcbiAgICAgICAgKSB7XG4gICAgICAgICAgZWxpZChcbiAgICAgICAgICAgIFwibWMtcGxheWVyLWhvdmVyLW1pbGxpc2Vjb25kXCJcbiAgICAgICAgICApLmlubmVySFRNTCA9IHRoaXMubG9vcEVuZE1pbGxpc2Vjb25kO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGllbnRYIC0gdmlld3BvcnRPZmZzZXQubGVmdCA8IDAgJiYgIXRoaXMucmVzaXplTG9vcCkge1xuICAgICAgICAgIGVsaWQoXG4gICAgICAgICAgICBcIm1jLXBsYXllci1ob3Zlci1taWxsaXNlY29uZFwiXG4gICAgICAgICAgKS5pbm5lckhUTUwgPSB0aGlzLmxvb3BTdGFydE1pbGxpc2Vjb25kO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBwb3NpdGlvblggPVxuICAgICAgICAgIGNsaWVudFggLSB2aWV3cG9ydE9mZnNldC5sZWZ0ICsgdGhpcy5sb29wTGFzdFBvc2l0aW9uWFB4bHM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uWCA8IDApIHtcbiAgICAgICAgICBwb3NpdGlvblggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGxlZnQgPSBwb3NpdGlvblggLSBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIikub2Zmc2V0V2lkdGggLyAyO1xuXG4gICAgICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgICAgIGxlZnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGxlZnQgKyBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIikub2Zmc2V0V2lkdGggPlxuICAgICAgICAgIHRoaXMudG90YWxCYXIub2Zmc2V0V2lkdGhcbiAgICAgICAgKSB7XG4gICAgICAgICAgbGVmdCA9XG4gICAgICAgICAgICB0aGlzLnRvdGFsQmFyLm9mZnNldFdpZHRoIC1cbiAgICAgICAgICAgIGVsaWQoXCJtYy1wbGF5ZXItaG92ZXItZGlzcGxheVwiKS5vZmZzZXRXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1zID0gTWF0aC5yb3VuZChcbiAgICAgICAgICAocG9zaXRpb25YIC8gdGhpcy50b3RhbEJhci5vZmZzZXRXaWR0aCkgKiB0aGlzLmNsaXAuZHVyYXRpb25cbiAgICAgICAgKTtcblxuICAgICAgICB0aGlzLmhvdmVySm91cm5leS5zdGF0aW9uKG1zKTtcblxuICAgICAgICBlbGlkKFwibWMtcGxheWVyLWhvdmVyLW1pbGxpc2Vjb25kXCIpLmlubmVySFRNTCA9IG1zO1xuICAgICAgICBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIikuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGVsKFwiYm9keVwiKVswXS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZSA9PiB7XG4gICAgICBpZiAoZS50YXJnZXQuY2xhc3NOYW1lID09PSBcIm1jLXBsYXllci1zcGVlZC12YWx1ZVwiKSB7XG4gICAgICAgIGxldCBzcGVlZERpc3BsYXkgPSBlLnRhcmdldC5kYXRhc2V0LnNwZWVkVmFsdWUgLSAwO1xuICAgICAgICB0aGlzLmNsaXAuZXhlY3V0aW9uU3BlZWQgPSBlLnRhcmdldC5kYXRhc2V0LnNwZWVkVmFsdWU7XG4gICAgICAgIHRoaXMuY2xpcC5zcGVlZCA9PSAxXG4gICAgICAgICAgPyAoc3BlZWREaXNwbGF5ID0gXCJOb3JtYWxcIilcbiAgICAgICAgICA6IChzcGVlZERpc3BsYXkgPSB0aGlzLmNsaXAuc3BlZWQpO1xuICAgICAgICB0aGlzLnNwZWVkQ3VycmVudC5pbm5lckhUTUwgPSBzcGVlZERpc3BsYXk7XG5cbiAgICAgICAgY29uc3Qgc3RlcCA9IDEgLyAodGhpcy5zcGVlZFZhbHVlcy5sZW5ndGggLSAxKTtcblxuICAgICAgICBjb25zdCBwb3NpdGlvblkgPSAoZS50YXJnZXQuZGF0YXNldC56b25lICogc3RlcCAtIDEpICogLTEgKiAxMjguNTtcblxuICAgICAgICBlbGlkKFwibWMtcGxheWVyLXNwZWVkLWN1cnNvclwiKS5zdHlsZS50b3AgPSBwb3NpdGlvblkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2FsY3VsYXRlU3BlZWQoc3RlcCwgYXJyYXlPZlZhbHVlcywgY3VycmVudFBlcmNlbnRhZ2UpIHtcbiAgICBjb25zdCBib3RMaW1pdEluZGV4ID0gTWF0aC5mbG9vcihjdXJyZW50UGVyY2VudGFnZSAvIHN0ZXApO1xuXG4gICAgaWYgKGJvdExpbWl0SW5kZXggPT09IGFycmF5T2ZWYWx1ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIGFycmF5T2ZWYWx1ZXNbYm90TGltaXRJbmRleF0udG9GaXhlZCgxKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaW1pdFpvbmVQZXJjZW50YWdlID0gKGN1cnJlbnRQZXJjZW50YWdlIC8gc3RlcCkgJSAxO1xuXG4gICAgY29uc3QgbGltaXRab25lTGVuZ3RoID0gTWF0aC5hYnMoXG4gICAgICBhcnJheU9mVmFsdWVzW2JvdExpbWl0SW5kZXhdIC0gYXJyYXlPZlZhbHVlc1tib3RMaW1pdEluZGV4ICsgMV1cbiAgICApO1xuXG4gICAgY29uc3QgcmVhbFpvbmVTcGVlZCA9IGxpbWl0Wm9uZVBlcmNlbnRhZ2UgKiBsaW1pdFpvbmVMZW5ndGg7XG5cbiAgICBjb25zdCByZWFsU3BlZWQgPSAocmVhbFpvbmVTcGVlZCArIGFycmF5T2ZWYWx1ZXNbYm90TGltaXRJbmRleF0pLnRvRml4ZWQoMSk7XG5cbiAgICBpZiAocmVhbFNwZWVkID09IDApIHtcbiAgICAgIHJldHVybiBcIjAuMFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVhbFNwZWVkO1xuICB9XG5cbiAgbGF1bmNoSW50b0Z1bGxzY3JlZW4oZWxlbWVudCkge1xuICAgIHRoaXMubWNQbGF5ZXIuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuICAgIGlmIChlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBlbGVtZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKSB7XG4gICAgICBlbGVtZW50Lm1velJlcXVlc3RGdWxsU2NyZWVuKCk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKSB7XG4gICAgICBlbGVtZW50LndlYmtpdFJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50Lm1zUmVxdWVzdEZ1bGxzY3JlZW4pIHtcbiAgICAgIGVsZW1lbnQubXNSZXF1ZXN0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfVxuXG4gIGV4aXRGdWxsc2NyZWVuKCkge1xuICAgIHRoaXMubWNQbGF5ZXIuY2xhc3NMaXN0LnRvZ2dsZShcImZ1bGwtc2NyZWVuXCIpO1xuICAgIGlmIChkb2N1bWVudC5leGl0RnVsbHNjcmVlbikge1xuICAgICAgZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4pIHtcbiAgICAgIGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW4oKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LndlYmtpdEV4aXRGdWxsc2NyZWVuKSB7XG4gICAgICBkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbigpO1xuICAgIH1cbiAgfVxuXG4gIHNldFRoZW1lKCkge1xuICAgIC8vIHJlcGxhY2UgbXVsdGlwbGUgc3BhY2VzIHdpdGggb25lIHNwYWNlXG4gICAgdGhpcy50aGVtZS5yZXBsYWNlKC9cXHNcXHMrL2csIFwiIFwiKTtcbiAgICB0aGlzLnRoZW1lLnRyaW0oKTtcblxuICAgIGlmIChcbiAgICAgICF0aGlzLnRoZW1lLmluY2x1ZGVzKFwib24tdG9wXCIpICYmXG4gICAgICAhdGhpcy50aGVtZS5pbmNsdWRlcyhcInBvc2l0aW9uLWRlZmF1bHRcIilcbiAgICApIHtcbiAgICAgIHRoaXMudGhlbWUgKz0gXCIgcG9zaXRpb24tZGVmYXVsdFwiO1xuICAgIH1cblxuICAgIGNvbnN0IHRoZW1lID0ge307XG4gICAgZm9yIChjb25zdCBpIGluIHRoaXMudGhlbWUuc3BsaXQoXCIgXCIpKSB7XG4gICAgICBjb25zdCBjb25mVGhlbWUgPSBjb25mVGhlbWVzKHRoaXMudGhlbWUuc3BsaXQoXCIgXCIpW2ldKTtcbiAgICAgIGZvciAoY29uc3QgcSBpbiBjb25mVGhlbWUgfHwge30pIHtcbiAgICAgICAgdGhlbWVbcV0gPSBjb25mVGhlbWVbcV07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNzcyA9IGNvbmZTdHlsZSh0aGVtZSk7XG5cbiAgICBjb25zdCBzdHlsZSA9IGVsY3JlYXRlKFwic3R5bGVcIik7XG5cbiAgICBzdHlsZS5zdHlsZVNoZWV0XG4gICAgICA/IChzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3MpXG4gICAgICA6IHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXG4gICAgLy8gYXBwZW5kIHBsYXllciBzdHlsZSB0byBkb2N1bWVudFxuICAgIGVsdGFnKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gIH1cblxuICBzZXRTcGVlZCgpIHtcbiAgICBsZXQgY3VycmVudFNwZWVkO1xuICAgIHRoaXMuY2xpcC5zcGVlZCA9PSAxXG4gICAgICA/IChjdXJyZW50U3BlZWQgPSBcIk5vcm1hbFwiKVxuICAgICAgOiAoY3VycmVudFNwZWVkID0gdGhpcy5jbGlwLnNwZWVkKTtcbiAgICB0aGlzLnNwZWVkQ3VycmVudC5pbm5lckhUTUwgPSBjdXJyZW50U3BlZWQ7XG5cbiAgICBjb25zdCB0YXJnZXRab25lID0gKCgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zcGVlZFZhbHVlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHRoaXMuc3BlZWRWYWx1ZXNbaV0gPD0gdGhpcy5jbGlwLnNwZWVkICYmXG4gICAgICAgICAgdGhpcy5zcGVlZFZhbHVlc1tpICsgMV0gPiB0aGlzLmNsaXAuc3BlZWRcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGkgK1xuICAgICAgICAgICAgTWF0aC5hYnMoXG4gICAgICAgICAgICAgICh0aGlzLmNsaXAuc3BlZWQgLSB0aGlzLnNwZWVkVmFsdWVzW2ldKSAvXG4gICAgICAgICAgICAgICAgKHRoaXMuc3BlZWRWYWx1ZXNbaV0gLSB0aGlzLnNwZWVkVmFsdWVzW2kgKyAxXSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoKTtcblxuICAgIGNvbnN0IHN0ZXAgPSAxIC8gODtcblxuICAgIGNvbnN0IHBvc2l0aW9uWSA9ICh0YXJnZXRab25lICogc3RlcCAtIDEpICogLTEgKiAxMjguNTtcblxuICAgIGVsaWQoXCJtYy1wbGF5ZXItc3BlZWQtY3Vyc29yXCIpLnN0eWxlLnRvcCA9IHBvc2l0aW9uWSArIFwicHhcIjtcbiAgfVxuXG4gIGNyZWF0ZUhvdmVyRGlzcGxheSgpIHtcbiAgICBjb25zdCBjbGlwID0gdGhpcy5jbGlwLnByb3BzLmhvc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIilbMF07XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5jbGlwLmV4cG9ydFN0YXRlKHsgdW5wcm9jZXNzZWQ6IHRydWUgfSk7XG5cbiAgICBkZWZpbml0aW9uLnByb3BzLmhvc3QgPSBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIik7XG4gICAgdGhpcy5wcmV2aWV3Q2xpcCA9IE1DLkNsaXBGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uICx0aGlzLmNsaXBDbGFzcyk7XG4gICAgY29uc29sZS5sb2coXCJhc2Rmc2FkZmRzYWZzYWRcIix0aGlzLmNsaXAsIHRoaXMucHJldmlld0NsaXApXG5cbiAgICBjb25zdCBwcmV2aWV3Q2xpcCA9IHRoaXMucHJldmlld0NsaXAucHJvcHMuaG9zdC5nZXRFbGVtZW50c0J5VGFnTmFtZShcbiAgICAgIFwiaWZyYW1lXCJcbiAgICApWzBdO1xuXG4gICAgcHJldmlld0NsaXAuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cbiAgICBwcmV2aWV3Q2xpcC5zdHlsZS56SW5kZXggPSAxO1xuXG4gICAgY29uc3QgY2xpcFdpZHRoID0gY2xpcC5vZmZzZXRXaWR0aDtcblxuICAgIGNvbnN0IGNsaXBIZWlnaHQgPSBjbGlwLm9mZnNldEhlaWdodDtcblxuICAgIGNvbnN0IHByZXZpZXdSYXRpbyA9IDAuMjUzMTI1O1xuXG4gICAgbGV0IHByZXZpZXdXaWR0aCA9IE1hdGgucm91bmQoY2xpcFdpZHRoICogcHJldmlld1JhdGlvKTtcblxuICAgIC8vIG1heCB3aWR0aCBpcyAzMDBcbiAgICBpZiAoXG4gICAgICBwcmV2aWV3V2lkdGggPiBwYXJzZUZsb2F0KGVsaWQoXCJtYy1wbGF5ZXItaG92ZXItZGlzcGxheVwiKS5zdHlsZS5tYXhXaWR0aClcbiAgICApIHtcbiAgICAgIHByZXZpZXdXaWR0aCA9IHBhcnNlRmxvYXQoZWxpZChcIm1jLXBsYXllci1ob3Zlci1kaXNwbGF5XCIpLnN0eWxlLm1heFdpZHRoKTtcbiAgICB9XG5cbiAgICBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIikuc3R5bGUud2lkdGggPSBwcmV2aWV3V2lkdGggKyBcInB4XCI7XG5cbiAgICBjb25zdCBwcmV2aWV3SGVpZ2h0ID0gTWF0aC5yb3VuZChcbiAgICAgIChjbGlwSGVpZ2h0IC8gY2xpcFdpZHRoKSAqIHByZXZpZXdXaWR0aFxuICAgICk7XG5cbiAgICBlbGlkKFwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIikuc3R5bGUuaGVpZ2h0ID0gcHJldmlld0hlaWdodCArIFwicHhcIjtcblxuICAgIGNvbnN0IHNjYWxlWSA9IHByZXZpZXdIZWlnaHQgLyBjbGlwSGVpZ2h0O1xuICAgIGNvbnN0IHNjYWxlWCA9IHByZXZpZXdXaWR0aCAvIGNsaXBXaWR0aDtcblxuICAgIHByZXZpZXdDbGlwLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3NjYWxlWH0sJHtzY2FsZVl9KWA7XG4gICAgcHJldmlld0NsaXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luPVwiY2VudGVyIGJvdHRvbVwiO1xuXG4gICAgLy8gY2hlY2sgaWYgd2lkdGggb2YgaWZyYW1lIGlzIHBlcmNlbnRhZ2VcbiAgICBpZiAodGhpcy5jbGlwLnByb3BzLmNvbnRhaW5lclBhcmFtcy53aWR0aC5pbmNsdWRlcyhcIiVcIikpe1xuICAgICAgcHJldmlld0NsaXAuc3R5bGUud2lkdGggPSBcbiAgICAgICAgMTAwICsgXG4gICAgICAgICgxMDAgKiBwcmV2aWV3UmF0aW8pICtcbiAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmNsaXAucHJvcHMuY29udGFpbmVyUGFyYW1zLndpZHRoKS9wcmV2aWV3UmF0aW8gKyBcIiVcIjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5jbGlwLnByb3BzLmNvbnRhaW5lclBhcmFtcy5oZWlnaHQuaW5jbHVkZXMoXCIlXCIpKXtcbiAgICAgIHByZXZpZXdDbGlwLnN0eWxlLmhlaWdodCA9IFxuICAgICAgICAxMDAgKyBcbiAgICAgICAgKDEwMCAqIHByZXZpZXdSYXRpbykgK1xuICAgICAgICBwYXJzZUZsb2F0KHRoaXMuY2xpcC5wcm9wcy5jb250YWluZXJQYXJhbXMuaGVpZ2h0KS9wcmV2aWV3UmF0aW8gKyBcIiVcIjtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZWwgPSBzZWxlY3RvciA9PiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbmNvbnN0IGVsaWQgPSBpZCA9PiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5jb25zdCBlbHRhZyA9IHRhZyA9PiBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWcpO1xuY29uc3QgZWxjcmVhdGUgPSB0YWcgPT4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuY29uc3QgYWRkTGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoLi4uYXJndW1lbnRzKTtcbn07XG5jb25zdCByZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciguLi5hcmd1bWVudHMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQbGF5ZXI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUlBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBSUE7QUFEQTtBQUNBO0FBS0E7QUFDQTtBQUdBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFNQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFHQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUlBO0FBREE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUtBO0FBQ0E7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFRQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQURBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBR0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7Ozs7OztBQUdBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/Player.js\n");

/***/ }),

/***/ "../src/playerHTML.js":
/*!****************************!*\
  !*** ../src/playerHTML.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (config) {\n  return \"\\n  <div class=\\\"grad\\\"></div>\\n  <div class=\\\"background\\\"></div>\\n  <div id=\\\"mc-player-controls\\\">\\n    <div id=\\\"mc-player-totalbar\\\">\\n      <div id=\\\"mc-player-hover-display\\\">\\n        <div id=\\\"mc-player-hover-millisecond\\\"></div>\\n      </div>\\n      <div id=\\\"mc-player-loopbar\\\">\\n        <div class=\\\"mc-player-loop-boundaries\\\" id=\\\"mc-player-loopbar-start\\\">\\n        </div>\\n        <div class=\\\"mc-player-loop-boundaries\\\" id=\\\"mc-player-loopbar-end\\\">\\n        </div>\\n        <div id=\\\"mc-player-helperbar\\\"></div>\\n        <div id=\\\"mc-player-runningbar\\\">\\n          <div id=\\\"mc-player-cursor\\\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div id=\\\"mc-player-status-btn\\\">\\n      \" + config.svg.playSVG + \"\\n      <span id=\\\"mc-player-indicator\\\"></span>\\n    </div>\\n    <div id=\\\"mc-player-time-display\\\">\\n      <span id=\\\"mc-player-time-current\\\"></span>\\n      <span id=\\\"mc-player-time-separator\\\"></span>\\n      <span id=\\\"mc-player-time-total\\\"></span>\\n    </div>\\n    <div id=\\\"mc-player-loop-time\\\">\\n      <span id=\\\"mc-player-loopbar-start-time\\\" class=\\\"mc-player-loopbar-time\\\"></span>\\n      <span>:</span>\\n      <span id=\\\"mc-player-loopbar-end-time\\\" class=\\\"mc-player-loopbar-time\\\"></span>\\n    </div>\\n    <div id=\\\"mc-player-loop-btn\\\">\" + config.svg.loopSVG + \"</div>\\n    <div id=\\\"mc-player-settings-btn\\\">\" + config.svg.settingsSVG + \"</div>\\n    <div id=\\\"mc-player-full-screen-btn\\\">\" + config.svg.fullScreenSVG + \"</div>\\n  </div>\\n  <div id=\\\"mc-player-settings-panel\\\">\\n    <ul id=\\\"mc-player-main-settings\\\">\\n      <li id=\\\"mc-player-settings-indicator\\\">\\n        <label>Show Indicator</label>\\n        <label class=\\\"switch settings-switch\\\">\\n          <input id=\\\"mc-player-show-indicator-checkbox\\\" type=\\\"checkbox\\\">\\n          <span class=\\\"slider round\\\"></span>\\n        </label>\\n      </li>\\n      <li id=\\\"mc-player-settings-speed-show\\\">\\n        <label>Speed</label>\\n        <div class=\\\"mc-player-speed-btn\\\">\" + config.svg.arrowRightSVG + \"</div>\\n        <span id=\\\"mc-player-speed-current\\\"></span>\\n      </li>\\n    </ul>\\n    <ul id=\\\"mc-player-speed-settings\\\">\\n      <li id=\\\"mc-player-settings-speed-hide\\\">\\n        <div class=\\\"mc-player-speed-btn\\\">\" + config.svg.arrowLeftSVG + \"</div>\\n        <label id=mc-player-speed-runtime>Speed</label>\\n      </li>\\n      <li>\\n        <div id=\\\"mc-player-speed-value-helperbar\\\"></div>\\n        <div id=\\\"mc-player-speed-value-bar\\\">\\n          <div class=\\\"mc-player-speed-value-step\\\" id=\\\"mc-player-speed-cursor\\\">\\n            <div></div>\\n          </div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n          <div class=\\\"mc-player-speed-value-step\\\"></div>\\n        </div>\\n        <div id=\\\"mc-player-speed-value\\\">\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"4.0\\\" data-zone=\\\"8\\\">4</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"2.0\\\" data-zone=\\\"7\\\">2</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"1.0\\\" data-zone=\\\"6\\\">Normal</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"0.5\\\" data-zone=\\\"5\\\">0.5</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"0.0\\\" data-zone=\\\"4\\\">0</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"-0.5\\\" data-zone=\\\"3\\\">-0.5</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"-1.0\\\" data-zone=\\\"2\\\">-1</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"-2.0\\\" data-zone=\\\"1\\\">-2</div>\\n          <div class=\\\"mc-player-speed-value\\\" data-speed-value=\\\"-4.0\\\" data-zone=\\\"0\\\">-4</div>\\n        </div>\\n      </li>\\n    </ul>\\n  </div>\\n\";\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL3BsYXllckhUTUwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vc3JjL3BsYXllckhUTUwuanM/MDg2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGNvbmZpZyA9PiBgXG4gIDxkaXYgY2xhc3M9XCJncmFkXCI+PC9kaXY+XG4gIDxkaXYgY2xhc3M9XCJiYWNrZ3JvdW5kXCI+PC9kaXY+XG4gIDxkaXYgaWQ9XCJtYy1wbGF5ZXItY29udHJvbHNcIj5cbiAgICA8ZGl2IGlkPVwibWMtcGxheWVyLXRvdGFsYmFyXCI+XG4gICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLWhvdmVyLWRpc3BsYXlcIj5cbiAgICAgICAgPGRpdiBpZD1cIm1jLXBsYXllci1ob3Zlci1taWxsaXNlY29uZFwiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLWxvb3BiYXJcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1jLXBsYXllci1sb29wLWJvdW5kYXJpZXNcIiBpZD1cIm1jLXBsYXllci1sb29wYmFyLXN0YXJ0XCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLWxvb3AtYm91bmRhcmllc1wiIGlkPVwibWMtcGxheWVyLWxvb3BiYXItZW5kXCI+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLWhlbHBlcmJhclwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLXJ1bm5pbmdiYXJcIj5cbiAgICAgICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLWN1cnNvclwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxkaXYgaWQ9XCJtYy1wbGF5ZXItc3RhdHVzLWJ0blwiPlxuICAgICAgJHtjb25maWcuc3ZnLnBsYXlTVkd9XG4gICAgICA8c3BhbiBpZD1cIm1jLXBsYXllci1pbmRpY2F0b3JcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cIm1jLXBsYXllci10aW1lLWRpc3BsYXlcIj5cbiAgICAgIDxzcGFuIGlkPVwibWMtcGxheWVyLXRpbWUtY3VycmVudFwiPjwvc3Bhbj5cbiAgICAgIDxzcGFuIGlkPVwibWMtcGxheWVyLXRpbWUtc2VwYXJhdG9yXCI+PC9zcGFuPlxuICAgICAgPHNwYW4gaWQ9XCJtYy1wbGF5ZXItdGltZS10b3RhbFwiPjwvc3Bhbj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGlkPVwibWMtcGxheWVyLWxvb3AtdGltZVwiPlxuICAgICAgPHNwYW4gaWQ9XCJtYy1wbGF5ZXItbG9vcGJhci1zdGFydC10aW1lXCIgY2xhc3M9XCJtYy1wbGF5ZXItbG9vcGJhci10aW1lXCI+PC9zcGFuPlxuICAgICAgPHNwYW4+Ojwvc3Bhbj5cbiAgICAgIDxzcGFuIGlkPVwibWMtcGxheWVyLWxvb3BiYXItZW5kLXRpbWVcIiBjbGFzcz1cIm1jLXBsYXllci1sb29wYmFyLXRpbWVcIj48L3NwYW4+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBpZD1cIm1jLXBsYXllci1sb29wLWJ0blwiPiR7Y29uZmlnLnN2Zy5sb29wU1ZHfTwvZGl2PlxuICAgIDxkaXYgaWQ9XCJtYy1wbGF5ZXItc2V0dGluZ3MtYnRuXCI+JHtjb25maWcuc3ZnLnNldHRpbmdzU1ZHfTwvZGl2PlxuICAgIDxkaXYgaWQ9XCJtYy1wbGF5ZXItZnVsbC1zY3JlZW4tYnRuXCI+JHtjb25maWcuc3ZnLmZ1bGxTY3JlZW5TVkd9PC9kaXY+XG4gIDwvZGl2PlxuICA8ZGl2IGlkPVwibWMtcGxheWVyLXNldHRpbmdzLXBhbmVsXCI+XG4gICAgPHVsIGlkPVwibWMtcGxheWVyLW1haW4tc2V0dGluZ3NcIj5cbiAgICAgIDxsaSBpZD1cIm1jLXBsYXllci1zZXR0aW5ncy1pbmRpY2F0b3JcIj5cbiAgICAgICAgPGxhYmVsPlNob3cgSW5kaWNhdG9yPC9sYWJlbD5cbiAgICAgICAgPGxhYmVsIGNsYXNzPVwic3dpdGNoIHNldHRpbmdzLXN3aXRjaFwiPlxuICAgICAgICAgIDxpbnB1dCBpZD1cIm1jLXBsYXllci1zaG93LWluZGljYXRvci1jaGVja2JveFwiIHR5cGU9XCJjaGVja2JveFwiPlxuICAgICAgICAgIDxzcGFuIGNsYXNzPVwic2xpZGVyIHJvdW5kXCI+PC9zcGFuPlxuICAgICAgICA8L2xhYmVsPlxuICAgICAgPC9saT5cbiAgICAgIDxsaSBpZD1cIm1jLXBsYXllci1zZXR0aW5ncy1zcGVlZC1zaG93XCI+XG4gICAgICAgIDxsYWJlbD5TcGVlZDwvbGFiZWw+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtYnRuXCI+JHtjb25maWcuc3ZnLmFycm93UmlnaHRTVkd9PC9kaXY+XG4gICAgICAgIDxzcGFuIGlkPVwibWMtcGxheWVyLXNwZWVkLWN1cnJlbnRcIj48L3NwYW4+XG4gICAgICA8L2xpPlxuICAgIDwvdWw+XG4gICAgPHVsIGlkPVwibWMtcGxheWVyLXNwZWVkLXNldHRpbmdzXCI+XG4gICAgICA8bGkgaWQ9XCJtYy1wbGF5ZXItc2V0dGluZ3Mtc3BlZWQtaGlkZVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLWJ0blwiPiR7Y29uZmlnLnN2Zy5hcnJvd0xlZnRTVkd9PC9kaXY+XG4gICAgICAgIDxsYWJlbCBpZD1tYy1wbGF5ZXItc3BlZWQtcnVudGltZT5TcGVlZDwvbGFiZWw+XG4gICAgICA8L2xpPlxuICAgICAgPGxpPlxuICAgICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLWhlbHBlcmJhclwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGlkPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLWJhclwiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWUtc3RlcFwiIGlkPVwibWMtcGxheWVyLXNwZWVkLWN1cnNvclwiPlxuICAgICAgICAgICAgPGRpdj48L2Rpdj5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXBcIj48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgaWQ9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlXCIgZGF0YS1zcGVlZC12YWx1ZT1cIjQuMFwiIGRhdGEtem9uZT1cIjhcIj40PC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cIm1jLXBsYXllci1zcGVlZC12YWx1ZVwiIGRhdGEtc3BlZWQtdmFsdWU9XCIyLjBcIiBkYXRhLXpvbmU9XCI3XCI+MjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIiBkYXRhLXNwZWVkLXZhbHVlPVwiMS4wXCIgZGF0YS16b25lPVwiNlwiPk5vcm1hbDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIiBkYXRhLXNwZWVkLXZhbHVlPVwiMC41XCIgZGF0YS16b25lPVwiNVwiPjAuNTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIiBkYXRhLXNwZWVkLXZhbHVlPVwiMC4wXCIgZGF0YS16b25lPVwiNFwiPjA8L2Rpdj5cbiAgICAgICAgICA8ZGl2IGNsYXNzPVwibWMtcGxheWVyLXNwZWVkLXZhbHVlXCIgZGF0YS1zcGVlZC12YWx1ZT1cIi0wLjVcIiBkYXRhLXpvbmU9XCIzXCI+LTAuNTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIiBkYXRhLXNwZWVkLXZhbHVlPVwiLTEuMFwiIGRhdGEtem9uZT1cIjJcIj4tMTwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIiBkYXRhLXNwZWVkLXZhbHVlPVwiLTIuMFwiIGRhdGEtem9uZT1cIjFcIj4tMjwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJtYy1wbGF5ZXItc3BlZWQtdmFsdWVcIiBkYXRhLXNwZWVkLXZhbHVlPVwiLTQuMFwiIGRhdGEtem9uZT1cIjBcIj4tNDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbGk+XG4gICAgPC91bD5cbiAgPC9kaXY+XG5gO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQUE7QUFBQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../src/playerHTML.js\n");

/***/ }),

/***/ "../src/style.js":
/*!***********************!*\
  !*** ../src/style.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (theme) {\n  return \"\\n.background {\\n  background-color: black;\\n  width:100%;\\n  height:100%;\\n  position:absolute;\\n  top:0px;\\n  left:0px;\\n  z-index:-2000;\\n}\\n.full-screen #mc-player-controls {\\n  position:fixed;\\n  left:0px;\\n  bottom:0px;\\n}\\n\\n.full-screen #mc-player-settings-panel {\\n  position:fixed;\\n  bottom: 45px;\\n}\\n\\n.svg {\\n  fill: \" + theme[\"svg-color\"] + \";\\n  stroke: \" + theme[\"svg-color\"] + \";\\n}\\n\\n.svg-selected svg{\\n  fill: \" + theme[\"svg-selected-color\"] + \";\\n  stroke: \" + theme[\"svg-selected-color\"] + \";\\n}\\n#mc-player-hover-display{\\n    border: \" + theme[\"preview-border\"] + \";\\n    max-width:300px;\\n    display: flex;\\n    height: ;\\n    background-color: whitesmoke;\\n    position: absolute;\\n    bottom: 14px;\\n    left: 0px;\\n    align-items: flex-end;\\n    justify-content: center;\\n}\\n\\n#mc-player-hover-millisecond {\\n  background-color: \" + theme[\"hms-background-color\"] + \";\\n  padding:3px;\\n  height:18px;\\n  margin:0px;\\n  line-height:12px;\\n  font-size:10px;\\n  text-align: center;\\n  min-width:20px;\\n  max-width:100px;\\n  z-index:2;\\n}\\n#mc-player,\\n#mc-player ::before,\\n#mc-player ::after,\\n#mc-player div,\\n#mc-player p,\\n#mc-player span,\\n#mc-player ul,\\n#mc-player li {\\n  font-weight: 400;\\n  line-height: 1.9 !important;\\n  color: \" + theme[\"color\"] + \";\\n  font-family: \\\"Century Gothic\\\", CenturyGothic, AppleGothic, sans-serif;\\n  box-sizing:border-box;\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n}\\n#mc-player {\\n  line-height: 1.9;\\n  font-size: 12px;\\n  overflow:hidden;\\n  height: calc(100% + \" + theme[\"controls-position\"] + \");\\n  width:100%;\\n  position: absolute;\\n  top: 0px;\\n  left: 0px;\\n  \\n}\\n\\n#mc-player-settings-speed-hide {\\n  text-align:right;\\n}\\n\\n.grad {\\n  background-image: linear-gradient(\\n    rgba(100,100,100,00.01),\\n    rgba(100,100,100,00.02),\\n    rgba(100,100,100,00.03),\\n    rgba(100,100,100,0.04),\\n    rgba(100,100,100,0.05),\\n    rgba(0,0,0,0.06),\\n    rgba(0,0,0,0.07),\\n    rgba(0,0,0,0.08),\\n    rgba(0,0,0,0.09),\\n    rgba(0,0,0,0.1),\\n    rgba(0,0,0,0.2),\\n    rgba(0,0,0,0.3),\\n    rgba(0,0,0,0.4),\\n    rgba(0,0,0,0.4),\\n    rgba(0,0,0,0.5),\\n    rgba(0,0,0,0.6),\\n    rgba(0,0,0,0.7),\\n    rgba(0,0,0,0.8),\\n    rgba(0,0,0,0.9),\\n    rgba(0,0,0,1)\\n  );\\n  position:absolute;\\n  width:100%;\\n  height:\" + theme[\"grad-height\"] + \";\\n  left:0px;\\n  bottom:0px;\\n}\\n\\n#mc-player-controls {\\n  background-color: \" + theme[\"background-color\"] + \";\\n  border: \" + theme[\"controls-border\"] + \";\\n  position: absolute;\\n  bottom: \" + theme[\"controls-bottom\"] + \";\\n  left: 0px;\\n  width: 100%;\\n  height: 40px;\\n}\\n\\n#mc-player-totalbar {\\n  width: calc(100% - 20px);\\n  height: 5px;\\n  margin: 0px 10px 0px 10px;\\n  background-color: #505056;\\n  position: relative;\\n  top: 0px;\\n  left: 0px;\\n}\\n\\n#mc-player-loopbar {\\n  position: absolute;\\n  height: 100%;\\n  width: 100%;\\n  top: 0px;\\n  left: 0px;\\n  background-color: \" + theme[\"loopbar-color\"] + \";\\n}\\n\\n.mc-player-loop-boundaries {\\n  transform:translate(-50%,-37%);\\n  position:absolute;\\n  width:18px;\\n  background-color:\" + theme[\"loopbar-color\"] + \";\\n  height:18px;\\n  border-radius:10px;\\n  z-index:40;\\n}\\n\\n#mc-player-helperbar {\\n  position: absolute;\\n  height: 20px;\\n  top: -7px;\\n  left: 0px;\\n  right: 0px;\\n  z-index:2;\\n}\\n\\n#mc-player-runningbar {\\n  position: relative;\\n  width: 0px;\\n  max-width:100%;\\n  height: 100%;\\n  background-color: \" + theme[\"runningbar-color\"] + \";\\n}\\n\\n#mc-player-cursor {\\n  transform:translate(50%,-36%);\\n  right: 0px;\\n  top: 0px;\\n  width: 0px;\\n  height: 0px;\\n  position: absolute;\\n  background-color: \" + theme[\"cursor-color\"] + \";\\n  border-radius: 10px;\\n  z-index: 5;\\n}\\n\\n#mc-player-time-display {\\n  display: table;\\n  text-align: center;\\n  width: auto;\\n  height: 34px;\\n  position: absolute;\\n  left: 45px;\\n}\\n\\n#mc-player-time-display span {\\n  display: table-cell;\\n  vertical-align: middle;\\n}\\n\\n#mc-player-status-btn {\\n  opacity: \" + theme[\"button-opacity\"] + \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 40px;\\n  height: 25px;\\n  position: absolute;\\n  left: 0px;\\n  bottom: 0px;\\n  margin: 10px 5px 5px 5px;\\n  text-align: center;\\n  z-index:3;\\n}\\n\\n\\n.mc-player-loopbar-time {\\n  width:auto;\\n  height:12px;\\n  background-color:\" + theme[\"background-color\"] + \";\\n  line-height:10px;\\n  font-size:10px;\\n}\\n\\n#mc-player-loop-time { \\n  position:absolute;\\n  right:85px;\\n  bottom:5px;\\n}\\n\\n#mc-player-loop-btn {\\n  opacity: \" + theme[\"button-opacity\"] + \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 15px;\\n  height: 15px;\\n  position: absolute;\\n  right: 55px;\\n  bottom: 5px;\\n  margin: 10px 5px 5px 5px;\\n}\\n\\n#mc-player-settings-btn {\\n  opacity: \" + theme[\"button-opacity\"] + \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 15px;\\n  height: 15px;\\n  position: absolute;\\n  right: 30px;\\n  bottom: 5px;\\n  margin: 10px 5px 5px 5px;\\n}\\n\\n#mc-player-full-screen-btn {\\n  opacity: \" + theme[\"button-opacity\"] + \";\\n  background-repeat: no-repeat;\\n  background-size: 100% 100%;\\n  width: 15px;\\n  height: 15px;\\n  position: absolute;\\n  right: 5px;\\n  bottom: 5px;\\n  margin: 10px 5px 5px 5px;\\n}\\n\\n.mc-player-speed-btn {\\n  position: relative;\\n  opacity: \" + theme[\"button-opacity\"] + \";\\n  width: 10px;\\n  height: 10px;\\n  display: inline-block;\\n}\\n\\n#mc-player-settings-panel {\\n  box-sizing: border-box;\\n  position: absolute;\\n  background-color: \" + theme[\"settings-background-color\"] + \";\\n  bottom: \" + theme[\"settings-panel-bottom\"] + \";\\n  border: \" + theme[\"border\"] + \";\\n  right: 5px;\\n  width: 164px;\\n  height: 78px;\\n  padding: 5px;\\n  margin: 0px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#mc-player-speed-value-bar {\\n  position: relative;\\n  width: 5px;\\n  background-color: \" + theme[\"speedbar-color\"] + \";\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: 144px;\\n  float: left;\\n  margin-right:15px;\\n}\\n\\n#mc-player-speed-value-helperbar {\\n  position: absolute;\\n  width: 25px;\\n  height: 144px;\\n  float: left;\\n  left: -5px;\\n  z-index:10;\\n}\\n\\n\\n#mc-player-speed-value-bar:hover,\\n#mc-player-speed-value-helperbar {\\n  cursor: pointer;\\n}\\n\\n#mc-player-speed-cursor {\\n  position: absolute;\\n  background-color: \" + theme[\"speedbar-cursor-color\"] + \";\\n  top: 0px;\\n  left: 0px;\\n}\\n\\n#mc-player-speed-cursor div {\\n  position: absolute;\\n  background-color: \" + theme[\"speedbar-cursor-color\"] + \";\\n  left: -2.5px;\\n  top: -4px;\\n  width: 10px;\\n  height: 10px;\\n  border-radius: 5px;\\n}\\n\\n#mc-player-speed-cursor:hover {\\n  cursor: pointer;\\n}\\n\\n.mc-player-speed-value-step {\\n  width: 15px;\\n  background-color: \" + theme[\"speedbar-color\"] + \";\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: 2px;\\n  margin-top: 7px;\\n  margin-bottom: 7px;\\n  float: left;\\n}\\n\\n#mc-player-speed-value {\\n  display: inline-block;\\n  box-sizing: border-box;\\n  height: 144px;\\n  text-align: left;\\n}\\n\\n.mc-player-speed-value {\\n  box-sizing: border-box;\\n  height: 16px;\\n  font-size: 12px;\\n}\\n\\n#mc-player-indicator {\\n  font-size: 10px !important;\\n  position: relative;\\n  bottom: 15px;\\n  color: \" + theme[\"color\"] + \";\\n}\\n\\n#mc-player-settings-panel.mc-player-settings-speed-panel {\\n  overflow: hidden;\\n  width: 80px;\\n  height: 195px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#mc-player-settings-panel.mc-player-settings-speed-panel .mc-player-speed-btn {\\n  float: left;\\n}\\n\\n.mc-player-settings-speed-panel ul:first-child {\\n  text-align: right;\\n}\\n\\n#mc-player-speed-current {\\n  float: right;\\n  padding-right: 10px\\n}\\n\\n#mc-player-settings-panel .mc-player-speed-btn {\\n  float: right;\\n}\\n\\n#mc-player-settings-panel ul {\\n  width: 100%;\\n  margin: 0px;\\n  padding: 0px;\\n  overflow: hidden;\\n}\\n\\n#mc-player-settings-panel.mc-player-settings-speed-panel ul li {\\n  min-width: 70px;\\n}\\n\\n#mc-player-settings-panel ul li.no-hover:hover {\\n  background-color: transparent;\\n  cursor: default;\\n}\\n\\ndiv.mc-player-speed-value:hover {\\n  background-color: \" + theme[\"hover-color\"] + \";\\n  cursor: pointer;\\n}\\n\\n#mc-player-settings-panel ul li {\\n  position: relative;\\n  width: 100%;\\n  min-width: 154px;\\n  list-style-type: none;\\n  margin: 0px;\\n  padding: 5px;\\n}\\n\\n#mc-player-settings-panel ul li label {\\n  margin: 0px;\\n}\\n\\n.switch {\\n  position: relative;\\n  display: inline-block;\\n  width: 35px;\\n  height: 18px;\\n}\\n\\n.switch input {\\n  display: none;\\n}\\n\\n.settings-switch {\\n  float: right;\\n}\\n\\n.settings-switch:after {\\n  clear: both;\\n}\\n\\n.slider {\\n  position: absolute;\\n  cursor: pointer;\\n  top: 0;\\n  left: 0;\\n  right: 0;\\n  bottom: 0;\\n  background-color: \" + theme[\"slider-off-color\"] + \";\\n  -webkit-transition: .4s;\\n  transition: .4s;\\n}\\n\\n.slider:before {\\n  position: absolute;\\n  content: \\\"\\\";\\n  height: 16px;\\n  width: 16px;\\n  left: 1px;\\n  bottom: 1px;\\n  background-color: white;\\n  -webkit-transition: .4s;\\n  transition: .4s;\\n}\\n\\ninput:checked+.slider {\\n  background-color: \" + theme[\"slider-on-color\"] + \";\\n}\\n\\ninput:focus+.slider {\\n  box-shadow: 0 0 1px \" + theme[\"slider-on-color\"] + \";\\n}\\n\\ninput:checked+.slider:before {\\n  -webkit-transform: translateX(16px);\\n  -ms-transform: translateX(16px);\\n  transform: translateX(16px);\\n}\\n\\n\\n/* Rounded sliders */\\n\\n.slider.round {\\n  border-radius: 34px;\\n}\\n\\n.slider.round:before {\\n  border-radius: 50%;\\n}\\n\\n\\n.m-fadeOut {\\n  visibility: hidden;\\n  opacity: 0;\\n  transition: visibility 0s linear 300ms, opacity 300ms;\\n}\\n\\n.m-fadeIn {\\n  visibility: visible;\\n  opacity: 1;\\n  transition: visibility 0s linear 0s, opacity 300ms;\\n}\\n\\n#mc-player-settings-panel ul li:hover {\\n  background-color: \" + theme[\"hover-color\"] + \";\\n  cursor: pointer;\\n}\\n\\n#mc-player-settings-panel ul li label:hover {\\n  cursor: pointer;\\n}\\n\\n#mc-player-loopbar:hover {\\n  cursor: pointer;\\n}\\n\\n#mc-player-status-btn:hover {\\n  cursor: pointer;\\n}\\n\\n#mc-player-controls:active #mc-player-cursor,\\n#mc-player-controls:hover #mc-player-cursor  {\\n  width: 16px;\\n  height: 16px;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#mc-player-settings-speed:hover .mc-player-speed-btn {\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#mc-player-status-btn:hover {\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#mc-player-loop-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n#mc-player-settings-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\\n\\n#mc-player-full-screen-btn:hover {\\n  cursor: pointer;\\n  opacity: 1;\\n  -webkit-transition: all 0.3s ease;\\n  -moz-transition: all 0.3s ease;\\n  transition: all 0.3s ease;\\n}\";\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL3N0eWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uL3NyYy9zdHlsZS5qcz82ZWM3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gdGhlbWUgPT4gYFxuLmJhY2tncm91bmQge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcbiAgd2lkdGg6MTAwJTtcbiAgaGVpZ2h0OjEwMCU7XG4gIHBvc2l0aW9uOmFic29sdXRlO1xuICB0b3A6MHB4O1xuICBsZWZ0OjBweDtcbiAgei1pbmRleDotMjAwMDtcbn1cbi5mdWxsLXNjcmVlbiAjbWMtcGxheWVyLWNvbnRyb2xzIHtcbiAgcG9zaXRpb246Zml4ZWQ7XG4gIGxlZnQ6MHB4O1xuICBib3R0b206MHB4O1xufVxuXG4uZnVsbC1zY3JlZW4gI21jLXBsYXllci1zZXR0aW5ncy1wYW5lbCB7XG4gIHBvc2l0aW9uOmZpeGVkO1xuICBib3R0b206IDQ1cHg7XG59XG5cbi5zdmcge1xuICBmaWxsOiAke3RoZW1lW1wic3ZnLWNvbG9yXCJdfTtcbiAgc3Ryb2tlOiAke3RoZW1lW1wic3ZnLWNvbG9yXCJdfTtcbn1cblxuLnN2Zy1zZWxlY3RlZCBzdmd7XG4gIGZpbGw6ICR7dGhlbWVbXCJzdmctc2VsZWN0ZWQtY29sb3JcIl19O1xuICBzdHJva2U6ICR7dGhlbWVbXCJzdmctc2VsZWN0ZWQtY29sb3JcIl19O1xufVxuI21jLXBsYXllci1ob3Zlci1kaXNwbGF5e1xuICAgIGJvcmRlcjogJHt0aGVtZVtcInByZXZpZXctYm9yZGVyXCJdfTtcbiAgICBtYXgtd2lkdGg6MzAwcHg7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBoZWlnaHQ6IDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZXNtb2tlO1xuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDE0cHg7XG4gICAgbGVmdDogMHB4O1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbn1cblxuI21jLXBsYXllci1ob3Zlci1taWxsaXNlY29uZCB7XG4gIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbXCJobXMtYmFja2dyb3VuZC1jb2xvclwiXX07XG4gIHBhZGRpbmc6M3B4O1xuICBoZWlnaHQ6MThweDtcbiAgbWFyZ2luOjBweDtcbiAgbGluZS1oZWlnaHQ6MTJweDtcbiAgZm9udC1zaXplOjEwcHg7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgbWluLXdpZHRoOjIwcHg7XG4gIG1heC13aWR0aDoxMDBweDtcbiAgei1pbmRleDoyO1xufVxuI21jLXBsYXllcixcbiNtYy1wbGF5ZXIgOjpiZWZvcmUsXG4jbWMtcGxheWVyIDo6YWZ0ZXIsXG4jbWMtcGxheWVyIGRpdixcbiNtYy1wbGF5ZXIgcCxcbiNtYy1wbGF5ZXIgc3BhbixcbiNtYy1wbGF5ZXIgdWwsXG4jbWMtcGxheWVyIGxpIHtcbiAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgbGluZS1oZWlnaHQ6IDEuOSAhaW1wb3J0YW50O1xuICBjb2xvcjogJHt0aGVtZVtcImNvbG9yXCJdfTtcbiAgZm9udC1mYW1pbHk6IFwiQ2VudHVyeSBHb3RoaWNcIiwgQ2VudHVyeUdvdGhpYywgQXBwbGVHb3RoaWMsIHNhbnMtc2VyaWY7XG4gIGJveC1zaXppbmc6Ym9yZGVyLWJveDtcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gIHVzZXItc2VsZWN0OiBub25lO1xufVxuI21jLXBsYXllciB7XG4gIGxpbmUtaGVpZ2h0OiAxLjk7XG4gIGZvbnQtc2l6ZTogMTJweDtcbiAgb3ZlcmZsb3c6aGlkZGVuO1xuICBoZWlnaHQ6IGNhbGMoMTAwJSArICR7dGhlbWVbXCJjb250cm9scy1wb3NpdGlvblwiXX0pO1xuICB3aWR0aDoxMDAlO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogMHB4O1xuICBsZWZ0OiAwcHg7XG4gIFxufVxuXG4jbWMtcGxheWVyLXNldHRpbmdzLXNwZWVkLWhpZGUge1xuICB0ZXh0LWFsaWduOnJpZ2h0O1xufVxuXG4uZ3JhZCB7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAwLjAxKSxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAwLjAyKSxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAwLjAzKSxcbiAgICByZ2JhKDEwMCwxMDAsMTAwLDAuMDQpLFxuICAgIHJnYmEoMTAwLDEwMCwxMDAsMC4wNSksXG4gICAgcmdiYSgwLDAsMCwwLjA2KSxcbiAgICByZ2JhKDAsMCwwLDAuMDcpLFxuICAgIHJnYmEoMCwwLDAsMC4wOCksXG4gICAgcmdiYSgwLDAsMCwwLjA5KSxcbiAgICByZ2JhKDAsMCwwLDAuMSksXG4gICAgcmdiYSgwLDAsMCwwLjIpLFxuICAgIHJnYmEoMCwwLDAsMC4zKSxcbiAgICByZ2JhKDAsMCwwLDAuNCksXG4gICAgcmdiYSgwLDAsMCwwLjQpLFxuICAgIHJnYmEoMCwwLDAsMC41KSxcbiAgICByZ2JhKDAsMCwwLDAuNiksXG4gICAgcmdiYSgwLDAsMCwwLjcpLFxuICAgIHJnYmEoMCwwLDAsMC44KSxcbiAgICByZ2JhKDAsMCwwLDAuOSksXG4gICAgcmdiYSgwLDAsMCwxKVxuICApO1xuICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgd2lkdGg6MTAwJTtcbiAgaGVpZ2h0OiR7dGhlbWVbXCJncmFkLWhlaWdodFwiXX07XG4gIGxlZnQ6MHB4O1xuICBib3R0b206MHB4O1xufVxuXG4jbWMtcGxheWVyLWNvbnRyb2xzIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcImJhY2tncm91bmQtY29sb3JcIl19O1xuICBib3JkZXI6ICR7dGhlbWVbXCJjb250cm9scy1ib3JkZXJcIl19O1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGJvdHRvbTogJHt0aGVtZVtcImNvbnRyb2xzLWJvdHRvbVwiXX07XG4gIGxlZnQ6IDBweDtcbiAgd2lkdGg6IDEwMCU7XG4gIGhlaWdodDogNDBweDtcbn1cblxuI21jLXBsYXllci10b3RhbGJhciB7XG4gIHdpZHRoOiBjYWxjKDEwMCUgLSAyMHB4KTtcbiAgaGVpZ2h0OiA1cHg7XG4gIG1hcmdpbjogMHB4IDEwcHggMHB4IDEwcHg7XG4gIGJhY2tncm91bmQtY29sb3I6ICM1MDUwNTY7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgdG9wOiAwcHg7XG4gIGxlZnQ6IDBweDtcbn1cblxuI21jLXBsYXllci1sb29wYmFyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHdpZHRoOiAxMDAlO1xuICB0b3A6IDBweDtcbiAgbGVmdDogMHB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lW1wibG9vcGJhci1jb2xvclwiXX07XG59XG5cbi5tYy1wbGF5ZXItbG9vcC1ib3VuZGFyaWVzIHtcbiAgdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC0zNyUpO1xuICBwb3NpdGlvbjphYnNvbHV0ZTtcbiAgd2lkdGg6MThweDtcbiAgYmFja2dyb3VuZC1jb2xvcjoke3RoZW1lW1wibG9vcGJhci1jb2xvclwiXX07XG4gIGhlaWdodDoxOHB4O1xuICBib3JkZXItcmFkaXVzOjEwcHg7XG4gIHotaW5kZXg6NDA7XG59XG5cbiNtYy1wbGF5ZXItaGVscGVyYmFyIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBoZWlnaHQ6IDIwcHg7XG4gIHRvcDogLTdweDtcbiAgbGVmdDogMHB4O1xuICByaWdodDogMHB4O1xuICB6LWluZGV4OjI7XG59XG5cbiNtYy1wbGF5ZXItcnVubmluZ2JhciB7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgd2lkdGg6IDBweDtcbiAgbWF4LXdpZHRoOjEwMCU7XG4gIGhlaWdodDogMTAwJTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcInJ1bm5pbmdiYXItY29sb3JcIl19O1xufVxuXG4jbWMtcGxheWVyLWN1cnNvciB7XG4gIHRyYW5zZm9ybTp0cmFuc2xhdGUoNTAlLC0zNiUpO1xuICByaWdodDogMHB4O1xuICB0b3A6IDBweDtcbiAgd2lkdGg6IDBweDtcbiAgaGVpZ2h0OiAwcHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcImN1cnNvci1jb2xvclwiXX07XG4gIGJvcmRlci1yYWRpdXM6IDEwcHg7XG4gIHotaW5kZXg6IDU7XG59XG5cbiNtYy1wbGF5ZXItdGltZS1kaXNwbGF5IHtcbiAgZGlzcGxheTogdGFibGU7XG4gIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgd2lkdGg6IGF1dG87XG4gIGhlaWdodDogMzRweDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBsZWZ0OiA0NXB4O1xufVxuXG4jbWMtcGxheWVyLXRpbWUtZGlzcGxheSBzcGFuIHtcbiAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbn1cblxuI21jLXBsYXllci1zdGF0dXMtYnRuIHtcbiAgb3BhY2l0eTogJHt0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdfTtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XG4gIHdpZHRoOiA0MHB4O1xuICBoZWlnaHQ6IDI1cHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgbGVmdDogMHB4O1xuICBib3R0b206IDBweDtcbiAgbWFyZ2luOiAxMHB4IDVweCA1cHggNXB4O1xuICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gIHotaW5kZXg6Mztcbn1cblxuXG4ubWMtcGxheWVyLWxvb3BiYXItdGltZSB7XG4gIHdpZHRoOmF1dG87XG4gIGhlaWdodDoxMnB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiR7dGhlbWVbXCJiYWNrZ3JvdW5kLWNvbG9yXCJdfTtcbiAgbGluZS1oZWlnaHQ6MTBweDtcbiAgZm9udC1zaXplOjEwcHg7XG59XG5cbiNtYy1wbGF5ZXItbG9vcC10aW1lIHsgXG4gIHBvc2l0aW9uOmFic29sdXRlO1xuICByaWdodDo4NXB4O1xuICBib3R0b206NXB4O1xufVxuXG4jbWMtcGxheWVyLWxvb3AtYnRuIHtcbiAgb3BhY2l0eTogJHt0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdfTtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDU1cHg7XG4gIGJvdHRvbTogNXB4O1xuICBtYXJnaW46IDEwcHggNXB4IDVweCA1cHg7XG59XG5cbiNtYy1wbGF5ZXItc2V0dGluZ3MtYnRuIHtcbiAgb3BhY2l0eTogJHt0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdfTtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDMwcHg7XG4gIGJvdHRvbTogNXB4O1xuICBtYXJnaW46IDEwcHggNXB4IDVweCA1cHg7XG59XG5cbiNtYy1wbGF5ZXItZnVsbC1zY3JlZW4tYnRuIHtcbiAgb3BhY2l0eTogJHt0aGVtZVtcImJ1dHRvbi1vcGFjaXR5XCJdfTtcbiAgYmFja2dyb3VuZC1yZXBlYXQ6IG5vLXJlcGVhdDtcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlIDEwMCU7XG4gIHdpZHRoOiAxNXB4O1xuICBoZWlnaHQ6IDE1cHg7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgcmlnaHQ6IDVweDtcbiAgYm90dG9tOiA1cHg7XG4gIG1hcmdpbjogMTBweCA1cHggNXB4IDVweDtcbn1cblxuLm1jLXBsYXllci1zcGVlZC1idG4ge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIG9wYWNpdHk6ICR7dGhlbWVbXCJidXR0b24tb3BhY2l0eVwiXX07XG4gIHdpZHRoOiAxMHB4O1xuICBoZWlnaHQ6IDEwcHg7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbn1cblxuI21jLXBsYXllci1zZXR0aW5ncy1wYW5lbCB7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIl19O1xuICBib3R0b206ICR7dGhlbWVbXCJzZXR0aW5ncy1wYW5lbC1ib3R0b21cIl19O1xuICBib3JkZXI6ICR7dGhlbWVbXCJib3JkZXJcIl19O1xuICByaWdodDogNXB4O1xuICB3aWR0aDogMTY0cHg7XG4gIGhlaWdodDogNzhweDtcbiAgcGFkZGluZzogNXB4O1xuICBtYXJnaW46IDBweDtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG59XG5cbiNtYy1wbGF5ZXItc3BlZWQtdmFsdWUtYmFyIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogNXB4O1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lW1wic3BlZWRiYXItY29sb3JcIl19O1xuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gIGhlaWdodDogMTQ0cHg7XG4gIGZsb2F0OiBsZWZ0O1xuICBtYXJnaW4tcmlnaHQ6MTVweDtcbn1cblxuI21jLXBsYXllci1zcGVlZC12YWx1ZS1oZWxwZXJiYXIge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHdpZHRoOiAyNXB4O1xuICBoZWlnaHQ6IDE0NHB4O1xuICBmbG9hdDogbGVmdDtcbiAgbGVmdDogLTVweDtcbiAgei1pbmRleDoxMDtcbn1cblxuXG4jbWMtcGxheWVyLXNwZWVkLXZhbHVlLWJhcjpob3ZlcixcbiNtYy1wbGF5ZXItc3BlZWQtdmFsdWUtaGVscGVyYmFyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4jbWMtcGxheWVyLXNwZWVkLWN1cnNvciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiXX07XG4gIHRvcDogMHB4O1xuICBsZWZ0OiAwcHg7XG59XG5cbiNtYy1wbGF5ZXItc3BlZWQtY3Vyc29yIGRpdiB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiXX07XG4gIGxlZnQ6IC0yLjVweDtcbiAgdG9wOiAtNHB4O1xuICB3aWR0aDogMTBweDtcbiAgaGVpZ2h0OiAxMHB4O1xuICBib3JkZXItcmFkaXVzOiA1cHg7XG59XG5cbiNtYy1wbGF5ZXItc3BlZWQtY3Vyc29yOmhvdmVyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4ubWMtcGxheWVyLXNwZWVkLXZhbHVlLXN0ZXAge1xuICB3aWR0aDogMTVweDtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcInNwZWVkYmFyLWNvbG9yXCJdfTtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBoZWlnaHQ6IDJweDtcbiAgbWFyZ2luLXRvcDogN3B4O1xuICBtYXJnaW4tYm90dG9tOiA3cHg7XG4gIGZsb2F0OiBsZWZ0O1xufVxuXG4jbWMtcGxheWVyLXNwZWVkLXZhbHVlIHtcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICBoZWlnaHQ6IDE0NHB4O1xuICB0ZXh0LWFsaWduOiBsZWZ0O1xufVxuXG4ubWMtcGxheWVyLXNwZWVkLXZhbHVlIHtcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgaGVpZ2h0OiAxNnB4O1xuICBmb250LXNpemU6IDEycHg7XG59XG5cbiNtYy1wbGF5ZXItaW5kaWNhdG9yIHtcbiAgZm9udC1zaXplOiAxMHB4ICFpbXBvcnRhbnQ7XG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgYm90dG9tOiAxNXB4O1xuICBjb2xvcjogJHt0aGVtZVtcImNvbG9yXCJdfTtcbn1cblxuI21jLXBsYXllci1zZXR0aW5ncy1wYW5lbC5tYy1wbGF5ZXItc2V0dGluZ3Mtc3BlZWQtcGFuZWwge1xuICBvdmVyZmxvdzogaGlkZGVuO1xuICB3aWR0aDogODBweDtcbiAgaGVpZ2h0OiAxOTVweDtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG59XG5cbiNtYy1wbGF5ZXItc2V0dGluZ3MtcGFuZWwubWMtcGxheWVyLXNldHRpbmdzLXNwZWVkLXBhbmVsIC5tYy1wbGF5ZXItc3BlZWQtYnRuIHtcbiAgZmxvYXQ6IGxlZnQ7XG59XG5cbi5tYy1wbGF5ZXItc2V0dGluZ3Mtc3BlZWQtcGFuZWwgdWw6Zmlyc3QtY2hpbGQge1xuICB0ZXh0LWFsaWduOiByaWdodDtcbn1cblxuI21jLXBsYXllci1zcGVlZC1jdXJyZW50IHtcbiAgZmxvYXQ6IHJpZ2h0O1xuICBwYWRkaW5nLXJpZ2h0OiAxMHB4XG59XG5cbiNtYy1wbGF5ZXItc2V0dGluZ3MtcGFuZWwgLm1jLXBsYXllci1zcGVlZC1idG4ge1xuICBmbG9hdDogcmlnaHQ7XG59XG5cbiNtYy1wbGF5ZXItc2V0dGluZ3MtcGFuZWwgdWwge1xuICB3aWR0aDogMTAwJTtcbiAgbWFyZ2luOiAwcHg7XG4gIHBhZGRpbmc6IDBweDtcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcbn1cblxuI21jLXBsYXllci1zZXR0aW5ncy1wYW5lbC5tYy1wbGF5ZXItc2V0dGluZ3Mtc3BlZWQtcGFuZWwgdWwgbGkge1xuICBtaW4td2lkdGg6IDcwcHg7XG59XG5cbiNtYy1wbGF5ZXItc2V0dGluZ3MtcGFuZWwgdWwgbGkubm8taG92ZXI6aG92ZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgY3Vyc29yOiBkZWZhdWx0O1xufVxuXG5kaXYubWMtcGxheWVyLXNwZWVkLXZhbHVlOmhvdmVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcImhvdmVyLWNvbG9yXCJdfTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4jbWMtcGxheWVyLXNldHRpbmdzLXBhbmVsIHVsIGxpIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xuICB3aWR0aDogMTAwJTtcbiAgbWluLXdpZHRoOiAxNTRweDtcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xuICBtYXJnaW46IDBweDtcbiAgcGFkZGluZzogNXB4O1xufVxuXG4jbWMtcGxheWVyLXNldHRpbmdzLXBhbmVsIHVsIGxpIGxhYmVsIHtcbiAgbWFyZ2luOiAwcHg7XG59XG5cbi5zd2l0Y2gge1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgd2lkdGg6IDM1cHg7XG4gIGhlaWdodDogMThweDtcbn1cblxuLnN3aXRjaCBpbnB1dCB7XG4gIGRpc3BsYXk6IG5vbmU7XG59XG5cbi5zZXR0aW5ncy1zd2l0Y2gge1xuICBmbG9hdDogcmlnaHQ7XG59XG5cbi5zZXR0aW5ncy1zd2l0Y2g6YWZ0ZXIge1xuICBjbGVhcjogYm90aDtcbn1cblxuLnNsaWRlciB7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICB0b3A6IDA7XG4gIGxlZnQ6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWVbXCJzbGlkZXItb2ZmLWNvbG9yXCJdfTtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiAuNHM7XG4gIHRyYW5zaXRpb246IC40cztcbn1cblxuLnNsaWRlcjpiZWZvcmUge1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGhlaWdodDogMTZweDtcbiAgd2lkdGg6IDE2cHg7XG4gIGxlZnQ6IDFweDtcbiAgYm90dG9tOiAxcHg7XG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuICAtd2Via2l0LXRyYW5zaXRpb246IC40cztcbiAgdHJhbnNpdGlvbjogLjRzO1xufVxuXG5pbnB1dDpjaGVja2VkKy5zbGlkZXIge1xuICBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoZW1lW1wic2xpZGVyLW9uLWNvbG9yXCJdfTtcbn1cblxuaW5wdXQ6Zm9jdXMrLnNsaWRlciB7XG4gIGJveC1zaGFkb3c6IDAgMCAxcHggJHt0aGVtZVtcInNsaWRlci1vbi1jb2xvclwiXX07XG59XG5cbmlucHV0OmNoZWNrZWQrLnNsaWRlcjpiZWZvcmUge1xuICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNnB4KTtcbiAgLW1zLXRyYW5zZm9ybTogdHJhbnNsYXRlWCgxNnB4KTtcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDE2cHgpO1xufVxuXG5cbi8qIFJvdW5kZWQgc2xpZGVycyAqL1xuXG4uc2xpZGVyLnJvdW5kIHtcbiAgYm9yZGVyLXJhZGl1czogMzRweDtcbn1cblxuLnNsaWRlci5yb3VuZDpiZWZvcmUge1xuICBib3JkZXItcmFkaXVzOiA1MCU7XG59XG5cblxuLm0tZmFkZU91dCB7XG4gIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgb3BhY2l0eTogMDtcbiAgdHJhbnNpdGlvbjogdmlzaWJpbGl0eSAwcyBsaW5lYXIgMzAwbXMsIG9wYWNpdHkgMzAwbXM7XG59XG5cbi5tLWZhZGVJbiB7XG4gIHZpc2liaWxpdHk6IHZpc2libGU7XG4gIG9wYWNpdHk6IDE7XG4gIHRyYW5zaXRpb246IHZpc2liaWxpdHkgMHMgbGluZWFyIDBzLCBvcGFjaXR5IDMwMG1zO1xufVxuXG4jbWMtcGxheWVyLXNldHRpbmdzLXBhbmVsIHVsIGxpOmhvdmVyIHtcbiAgYmFja2dyb3VuZC1jb2xvcjogJHt0aGVtZVtcImhvdmVyLWNvbG9yXCJdfTtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4jbWMtcGxheWVyLXNldHRpbmdzLXBhbmVsIHVsIGxpIGxhYmVsOmhvdmVyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xufVxuXG4jbWMtcGxheWVyLWxvb3BiYXI6aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG59XG5cbiNtYy1wbGF5ZXItc3RhdHVzLWJ0bjpob3ZlciB7XG4gIGN1cnNvcjogcG9pbnRlcjtcbn1cblxuI21jLXBsYXllci1jb250cm9sczphY3RpdmUgI21jLXBsYXllci1jdXJzb3IsXG4jbWMtcGxheWVyLWNvbnRyb2xzOmhvdmVyICNtYy1wbGF5ZXItY3Vyc29yICB7XG4gIHdpZHRoOiAxNnB4O1xuICBoZWlnaHQ6IDE2cHg7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xufVxuXG4jbWMtcGxheWVyLXNldHRpbmdzLXNwZWVkOmhvdmVyIC5tYy1wbGF5ZXItc3BlZWQtYnRuIHtcbiAgb3BhY2l0eTogMTtcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICAtbW96LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG59XG5cbiNtYy1wbGF5ZXItc3RhdHVzLWJ0bjpob3ZlciB7XG4gIG9wYWNpdHk6IDE7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xufVxuXG4jbWMtcGxheWVyLWxvb3AtYnRuOmhvdmVyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBvcGFjaXR5OiAxO1xuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbn1cbiNtYy1wbGF5ZXItc2V0dGluZ3MtYnRuOmhvdmVyIHtcbiAgY3Vyc29yOiBwb2ludGVyO1xuICBvcGFjaXR5OiAxO1xuICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XG4gIC1tb3otdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbn1cblxuI21jLXBsYXllci1mdWxsLXNjcmVlbi1idG46aG92ZXIge1xuICBjdXJzb3I6IHBvaW50ZXI7XG4gIG9wYWNpdHk6IDE7XG4gIC13ZWJraXQtdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcbiAgLW1vei10cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xufWA7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFBQTtBQUFBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/style.js\n");

/***/ }),

/***/ "../src/svg.js":
/*!*********************!*\
  !*** ../src/svg.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar svg = module.exports = {};\nsvg.playSVG = \"\\n  <svg width=\\\"100%\\\" class=\\\"svg\\\" height=\\\"100%\\\" viewBox=\\\"0 0 36 36\\\" >\\n    <path id=\\\"play-icon\\\" data-state=\\\"paused\\\"  d=\\\"M11,10 L18,13.74 18,22.28 11,26 M18,13.74 L26,18 26,18 18,22.28\\\" />\\n  </svg>\\n\";\n\nsvg.pauseSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 36 36\\\" >\\n    <path id=\\\"pause-icon\\\" data-state=\\\"playing\\\" d=\\\"M11,10 L17,10 17,26 11,26 M20,10 L26,10 26,26 20,26\\\" />\\n  </svg>\\n\";\n\nsvg.replaySVG = \"\\n  <svg  class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 1000 1000\\\" enable-background=\\\"new 0 0 1000 1000\\\" xml:space=\\\"preserve\\\">\\n    <metadata> Svg Vector Icons : http://www.onlinewebfonts.com/icon </metadata>\\n    <g><g transform=\\\"translate(0.000000,511.000000) scale(0.100000,-0.100000)\\\">\\n      <path d=\\\"M5356.3,4203.8c-1247.8-153.1-2324.2-811.3-3000.7-1839.7c-379.4-578.2-596.5-1209-660.5-1933.4l-27.4-294.8H883.9c-431.9,0-783.9-6.9-783.9-18.3c0-9.2,477.6-493.7,1062.7-1078.7l1062.7-1062.7L3288.1-961.1C3873.1-376,4350.8,108.5,4350.8,117.6c0,11.4-356.5,18.3-790.7,18.3h-793l18.3,189.7C2831,876.3,2991,1338,3288.1,1779.1C4122.3,3026.9,5706,3472.5,7065.8,2841.8C7639.4,2578.9,8197,2035,8487.3,1461.4C8581,1274,8709,896.9,8754.7,666.1c48-246.8,54.8-811.3,9.1-1055.8C8567.3-1491.3,7788-2394,6720.7-2750.5c-315.4-107.4-541.6-139.4-941.6-139.4c-287.9,0-415.9,11.4-598.8,50.3c-523.3,112-973.6,335.9-1371.2,681c-75.4,68.6-148.5,123.4-160,123.4c-9.1,0-187.4-169.1-393.1-374.8c-434.2-434.2-420.5-363.4-105.1-628.5c852.4-710.7,1972.3-1055.8,3046.4-937c1627.2,176,2977.8,1257,3489.8,2790.4c457.1,1368.9,169.1,2843-777,3969.7C8322.7,3484,7417.8,4000.4,6503.6,4160.4C6197.4,4213,5619.2,4235.8,5356.3,4203.8z\\\"/>\\n      <path d=\\\"M4990.7,124.5c0-1503.8,4.6-1794,32-1778c16,9.1,505.1,413.6,1085.6,895.8C7113.8,78.8,7161.8,122.2,7122.9,161c-80,75.4-2109.4,1757.5-2120.8,1757.5C4995.3,1918.5,4990.7,1111.8,4990.7,124.5z\\\"/>\\n    </g></g>\\n  </svg>\\n\";\n\nsvg.settingsSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 268.765 268.765\\\" style=\\\"enable-background:new 0 0 268.765 268.765;\\\" xml:space=\\\"preserve\\\">\\n    <g id=\\\"Settings\\\">\\n      <g>\\n        <path style=\\\"fill-rule:evenodd;clip-rule:evenodd;\\\" d=\\\"M267.92,119.461c-0.425-3.778-4.83-6.617-8.639-6.617\\n          c-12.315,0-23.243-7.231-27.826-18.414c-4.682-11.454-1.663-24.812,7.515-33.231c2.889-2.641,3.24-7.062,0.817-10.133\\n          c-6.303-8.004-13.467-15.234-21.289-21.5c-3.063-2.458-7.557-2.116-10.213,0.825c-8.01,8.871-22.398,12.168-33.516,7.529\\n          c-11.57-4.867-18.866-16.591-18.152-29.176c0.235-3.953-2.654-7.39-6.595-7.849c-10.038-1.161-20.164-1.197-30.232-0.08\\n          c-3.896,0.43-6.785,3.786-6.654,7.689c0.438,12.461-6.946,23.98-18.401,28.672c-10.985,4.487-25.272,1.218-33.266-7.574\\n          c-2.642-2.896-7.063-3.252-10.141-0.853c-8.054,6.319-15.379,13.555-21.74,21.493c-2.481,3.086-2.116,7.559,0.802,10.214\\n          c9.353,8.47,12.373,21.944,7.514,33.53c-4.639,11.046-16.109,18.165-29.24,18.165c-4.261-0.137-7.296,2.723-7.762,6.597\\n          c-1.182,10.096-1.196,20.383-0.058,30.561c0.422,3.794,4.961,6.608,8.812,6.608c11.702-0.299,22.937,6.946,27.65,18.415\\n          c4.698,11.454,1.678,24.804-7.514,33.23c-2.875,2.641-3.24,7.055-0.817,10.126c6.244,7.953,13.409,15.19,21.259,21.508\\n          c3.079,2.481,7.559,2.131,10.228-0.81c8.04-8.893,22.427-12.184,33.501-7.536c11.599,4.852,18.895,16.575,18.181,29.167\\n          c-0.233,3.955,2.67,7.398,6.595,7.85c5.135,0.599,10.301,0.898,15.481,0.898c4.917,0,9.835-0.27,14.752-0.817\\n          c3.897-0.43,6.784-3.786,6.653-7.696c-0.451-12.454,6.946-23.973,18.386-28.657c11.059-4.517,25.286-1.211,33.281,7.572\\n          c2.657,2.89,7.047,3.239,10.142,0.848c8.039-6.304,15.349-13.534,21.74-21.494c2.48-3.079,2.13-7.559-0.803-10.213\\n          c-9.353-8.47-12.388-21.946-7.529-33.524c4.568-10.899,15.612-18.217,27.491-18.217l1.662,0.043\\n          c3.853,0.313,7.398-2.655,7.865-6.588C269.044,139.917,269.058,129.639,267.92,119.461z M134.595,179.491\\n          c-24.718,0-44.824-20.106-44.824-44.824c0-24.717,20.106-44.824,44.824-44.824c24.717,0,44.823,20.107,44.823,44.824\\n          C179.418,159.385,159.312,179.491,134.595,179.491z\\\"/>\\n      </g>\\n    </g>\\n  <g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\n\nsvg.arrowRightSVG = \"\\n  <svg class=\\\"svg\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 80\\\" xml:space=\\\"preserve\\\">\\n    <polyline fill=\\\"none\\\" stroke-width=\\\"10\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" points=\\\"0.375,0.375 45.63,38.087 0.375,75.8 \\\"/>\\n  </svg>\\n\";\n\nsvg.arrowLeftSVG = \"\\n  <svg class=\\\"svg\\\" class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" viewBox=\\\"0 0 50 80\\\" xml:space=\\\"preserve\\\">\\n    <polyline fill=\\\"none\\\" stroke-width=\\\"10\\\" stroke-linecap=\\\"round\\\" stroke-linejoin=\\\"round\\\" points=\\\"45.63,75.8 0.375,38.087 45.63,0.375 \\\"/>\\n  </svg> \\n\";\n\nsvg.fullScreenSVG = \"\\n  <svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 298.667 298.667\\\" style=\\\"enable-background:new 0 0 298.667 298.667;\\\" xml:space=\\\"preserve\\\">\\n    <g>\\n      <g>\\n        <g>\\n          <polygon points=\\\"42.667,192 0,192 0,298.667 106.667,298.667 106.667,256 42.667,256\\\"/>\\n          <polygon points=\\\"0,106.667 42.667,106.667 42.667,42.667 106.667,42.667 106.667,0 0,0\\\"/>\\n          <polygon points=\\\"192,0 192,42.667 256,42.667 256,106.667 298.667,106.667 298.667,0\\\"/>\\n          <polygon points=\\\"256,256 192,256 192,298.667 298.667,298.667 298.667,192 256,192\\\"/>\\n        </g>\\n      </g>\\n    </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n  </svg>\\n\";\n\nsvg.loopSVG = \"\\n<svg class=\\\"svg\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" id=\\\"Capa_1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 32 32\\\" style=\\\"enable-background:new 0 0 32 32;\\\" xml:space=\\\"preserve\\\">\\n  <g>\\n    <g id=\\\"loop_x5F_alt3\\\">\\n      <g>\\n        <path d=\\\"M28,16v2c0,1.102-0.898,2-2,2H11.996L12,16l-8,6l8,6l-0.004-4H26c3.309,0,6-2.695,6-6v-2H28z\\\"/>\\n        <path d=\\\"M4,14c0-1.105,0.898-2,2-2h14v4l7.992-6L20,4v4H6c-3.309,0-6,2.688-6,6v2h4V14z\\\"/>\\n      </g>\\n    </g>\\n  </g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g><g></g>\\n</svg>\";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL3N2Zy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvc3ZnLmpzPzkxOTciXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgc3ZnID0gKG1vZHVsZS5leHBvcnRzID0ge30pO1xuc3ZnLnBsYXlTVkcgPSBgXG4gIDxzdmcgd2lkdGg9XCIxMDAlXCIgY2xhc3M9XCJzdmdcIiBoZWlnaHQ9XCIxMDAlXCIgdmlld0JveD1cIjAgMCAzNiAzNlwiID5cbiAgICA8cGF0aCBpZD1cInBsYXktaWNvblwiIGRhdGEtc3RhdGU9XCJwYXVzZWRcIiAgZD1cIk0xMSwxMCBMMTgsMTMuNzQgMTgsMjIuMjggMTEsMjYgTTE4LDEzLjc0IEwyNiwxOCAyNiwxOCAxOCwyMi4yOFwiIC8+XG4gIDwvc3ZnPlxuYDtcblxuc3ZnLnBhdXNlU1ZHID0gYFxuICA8c3ZnIGNsYXNzPVwic3ZnXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgMzYgMzZcIiA+XG4gICAgPHBhdGggaWQ9XCJwYXVzZS1pY29uXCIgZGF0YS1zdGF0ZT1cInBsYXlpbmdcIiBkPVwiTTExLDEwIEwxNywxMCAxNywyNiAxMSwyNiBNMjAsMTAgTDI2LDEwIDI2LDI2IDIwLDI2XCIgLz5cbiAgPC9zdmc+XG5gO1xuXG5zdmcucmVwbGF5U1ZHID0gYFxuICA8c3ZnICBjbGFzcz1cInN2Z1wiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgdmlld0JveD1cIjAgMCAxMDAwIDEwMDBcIiBlbmFibGUtYmFja2dyb3VuZD1cIm5ldyAwIDAgMTAwMCAxMDAwXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cbiAgICA8bWV0YWRhdGE+IFN2ZyBWZWN0b3IgSWNvbnMgOiBodHRwOi8vd3d3Lm9ubGluZXdlYmZvbnRzLmNvbS9pY29uIDwvbWV0YWRhdGE+XG4gICAgPGc+PGcgdHJhbnNmb3JtPVwidHJhbnNsYXRlKDAuMDAwMDAwLDUxMS4wMDAwMDApIHNjYWxlKDAuMTAwMDAwLC0wLjEwMDAwMClcIj5cbiAgICAgIDxwYXRoIGQ9XCJNNTM1Ni4zLDQyMDMuOGMtMTI0Ny44LTE1My4xLTIzMjQuMi04MTEuMy0zMDAwLjctMTgzOS43Yy0zNzkuNC01NzguMi01OTYuNS0xMjA5LTY2MC41LTE5MzMuNGwtMjcuNC0yOTQuOEg4ODMuOWMtNDMxLjksMC03ODMuOS02LjktNzgzLjktMTguM2MwLTkuMiw0NzcuNi00OTMuNywxMDYyLjctMTA3OC43bDEwNjIuNy0xMDYyLjdMMzI4OC4xLTk2MS4xQzM4NzMuMS0zNzYsNDM1MC44LDEwOC41LDQzNTAuOCwxMTcuNmMwLDExLjQtMzU2LjUsMTguMy03OTAuNywxOC4zaC03OTNsMTguMywxODkuN0MyODMxLDg3Ni4zLDI5OTEsMTMzOCwzMjg4LjEsMTc3OS4xQzQxMjIuMywzMDI2LjksNTcwNiwzNDcyLjUsNzA2NS44LDI4NDEuOEM3NjM5LjQsMjU3OC45LDgxOTcsMjAzNSw4NDg3LjMsMTQ2MS40Qzg1ODEsMTI3NCw4NzA5LDg5Ni45LDg3NTQuNyw2NjYuMWM0OC0yNDYuOCw1NC44LTgxMS4zLDkuMS0xMDU1LjhDODU2Ny4zLTE0OTEuMyw3Nzg4LTIzOTQsNjcyMC43LTI3NTAuNWMtMzE1LjQtMTA3LjQtNTQxLjYtMTM5LjQtOTQxLjYtMTM5LjRjLTI4Ny45LDAtNDE1LjksMTEuNC01OTguOCw1MC4zYy01MjMuMywxMTItOTczLjYsMzM1LjktMTM3MS4yLDY4MWMtNzUuNCw2OC42LTE0OC41LDEyMy40LTE2MCwxMjMuNGMtOS4xLDAtMTg3LjQtMTY5LjEtMzkzLjEtMzc0LjhjLTQzNC4yLTQzNC4yLTQyMC41LTM2My40LTEwNS4xLTYyOC41Yzg1Mi40LTcxMC43LDE5NzIuMy0xMDU1LjgsMzA0Ni40LTkzN2MxNjI3LjIsMTc2LDI5NzcuOCwxMjU3LDM0ODkuOCwyNzkwLjRjNDU3LjEsMTM2OC45LDE2OS4xLDI4NDMtNzc3LDM5NjkuN0M4MzIyLjcsMzQ4NCw3NDE3LjgsNDAwMC40LDY1MDMuNiw0MTYwLjRDNjE5Ny40LDQyMTMsNTYxOS4yLDQyMzUuOCw1MzU2LjMsNDIwMy44elwiLz5cbiAgICAgIDxwYXRoIGQ9XCJNNDk5MC43LDEyNC41YzAtMTUwMy44LDQuNi0xNzk0LDMyLTE3NzhjMTYsOS4xLDUwNS4xLDQxMy42LDEwODUuNiw4OTUuOEM3MTEzLjgsNzguOCw3MTYxLjgsMTIyLjIsNzEyMi45LDE2MWMtODAsNzUuNC0yMTA5LjQsMTc1Ny41LTIxMjAuOCwxNzU3LjVDNDk5NS4zLDE5MTguNSw0OTkwLjcsMTExMS44LDQ5OTAuNywxMjQuNXpcIi8+XG4gICAgPC9nPjwvZz5cbiAgPC9zdmc+XG5gO1xuXG5zdmcuc2V0dGluZ3NTVkcgPSBgXG4gIDxzdmcgY2xhc3M9XCJzdmdcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmVyc2lvbj1cIjEuMVwiIGlkPVwiQ2FwYV8xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgdmlld0JveD1cIjAgMCAyNjguNzY1IDI2OC43NjVcIiBzdHlsZT1cImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjY4Ljc2NSAyNjguNzY1O1wiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XG4gICAgPGcgaWQ9XCJTZXR0aW5nc1wiPlxuICAgICAgPGc+XG4gICAgICAgIDxwYXRoIHN0eWxlPVwiZmlsbC1ydWxlOmV2ZW5vZGQ7Y2xpcC1ydWxlOmV2ZW5vZGQ7XCIgZD1cIk0yNjcuOTIsMTE5LjQ2MWMtMC40MjUtMy43NzgtNC44My02LjYxNy04LjYzOS02LjYxN1xuICAgICAgICAgIGMtMTIuMzE1LDAtMjMuMjQzLTcuMjMxLTI3LjgyNi0xOC40MTRjLTQuNjgyLTExLjQ1NC0xLjY2My0yNC44MTIsNy41MTUtMzMuMjMxYzIuODg5LTIuNjQxLDMuMjQtNy4wNjIsMC44MTctMTAuMTMzXG4gICAgICAgICAgYy02LjMwMy04LjAwNC0xMy40NjctMTUuMjM0LTIxLjI4OS0yMS41Yy0zLjA2My0yLjQ1OC03LjU1Ny0yLjExNi0xMC4yMTMsMC44MjVjLTguMDEsOC44NzEtMjIuMzk4LDEyLjE2OC0zMy41MTYsNy41MjlcbiAgICAgICAgICBjLTExLjU3LTQuODY3LTE4Ljg2Ni0xNi41OTEtMTguMTUyLTI5LjE3NmMwLjIzNS0zLjk1My0yLjY1NC03LjM5LTYuNTk1LTcuODQ5Yy0xMC4wMzgtMS4xNjEtMjAuMTY0LTEuMTk3LTMwLjIzMi0wLjA4XG4gICAgICAgICAgYy0zLjg5NiwwLjQzLTYuNzg1LDMuNzg2LTYuNjU0LDcuNjg5YzAuNDM4LDEyLjQ2MS02Ljk0NiwyMy45OC0xOC40MDEsMjguNjcyYy0xMC45ODUsNC40ODctMjUuMjcyLDEuMjE4LTMzLjI2Ni03LjU3NFxuICAgICAgICAgIGMtMi42NDItMi44OTYtNy4wNjMtMy4yNTItMTAuMTQxLTAuODUzYy04LjA1NCw2LjMxOS0xNS4zNzksMTMuNTU1LTIxLjc0LDIxLjQ5M2MtMi40ODEsMy4wODYtMi4xMTYsNy41NTksMC44MDIsMTAuMjE0XG4gICAgICAgICAgYzkuMzUzLDguNDcsMTIuMzczLDIxLjk0NCw3LjUxNCwzMy41M2MtNC42MzksMTEuMDQ2LTE2LjEwOSwxOC4xNjUtMjkuMjQsMTguMTY1Yy00LjI2MS0wLjEzNy03LjI5NiwyLjcyMy03Ljc2Miw2LjU5N1xuICAgICAgICAgIGMtMS4xODIsMTAuMDk2LTEuMTk2LDIwLjM4My0wLjA1OCwzMC41NjFjMC40MjIsMy43OTQsNC45NjEsNi42MDgsOC44MTIsNi42MDhjMTEuNzAyLTAuMjk5LDIyLjkzNyw2Ljk0NiwyNy42NSwxOC40MTVcbiAgICAgICAgICBjNC42OTgsMTEuNDU0LDEuNjc4LDI0LjgwNC03LjUxNCwzMy4yM2MtMi44NzUsMi42NDEtMy4yNCw3LjA1NS0wLjgxNywxMC4xMjZjNi4yNDQsNy45NTMsMTMuNDA5LDE1LjE5LDIxLjI1OSwyMS41MDhcbiAgICAgICAgICBjMy4wNzksMi40ODEsNy41NTksMi4xMzEsMTAuMjI4LTAuODFjOC4wNC04Ljg5MywyMi40MjctMTIuMTg0LDMzLjUwMS03LjUzNmMxMS41OTksNC44NTIsMTguODk1LDE2LjU3NSwxOC4xODEsMjkuMTY3XG4gICAgICAgICAgYy0wLjIzMywzLjk1NSwyLjY3LDcuMzk4LDYuNTk1LDcuODVjNS4xMzUsMC41OTksMTAuMzAxLDAuODk4LDE1LjQ4MSwwLjg5OGM0LjkxNywwLDkuODM1LTAuMjcsMTQuNzUyLTAuODE3XG4gICAgICAgICAgYzMuODk3LTAuNDMsNi43ODQtMy43ODYsNi42NTMtNy42OTZjLTAuNDUxLTEyLjQ1NCw2Ljk0Ni0yMy45NzMsMTguMzg2LTI4LjY1N2MxMS4wNTktNC41MTcsMjUuMjg2LTEuMjExLDMzLjI4MSw3LjU3MlxuICAgICAgICAgIGMyLjY1NywyLjg5LDcuMDQ3LDMuMjM5LDEwLjE0MiwwLjg0OGM4LjAzOS02LjMwNCwxNS4zNDktMTMuNTM0LDIxLjc0LTIxLjQ5NGMyLjQ4LTMuMDc5LDIuMTMtNy41NTktMC44MDMtMTAuMjEzXG4gICAgICAgICAgYy05LjM1My04LjQ3LTEyLjM4OC0yMS45NDYtNy41MjktMzMuNTI0YzQuNTY4LTEwLjg5OSwxNS42MTItMTguMjE3LDI3LjQ5MS0xOC4yMTdsMS42NjIsMC4wNDNcbiAgICAgICAgICBjMy44NTMsMC4zMTMsNy4zOTgtMi42NTUsNy44NjUtNi41ODhDMjY5LjA0NCwxMzkuOTE3LDI2OS4wNTgsMTI5LjYzOSwyNjcuOTIsMTE5LjQ2MXogTTEzNC41OTUsMTc5LjQ5MVxuICAgICAgICAgIGMtMjQuNzE4LDAtNDQuODI0LTIwLjEwNi00NC44MjQtNDQuODI0YzAtMjQuNzE3LDIwLjEwNi00NC44MjQsNDQuODI0LTQ0LjgyNGMyNC43MTcsMCw0NC44MjMsMjAuMTA3LDQ0LjgyMyw0NC44MjRcbiAgICAgICAgICBDMTc5LjQxOCwxNTkuMzg1LDE1OS4zMTIsMTc5LjQ5MSwxMzQuNTk1LDE3OS40OTF6XCIvPlxuICAgICAgPC9nPlxuICAgIDwvZz5cbiAgPGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+XG4gIDwvc3ZnPlxuYDtcblxuc3ZnLmFycm93UmlnaHRTVkcgPSBgXG4gIDxzdmcgY2xhc3M9XCJzdmdcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgeG1sbnM6eGxpbms9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZpZXdCb3g9XCIwIDAgNTAgODBcIiB4bWw6c3BhY2U9XCJwcmVzZXJ2ZVwiPlxuICAgIDxwb2x5bGluZSBmaWxsPVwibm9uZVwiIHN0cm9rZS13aWR0aD1cIjEwXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCIgcG9pbnRzPVwiMC4zNzUsMC4zNzUgNDUuNjMsMzguMDg3IDAuMzc1LDc1LjggXCIvPlxuICA8L3N2Zz5cbmA7XG5cbnN2Zy5hcnJvd0xlZnRTVkcgPSBgXG4gIDxzdmcgY2xhc3M9XCJzdmdcIiBjbGFzcz1cInN2Z1wiIHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiB2aWV3Qm94PVwiMCAwIDUwIDgwXCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cbiAgICA8cG9seWxpbmUgZmlsbD1cIm5vbmVcIiBzdHJva2Utd2lkdGg9XCIxMFwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiIHBvaW50cz1cIjQ1LjYzLDc1LjggMC4zNzUsMzguMDg3IDQ1LjYzLDAuMzc1IFwiLz5cbiAgPC9zdmc+IFxuYDtcblxuc3ZnLmZ1bGxTY3JlZW5TVkcgPSBgXG4gIDxzdmcgY2xhc3M9XCJzdmdcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCIxMDAlXCIgdmVyc2lvbj1cIjEuMVwiIGlkPVwiQ2FwYV8xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHhtbG5zOnhsaW5rPVwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiIHg9XCIwcHhcIiB5PVwiMHB4XCIgdmlld0JveD1cIjAgMCAyOTguNjY3IDI5OC42NjdcIiBzdHlsZT1cImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMjk4LjY2NyAyOTguNjY3O1wiIHhtbDpzcGFjZT1cInByZXNlcnZlXCI+XG4gICAgPGc+XG4gICAgICA8Zz5cbiAgICAgICAgPGc+XG4gICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVwiNDIuNjY3LDE5MiAwLDE5MiAwLDI5OC42NjcgMTA2LjY2NywyOTguNjY3IDEwNi42NjcsMjU2IDQyLjY2NywyNTZcIi8+XG4gICAgICAgICAgPHBvbHlnb24gcG9pbnRzPVwiMCwxMDYuNjY3IDQyLjY2NywxMDYuNjY3IDQyLjY2Nyw0Mi42NjcgMTA2LjY2Nyw0Mi42NjcgMTA2LjY2NywwIDAsMFwiLz5cbiAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XCIxOTIsMCAxOTIsNDIuNjY3IDI1Niw0Mi42NjcgMjU2LDEwNi42NjcgMjk4LjY2NywxMDYuNjY3IDI5OC42NjcsMFwiLz5cbiAgICAgICAgICA8cG9seWdvbiBwb2ludHM9XCIyNTYsMjU2IDE5MiwyNTYgMTkyLDI5OC42NjcgMjk4LjY2NywyOTguNjY3IDI5OC42NjcsMTkyIDI1NiwxOTJcIi8+XG4gICAgICAgIDwvZz5cbiAgICAgIDwvZz5cbiAgICA8L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+XG4gIDwvc3ZnPlxuYDtcblxuc3ZnLmxvb3BTVkcgPSBgXG48c3ZnIGNsYXNzPVwic3ZnXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiMTAwJVwiIHZlcnNpb249XCIxLjFcIiBpZD1cIkNhcGFfMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiB4PVwiMHB4XCIgeT1cIjBweFwiIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiBzdHlsZT1cImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgMzIgMzI7XCIgeG1sOnNwYWNlPVwicHJlc2VydmVcIj5cbiAgPGc+XG4gICAgPGcgaWQ9XCJsb29wX3g1Rl9hbHQzXCI+XG4gICAgICA8Zz5cbiAgICAgICAgPHBhdGggZD1cIk0yOCwxNnYyYzAsMS4xMDItMC44OTgsMi0yLDJIMTEuOTk2TDEyLDE2bC04LDZsOCw2bC0wLjAwNC00SDI2YzMuMzA5LDAsNi0yLjY5NSw2LTZ2LTJIMjh6XCIvPlxuICAgICAgICA8cGF0aCBkPVwiTTQsMTRjMC0xLjEwNSwwLjg5OC0yLDItMmgxNHY0bDcuOTkyLTZMMjAsNHY0SDZjLTMuMzA5LDAtNiwyLjY4OC02LDZ2Mmg0VjE0elwiLz5cbiAgICAgIDwvZz5cbiAgICA8L2c+XG4gIDwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz48Zz48L2c+PGc+PC9nPjxnPjwvZz5cbjwvc3ZnPmA7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUtBO0FBQ0E7QUFTQTtBQUNBO0FBMEJBO0FBQ0E7QUFLQTtBQUNBO0FBS0E7QUFDQTtBQWNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../src/svg.js\n");

/***/ }),

/***/ "../src/themes.js":
/*!************************!*\
  !*** ../src/themes.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar themes = {\n  default: {\n    \"settings-background-color\": \"whitesmoke\",\n    \"hms-background-color\": \"whitesmoke\",\n    \"background-color\": \"whitesmoke\",\n    \"grad-height\": \"0px\",\n    color: \"black\",\n    \"svg-color\": \"black\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"red\",\n    \"cursor-color\": \"red\",\n    \"speedbar-cursor-color\": \"red\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"red\",\n    \"preview-border\": \"2px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  dark: {\n    \"settings-background-color\": \"black\",\n    \"hms-background-color\": \"black\",\n    \"background-color\": \"black\",\n    \"grad-height\": \"0px\",\n    color: \"white\",\n    \"svg-color\": \"white\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"red\",\n    \"cursor-color\": \"red\",\n    \"speedbar-cursor-color\": \"red\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(90, 90, 90, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"red\",\n    \"preview-border\": \"2px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  whiteGold: {\n    \"settings-background-color\": \"white\",\n    \"hms-background-color\": \"white\",\n    \"background-color\": \"white\",\n    \"grad-height\": \"0px\",\n    color: \"#a17f1a\",\n    \"svg-color\": \"#a17f1a\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"#a17f1a\",\n    \"cursor-color\": \"#a17f1a\",\n    \"speedbar-cursor-color\": \"#a17f1a\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"#a17f1a\",\n    \"preview-border\": \"2px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  darkGold: {\n    \"settings-background-color\": \"black\",\n    \"hms-background-color\": \"black\",\n    \"background-color\": \"black\",\n    \"grad-height\": \"0px\",\n    color: \"#a17f1a\",\n    \"svg-color\": \"#a17f1a\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"#a17f1a\",\n    \"cursor-color\": \"#a17f1a\",\n    \"speedbar-cursor-color\": \"#a17f1a\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(90, 90, 90, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"#a17f1a\",\n    \"preview-border\": \"2px solid rgba(0,0,0,1)\",\n    border: \"1px solid rgba(255,255,255,0.2)\",\n    \"controls-border\": \"none\",\n    \"svg-selected-color\": \"red\"\n  },\n  transparent: {\n    \"background-color\": \"transparent\",\n    \"settings-background-color\": \"rgba(0,0,0,0.5)\",\n    \"hms-background-color\": \"rgba(0,0,0,0.5)\",\n    \"preview-border\": \"2px solid rgba(0,0,0,1)\",\n    color: \"white\",\n    \"grad-height\": \"60px\",\n    \"svg-color\": \"white\",\n    \"loopbar-color\": \"#808086\",\n    \"speedbar-color\": \"#666\",\n    \"runningbar-color\": \"red\",\n    \"cursor-color\": \"red\",\n    \"speedbar-cursor-color\": \"red\",\n    \"button-opacity\": \"0.8\",\n    \"hover-color\": \"rgba(200, 200, 200, 0.5)\",\n    \"slider-off-color\": \"#ccc\",\n    \"slider-on-color\": \"red\",\n    border: \"1px solid rgba(255,255,255,0.1)\",\n    \"controls-border\": \"1px solid rgba(255,255,255,0.1)\",\n    \"svg-selected-color\": \"red\"\n  },\n  \"on-top\": {\n    \"controls-bottom\": \"0px\",\n    \"settings-panel-bottom\": \"45px\",\n    \"controls-position\": \"0px\"\n  },\n  \"position-default\": {\n    \"controls-bottom\": \"-40px\",\n    \"settings-panel-bottom\": \"5px\",\n    \"controls-position\": \"40px\"\n  }\n};\n\nmodule.exports = function (theme) {\n  return themes[theme];\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vc3JjL3RoZW1lcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9zcmMvdGhlbWVzLmpzPzk4NTUiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgdGhlbWVzID0ge1xuICBkZWZhdWx0OiB7XG4gICAgXCJzZXR0aW5ncy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVzbW9rZVwiLFxuICAgIFwiaG1zLWJhY2tncm91bmQtY29sb3JcIjogXCJ3aGl0ZXNtb2tlXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVzbW9rZVwiLFxuICAgIFwiZ3JhZC1oZWlnaHRcIjogXCIwcHhcIixcbiAgICBjb2xvcjogXCJibGFja1wiLFxuICAgIFwic3ZnLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICBcImxvb3BiYXItY29sb3JcIjogXCIjODA4MDg2XCIsXG4gICAgXCJzcGVlZGJhci1jb2xvclwiOiBcIiM2NjZcIixcbiAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCJyZWRcIixcbiAgICBcImN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjAuOFwiLFxuICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSlcIixcbiAgICBcInNsaWRlci1vZmYtY29sb3JcIjogXCIjY2NjXCIsXG4gICAgXCJzbGlkZXItb24tY29sb3JcIjogXCJyZWRcIixcbiAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMnB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLFxuICAgIFwiY29udHJvbHMtYm9yZGVyXCI6IFwibm9uZVwiLFxuICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCJcbiAgfSxcbiAgZGFyazoge1xuICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgXCJobXMtYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwiYmxhY2tcIixcbiAgICBcImdyYWQtaGVpZ2h0XCI6IFwiMHB4XCIsXG4gICAgY29sb3I6IFwid2hpdGVcIixcbiAgICBcInN2Zy1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgXCJsb29wYmFyLWNvbG9yXCI6IFwiIzgwODA4NlwiLFxuICAgIFwic3BlZWRiYXItY29sb3JcIjogXCIjNjY2XCIsXG4gICAgXCJydW5uaW5nYmFyLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJjdXJzb3ItY29sb3JcIjogXCJyZWRcIixcbiAgICBcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwiYnV0dG9uLW9wYWNpdHlcIjogXCIwLjhcIixcbiAgICBcImhvdmVyLWNvbG9yXCI6IFwicmdiYSg5MCwgOTAsIDkwLCAwLjUpXCIsXG4gICAgXCJzbGlkZXItb2ZmLWNvbG9yXCI6IFwiI2NjY1wiLFxuICAgIFwic2xpZGVyLW9uLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJwcmV2aWV3LWJvcmRlclwiOiBcIjJweCBzb2xpZCByZ2JhKDAsMCwwLDEpXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMilcIixcbiAgICBcImNvbnRyb2xzLWJvcmRlclwiOiBcIm5vbmVcIixcbiAgICBcInN2Zy1zZWxlY3RlZC1jb2xvclwiOiBcInJlZFwiXG4gIH0sXG4gIHdoaXRlR29sZDoge1xuICAgIFwic2V0dGluZ3MtYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgXCJobXMtYmFja2dyb3VuZC1jb2xvclwiOiBcIndoaXRlXCIsXG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICBcImdyYWQtaGVpZ2h0XCI6IFwiMHB4XCIsXG4gICAgY29sb3I6IFwiI2ExN2YxYVwiLFxuICAgIFwic3ZnLWNvbG9yXCI6IFwiI2ExN2YxYVwiLFxuICAgIFwibG9vcGJhci1jb2xvclwiOiBcIiM4MDgwODZcIixcbiAgICBcInNwZWVkYmFyLWNvbG9yXCI6IFwiIzY2NlwiLFxuICAgIFwicnVubmluZ2Jhci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcImN1cnNvci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcInNwZWVkYmFyLWN1cnNvci1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcImJ1dHRvbi1vcGFjaXR5XCI6IFwiMC44XCIsXG4gICAgXCJob3Zlci1jb2xvclwiOiBcInJnYmEoMjAwLCAyMDAsIDIwMCwgMC41KVwiLFxuICAgIFwic2xpZGVyLW9mZi1jb2xvclwiOiBcIiNjY2NcIixcbiAgICBcInNsaWRlci1vbi1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcInByZXZpZXctYm9yZGVyXCI6IFwiMnB4IHNvbGlkIHJnYmEoMCwwLDAsMSlcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4yKVwiLFxuICAgIFwiY29udHJvbHMtYm9yZGVyXCI6IFwibm9uZVwiLFxuICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCJcbiAgfSxcbiAgZGFya0dvbGQ6IHtcbiAgICBcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIjogXCJibGFja1wiLFxuICAgIFwiaG1zLWJhY2tncm91bmQtY29sb3JcIjogXCJibGFja1wiLFxuICAgIFwiYmFja2dyb3VuZC1jb2xvclwiOiBcImJsYWNrXCIsXG4gICAgXCJncmFkLWhlaWdodFwiOiBcIjBweFwiLFxuICAgIGNvbG9yOiBcIiNhMTdmMWFcIixcbiAgICBcInN2Zy1jb2xvclwiOiBcIiNhMTdmMWFcIixcbiAgICBcImxvb3BiYXItY29sb3JcIjogXCIjODA4MDg2XCIsXG4gICAgXCJzcGVlZGJhci1jb2xvclwiOiBcIiM2NjZcIixcbiAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgXCJjdXJzb3ItY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgXCJzcGVlZGJhci1jdXJzb3ItY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjAuOFwiLFxuICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDkwLCA5MCwgOTAsIDAuNSlcIixcbiAgICBcInNsaWRlci1vZmYtY29sb3JcIjogXCIjY2NjXCIsXG4gICAgXCJzbGlkZXItb24tY29sb3JcIjogXCIjYTE3ZjFhXCIsXG4gICAgXCJwcmV2aWV3LWJvcmRlclwiOiBcIjJweCBzb2xpZCByZ2JhKDAsMCwwLDEpXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCByZ2JhKDI1NSwyNTUsMjU1LDAuMilcIixcbiAgICBcImNvbnRyb2xzLWJvcmRlclwiOiBcIm5vbmVcIixcbiAgICBcInN2Zy1zZWxlY3RlZC1jb2xvclwiOiBcInJlZFwiXG4gIH0sXG4gIHRyYW5zcGFyZW50OiB7XG4gICAgXCJiYWNrZ3JvdW5kLWNvbG9yXCI6IFwidHJhbnNwYXJlbnRcIixcbiAgICBcInNldHRpbmdzLWJhY2tncm91bmQtY29sb3JcIjogXCJyZ2JhKDAsMCwwLDAuNSlcIixcbiAgICBcImhtcy1iYWNrZ3JvdW5kLWNvbG9yXCI6IFwicmdiYSgwLDAsMCwwLjUpXCIsXG4gICAgXCJwcmV2aWV3LWJvcmRlclwiOiBcIjJweCBzb2xpZCByZ2JhKDAsMCwwLDEpXCIsXG4gICAgY29sb3I6IFwid2hpdGVcIixcbiAgICBcImdyYWQtaGVpZ2h0XCI6IFwiNjBweFwiLFxuICAgIFwic3ZnLWNvbG9yXCI6IFwid2hpdGVcIixcbiAgICBcImxvb3BiYXItY29sb3JcIjogXCIjODA4MDg2XCIsXG4gICAgXCJzcGVlZGJhci1jb2xvclwiOiBcIiM2NjZcIixcbiAgICBcInJ1bm5pbmdiYXItY29sb3JcIjogXCJyZWRcIixcbiAgICBcImN1cnNvci1jb2xvclwiOiBcInJlZFwiLFxuICAgIFwic3BlZWRiYXItY3Vyc29yLWNvbG9yXCI6IFwicmVkXCIsXG4gICAgXCJidXR0b24tb3BhY2l0eVwiOiBcIjAuOFwiLFxuICAgIFwiaG92ZXItY29sb3JcIjogXCJyZ2JhKDIwMCwgMjAwLCAyMDAsIDAuNSlcIixcbiAgICBcInNsaWRlci1vZmYtY29sb3JcIjogXCIjY2NjXCIsXG4gICAgXCJzbGlkZXItb24tY29sb3JcIjogXCJyZWRcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKVwiLFxuICAgIFwiY29udHJvbHMtYm9yZGVyXCI6IFwiMXB4IHNvbGlkIHJnYmEoMjU1LDI1NSwyNTUsMC4xKVwiLFxuICAgIFwic3ZnLXNlbGVjdGVkLWNvbG9yXCI6IFwicmVkXCJcbiAgfSxcbiAgXCJvbi10b3BcIjoge1xuICAgIFwiY29udHJvbHMtYm90dG9tXCI6IFwiMHB4XCIsXG4gICAgXCJzZXR0aW5ncy1wYW5lbC1ib3R0b21cIjogXCI0NXB4XCIsXG4gICAgXCJjb250cm9scy1wb3NpdGlvblwiOiBcIjBweFwiXG4gIH0sXG4gIFwicG9zaXRpb24tZGVmYXVsdFwiOiB7XG4gICAgXCJjb250cm9scy1ib3R0b21cIjogXCItNDBweFwiLFxuICAgIFwic2V0dGluZ3MtcGFuZWwtYm90dG9tXCI6IFwiNXB4XCIsXG4gICAgXCJjb250cm9scy1wb3NpdGlvblwiOiBcIjQwcHhcIlxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRoZW1lID0+IHRoZW1lc1t0aGVtZV07XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW5CQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBcUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFuQkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUEvR0E7QUFDQTtBQXFIQTtBQUFBO0FBQUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../src/themes.js\n");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar MotorCortex = __webpack_require__(/*! ./node_modules/@kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\nvar TestPluginDefinition = __webpack_require__(/*! ./testPlugin/main */ \"./testPlugin/main.js\");\nvar Player = __webpack_require__(/*! ../src/Player */ \"../src/Player.js\");\n\nvar TestPlugin = MotorCortex.loadPlugin(TestPluginDefinition);\n\n// Configure clip\nvar config = {\n  css: \"\\n    body{\\n      background-color:black;\\n    }\\n    #one {\\n      font-size:40px;\\n      display: table-cell;\\n      vertical-align: middle;\\n      text-align:center;\\n      font-family: \\\"Century Gothic\\\", CenturyGothic, AppleGothic, sans-serif;\\n      color:#4b475f;\\n      \\n    }\\n    .container {\\n      display: table;\\n      position: absolute;\\n      height: 100%;\\n      width: 80%;\\n      background-color:#292929;\\n      margin-left:10%;\\n      border:2px solid black;\\n    }\\n  \",\n  html: \"<div class=\\\"container\\\">\\n    <div id=\\\"one\\\" class=\\\"element\\\">MotorCortex\\n Textillate-Plugin</div>\\n  </div>\",\n  host: document.getElementById(\"clip\"),\n  containerParams: {\n    width: \"70%\",\n    height: \"100%\"\n  }\n};\n\n// Create clip\nvar clip = new MotorCortex.Clip(null, config);\nvar animation_1 = new TestPlugin.TestIncident({\n  animatedAttrs: {\n    left: 800,\n    opacity: 0\n  }\n}, {\n  id: \"animation_1\",\n  selector: \"#one\",\n  duration: 9000\n});\n\nclip.addIncident(animation_1, 0);\n\n// Add clip to timer\nnew Player({ clip: clip, theme: \"transparent on-top\" });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9pbmRleC5qcz8wNDk3Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1vdG9yQ29ydGV4ID0gcmVxdWlyZShcIi4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXhcIik7XG5jb25zdCBUZXN0UGx1Z2luRGVmaW5pdGlvbiA9IHJlcXVpcmUoXCIuL3Rlc3RQbHVnaW4vbWFpblwiKTtcbmNvbnN0IFBsYXllciA9IHJlcXVpcmUoXCIuLi9zcmMvUGxheWVyXCIpO1xuXG5jb25zdCBUZXN0UGx1Z2luID0gTW90b3JDb3J0ZXgubG9hZFBsdWdpbihUZXN0UGx1Z2luRGVmaW5pdGlvbik7XG5cbi8vIENvbmZpZ3VyZSBjbGlwXG5jb25zdCBjb25maWcgPSB7XG4gIGNzczogYFxuICAgIGJvZHl7XG4gICAgICBiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrO1xuICAgIH1cbiAgICAjb25lIHtcbiAgICAgIGZvbnQtc2l6ZTo0MHB4O1xuICAgICAgZGlzcGxheTogdGFibGUtY2VsbDtcbiAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG4gICAgICB0ZXh0LWFsaWduOmNlbnRlcjtcbiAgICAgIGZvbnQtZmFtaWx5OiBcIkNlbnR1cnkgR290aGljXCIsIENlbnR1cnlHb3RoaWMsIEFwcGxlR290aGljLCBzYW5zLXNlcmlmO1xuICAgICAgY29sb3I6IzRiNDc1ZjtcbiAgICAgIFxuICAgIH1cbiAgICAuY29udGFpbmVyIHtcbiAgICAgIGRpc3BsYXk6IHRhYmxlO1xuICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgd2lkdGg6IDgwJTtcbiAgICAgIGJhY2tncm91bmQtY29sb3I6IzI5MjkyOTtcbiAgICAgIG1hcmdpbi1sZWZ0OjEwJTtcbiAgICAgIGJvcmRlcjoycHggc29saWQgYmxhY2s7XG4gICAgfVxuICBgLFxuICBodG1sOiBgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgIDxkaXYgaWQ9XCJvbmVcIiBjbGFzcz1cImVsZW1lbnRcIj5Nb3RvckNvcnRleFxcbiBUZXh0aWxsYXRlLVBsdWdpbjwvZGl2PlxuICA8L2Rpdj5gLFxuICBob3N0OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNsaXBcIiksXG4gIGNvbnRhaW5lclBhcmFtczoge1xuICAgIHdpZHRoOiBcIjcwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCJcbiAgfVxufTtcblxuLy8gQ3JlYXRlIGNsaXBcbmNvbnN0IGNsaXAgPSBuZXcgTW90b3JDb3J0ZXguQ2xpcChudWxsLCBjb25maWcpO1xuY29uc3QgYW5pbWF0aW9uXzEgPSBuZXcgVGVzdFBsdWdpbi5UZXN0SW5jaWRlbnQoXG4gIHtcbiAgICBhbmltYXRlZEF0dHJzOiB7XG4gICAgICBsZWZ0OiA4MDAsXG4gICAgICBvcGFjaXR5OiAwXG4gICAgfVxuICB9LFxuICB7XG4gICAgaWQ6IFwiYW5pbWF0aW9uXzFcIixcbiAgICBzZWxlY3RvcjogXCIjb25lXCIsXG4gICAgZHVyYXRpb246IDkwMDBcbiAgfVxuKTtcblxuY2xpcC5hZGRJbmNpZGVudChhbmltYXRpb25fMSwgMCk7XG5cbi8vIEFkZCBjbGlwIHRvIHRpbWVyXG5uZXcgUGxheWVyKHsgY2xpcCwgdGhlbWU6IFwidHJhbnNwYXJlbnQgb24tdG9wXCIgfSk7XG4iXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdUJBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQTVCQTtBQUNBO0FBaUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUZBO0FBREE7QUFPQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TimedIncident = __webpack_require__(/*! ./TimedIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar checkTransition = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").checkTransition;\n\n/** @classdesc\n * A Scene is a TimeIncident that can have other Incidents (any kind of) on its timeline and its state mainly derives\n * from the state of its incidents rather than itself.\n */\n\nvar Group = function (_TimedIncident) {\n    _inherits(Group, _TimedIncident);\n\n    function Group() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, Group);\n\n        var attrsToPass = void 0,\n            propsToPass = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToPass = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToPass = oldProps;\n        }\n\n        var _this = _possibleConstructorReturn(this, (Group.__proto__ || Object.getPrototypeOf(Group)).call(this, attrsToPass, propsToPass));\n\n        _this.hasIncidents = true;\n        _this.isChannel = false;\n\n        /**\n          keyframes are special points on the Scene's time where Incidents should be executed\n          The keys of the keyframes array are the millisecond on which the keyframes should get executed:\n          e.g.:\n          keyframes = {\n                sec_2000: {\n                    incident_id: IncidentObject,\n                    incident_id: IncidentObject,\n                    ...\n                },\n                ...\n          }\n          */\n        _this.keyframes = {};\n\n        /**\n          An object holding the mapping incidentid / keyframekey, from which we can get the keyframe id as defined on\n          the this.keyframes object where the incident belongs to\n          e.g.:\n          incidentsKeyframeKeys = {\n                incidentid: sec_2000,\n                ...\n          }\n           */\n        _this.incidentsKeyframeKeys = {};\n\n        /**\n          The array holds the Incidents of the Scene on the format:\n          {\n                id // the id of the Incident object\n                incident // the incident object\n                millisecond // the millisecond the incident should be executed\n          }\n           */\n        _this.incidents = [];\n\n        /*\n        an object / associative array holding all Incidents in the form:\n        <incident_id>: Incident object\n         */\n        _this.incidentsById = {};\n\n        _this.calculatedDuration = 0;\n\n        /**\n         * The cnannels attribute holds a list of all intantiated Channels of the Incidents belonging to the clip\n         * this attribute is only valuable when the Group becomes the Clip\n         * The format of the attribute is:\n         *  key-value pairs in the manner:\n         * <mc_plugin_npm_name>: Channel object\n        */\n        _this.instantiatedChannels = {};\n\n        _this.isTheClip = false;\n\n        _this.onGroupInitialise();\n        return _this;\n    }\n\n    _createClass(Group, [{\n        key: 'onGroupInitialise',\n        value: function onGroupInitialise() {\n            // called when group gets initialised\n        }\n    }, {\n        key: '_getChannel',\n\n\n        /*\n        returns the initialised channel by the Clip the Incident belongs to\n        */\n        value: function _getChannel(mc_plugin_npm_name) {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject._getChannel(mc_plugin_npm_name);\n            } else {\n                return null;\n            }\n        }\n\n        /*\n        return the direct parent of a specific Incident\n        */\n\n    }, {\n        key: '_getDirectParent',\n        value: function _getDirectParent(incidentId) {\n            if (this.incidentsById.hasOwnProperty(incidentId)) {\n                return this;\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var directParent = this.incidents[i].incident._getDirectParent(incidentId);\n                        if (directParent != null) {\n                            return directParent;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Returns all of its Incidents (not groups) in a collection of the form:\n         * {\n                id,\n                millisecond\n                incident\n            }\n        */\n\n    }, {\n        key: 'getIncidentsByPlugin',\n\n\n        /**\n         * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n         * tree of the Group. All Incidents are projected to the Group's timeline.\n         * The array includes the Group's projection too\n        */\n        value: function getIncidentsByPlugin() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            // initially it only puts itself onthe incidentsByPlugin array, exactly as the plain Incidents do\n            var incidentsByPlugin = {};\n            incidentsByPlugin[this.mc_plugin_npm_name] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n\n            // if it is a self contained incident return just that\n            if (this.isTheClip) {\n                return incidentsByPlugin;\n            }\n\n            // otherwise proceed to gather the contained incidents as well\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incidentsToAdd = this.incidents[i].incident.getIncidentsByPlugin(adjustMillisecond + this.incidents[i].millisecond);\n                for (var key in incidentsToAdd) {\n                    if (incidentsByPlugin.hasOwnProperty(key)) {\n                        incidentsByPlugin[key] = incidentsByPlugin[key].concat(incidentsToAdd[key]);\n                    } else {\n                        incidentsByPlugin[key] = incidentsToAdd[key];\n                    }\n                }\n            }\n            return incidentsByPlugin;\n        }\n    }, {\n        key: 'checkStateTransition',\n        value: function checkStateTransition(targetState) {\n            if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * This method returns the Incidents of each Incident in array format holding the incidents in the structure:\n            {\n                id,\n                millisecond\n                incident\n            }\n            Depending on who asks for the incidents, it might pass the adjustMillisecond argument. This argument is\n            used in case a parent Group wants to receive the Incidents of its child but by passing a correction millisecond\n            that represents the millisecond the Incident starts on its parent's timeline.\n            @param {int} adjustMillisecond\n        */\n\n    }, {\n        key: 'getProjectedIncidents',\n        value: function getProjectedIncidents() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var projectedIncidents = [];\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incidentsToAdd = this.incidents[i].incident.getProjectedIncidents(adjustMillisecond + this.incidents[i].millisecond);\n                projectedIncidents = projectedIncidents.concat(incidentsToAdd);\n            }\n            return projectedIncidents;\n        }\n\n        // ******** METHODS TO CALCULATE OVERALL DURATION OF SCENE\n        // *******************************************************\n\n        /**\n         * called when an Incident of the Scene gets affected by an edit or a deletion. The command targets the\n         * root of the scenes tree where a recalc state and a set current millisecond should take place\n         */\n\n    }, {\n        key: 'getDurationAfterIncidentAffected',\n        value: function getDurationAfterIncidentAffected() {\n            var durationBeforeChange = this.duration * 1;\n            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;\n            var stateBeforeChage = this.state + '';\n\n            var newDuration = 0;\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i];\n                if (incident.incident.duration + incident.millisecond > newDuration) {\n                    newDuration = incident.incident.duration + incident.millisecond;\n                }\n            }\n            this.duration = newDuration;\n            // helper.log('duration changed on incident: ' + this.id + '. New duration: ' + newDuration);\n            if (this.duration != durationBeforeChange) {\n                this.broadcastEvent('duration-change', { newDuration: newDuration });\n            }\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            } else {\n                this.stop();\n                this.setCurrentMillisecond(currentMillisecondBeforeChange);\n                this.recalcState(currentMillisecondBeforeChange);\n                this.restore();\n            }\n        }\n\n        /**\n         * called when an Incident gets added on the Scene\n         * @param {int} startMillisecond\n         * @param {int} incidentDuration\n         */\n\n    }, {\n        key: 'getDurationAfterIncidentAdded',\n        value: function getDurationAfterIncidentAdded(startMillisecond, incidentDuration) {\n            var durationBeforeChange = this.duration * 1;\n            var currentMillisecondBeforeChange = this.runTimeInfo.currentMillisecond * 1;\n            // const stateBeforeRecal = this.state + \"\";\n\n            if (startMillisecond + incidentDuration > this.calculatedDuration) {\n                this.calculatedDuration = startMillisecond + incidentDuration;\n            }\n\n            if (this.duration != durationBeforeChange) {\n                this.broadcastEvent('duration-change', { newDuration: this.duration });\n            }\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            } else {\n                this.stop();\n                this.setCurrentMillisecond(currentMillisecondBeforeChange);\n                this.recalcState(currentMillisecondBeforeChange);\n                this.restore();\n            }\n        }\n\n        // ******** INCIDENT METHODS IMPLEMENTATION **************\n        // *******************************************************\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.isHeadlessClip) {\n                return false;\n            }\n            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'play', this).call(this, props);\n        }\n\n        /** timer blocking */\n\n    }, {\n        key: 'wait',\n        value: function wait() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'wait', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (props.callerId === this.incidents[i].id) continue;\n                    this.incidents[i].incident.block(props);\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /** timer blocking */\n\n    }, {\n        key: 'block',\n        value: function block(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'block', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.block();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /** timer unblocking */\n\n    }, {\n        key: 'resume',\n        value: function resume(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'resume', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.resume();\n                }\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'reset',\n        value: function reset(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'reset', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.reset();\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'stop',\n        value: function stop(props) {\n            if (_get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'stop', this).call(this, props)) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.stop();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n        */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState(targetMillisecondDeltaFromStart) {\n            _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'recalcState', this).call(this, targetMillisecondDeltaFromStart);\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i].incident;\n                var startMillisecond = this.incidents[i].millisecond;\n                incident.recalcState(targetMillisecondDeltaFromStart - startMillisecond);\n            }\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.lastWish();\n            }\n            this.stop();\n        }\n\n        // *******************************************************\n        // SCENE SPECIFIC FUNCTIONS / HELPER FUNCTIONS\n\n    }, {\n        key: 'reverse',\n        value: function reverse(_reverse) {\n            this.reversed = _reverse;\n        }\n    }, {\n        key: 'getIncidentMillisecond',\n        value: function getIncidentMillisecond(incidentId) {\n            return conf.getMillisecondFromKeyframeKey(this.incidentsKeyframeKeys[incidentId]);\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            var incidents = [];\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = {};\n                incident.millisecond = this.incidents[i].millisecond;\n                incident.incident = this.incidents[i].incident.exportState(props);\n                incident.id = this.incidents[i].id;\n                incidents.push(incident);\n            }\n\n            var state = _get(Group.prototype.__proto__ || Object.getPrototypeOf(Group.prototype), 'exportState', this).call(this);\n            state.incidents = incidents;\n\n            return state;\n        }\n    }, {\n        key: 'setCurrentMillisecond',\n        value: function setCurrentMillisecond(millisecond) {\n            // helper.log(`setting currentUser of ${this.id} to ${millisecond}`);\n            this.runTimeInfo.currentMillisecond = millisecond;\n\n            for (var i = 0; i < this.incidents.length; i++) {\n                var childIncident = this.incidents[i];\n\n                // if the child incident starts before the millisecond and has not ended yet\n                if (childIncident.millisecond < millisecond && childIncident.incident.duration + childIncident.millisecond > millisecond) {\n                    childIncident.incident.setCurrentMillisecond(millisecond - childIncident.millisecond);\n                } else {\n                    childIncident.incident.setCurrentMillisecond(0);\n                }\n            }\n        }\n\n        /**\n         * Returns the Incident by ID no matter if the Incident balongs directly to the Scene of to a child Scene\n         * @param {string} id - the id of the Incident to get\n        */\n\n    }, {\n        key: 'getIncidentById',\n        value: function getIncidentById(id) {\n            if (this.incidentsById.hasOwnProperty(id)) {\n                return this.incidentsById[id];\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        var incident = this.incidents[i].incident.getIncidentById(id);\n                        if (incident != null) {\n                            return incident;\n                        }\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        // *******************************************************\n        // INCIDENTS MANAGEMENT METHODS\n        // POLYMORPHISM APPLIED. IF THE GROUP HAS NO PARENT IT ACTS AS A SCENE. IF THE GROUP HAS PARENT IT ACTS AS\n        // A \"TRANSPARENT GROUP\"\n\n        /**\n         * The checkAddition method serves exactly what its name implies. To check if the addition of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip by carrying adjusting the millisecond.\n         * The method takes as input the management type. On error / conflict:\n         *  - on type === 'all-or-nothing' completely discard addition of all incidents\n         *  - on type === 'keep-passing' it will only add the passing incidents no matter if some other incidents of the addition failed\n         * @param {object} incident - the incident to add\n         * @param {int} millisecond - the millisecond to add the Incident to\n         * @param {string} type - as explained above\n         * The method returns either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incident, millisecond) {\n            var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"all-or-nothing\";\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip) {\n                var existingIncidentWithTheSameId = this.getIncidentById(incident.id);\n                if (existingIncidentWithTheSameId != null) {\n                    return { result: false, errors: [{ reason: 'Already existing Incident with id ' + incident.id, incident: existingIncidentWithTheSameId }] };\n                }\n\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin(millisecond);\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n\n                // for each key of the incidentsById object perform the check\n                for (var key in incidentsById) {\n                    // if the clip had no channel instantiated for the specific key (plugin id) yet create it\n                    if (!this.instantiatedChannels.hasOwnProperty(key)) {\n                        // intstantiate the channel of the plugin by using the reference to the class definition stored on\n                        // the very first incident of the array\n                        this.instantiatedChannels[key] = new incidentsById[key][0].incident.plugin_channel_class({\n                            runTimeInfo: this.runTimeInfo,\n                            context: this.context\n                        });\n                    }\n\n                    // perform the check\n                    var pluginResult = this.instantiatedChannels[key].addIncidents(incidentsById[key], type);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var additionResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return additionResult;\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkAddition(incident, millisecond + this.parentSceneObject.getIncidentMillisecond(this.id), type);\n            }\n        }\n\n        /**\n         * The checkEdit method serves exactly what its name implies. To check if the edit of an Incident (edit of Incident's position given in milliseconds delta)\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {int} millisecondsDelta - the milliseconds delta of the Incident's start time\n         The method should return either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will edit the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incident, millisecondsDelta) {\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip) {\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n\n                // for each key of the incidentsById object perform the check\n                for (var key in incidentsById) {\n                    // perform the check\n                    var pluginResult = this.instantiatedChannels[key].editIncidents(incidentsById[key], millisecondsDelta);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkEdit(incident, millisecondsDelta);\n            }\n        }\n\n        /**\n         * The checkDelete method serves exactly what its name implies. To check if the deletion of an Incident\n         * is valid and accepted, according to the rules defined on the channels.\n         * The method boobles up until it reaches the Clip.\n         * @param {object} incident - the incident to edit\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n          The result might be either:\n            {\n                result:true,\n                execute: // an array of functions that when executed it will remove the Incident on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentId) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip) {\n                var incident = this.getIncidentById(incidentId);\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n\n                // for each key of the incidentsById object perform the check\n                for (var key in incidentsById) {\n                    // perform the check\n                    var pluginResult = this.instantiatedChannels[key].removeIncidents(incidentsById[key], props);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkDelete(incidentId, props);\n            }\n        }\n\n        /**\n         * It's called always by a child to Scene that wants to expand to the left to its parent.\n         * Expanding a Scene to the left means it tries to add extra (initially unsued) space (in milliseconds) before its\n         * current starting point.\n         * In order for this action to be allowed the Scene's context should allow such an expansion. This means:\n         *  - that if the Scene has no parents this expansion is not legal\n         *  - that if the root Scene of the Scene's parents tree needs to expand on the left in order to apply the expansion\n         *      then the expansion is not acceptable\n         * @param {int} howManyMilliseconds - the milliseconds to expand the Scene to the left\n         * @param {string} sceneId - the child scene id that wants to gain extra space to the left\n         * @returns {object} - the result is an object with two keys:\n         *  - the first key is the \"result\" which might either be true or false\n         *  - the second key is the \"undo\" which is a function that can undo the (approved) expansion\n        */\n\n    }, {\n        key: 'expandSceneToTheLeft',\n        value: function expandSceneToTheLeft(howManyMilliseconds, sceneId) {\n            var _this2 = this;\n\n            // First we identify the expansion within the context of the parent (this) Scene\n            var currentStartMillisecondOfTheChildScene = this.getIncidentMillisecond(sceneId);\n            var newStartMillisecondOfTheChildScene = howManyMilliseconds - currentStartMillisecondOfTheChildScene;\n\n            // Check if the expansion is allowed\n            // if the millisecons to expand are zero or less (meaning the current Scene is actually not affected by the expansion)\n            if (newStartMillisecondOfTheChildScene <= 0) {\n                var rootScene = this;\n                var changeResult = this.changeIncidentsStartMillisecond(-newStartMillisecondOfTheChildScene, sceneId);\n                var undo = function undo() {\n                    _this2.changeIncidentsStartMillisecond(changeResult.oldMillisecond, sceneId);\n                };\n                return {\n                    result: true,\n                    undo: undo,\n                    rootScene: rootScene\n                };\n            }\n\n            // if it reaches to that point that means the expansion afects the left borders of this (parent) Scene as well\n            // If it doesn't have a parent scene that means the expansion is illegal\n            if (!this.checkParentScene()) {\n                return {\n                    result: false\n                };\n            }\n\n            // if it has a parent scene and the this Scene needs to expand to the left as well then this Scene\n            // assigns the obligation to evaluate the expansion to its parent\n            var parentDecision = this.parentSceneObject.expandSceneToTheLeft(newStartMillisecondOfTheChildScene, this.id);\n            // if the parent approves the expansion\n            if (parentDecision.result === true) {\n                // TODO apply the expansion itself and bundle its undo along with the undo coming from the parent\n                this.expandStartPoint(-newStartMillisecondOfTheChildScene);\n                var overallUndo = function overallUndo() {\n                    parentDecision.undo();\n                    _this2.expandStartPoint(newStartMillisecondOfTheChildScene);\n                };\n                return {\n                    result: true,\n                    undo: overallUndo,\n                    rootScene: parentDecision.rootScene\n                };\n            } else {\n                // otherwise\n                return {\n                    result: false\n                };\n            }\n        }\n\n        /**\n         * expands or collapses the Scene's start millisecond by the given milliseconds\n         * e.g. expandStartPoint(200) will expand the Scene by 200 milliseconds to the left keeping all\n         *      of its incidents to the exact same place they were before on the overall timeline\n         * e.g. expandStartPoint(-200) will collapse the Scene, moving its start point by 200 milliseconds\n         *      to the right, again without affecting at all its Incidents' start point on the overall timeline\n         * @param {int} byMilliseconds - the number of milliseconds to expand (positive number) or collapse (minus number) number of milliseconds\n        */\n\n    }, {\n        key: 'expandStartPoint',\n        value: function expandStartPoint(byMilliseconds) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                var incident = this.incidents[i];\n                this.changeIncidentsStartMillisecond(incident.millisecond + byMilliseconds, incident.id);\n            }\n        }\n\n        /**\n         * it alters the start millisecond of any already existing Incident of the Scene\n         * @param {int} newmillisecond - the new millisecond to place the Incident\n         * @param {string} incidentId - the incident id\n         * @returns {function} - the undo function of the change\n        */\n\n    }, {\n        key: 'changeIncidentsStartMillisecond',\n        value: function changeIncidentsStartMillisecond(newmillisecond, id) {\n            var keyframe_sec_key = this.incidentsKeyframeKeys[id];\n            //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined\n            delete this.keyframes[keyframe_sec_key][id];\n\n            if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {\n                delete this.keyframes[keyframe_sec_key];\n            }\n\n            delete this.listeners[id]; // delete the listener that currently manages the Incident's execution\n\n\n            var oldMillisecond = void 0; // the previous millisecond of the edited incident before the edit\n            for (var i = 0; i < this.incidents.length; i++) {\n                if (this.incidents[i].id === id) {\n                    oldMillisecond = this.incidents[i].millisecond * 1; // *1 to avoid reference, keep value\n                    this.incidents[i].millisecond = newmillisecond;\n                    break;\n                }\n            }\n\n            var incident = this.incidentsById[id];\n            var new_keyframe_sec_key = conf.keyframe_sec_key + newmillisecond;\n            if (!this.keyframes.hasOwnProperty(new_keyframe_sec_key)) {\n                this.keyframes[new_keyframe_sec_key] = {};\n            }\n            this.keyframes[new_keyframe_sec_key][incident.id] = incident;\n            this.incidentsKeyframeKeys[incident.id] = new_keyframe_sec_key;\n\n            // subscribe Incident start on the listeners\n            var funct = function funct(sceneMillisecond, previousTimeStamp, sceneState) {\n                if (sceneMillisecond >= newmillisecond && sceneMillisecond <= newmillisecond + incident.duration) {\n                    incident.play({ startFrom: sceneMillisecond - newmillisecond, previousTimeStamp: previousTimeStamp });\n                }\n            };\n\n            this.subscribe(incident.id, funct);\n\n            return {\n                oldMillisecond: oldMillisecond,\n                incident: incident\n            };\n        }\n\n        /**\n         * Plain groups\n            Can have on their timeline:\n            - Another plain group\n            - An incident with no selector\n            - A dom group (this method should actually turn any incident with selector to one)\n            Can’t have on their timeline:\n            - An attribute group\n         */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.props.hasOwnProperty('selector') && !incident.hasIncidents) {\n                // if the incident is not a group and it has no selector proceed normally\n                return incident;\n            } else if (incident.groupType === \"plain\") {\n                // if the Incident is a plain group proceed normally\n                return incident;\n            } else if (incident.groupType === \"attribute\") {\n                helper.error(\"Plain groups can not accept attribute groups on their timeline\");\n                return null;\n            }\n\n            // We need to turn the Incident to a DOMAwareIncident\n            // before adding it to the group\n            var DOMAwareIncident = __webpack_require__(/*! ../_responsiveness/DOMAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\");\n            var theDOMAwareIncident = new DOMAwareIncident(incident);\n            return theDOMAwareIncident;\n        }\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            var result = {\n                failedAdditions: []\n            };\n            for (var i = 0; i < this.incidents.length; i++) {\n                var flashResult = this.incidents[i].incident.flashDOM();\n                result.failedAdditions = result.failedAdditions.concat(flashResult.failedAdditions);\n            }\n            return result;\n        }\n\n        /**\n        Any Scene can receive the addIncdent command either for adding an Incident on its own Incidents list or in order\n        to pass deeper the command to the parent Scene of the Incident (sceneId).\n        No matter which Scene took the command, all parent Scenes get informed\n         addIncident takes 3 arguments:\n        @param {Incident} incident - the Incident object to get added\n        @param {int} millisecond - the millisecond to which we want the Incident to get added, starting from the zero point of the\n            target Scene. It can't be negative\n        @param {string} sceneId - the sceneId to which we want to put the new Incident. It is optional and if it is not specified the\n            target Scene is the current one\n        @param {string} type - one of \"all-or-nothing\" / \"keep-passing\"\n         */\n\n    }, {\n        key: 'addIncident',\n        value: function addIncident(incident, millisecond, sceneId) {\n            var type = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"all-or-nothing\";\n\n            if (millisecond < 0) {\n                return {\n                    result: false,\n                    conflicts: [{\n                        type: 'minus millisecond violation'\n                    }]\n                };\n            }\n\n            var originalMillisecond = millisecond * 1; // a backup variable holding the original millisecond passed as\n            // this might change during potential left expansion manipulation\n\n            if (!sceneId || sceneId === this.id) {\n                var that = this;\n                incident = this._prepareInicdentForAddition(incident);\n\n                // when adding headless Clips to a group that has context (either because it's the clip itself or because\n                // it belongs to a clip that has context) we need to run flash the newly entered group's dom so it creates\n                // its elementIncidents\n                var flashIncidentsDOMAfterEnter = false;\n\n                if (incident.hasIncidents && incident.isHeadlessClip && this.context != null) {\n                    flashIncidentsDOMAfterEnter = true;\n                }\n\n                incident.setParentScene(that);\n\n                // check if the Incident is eligible for addition\n                var additionCheck = this.checkAddition(incident, millisecond, type);\n                if (additionCheck.result === false) {\n                    return additionCheck;\n                }\n                additionCheck.execute();\n\n                // indexing start\n                this.incidents.push({\n                    id: incident.id,\n                    incident: incident,\n                    millisecond: millisecond\n                });\n                this.incidentsById[incident.id] = incident;\n                var keyframe_sec_key = conf.keyframe_sec_key + millisecond;\n                if (!this.keyframes.hasOwnProperty(keyframe_sec_key)) {\n                    this.keyframes[keyframe_sec_key] = {};\n                }\n                this.keyframes[keyframe_sec_key][incident.id] = incident;\n                this.incidentsKeyframeKeys[incident.id] = keyframe_sec_key;\n                // indexing end\n\n                incident.executionSpeed = this.speed;\n\n                // subscribe Incident start on the listeners\n                // currentMillisecond: the millisecond the Group is on\n                // millisecond: the millisecond we set our Incident to get executed on the Group's timeline\n                var funct = function funct(currentMillisecond, previousTimeStamp, sceneState) {\n                    if (incident.speed > 0) {\n                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'idle' && currentMillisecond > millisecond) {\n                            // helper.log('greater');\n                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });\n                        }\n                    } else {\n                        if (currentMillisecond >= millisecond && currentMillisecond <= millisecond + incident.duration || incident.state === 'completed' && currentMillisecond < millisecond) {\n                            // helper.log('greater');\n                            incident.play({ startFrom: currentMillisecond - millisecond, previousTimeStamp: previousTimeStamp });\n                        }\n                    }\n                };\n\n                this.subscribe(incident.id, funct);\n                this.getDurationAfterIncidentAdded(millisecond, incident.duration);\n\n                if (flashIncidentsDOMAfterEnter) {\n                    var result = incident.flashDOM();\n                    if (result.failedAdditions.length > 0 && type === \"all-or-nothing\") {\n                        this.removeIncident(incident.id);\n                        return {\n                            result: false,\n                            conflicts: result.failedAdditions\n                        };\n                    } else {\n                        // if flashing incident's DOM passes let the Incident know that\n                        // it now has context\n                        incident._onGetContextOnce();\n                        this.onAddIncident(incident, millisecond);\n                        helper.notice('incident added');\n\n                        return {\n                            result: true\n                        };\n                    }\n                } else {\n                    this.onAddIncident(incident, millisecond);\n                    helper.notice('incident added');\n                    return { result: true };\n                }\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        if (this.incidents[i].incident.addIncident(incident, millisecond - this.incidents[i].millisecond, sceneId).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n        Any Scene can receive the editIncident command in order to set a new starting point for one of its own Incidents or to\n        pass the command deeper down to its children Scenes so the parent of it can take care of it.\n        The Incident object and id remain the same after the edit.\n        No matter which Scene takes the command, all Parents get infomed about the edit.\n         It takes two params:\n         @param {string} id - the id of the incident to be edited\n         @param {int} newmillisecond - the new position of the Incident compared to the target Scene start (and not to the Scene it belongs)\n         */\n\n    }, {\n        key: 'editIncident',\n        value: function editIncident(id, newmillisecond) {\n            var expansionValidation = null;\n            var originalMillisecond = newmillisecond * 1;\n\n            if (!helper.isString(id)) {\n                helper.error('editIncident method of Group expects as its first argument the id of the Incident to edit in string format. ' + (typeof id === 'undefined' ? 'undefined' : _typeof(id)) + ' passed');\n                return {\n                    result: false,\n                    conflicts: [{\n                        type: 'wrong parameter type'\n                    }]\n                };\n            }\n\n            if (this.incidentsById[id]) {\n                var existingMillisecond = this.getIncidentMillisecond(id);\n                var millisecondDelta = newmillisecond - existingMillisecond;\n                // first check for minus expansion\n                if (newmillisecond < 0) {\n                    // if the Scene doesn't have a parent then it is the root and thus it can't expand to the left\n                    if (!this.checkParentScene()) {\n                        return {\n                            result: false,\n                            conflicts: [{\n                                type: 'minus millisecond violation'\n                            }]\n                        };\n                    }\n\n                    expansionValidation = this.parentSceneObject.expandSceneToTheLeft(-newmillisecond, this.id);\n                    if (expansionValidation.result === false) {\n                        return {\n                            result: false,\n                            conflicts: [{\n                                type: 'minus millisecond violation'\n                            }]\n                        };\n                    } else {\n                        newmillisecond = 0;\n                    }\n                } // end of if millisecond < 0\n\n                // if the edit is allowed (thus we come to that point) and the originalMillisecond is lower than 0\n                if (originalMillisecond < 0) {\n                    this.expandStartPoint(-originalMillisecond);\n                }\n\n                this.incidentsById[id].stop();\n\n                var editCheck = this.checkEdit(this.incidentsById[id], millisecondDelta);\n                if (editCheck.result === false) {\n                    helper.error(editCheck);\n                    if (expansionValidation !== null) {\n                        expansionValidation.undo();\n                        this.expandStartPoint(originalMillisecond);\n                    }\n                    return editCheck;\n                }\n\n                editCheck.execute();\n\n                var editIncidentStartResult = this.changeIncidentsStartMillisecond(newmillisecond, id);\n\n                this.getDurationAfterIncidentAffected();\n\n                this.onEditIncident(this.incidentsById[id], editIncidentStartResult.oldMillisecond, newmillisecond);\n\n                return { result: true };\n            } else {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].incident.hasIncidents) {\n                        if (this.incidents[i].incident.editIncident(id, newmillisecond - this.incidents[i].millisecond).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n        Any Scene can receive the removeIncident command either for removing one of its own Incidents or for passing the command\n        deeper down to its Scenes tree and have the Incident deleted no matter to which child Scene it belongs\n        No matter which Scene took the command, all parent Scenes get informed\n         It takes just one argument:\n        @param {string} id - the id of the Incident to be deleted\n        @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessary\n         */\n\n    }, {\n        key: 'removeIncident',\n        value: function removeIncident(id) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            if (this.incidentsById[id]) {\n                var deleteCheck = this.checkDelete(id, props);\n                if (deleteCheck.result === false) {\n                    helper.error(deleteCheck);\n                    return deleteCheck;\n                }\n\n                deleteCheck.execute();\n\n                this.incidentsById[id].lastWish();\n\n                var keyframe_sec_key = this.incidentsKeyframeKeys[id];\n                //OPTIMIZE delete is slow on v8 engine we should check if we can achieve the same result by setting the value of the key to undefined\n                delete this.incidentsKeyframeKeys[id];\n                delete this.keyframes[keyframe_sec_key][id];\n                delete this.incidentsById[id];\n                if (Object.keys(this.keyframes[keyframe_sec_key]).length === 0) {\n                    delete this.keyframes[keyframe_sec_key];\n                }\n                delete this.listeners[id]; // delete the listener that manages the Incident's execution\n\n                var deletedIncident = void 0;\n                for (var i = 0; i < this.incidents.length; i++) {\n                    if (this.incidents[i].id === id) {\n                        deletedIncident = this.incidents.splice(i, 1);\n                        break;\n                    }\n                }\n\n                this.getDurationAfterIncidentAffected();\n                this.onRemoveIncident(deletedIncident[0]);\n\n                return { result: true };\n            } else {\n                for (var _i = 0; _i < this.incidents.length; _i++) {\n                    if (this.incidents[_i].incident.hasIncidents) {\n                        if (this.incidents[_i].incident.removeIncident(id).result === true) {\n                            return { result: true };\n                        }\n                    }\n                } // if it reaches the end of the loop without having returned true\n                return { result: false };\n            }\n        }\n\n        /**\n         * This method which is provided only by Groups accepts an incidentId and a new duration and \n         * edits the duration of the corresponding incident accordingly\n         * @param {string} incidentId - the id of the incident to resize\n         * @param {int} newDuration - the new duration of the incident in milliseconds\n        */\n\n    }, {\n        key: 'resizeIncident',\n        value: function resizeIncident(incidentId, newDuration) {\n            var existingIncident = this.getIncidentById(incidentId);\n            if (existingIncident === null) {\n                return { result: false, errors: [{ reason: 'The incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups' }] };\n            }\n            return existingIncident.resize(newDuration);\n        }\n\n        /**\n         * This method which is provided only by Groups accepts an incidentId and a new attrs object \n         * and edits the attributes of the corresponding incident accordingly\n         * If the attribute editing ends up with conflicts the edit is discarded.\n         * @param {string} incidentId - the id of the incident to resize\n         * @param {int} attrs - the new attrs of the Incident\n        */\n\n    }, {\n        key: 'editIncidentAttributes',\n        value: function editIncidentAttributes(incidentId, attrs) {\n            var directParent = this._getDirectParent(incidentId);\n            if (directParent === null) {\n                return {\n                    result: false,\n                    errors: ['The Incident with id ' + incidentId + ' does not belong to the Group or any of its child Groups']\n                };\n            }\n            return directParent._editChildIncidentAttributes(incidentId, attrs);\n        }\n\n        /**\n         * By this method a Group tries to edit the attributes of one of its children. The process goes as follows:\n         * 1. The Group gets an export of the Incident's state\n         * 2. The Group deletes the Incident\n         * 3. The Group tries to create a new Incident with the same id as the old one and with type=\"all-or-nothing\"\n         * 4.a. If the new Incident gets added ok process finishes\n         * 4.b. If the new Incident doesn't get added because of conflicts the previous Incident gets back in\n         * @param {string} incidentId - the id of the Incident to edit its attrs\n         * @param {object} attrs - the new attributes of the Incident\n        */\n\n    }, {\n        key: '_editChildIncidentAttributes',\n        value: function _editChildIncidentAttributes(incidentId, attrs) {\n            var incidentToEdit = this.getIncidentById(incidentId);\n            var existingIncidentDefinition = incidentToEdit.exportState();\n            var millisecond = this.getIncidentMillisecond(incidentId);\n            this.removeIncident(incidentId);\n            var newIncidentProps = Object.assign({}, existingIncidentDefinition.props);\n            var newIncident = new existingIncidentDefinition.Incident(attrs, newIncidentProps);\n            var result = this.addIncident(newIncident, millisecond);\n            if (result.result === false) {\n                var myOldIncident = new existingIncidentDefinition.Incident(existingIncidentDefinition.attrs, newIncidentProps);\n                this.addIncident(myOldIncident, millisecond);\n                return result;\n            } else {\n                return {\n                    result: true\n                };\n            }\n        }\n\n        /**\n         * Starting from itself and going all the way down to each and every leaf of its tree it systols/diastoles the\n         * Incidents\n         * @param {float} durationFraction the fraction of the new duration to the existing duration\n        **/\n\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            this.calculatedDuration = durationFraction * this.duration;\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.changeIncidentsStartMillisecond(this.incidents[i].millisecond * durationFraction, this.incidents[i].incident.id);\n                this.incidents[i].incident.systolDiastole(durationFraction);\n            }\n\n            // if it is a Clip all Channels of it should get resized\n            if (this.isTheClip) {\n                for (var key in this.instantiatedChannels) {\n                    this.instantiatedChannels[key]._resize(durationFraction);\n                }\n            }\n        }\n\n        // THE \"EARS\" OF THE SCENE TO ITS CHILD INCIDENTS\n        /**\n              NEW STATE CALCULATION RULES:\n              If a Scene has at least one clipBlockingWaiting (meaning the full Clip is halted at the moment) the Scene’s state will be “clipBlockingWaiting” unless it is the Clip so its state will be “waiting”.\n              If a Scene has all children on the completed state, the Scene has the completed state as well.\n              If a Scene has at least one of its children on one of the following states:\n                    waiting     it has started playing and has been halted internally\n                    playing     it has started playing\n                    idle            it has not been executed yet\n              the Scene is on playing state\n               */\n\n    }, {\n        key: 'incidentStateChange',\n        value: function incidentStateChange(id, oldState, newState, props) {\n            if (newState === 'clipBlockingWaiting' || newState === 'sceneBlockingWaiting') {\n                var propsToPass = props;\n                propsToPass.callerId = id;\n                if (newState === 'sceneBlockingWaiting') {\n                    // stop propagation as this should only affect the Scene and not its parents\n                    props.waitingStateName = 'waiting';\n                }\n                this.wait(propsToPass);\n            } else if (newState === 'completed' && this.speed > 0) {\n                // helper.log('Incident ' + id + ' got into completed state');\n                // helper.log('Incident ' + this.id + ' takes care of it');\n                var allCompleted = true;\n                // helper.log('going to iterate on all Incidents');\n                for (var i = 0; i < this.incidents.length; i++) {\n                    // helper.log(\n                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state\n                    // );\n                    if (this.incidents[i].incident.state != 'completed') {\n                        allCompleted = false;\n                        break;\n                    }\n                }\n                if (allCompleted) {\n                    this.complete();\n                }\n            } else if (newState === 'idle' && this.speed < 0) {\n                // helper.log('Incident ' + id + ' got into completed state');\n                // helper.log('Incident ' + this.id + ' takes care of it');\n                var _allCompleted = true;\n                // helper.log('going to iterate on all Incidents');\n                for (var _i2 = 0; _i2 < this.incidents.length; _i2++) {\n                    // helper.log(\n                    //     this.incidents[i].incident.id + '.state = ' + this.incidents[i].incident.state\n                    // );\n                    if (this.incidents[_i2].incident.state != 'idle') {\n                        _allCompleted = false;\n                        break;\n                    }\n                }\n                if (_allCompleted) {\n                    this.complete();\n                }\n            } else {\n                // in case the child was either on sceneBlockingWaiting or clipBlockingWaiting and now is changing\n                this.resume();\n            }\n        }\n\n        /*\n        BLOCK WAITINGS MANIPULATION METHODS\n        */\n        /**\n        @param {object} props -\n        the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - channelBlockingWaiting\n             - clipBlockingWaiting\n        id: the id of the triggering Incident\n        */\n\n    }, {\n        key: 'setBlockWaiting',\n        value: function setBlockWaiting(props) {\n            if (props.waitingStateName === 'sceneBlockingWaiting') {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else if (props.waitingStateName === 'channelBlockingWaiting' && this.isChannel) {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else if (props.waitingStateName === 'clipBlockingWaiting' && this.isTheClip) {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.wait(props);\n                this.blockingWaitings.push(props);\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.setBlockWaiting(props);\n                }\n            }\n        }\n\n        /**\n         @param {object} props -\n        the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - channelBlockingWaiting\n             - clipBlockingWaiting\n        id: the id of the triggering Incident\n        */\n\n    }, {\n        key: 'unsetBlockWaiting',\n        value: function unsetBlockWaiting(props) {\n            if (props.waitingStateName === 'sceneBlockingWaiting') {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else if (props.waitingStateName === 'channelBlockingWaiting' && this.isChannel) {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else if (props.waitingStateName === 'clipBlockingWaiting' && this.isTheClip) {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.removeBlock(props);\n                if (this.blockingWaitings.length === 0) {\n                    this.unblock();\n                }\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.unsetBlockWaiting(props);\n                }\n            }\n        }\n\n        /**\n         * it checks if a block with the provided props exists on its blockingWaitings array\n         * if it exists it removes it.\n         * If the remaining blocking waitings are equal to 0 it returns true otherwise it returns false\n        */\n\n    }, {\n        key: 'removeBlock',\n        value: function removeBlock(props) {\n            var newBlockingWaitings = [];\n            var found = false;\n            for (var i = 0; i < this.blockingWaitings.length; i++) {\n                var bWaiting = this.blockingWaitings[i];\n                if (bWaiting.id === props.id) {\n                    found = true;\n                    continue;\n                }\n                newBlockingWaitings.push(this.blockingWaitings[i]);\n            }\n\n            this.blockingWaitings = newBlockingWaitings;\n            return found;\n        }\n\n        /**\n         * goTo method should always be handled by the Clip. No other Group nor Incident can handle goTo alone.\n         * Thus, if the Group is not the Clip it passes the command up. If the Group is the Clip then it handles goTo\n         * by passing the command to its Channels.\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            if (millisecond > this.duration) {\n                millisecond = this.duration;\n            } else if (millisecond < 0) {\n                millisecond = 0;\n            }\n\n            if (this.isTheClip) {\n                for (var key in this.instantiatedChannels) {\n                    this.instantiatedChannels[key].goTo(millisecond, props);\n                }\n                return true;\n            } else if (this.isHeadlessClip) {\n                return false;\n            } else {\n                props.relativeTo = this.id;\n                if (this.parentSceneObject.goTo(millisecond, props)) {\n                    return true;\n                }\n            }\n        }\n\n        /**\n         * when the Group is on test mode (this.isOnTestMode = true) the emulateStep method\n         * becomes functional.\n         * The method takes as input the millisecondsDelta from the previous timestamp and triggers\n         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run\n         * passing a timestamp that has exactly millisecondsDelta difference from the previous one\n         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one\n        */\n\n    }, {\n        key: 'emulateStep',\n        value: function emulateStep(millisecondsDelta) {\n            if (!this.isOnTestMode) {\n                helper.error('emulateStep method can only be used on test mode');\n            } else {\n                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);\n                for (var i = 0; i < this.incidents.length; i++) {\n                    var childIncident = this.incidents[i];\n\n                    if (childIncident.incident.state === \"playing\") {\n                        childIncident.incident.emulateStep(Math.abs((this.runTimeInfo.currentMillisecond - childIncident.millisecond - childIncident.incident.runTimeInfo.currentMillisecond) / this.speed));\n                    }\n                }\n            }\n        }\n\n        /**\n         * The Scene receives this command from its chilren and the purpose of it is to help the caller\n         * identify the milliseconds delta of its start compared to the root Scene of it.\n         * In a multi-level situation with Scenes within scenes the Scene that receives this command might not own\n         * the Incident that triggered this thread directly. That's why we use the extraDelta helping parameter that\n         * actually delivers level by level the delta of the triggering Incident within the tree\n         * @param {string} incidentId = the id of the child incident of the scene that trigerred the method\n         * @param {int} extraDelta - the extra delta to add to the result\n        **/\n\n    }, {\n        key: 'getRootCurrentMillisecondDeltaFromIncidentsStart',\n        value: function getRootCurrentMillisecondDeltaFromIncidentsStart(incidentId) {\n            var extraDelta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n            // first step find the start millisecond of the incident\n            var incidentMillisecond = this.getIncidentMillisecond(incidentId);\n            if (!this.checkParentScene()) {\n                return this.runTimeInfo.currentMillisecond - incidentMillisecond - extraDelta;\n            } else {\n                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id, incidentMillisecond + extraDelta);\n            }\n        }\n\n        /*\n        CALLBACKS AFTER SUCCESSFUL ADDING / EDITING / DELETING AN INCIDENT\n         */\n\n    }, {\n        key: 'onAddIncident',\n        value: function onAddIncident(incident, millisecond) {}\n    }, {\n        key: 'onEditIncident',\n        value: function onEditIncident(incident, oldMillisecond, newMillisecond) {}\n    }, {\n        key: 'onRemoveIncident',\n        value: function onRemoveIncident(incident) {}\n\n        // on Groups there is no need to prevent re-invoking the onGetContext method\n\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            this.onGetContext();\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident._onGetContextOnce();\n            }\n        }\n    }, {\n        key: 'duration',\n        get: function get() {\n            return this.calculatedDuration;\n        },\n        set: function set(duration) {\n            this.calculatedDuration = duration;\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"plain\";\n        }\n    }, {\n        key: 'projectedIncidents',\n        get: function get() {\n            return this.getProjectedIncidents();\n        }\n    }, {\n        key: 'executionSpeed',\n        set: function set(speed) {\n            helper.notice(this.id + ' is setting its execution speed to: ' + speed + ' while on millisecond: ' + this.runTimeInfo.currentMillisecond);\n            if (speed === 0) {\n                helper.error(\"Speed can't be 0\");\n                return false;\n            }\n\n            this.speed = speed;\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.executionSpeed = speed;\n            }\n        }\n    }, {\n        key: 'isHeadlessClip',\n        get: function get() {\n            return !this.checkParentScene() && !this.isTheClip;\n        }\n    }, {\n        key: 'context',\n        get: function get() {\n            if (this.isTheClip) {\n                return this.ownContext;\n            } else if (this.isHeadlessClip) {\n                return null;\n            } else {\n                return this.parentSceneObject.context;\n            }\n        }\n    }]);\n\n    return Group;\n}(TimedIncident);\n\nmodule.exports = Group;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9Hcm91cC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL0dyb3VwLmpzP2ZmZTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KG9iamVjdCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyByZXR1cm4gZ2V0KHBhcmVudCwgcHJvcGVydHksIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKFwidmFsdWVcIiBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVGltZWRJbmNpZGVudCA9IHJlcXVpcmUoJy4vVGltZWRJbmNpZGVudCcpO1xudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgY2hlY2tUcmFuc2l0aW9uID0gcmVxdWlyZSgnLi4vY29uZmlndXJhdGlvbi9hbGxvd2VkU3RhdGVDaGFuZ2VzJykuY2hlY2tUcmFuc2l0aW9uO1xuXG4vKiogQGNsYXNzZGVzY1xuICogQSBTY2VuZSBpcyBhIFRpbWVJbmNpZGVudCB0aGF0IGNhbiBoYXZlIG90aGVyIEluY2lkZW50cyAoYW55IGtpbmQgb2YpIG9uIGl0cyB0aW1lbGluZSBhbmQgaXRzIHN0YXRlIG1haW5seSBkZXJpdmVzXG4gKiBmcm9tIHRoZSBzdGF0ZSBvZiBpdHMgaW5jaWRlbnRzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAqL1xuXG52YXIgR3JvdXAgPSBmdW5jdGlvbiAoX1RpbWVkSW5jaWRlbnQpIHtcbiAgICBfaW5oZXJpdHMoR3JvdXAsIF9UaW1lZEluY2lkZW50KTtcblxuICAgIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgb2xkUHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyb3VwKTtcblxuICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSB2b2lkIDAsXG4gICAgICAgICAgICBwcm9wc1RvUGFzcyA9IHZvaWQgMDtcblxuICAgICAgICAvKlxuICAgICAgICBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gSWYgdGhlIHVzZXIgZG9lc24ndCBwYXNzIGEgc2Vjb25kIGFyZ3VtZW50IG9uIHRoZSBjb25zdHJ1Y3RvciB0aGVuIHRoaXMgaXMgXG4gICAgICAgIHRoZSBuZXcgd2F5IG9mIGluaXRpYWxpc2luZyBhIEdyb3VwIChvbmx5IHByb3BzKS5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKG9sZFByb3BzID09PSBudWxsKSB7XG4gICAgICAgICAgICBhdHRyc1RvUGFzcyA9IHt9O1xuICAgICAgICAgICAgcHJvcHNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGVsc2UsIGluIGNhc2UgdGhlIHVzZXIgaGFzIHBhc3NlZCB0d28gYXJndW1lbnRzIHRoZW4gYm90aCBzaG91bGQgYmUgdXNlZFxuICAgICAgICAgICAgYXR0cnNUb1Bhc3MgPSBwcm9wcztcbiAgICAgICAgICAgIHByb3BzVG9QYXNzID0gb2xkUHJvcHM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3RoaXMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCAoR3JvdXAuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cCkpLmNhbGwodGhpcywgYXR0cnNUb1Bhc3MsIHByb3BzVG9QYXNzKSk7XG5cbiAgICAgICAgX3RoaXMuaGFzSW5jaWRlbnRzID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMuaXNDaGFubmVsID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAga2V5ZnJhbWVzIGFyZSBzcGVjaWFsIHBvaW50cyBvbiB0aGUgU2NlbmUncyB0aW1lIHdoZXJlIEluY2lkZW50cyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgICAgICBUaGUga2V5cyBvZiB0aGUga2V5ZnJhbWVzIGFycmF5IGFyZSB0aGUgbWlsbGlzZWNvbmQgb24gd2hpY2ggdGhlIGtleWZyYW1lcyBzaG91bGQgZ2V0IGV4ZWN1dGVkOlxuICAgICAgICAgIGUuZy46XG4gICAgICAgICAga2V5ZnJhbWVzID0ge1xuICAgICAgICAgICAgICAgIHNlY18yMDAwOiB7XG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50X2lkOiBJbmNpZGVudE9iamVjdCxcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnRfaWQ6IEluY2lkZW50T2JqZWN0LFxuICAgICAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgIH1cbiAgICAgICAgICAqL1xuICAgICAgICBfdGhpcy5rZXlmcmFtZXMgPSB7fTtcblxuICAgICAgICAvKipcbiAgICAgICAgICBBbiBvYmplY3QgaG9sZGluZyB0aGUgbWFwcGluZyBpbmNpZGVudGlkIC8ga2V5ZnJhbWVrZXksIGZyb20gd2hpY2ggd2UgY2FuIGdldCB0aGUga2V5ZnJhbWUgaWQgYXMgZGVmaW5lZCBvblxuICAgICAgICAgIHRoZSB0aGlzLmtleWZyYW1lcyBvYmplY3Qgd2hlcmUgdGhlIGluY2lkZW50IGJlbG9uZ3MgdG9cbiAgICAgICAgICBlLmcuOlxuICAgICAgICAgIGluY2lkZW50c0tleWZyYW1lS2V5cyA9IHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudGlkOiBzZWNfMjAwMCxcbiAgICAgICAgICAgICAgICAuLi5cbiAgICAgICAgICB9XG4gICAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluY2lkZW50c0tleWZyYW1lS2V5cyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgIFRoZSBhcnJheSBob2xkcyB0aGUgSW5jaWRlbnRzIG9mIHRoZSBTY2VuZSBvbiB0aGUgZm9ybWF0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZCAvLyB0aGUgaWQgb2YgdGhlIEluY2lkZW50IG9iamVjdFxuICAgICAgICAgICAgICAgIGluY2lkZW50IC8vIHRoZSBpbmNpZGVudCBvYmplY3RcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCAvLyB0aGUgbWlsbGlzZWNvbmQgdGhlIGluY2lkZW50IHNob3VsZCBiZSBleGVjdXRlZFxuICAgICAgICAgIH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5jaWRlbnRzID0gW107XG5cbiAgICAgICAgLypcbiAgICAgICAgYW4gb2JqZWN0IC8gYXNzb2NpYXRpdmUgYXJyYXkgaG9sZGluZyBhbGwgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAgICA8aW5jaWRlbnRfaWQ+OiBJbmNpZGVudCBvYmplY3RcbiAgICAgICAgICovXG4gICAgICAgIF90aGlzLmluY2lkZW50c0J5SWQgPSB7fTtcblxuICAgICAgICBfdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24gPSAwO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY25hbm5lbHMgYXR0cmlidXRlIGhvbGRzIGEgbGlzdCBvZiBhbGwgaW50YW50aWF0ZWQgQ2hhbm5lbHMgb2YgdGhlIEluY2lkZW50cyBiZWxvbmdpbmcgdG8gdGhlIGNsaXBcbiAgICAgICAgICogdGhpcyBhdHRyaWJ1dGUgaXMgb25seSB2YWx1YWJsZSB3aGVuIHRoZSBHcm91cCBiZWNvbWVzIHRoZSBDbGlwXG4gICAgICAgICAqIFRoZSBmb3JtYXQgb2YgdGhlIGF0dHJpYnV0ZSBpczpcbiAgICAgICAgICogIGtleS12YWx1ZSBwYWlycyBpbiB0aGUgbWFubmVyOlxuICAgICAgICAgKiA8bWNfcGx1Z2luX25wbV9uYW1lPjogQ2hhbm5lbCBvYmplY3RcbiAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMgPSB7fTtcblxuICAgICAgICBfdGhpcy5pc1RoZUNsaXAgPSBmYWxzZTtcblxuICAgICAgICBfdGhpcy5vbkdyb3VwSW5pdGlhbGlzZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEdyb3VwLCBbe1xuICAgICAgICBrZXk6ICdvbkdyb3VwSW5pdGlhbGlzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkdyb3VwSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGdyb3VwIGdldHMgaW5pdGlhbGlzZWRcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldENoYW5uZWwnLFxuXG5cbiAgICAgICAgLypcbiAgICAgICAgcmV0dXJucyB0aGUgaW5pdGlhbGlzZWQgY2hhbm5lbCBieSB0aGUgQ2xpcCB0aGUgSW5jaWRlbnQgYmVsb25ncyB0b1xuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENoYW5uZWwobWNfcGx1Z2luX25wbV9uYW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5fZ2V0Q2hhbm5lbChtY19wbHVnaW5fbnBtX25hbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIHJldHVybiB0aGUgZGlyZWN0IHBhcmVudCBvZiBhIHNwZWNpZmljIEluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19nZXREaXJlY3RQYXJlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERpcmVjdFBhcmVudChpbmNpZGVudElkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNCeUlkLmhhc093blByb3BlcnR5KGluY2lkZW50SWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdFBhcmVudCA9IHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Ll9nZXREaXJlY3RQYXJlbnQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0UGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0UGFyZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFsbCBvZiBpdHMgSW5jaWRlbnRzIChub3QgZ3JvdXBzKSBpbiBhIGNvbGxlY3Rpb24gb2YgdGhlIGZvcm06XG4gICAgICAgICAqIHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50c0J5UGx1Z2luJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGtleXMgdGhlIGtleXMgb2YgYWxsIHRoZSBwbHVnaW5zIEluY2lkZW50cyBvZiB3aGljaCBhcHBlYXIgaW4gdGhlXG4gICAgICAgICAqIHRyZWUgb2YgdGhlIEdyb3VwLiBBbGwgSW5jaWRlbnRzIGFyZSBwcm9qZWN0ZWQgdG8gdGhlIEdyb3VwJ3MgdGltZWxpbmUuXG4gICAgICAgICAqIFRoZSBhcnJheSBpbmNsdWRlcyB0aGUgR3JvdXAncyBwcm9qZWN0aW9uIHRvb1xuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5jaWRlbnRzQnlQbHVnaW4oKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgICAgICAgIC8vIGluaXRpYWxseSBpdCBvbmx5IHB1dHMgaXRzZWxmIG9udGhlIGluY2lkZW50c0J5UGx1Z2luIGFycmF5LCBleGFjdGx5IGFzIHRoZSBwbGFpbiBJbmNpZGVudHMgZG9cbiAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5bdGhpcy5tY19wbHVnaW5fbnBtX25hbWVdID0gW3tcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH1dO1xuXG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBhIHNlbGYgY29udGFpbmVkIGluY2lkZW50IHJldHVybiBqdXN0IHRoYXRcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudHNCeVBsdWdpbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHByb2NlZWQgdG8gZ2F0aGVyIHRoZSBjb250YWluZWQgaW5jaWRlbnRzIGFzIHdlbGxcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzVG9BZGQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5nZXRJbmNpZGVudHNCeVBsdWdpbihhZGp1c3RNaWxsaXNlY29uZCArIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzVG9BZGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluY2lkZW50c0J5UGx1Z2luLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50c0J5UGx1Z2luW2tleV0gPSBpbmNpZGVudHNCeVBsdWdpbltrZXldLmNvbmNhdChpbmNpZGVudHNUb0FkZFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50c0J5UGx1Z2luW2tleV0gPSBpbmNpZGVudHNUb0FkZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1N0YXRlVHJhbnNpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1N0YXRlVHJhbnNpdGlvbih0YXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgaWYgKGNoZWNrVHJhbnNpdGlvbih0aGlzLnJ1blRpbWVJbmZvLnN0YXRlLCB0YXJnZXRTdGF0ZSwgdGhpcy5kaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBJbmNpZGVudHMgb2YgZWFjaCBJbmNpZGVudCBpbiBhcnJheSBmb3JtYXQgaG9sZGluZyB0aGUgaW5jaWRlbnRzIGluIHRoZSBzdHJ1Y3R1cmU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRGVwZW5kaW5nIG9uIHdobyBhc2tzIGZvciB0aGUgaW5jaWRlbnRzLCBpdCBtaWdodCBwYXNzIHRoZSBhZGp1c3RNaWxsaXNlY29uZCBhcmd1bWVudC4gVGhpcyBhcmd1bWVudCBpc1xuICAgICAgICAgICAgdXNlZCBpbiBjYXNlIGEgcGFyZW50IEdyb3VwIHdhbnRzIHRvIHJlY2VpdmUgdGhlIEluY2lkZW50cyBvZiBpdHMgY2hpbGQgYnV0IGJ5IHBhc3NpbmcgYSBjb3JyZWN0aW9uIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICB0aGF0IHJlcHJlc2VudHMgdGhlIG1pbGxpc2Vjb25kIHRoZSBJbmNpZGVudCBzdGFydHMgb24gaXRzIHBhcmVudCdzIHRpbWVsaW5lLlxuICAgICAgICAgICAgQHBhcmFtIHtpbnR9IGFkanVzdE1pbGxpc2Vjb25kXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFByb2plY3RlZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9qZWN0ZWRJbmNpZGVudHMoKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRJbmNpZGVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzVG9BZGQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5nZXRQcm9qZWN0ZWRJbmNpZGVudHMoYWRqdXN0TWlsbGlzZWNvbmQgKyB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgcHJvamVjdGVkSW5jaWRlbnRzID0gcHJvamVjdGVkSW5jaWRlbnRzLmNvbmNhdChpbmNpZGVudHNUb0FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvamVjdGVkSW5jaWRlbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKiogTUVUSE9EUyBUTyBDQUxDVUxBVEUgT1ZFUkFMTCBEVVJBVElPTiBPRiBTQ0VORVxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxlZCB3aGVuIGFuIEluY2lkZW50IG9mIHRoZSBTY2VuZSBnZXRzIGFmZmVjdGVkIGJ5IGFuIGVkaXQgb3IgYSBkZWxldGlvbi4gVGhlIGNvbW1hbmQgdGFyZ2V0cyB0aGVcbiAgICAgICAgICogcm9vdCBvZiB0aGUgc2NlbmVzIHRyZWUgd2hlcmUgYSByZWNhbGMgc3RhdGUgYW5kIGEgc2V0IGN1cnJlbnQgbWlsbGlzZWNvbmQgc2hvdWxkIHRha2UgcGxhY2VcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkKCkge1xuICAgICAgICAgICAgdmFyIGR1cmF0aW9uQmVmb3JlQ2hhbmdlID0gdGhpcy5kdXJhdGlvbiAqIDE7XG4gICAgICAgICAgICB2YXIgY3VycmVudE1pbGxpc2Vjb25kQmVmb3JlQ2hhbmdlID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICAgICAgdmFyIHN0YXRlQmVmb3JlQ2hhZ2UgPSB0aGlzLnN0YXRlICsgJyc7XG5cbiAgICAgICAgICAgIHZhciBuZXdEdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGluY2lkZW50LmluY2lkZW50LmR1cmF0aW9uICsgaW5jaWRlbnQubWlsbGlzZWNvbmQgPiBuZXdEdXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBuZXdEdXJhdGlvbiA9IGluY2lkZW50LmluY2lkZW50LmR1cmF0aW9uICsgaW5jaWRlbnQubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IG5ld0R1cmF0aW9uO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnZHVyYXRpb24gY2hhbmdlZCBvbiBpbmNpZGVudDogJyArIHRoaXMuaWQgKyAnLiBOZXcgZHVyYXRpb246ICcgKyBuZXdEdXJhdGlvbik7XG4gICAgICAgICAgICBpZiAodGhpcy5kdXJhdGlvbiAhPSBkdXJhdGlvbkJlZm9yZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ2R1cmF0aW9uLWNoYW5nZScsIHsgbmV3RHVyYXRpb246IG5ld0R1cmF0aW9uIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmdldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pbGxpc2Vjb25kKGN1cnJlbnRNaWxsaXNlY29uZEJlZm9yZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGNTdGF0ZShjdXJyZW50TWlsbGlzZWNvbmRCZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNhbGxlZCB3aGVuIGFuIEluY2lkZW50IGdldHMgYWRkZWQgb24gdGhlIFNjZW5lXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBzdGFydE1pbGxpc2Vjb25kXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBpbmNpZGVudER1cmF0aW9uXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZGRlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREdXJhdGlvbkFmdGVySW5jaWRlbnRBZGRlZChzdGFydE1pbGxpc2Vjb25kLCBpbmNpZGVudER1cmF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb25CZWZvcmVDaGFuZ2UgPSB0aGlzLmR1cmF0aW9uICogMTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TWlsbGlzZWNvbmRCZWZvcmVDaGFuZ2UgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAqIDE7XG4gICAgICAgICAgICAvLyBjb25zdCBzdGF0ZUJlZm9yZVJlY2FsID0gdGhpcy5zdGF0ZSArIFwiXCI7XG5cbiAgICAgICAgICAgIGlmIChzdGFydE1pbGxpc2Vjb25kICsgaW5jaWRlbnREdXJhdGlvbiA+IHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxjdWxhdGVkRHVyYXRpb24gPSBzdGFydE1pbGxpc2Vjb25kICsgaW5jaWRlbnREdXJhdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gIT0gZHVyYXRpb25CZWZvcmVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KCdkdXJhdGlvbi1jaGFuZ2UnLCB7IG5ld0R1cmF0aW9uOiB0aGlzLmR1cmF0aW9uIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmdldER1cmF0aW9uQWZ0ZXJJbmNpZGVudEFmZmVjdGVkKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudE1pbGxpc2Vjb25kKGN1cnJlbnRNaWxsaXNlY29uZEJlZm9yZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNhbGNTdGF0ZShjdXJyZW50TWlsbGlzZWNvbmRCZWZvcmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKiogSU5DSURFTlQgTUVUSE9EUyBJTVBMRU1FTlRBVElPTiAqKioqKioqKioqKioqKlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3BsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2dldChHcm91cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCAncGxheScsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIHRpbWVyIGJsb2NraW5nICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3dhaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gd2FpdCgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICd3YWl0JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5jYWxsZXJJZCA9PT0gdGhpcy5pbmNpZGVudHNbaV0uaWQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5ibG9jayhwcm9wcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIHRpbWVyIGJsb2NraW5nICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Jsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoX2dldChHcm91cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCAnYmxvY2snLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuYmxvY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogdGltZXIgdW5ibG9ja2luZyAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXN1bWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzdW1lKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoX2dldChHcm91cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCAncmVzdW1lJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdyZXNldCcsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5yZXNldCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3RvcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdG9wKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoX2dldChHcm91cC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihHcm91cC5wcm90b3R5cGUpLCAnc3RvcCcsIHRoaXMpLmNhbGwodGhpcywgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXIgaXQgdGFrZXMgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgSW5jaWRlbnQgaXRzZWxmIGFuZCBpdCBtaWdodCBiZSBuZWdhdGl2ZVxuICAgICAgICAgKiBOZWdhdGl2ZSB0YXJnZXRNaWxsaXNlY29uZCBtZWFucyB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGlzIE4gbWlsbGlzZWNvbmRzIEJFRk9SRSB0aGUgc3RhcnQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IC0gdGhlIGRlbHRhIG9mIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgY29tcGFyZWQgdG8gdGhlIEluY2lkZW50IHN0YXJ0XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlY2FsY1N0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlY2FsY1N0YXRlKHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQpIHtcbiAgICAgICAgICAgIF9nZXQoR3JvdXAucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoR3JvdXAucHJvdG90eXBlKSwgJ3JlY2FsY1N0YXRlJywgdGhpcykuY2FsbCh0aGlzLCB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRNaWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIGluY2lkZW50LnJlY2FsY1N0YXRlKHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgLSBzdGFydE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGFzdFdpc2gnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbGFzdFdpc2goKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQubGFzdFdpc2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBTQ0VORSBTUEVDSUZJQyBGVU5DVElPTlMgLyBIRUxQRVIgRlVOQ1RJT05TXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JldmVyc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmV2ZXJzZShfcmV2ZXJzZSkge1xuICAgICAgICAgICAgdGhpcy5yZXZlcnNlZCA9IF9yZXZlcnNlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbmNpZGVudE1pbGxpc2Vjb25kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluY2lkZW50TWlsbGlzZWNvbmQoaW5jaWRlbnRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbmYuZ2V0TWlsbGlzZWNvbmRGcm9tS2V5ZnJhbWVLZXkodGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaW5jaWRlbnRJZF0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBvcnRTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRTdGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIHZhciBpbmNpZGVudHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnQgPSB7fTtcbiAgICAgICAgICAgICAgICBpbmNpZGVudC5taWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIGluY2lkZW50LmluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZXhwb3J0U3RhdGUocHJvcHMpO1xuICAgICAgICAgICAgICAgIGluY2lkZW50LmlkID0gdGhpcy5pbmNpZGVudHNbaV0uaWQ7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnRzLnB1c2goaW5jaWRlbnQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3RhdGUgPSBfZ2V0KEdyb3VwLnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEdyb3VwLnByb3RvdHlwZSksICdleHBvcnRTdGF0ZScsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBzdGF0ZS5pbmNpZGVudHMgPSBpbmNpZGVudHM7XG5cbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0Q3VycmVudE1pbGxpc2Vjb25kJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRNaWxsaXNlY29uZChtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgc2V0dGluZyBjdXJyZW50VXNlciBvZiAke3RoaXMuaWR9IHRvICR7bWlsbGlzZWNvbmR9YCk7XG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkSW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjaGlsZCBpbmNpZGVudCBzdGFydHMgYmVmb3JlIHRoZSBtaWxsaXNlY29uZCBhbmQgaGFzIG5vdCBlbmRlZCB5ZXRcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRJbmNpZGVudC5taWxsaXNlY29uZCA8IG1pbGxpc2Vjb25kICYmIGNoaWxkSW5jaWRlbnQuaW5jaWRlbnQuZHVyYXRpb24gKyBjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kID4gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRJbmNpZGVudC5pbmNpZGVudC5zZXRDdXJyZW50TWlsbGlzZWNvbmQobWlsbGlzZWNvbmQgLSBjaGlsZEluY2lkZW50Lm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEluY2lkZW50LmluY2lkZW50LnNldEN1cnJlbnRNaWxsaXNlY29uZCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgSW5jaWRlbnQgYnkgSUQgbm8gbWF0dGVyIGlmIHRoZSBJbmNpZGVudCBiYWxvbmdzIGRpcmVjdGx5IHRvIHRoZSBTY2VuZSBvZiB0byBhIGNoaWxkIFNjZW5lXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQgdG8gZ2V0XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50QnlJZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmNpZGVudEJ5SWQoaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c0J5SWQuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZ2V0SW5jaWRlbnRCeUlkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmNpZGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gSU5DSURFTlRTIE1BTkFHRU1FTlQgTUVUSE9EU1xuICAgICAgICAvLyBQT0xZTU9SUEhJU00gQVBQTElFRC4gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgSVQgQUNUUyBBUyBBIFNDRU5FLiBJRiBUSEUgR1JPVVAgSEFTIFBBUkVOVCBJVCBBQ1RTIEFTXG4gICAgICAgIC8vIEEgXCJUUkFOU1BBUkVOVCBHUk9VUFwiXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBzZXJ2ZXMgZXhhY3RseSB3aGF0IGl0cyBuYW1lIGltcGxpZXMuIFRvIGNoZWNrIGlmIHRoZSBhZGRpdGlvbiBvZiBhbiBJbmNpZGVudFxuICAgICAgICAgKiBpcyB2YWxpZCBhbmQgYWNjZXB0ZWQsIGFjY29yZGluZyB0byB0aGUgcnVsZXMgZGVmaW5lZCBvbiB0aGUgY2hhbm5lbHMuXG4gICAgICAgICAqIFRoZSBtZXRob2QgYm9vYmxlcyB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBDbGlwIGJ5IGNhcnJ5aW5nIGFkanVzdGluZyB0aGUgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIFRoZSBtZXRob2QgdGFrZXMgYXMgaW5wdXQgdGhlIG1hbmFnZW1lbnQgdHlwZS4gT24gZXJyb3IgLyBjb25mbGljdDpcbiAgICAgICAgICogIC0gb24gdHlwZSA9PT0gJ2FsbC1vci1ub3RoaW5nJyBjb21wbGV0ZWx5IGRpc2NhcmQgYWRkaXRpb24gb2YgYWxsIGluY2lkZW50c1xuICAgICAgICAgKiAgLSBvbiB0eXBlID09PSAna2VlcC1wYXNzaW5nJyBpdCB3aWxsIG9ubHkgYWRkIHRoZSBwYXNzaW5nIGluY2lkZW50cyBubyBtYXR0ZXIgaWYgc29tZSBvdGhlciBpbmNpZGVudHMgb2YgdGhlIGFkZGl0aW9uIGZhaWxlZFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gaW5jaWRlbnQgLSB0aGUgaW5jaWRlbnQgdG8gYWRkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0byBhZGQgdGhlIEluY2lkZW50IHRvXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gYXMgZXhwbGFpbmVkIGFib3ZlXG4gICAgICAgICAqIFRoZSBtZXRob2QgcmV0dXJucyBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIGFkZCB0aGUgSW5jaWRlbnRzIG9uIHRoZSBDaGFubmVsc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3JcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yc1xuICAgICAgICAgICAgfVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0FkZGl0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrQWRkaXRpb24oaW5jaWRlbnQsIG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogXCJhbGwtb3Itbm90aGluZ1wiO1xuXG4gICAgICAgICAgICAvLyBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVFMgKElTIEEgQ0xJUClcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ0luY2lkZW50V2l0aFRoZVNhbWVJZCA9IHRoaXMuZ2V0SW5jaWRlbnRCeUlkKGluY2lkZW50LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdJbmNpZGVudFdpdGhUaGVTYW1lSWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCBlcnJvcnM6IFt7IHJlYXNvbjogJ0FscmVhZHkgZXhpc3RpbmcgSW5jaWRlbnQgd2l0aCBpZCAnICsgaW5jaWRlbnQuaWQsIGluY2lkZW50OiBleGlzdGluZ0luY2lkZW50V2l0aFRoZVNhbWVJZCB9XSB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgaW5jaWRlbnRzIHNlcGFyYXRlZCBieSBwbHVnaW5cbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlJZCA9IGluY2lkZW50LmdldEluY2lkZW50c0J5UGx1Z2luKG1pbGxpc2Vjb25kKTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudHNCeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBjbGlwIGhhZCBubyBjaGFubmVsIGluc3RhbnRpYXRlZCBmb3IgdGhlIHNwZWNpZmljIGtleSAocGx1Z2luIGlkKSB5ZXQgY3JlYXRlIGl0XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnRzdGFudGlhdGUgdGhlIGNoYW5uZWwgb2YgdGhlIHBsdWdpbiBieSB1c2luZyB0aGUgcmVmZXJlbmNlIHRvIHRoZSBjbGFzcyBkZWZpbml0aW9uIHN0b3JlZCBvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZlcnkgZmlyc3QgaW5jaWRlbnQgb2YgdGhlIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0gPSBuZXcgaW5jaWRlbnRzQnlJZFtrZXldWzBdLmluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5UaW1lSW5mbzogdGhpcy5ydW5UaW1lSW5mbyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsdWdpblJlc3VsdCA9IHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5hZGRJbmNpZGVudHMoaW5jaWRlbnRzQnlJZFtrZXldLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5SZXN1bHQgPSB0b1JldHVyblJlc3VsdCAmJiBwbHVnaW5SZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGx1Z2luUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXJyb3JzID0gdG9SZXR1cm5FcnJvcnMuY29uY2F0KHBsdWdpblJlc3VsdC5lcnJvcnMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlcy5wdXNoKHBsdWdpblJlc3VsdC5leGVjdXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5mIG9mIGl0ZXJhdGlvbiBvbiB0aGUgaW5jaWRlbnRzQnlJZCBrZXlzXG5cbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRlID0gZnVuY3Rpb24gdG9SZXR1cm5FeGVjdXRlKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvUmV0dXJuRXhlY3V0YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXNbaV0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgYWRkaXRpb25SZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZGl0aW9uUmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgKEFDVCBBUyBUSEUgQ0xJUClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jaGVja0FkZGl0aW9uKGluY2lkZW50LCBtaWxsaXNlY29uZCArIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZCh0aGlzLmlkKSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGNoZWNrRWRpdCBtZXRob2Qgc2VydmVzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBpbXBsaWVzLiBUbyBjaGVjayBpZiB0aGUgZWRpdCBvZiBhbiBJbmNpZGVudCAoZWRpdCBvZiBJbmNpZGVudCdzIHBvc2l0aW9uIGdpdmVuIGluIG1pbGxpc2Vjb25kcyBkZWx0YSlcbiAgICAgICAgICogaXMgdmFsaWQgYW5kIGFjY2VwdGVkLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgb24gdGhlIGNoYW5uZWxzLlxuICAgICAgICAgKiBUaGUgbWV0aG9kIGJvb2JsZXMgdXAgdW50aWwgaXQgcmVhY2hlcyB0aGUgQ2xpcC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluY2lkZW50IC0gdGhlIGluY2lkZW50IHRvIGVkaXRcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kc0RlbHRhIC0gdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBvZiB0aGUgSW5jaWRlbnQncyBzdGFydCB0aW1lXG4gICAgICAgICBUaGUgbWV0aG9kIHNob3VsZCByZXR1cm4gZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBlZGl0IHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICAvLyBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVFMgKElTIEEgQ0xJUClcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgaW5jaWRlbnRzIHNlcGFyYXRlZCBieSBwbHVnaW5cbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRzQnlJZCA9IGluY2lkZW50LmdldEluY2lkZW50c0J5UGx1Z2luKCk7XG5cbiAgICAgICAgICAgICAgICAvLyBwcmVwYXJlIHRoZSByZXR1cm4gcGF5bG9hZFxuICAgICAgICAgICAgICAgIHZhciB0b1JldHVyblJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0YWJsZXMgPSBbXTtcblxuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGtleSBvZiB0aGUgaW5jaWRlbnRzQnlJZCBvYmplY3QgcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRzQnlJZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmVkaXRJbmNpZGVudHMoaW5jaWRlbnRzQnlJZFtrZXldLCBtaWxsaXNlY29uZHNEZWx0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuUmVzdWx0ID0gdG9SZXR1cm5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVuZiBvZiBpdGVyYXRpb24gb24gdGhlIGluY2lkZW50c0J5SWQga2V5c1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNIZWFkbGVzc0NsaXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJRiBUSEUgR1JPVVAgSEFTIE5PIFBBUkVOVCAoQUNUIEFTIFRIRSBDTElQKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmNoZWNrRWRpdChpbmNpZGVudCwgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjaGVja0RlbGV0ZSBtZXRob2Qgc2VydmVzIGV4YWN0bHkgd2hhdCBpdHMgbmFtZSBpbXBsaWVzLiBUbyBjaGVjayBpZiB0aGUgZGVsZXRpb24gb2YgYW4gSW5jaWRlbnRcbiAgICAgICAgICogaXMgdmFsaWQgYW5kIGFjY2VwdGVkLCBhY2NvcmRpbmcgdG8gdGhlIHJ1bGVzIGRlZmluZWQgb24gdGhlIGNoYW5uZWxzLlxuICAgICAgICAgKiBUaGUgbWV0aG9kIGJvb2JsZXMgdXAgdW50aWwgaXQgcmVhY2hlcyB0aGUgQ2xpcC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGluY2lkZW50IC0gdGhlIGluY2lkZW50IHRvIGVkaXRcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gaWYgcGFzc2VkIGl0IHN1cHBvcnRzIHRoZSBwcmV2ZW50U2xpcCBrZXkgd2hpY2ggaWYgZmFsc2UgdGhlIGNoYW5uZWwgc2hvdWxkIG5vdCBzbGlwLiBUaGlzIGNhc2UgaXMgZm9yIFxuICAgICAgICAgICAgZmxhc2hET00gb2YgRE9NQXdhcmVJbmNpZGVudHMgd2hlcmUgd2UgaGF2ZSBlbGVtZW50cyBkZWxldGVkIHNvIHNsaXBwaW5nIG9uIHRoZWlyIGxhbmVzIGlzIG5vdCB2YWxpZCBub3IgbmVjZXNzYXJ5XG4gICAgICAgICAgVGhlIHJlc3VsdCBtaWdodCBiZSBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYW4gYXJyYXkgb2YgZnVuY3Rpb25zIHRoYXQgd2hlbiBleGVjdXRlZCBpdCB3aWxsIHJlbW92ZSB0aGUgSW5jaWRlbnQgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UUyAoSVMgQSBDTElQKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5nZXRJbmNpZGVudEJ5SWQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICAgICAgLy8gZ2V0IGFsbCBpbmNpZGVudHMgc2VwYXJhdGVkIGJ5IHBsdWdpblxuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeUlkID0gaW5jaWRlbnQuZ2V0SW5jaWRlbnRzQnlQbHVnaW4oKTtcblxuICAgICAgICAgICAgICAgIC8vIHByZXBhcmUgdGhlIHJldHVybiBwYXlsb2FkXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuUmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5FeGVjdXRhYmxlcyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBpbmNpZGVudHNCeUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBlcmZvcm0gdGhlIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgIHZhciBwbHVnaW5SZXN1bHQgPSB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0ucmVtb3ZlSW5jaWRlbnRzKGluY2lkZW50c0J5SWRba2V5XSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICB0b1JldHVyblJlc3VsdCA9IHRvUmV0dXJuUmVzdWx0ICYmIHBsdWdpblJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW5SZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FcnJvcnMgPSB0b1JldHVybkVycm9ycy5jb25jYXQocGx1Z2luUmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzLnB1c2gocGx1Z2luUmVzdWx0LmV4ZWN1dGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBlbmYgb2YgaXRlcmF0aW9uIG9uIHRoZSBpbmNpZGVudHNCeUlkIGtleXNcblxuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGUgPSBmdW5jdGlvbiB0b1JldHVybkV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9SZXR1cm5FeGVjdXRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9SZXR1cm5FeGVjdXRhYmxlc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0UmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRvUmV0dXJuUmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHRvUmV0dXJuRXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiB0b1JldHVybkV4ZWN1dGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0UmVzdWx0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzSGVhZGxlc3NDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSUYgVEhFIEdST1VQIEhBUyBOTyBQQVJFTlQgKEFDVCBBUyBUSEUgQ0xJUClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jaGVja0RlbGV0ZShpbmNpZGVudElkLCBwcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQncyBjYWxsZWQgYWx3YXlzIGJ5IGEgY2hpbGQgdG8gU2NlbmUgdGhhdCB3YW50cyB0byBleHBhbmQgdG8gdGhlIGxlZnQgdG8gaXRzIHBhcmVudC5cbiAgICAgICAgICogRXhwYW5kaW5nIGEgU2NlbmUgdG8gdGhlIGxlZnQgbWVhbnMgaXQgdHJpZXMgdG8gYWRkIGV4dHJhIChpbml0aWFsbHkgdW5zdWVkKSBzcGFjZSAoaW4gbWlsbGlzZWNvbmRzKSBiZWZvcmUgaXRzXG4gICAgICAgICAqIGN1cnJlbnQgc3RhcnRpbmcgcG9pbnQuXG4gICAgICAgICAqIEluIG9yZGVyIGZvciB0aGlzIGFjdGlvbiB0byBiZSBhbGxvd2VkIHRoZSBTY2VuZSdzIGNvbnRleHQgc2hvdWxkIGFsbG93IHN1Y2ggYW4gZXhwYW5zaW9uLiBUaGlzIG1lYW5zOlxuICAgICAgICAgKiAgLSB0aGF0IGlmIHRoZSBTY2VuZSBoYXMgbm8gcGFyZW50cyB0aGlzIGV4cGFuc2lvbiBpcyBub3QgbGVnYWxcbiAgICAgICAgICogIC0gdGhhdCBpZiB0aGUgcm9vdCBTY2VuZSBvZiB0aGUgU2NlbmUncyBwYXJlbnRzIHRyZWUgbmVlZHMgdG8gZXhwYW5kIG9uIHRoZSBsZWZ0IGluIG9yZGVyIHRvIGFwcGx5IHRoZSBleHBhbnNpb25cbiAgICAgICAgICogICAgICB0aGVuIHRoZSBleHBhbnNpb24gaXMgbm90IGFjY2VwdGFibGVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGhvd01hbnlNaWxsaXNlY29uZHMgLSB0aGUgbWlsbGlzZWNvbmRzIHRvIGV4cGFuZCB0aGUgU2NlbmUgdG8gdGhlIGxlZnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNjZW5lSWQgLSB0aGUgY2hpbGQgc2NlbmUgaWQgdGhhdCB3YW50cyB0byBnYWluIGV4dHJhIHNwYWNlIHRvIHRoZSBsZWZ0XG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gdGhlIHJlc3VsdCBpcyBhbiBvYmplY3Qgd2l0aCB0d28ga2V5czpcbiAgICAgICAgICogIC0gdGhlIGZpcnN0IGtleSBpcyB0aGUgXCJyZXN1bHRcIiB3aGljaCBtaWdodCBlaXRoZXIgYmUgdHJ1ZSBvciBmYWxzZVxuICAgICAgICAgKiAgLSB0aGUgc2Vjb25kIGtleSBpcyB0aGUgXCJ1bmRvXCIgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0IGNhbiB1bmRvIHRoZSAoYXBwcm92ZWQpIGV4cGFuc2lvblxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBhbmRTY2VuZVRvVGhlTGVmdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBhbmRTY2VuZVRvVGhlTGVmdChob3dNYW55TWlsbGlzZWNvbmRzLCBzY2VuZUlkKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgICAgLy8gRmlyc3Qgd2UgaWRlbnRpZnkgdGhlIGV4cGFuc2lvbiB3aXRoaW4gdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudCAodGhpcykgU2NlbmVcbiAgICAgICAgICAgIHZhciBjdXJyZW50U3RhcnRNaWxsaXNlY29uZE9mVGhlQ2hpbGRTY2VuZSA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChzY2VuZUlkKTtcbiAgICAgICAgICAgIHZhciBuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lID0gaG93TWFueU1pbGxpc2Vjb25kcyAtIGN1cnJlbnRTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZXhwYW5zaW9uIGlzIGFsbG93ZWRcbiAgICAgICAgICAgIC8vIGlmIHRoZSBtaWxsaXNlY29ucyB0byBleHBhbmQgYXJlIHplcm8gb3IgbGVzcyAobWVhbmluZyB0aGUgY3VycmVudCBTY2VuZSBpcyBhY3R1YWxseSBub3QgYWZmZWN0ZWQgYnkgdGhlIGV4cGFuc2lvbilcbiAgICAgICAgICAgIGlmIChuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lIDw9IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdFNjZW5lID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgY2hhbmdlUmVzdWx0ID0gdGhpcy5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKC1uZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lLCBzY2VuZUlkKTtcbiAgICAgICAgICAgICAgICB2YXIgdW5kbyA9IGZ1bmN0aW9uIHVuZG8oKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMi5jaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKGNoYW5nZVJlc3VsdC5vbGRNaWxsaXNlY29uZCwgc2NlbmVJZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHVuZG86IHVuZG8sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RTY2VuZTogcm9vdFNjZW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgaXQgcmVhY2hlcyB0byB0aGF0IHBvaW50IHRoYXQgbWVhbnMgdGhlIGV4cGFuc2lvbiBhZmVjdHMgdGhlIGxlZnQgYm9yZGVycyBvZiB0aGlzIChwYXJlbnQpIFNjZW5lIGFzIHdlbGxcbiAgICAgICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCBzY2VuZSB0aGF0IG1lYW5zIHRoZSBleHBhbnNpb24gaXMgaWxsZWdhbFxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBpdCBoYXMgYSBwYXJlbnQgc2NlbmUgYW5kIHRoZSB0aGlzIFNjZW5lIG5lZWRzIHRvIGV4cGFuZCB0byB0aGUgbGVmdCBhcyB3ZWxsIHRoZW4gdGhpcyBTY2VuZVxuICAgICAgICAgICAgLy8gYXNzaWducyB0aGUgb2JsaWdhdGlvbiB0byBldmFsdWF0ZSB0aGUgZXhwYW5zaW9uIHRvIGl0cyBwYXJlbnRcbiAgICAgICAgICAgIHZhciBwYXJlbnREZWNpc2lvbiA9IHRoaXMucGFyZW50U2NlbmVPYmplY3QuZXhwYW5kU2NlbmVUb1RoZUxlZnQobmV3U3RhcnRNaWxsaXNlY29uZE9mVGhlQ2hpbGRTY2VuZSwgdGhpcy5pZCk7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcGFyZW50IGFwcHJvdmVzIHRoZSBleHBhbnNpb25cbiAgICAgICAgICAgIGlmIChwYXJlbnREZWNpc2lvbi5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGFwcGx5IHRoZSBleHBhbnNpb24gaXRzZWxmIGFuZCBidW5kbGUgaXRzIHVuZG8gYWxvbmcgd2l0aCB0aGUgdW5kbyBjb21pbmcgZnJvbSB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGFydFBvaW50KC1uZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lKTtcbiAgICAgICAgICAgICAgICB2YXIgb3ZlcmFsbFVuZG8gPSBmdW5jdGlvbiBvdmVyYWxsVW5kbygpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50RGVjaXNpb24udW5kbygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXhwYW5kU3RhcnRQb2ludChuZXdTdGFydE1pbGxpc2Vjb25kT2ZUaGVDaGlsZFNjZW5lKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5kbzogb3ZlcmFsbFVuZG8sXG4gICAgICAgICAgICAgICAgICAgIHJvb3RTY2VuZTogcGFyZW50RGVjaXNpb24ucm9vdFNjZW5lXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwYW5kcyBvciBjb2xsYXBzZXMgdGhlIFNjZW5lJ3Mgc3RhcnQgbWlsbGlzZWNvbmQgYnkgdGhlIGdpdmVuIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiBlLmcuIGV4cGFuZFN0YXJ0UG9pbnQoMjAwKSB3aWxsIGV4cGFuZCB0aGUgU2NlbmUgYnkgMjAwIG1pbGxpc2Vjb25kcyB0byB0aGUgbGVmdCBrZWVwaW5nIGFsbFxuICAgICAgICAgKiAgICAgIG9mIGl0cyBpbmNpZGVudHMgdG8gdGhlIGV4YWN0IHNhbWUgcGxhY2UgdGhleSB3ZXJlIGJlZm9yZSBvbiB0aGUgb3ZlcmFsbCB0aW1lbGluZVxuICAgICAgICAgKiBlLmcuIGV4cGFuZFN0YXJ0UG9pbnQoLTIwMCkgd2lsbCBjb2xsYXBzZSB0aGUgU2NlbmUsIG1vdmluZyBpdHMgc3RhcnQgcG9pbnQgYnkgMjAwIG1pbGxpc2Vjb25kc1xuICAgICAgICAgKiAgICAgIHRvIHRoZSByaWdodCwgYWdhaW4gd2l0aG91dCBhZmZlY3RpbmcgYXQgYWxsIGl0cyBJbmNpZGVudHMnIHN0YXJ0IHBvaW50IG9uIHRoZSBvdmVyYWxsIHRpbWVsaW5lXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBieU1pbGxpc2Vjb25kcyAtIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGV4cGFuZCAocG9zaXRpdmUgbnVtYmVyKSBvciBjb2xsYXBzZSAobWludXMgbnVtYmVyKSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cGFuZFN0YXJ0UG9pbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZXhwYW5kU3RhcnRQb2ludChieU1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpbmNpZGVudCA9IHRoaXMuaW5jaWRlbnRzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSW5jaWRlbnRzU3RhcnRNaWxsaXNlY29uZChpbmNpZGVudC5taWxsaXNlY29uZCArIGJ5TWlsbGlzZWNvbmRzLCBpbmNpZGVudC5pZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXQgYWx0ZXJzIHRoZSBzdGFydCBtaWxsaXNlY29uZCBvZiBhbnkgYWxyZWFkeSBleGlzdGluZyBJbmNpZGVudCBvZiB0aGUgU2NlbmVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG5ld21pbGxpc2Vjb25kIC0gdGhlIG5ldyBtaWxsaXNlY29uZCB0byBwbGFjZSB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluY2lkZW50SWQgLSB0aGUgaW5jaWRlbnQgaWRcbiAgICAgICAgICogQHJldHVybnMge2Z1bmN0aW9ufSAtIHRoZSB1bmRvIGZ1bmN0aW9uIG9mIHRoZSBjaGFuZ2VcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hhbmdlSW5jaWRlbnRzU3RhcnRNaWxsaXNlY29uZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGFuZ2VJbmNpZGVudHNTdGFydE1pbGxpc2Vjb25kKG5ld21pbGxpc2Vjb25kLCBpZCkge1xuICAgICAgICAgICAgdmFyIGtleWZyYW1lX3NlY19rZXkgPSB0aGlzLmluY2lkZW50c0tleWZyYW1lS2V5c1tpZF07XG4gICAgICAgICAgICAvL09QVElNSVpFIGRlbGV0ZSBpcyBzbG93IG9uIHY4IGVuZ2luZSB3ZSBzaG91bGQgY2hlY2sgaWYgd2UgY2FuIGFjaGlldmUgdGhlIHNhbWUgcmVzdWx0IGJ5IHNldHRpbmcgdGhlIHZhbHVlIG9mIHRoZSBrZXkgdG8gdW5kZWZpbmVkXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV1baWRdO1xuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5rZXlmcmFtZXNba2V5ZnJhbWVfc2VjX2tleV0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1trZXlmcmFtZV9zZWNfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2lkXTsgLy8gZGVsZXRlIHRoZSBsaXN0ZW5lciB0aGF0IGN1cnJlbnRseSBtYW5hZ2VzIHRoZSBJbmNpZGVudCdzIGV4ZWN1dGlvblxuXG5cbiAgICAgICAgICAgIHZhciBvbGRNaWxsaXNlY29uZCA9IHZvaWQgMDsgLy8gdGhlIHByZXZpb3VzIG1pbGxpc2Vjb25kIG9mIHRoZSBlZGl0ZWQgaW5jaWRlbnQgYmVmb3JlIHRoZSBlZGl0XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW2ldLmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBvbGRNaWxsaXNlY29uZCA9IHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kICogMTsgLy8gKjEgdG8gYXZvaWQgcmVmZXJlbmNlLCBrZWVwIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kID0gbmV3bWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gdGhpcy5pbmNpZGVudHNCeUlkW2lkXTtcbiAgICAgICAgICAgIHZhciBuZXdfa2V5ZnJhbWVfc2VjX2tleSA9IGNvbmYua2V5ZnJhbWVfc2VjX2tleSArIG5ld21pbGxpc2Vjb25kO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmtleWZyYW1lcy5oYXNPd25Qcm9wZXJ0eShuZXdfa2V5ZnJhbWVfc2VjX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmtleWZyYW1lc1tuZXdfa2V5ZnJhbWVfc2VjX2tleV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW25ld19rZXlmcmFtZV9zZWNfa2V5XVtpbmNpZGVudC5pZF0gPSBpbmNpZGVudDtcbiAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzS2V5ZnJhbWVLZXlzW2luY2lkZW50LmlkXSA9IG5ld19rZXlmcmFtZV9zZWNfa2V5O1xuXG4gICAgICAgICAgICAvLyBzdWJzY3JpYmUgSW5jaWRlbnQgc3RhcnQgb24gdGhlIGxpc3RlbmVyc1xuICAgICAgICAgICAgdmFyIGZ1bmN0ID0gZnVuY3Rpb24gZnVuY3Qoc2NlbmVNaWxsaXNlY29uZCwgcHJldmlvdXNUaW1lU3RhbXAsIHNjZW5lU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NlbmVNaWxsaXNlY29uZCA+PSBuZXdtaWxsaXNlY29uZCAmJiBzY2VuZU1pbGxpc2Vjb25kIDw9IG5ld21pbGxpc2Vjb25kICsgaW5jaWRlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQucGxheSh7IHN0YXJ0RnJvbTogc2NlbmVNaWxsaXNlY29uZCAtIG5ld21pbGxpc2Vjb25kLCBwcmV2aW91c1RpbWVTdGFtcDogcHJldmlvdXNUaW1lU3RhbXAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoaW5jaWRlbnQuaWQsIGZ1bmN0KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvbGRNaWxsaXNlY29uZDogb2xkTWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGluY2lkZW50XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBsYWluIGdyb3Vwc1xuICAgICAgICAgICAgQ2FuIGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgICAgICAtIEFub3RoZXIgcGxhaW4gZ3JvdXBcbiAgICAgICAgICAgIC0gQW4gaW5jaWRlbnQgd2l0aCBubyBzZWxlY3RvclxuICAgICAgICAgICAgLSBBIGRvbSBncm91cCAodGhpcyBtZXRob2Qgc2hvdWxkIGFjdHVhbGx5IHR1cm4gYW55IGluY2lkZW50IHdpdGggc2VsZWN0b3IgdG8gb25lKVxuICAgICAgICAgICAgQ2Fu4oCZdCBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAgICAgLSBBbiBhdHRyaWJ1dGUgZ3JvdXBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24oaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQucHJvcHMuaGFzT3duUHJvcGVydHkoJ3NlbGVjdG9yJykgJiYgIWluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbmNpZGVudCBpcyBub3QgYSBncm91cCBhbmQgaXQgaGFzIG5vIHNlbGVjdG9yIHByb2NlZWQgbm9ybWFsbHlcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2lkZW50Lmdyb3VwVHlwZSA9PT0gXCJwbGFpblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIEluY2lkZW50IGlzIGEgcGxhaW4gZ3JvdXAgcHJvY2VlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnQuZ3JvdXBUeXBlID09PSBcImF0dHJpYnV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiUGxhaW4gZ3JvdXBzIGNhbiBub3QgYWNjZXB0IGF0dHJpYnV0ZSBncm91cHMgb24gdGhlaXIgdGltZWxpbmVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdHVybiB0aGUgSW5jaWRlbnQgdG8gYSBET01Bd2FyZUluY2lkZW50XG4gICAgICAgICAgICAvLyBiZWZvcmUgYWRkaW5nIGl0IHRvIHRoZSBncm91cFxuICAgICAgICAgICAgdmFyIERPTUF3YXJlSW5jaWRlbnQgPSByZXF1aXJlKCcuLi9fcmVzcG9uc2l2ZW5lc3MvRE9NQXdhcmVJbmNpZGVudCcpO1xuICAgICAgICAgICAgdmFyIHRoZURPTUF3YXJlSW5jaWRlbnQgPSBuZXcgRE9NQXdhcmVJbmNpZGVudChpbmNpZGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhlRE9NQXdhcmVJbmNpZGVudDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZmxhc2hET00nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZmxhc2hET00oKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIGZhaWxlZEFkZGl0aW9uczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZsYXNoUmVzdWx0ID0gdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZmxhc2hET00oKTtcbiAgICAgICAgICAgICAgICByZXN1bHQuZmFpbGVkQWRkaXRpb25zID0gcmVzdWx0LmZhaWxlZEFkZGl0aW9ucy5jb25jYXQoZmxhc2hSZXN1bHQuZmFpbGVkQWRkaXRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgQW55IFNjZW5lIGNhbiByZWNlaXZlIHRoZSBhZGRJbmNkZW50IGNvbW1hbmQgZWl0aGVyIGZvciBhZGRpbmcgYW4gSW5jaWRlbnQgb24gaXRzIG93biBJbmNpZGVudHMgbGlzdCBvciBpbiBvcmRlclxuICAgICAgICB0byBwYXNzIGRlZXBlciB0aGUgY29tbWFuZCB0byB0aGUgcGFyZW50IFNjZW5lIG9mIHRoZSBJbmNpZGVudCAoc2NlbmVJZCkuXG4gICAgICAgIE5vIG1hdHRlciB3aGljaCBTY2VuZSB0b29rIHRoZSBjb21tYW5kLCBhbGwgcGFyZW50IFNjZW5lcyBnZXQgaW5mb3JtZWRcbiAgICAgICAgIGFkZEluY2lkZW50IHRha2VzIDMgYXJndW1lbnRzOlxuICAgICAgICBAcGFyYW0ge0luY2lkZW50fSBpbmNpZGVudCAtIHRoZSBJbmNpZGVudCBvYmplY3QgdG8gZ2V0IGFkZGVkXG4gICAgICAgIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0byB3aGljaCB3ZSB3YW50IHRoZSBJbmNpZGVudCB0byBnZXQgYWRkZWQsIHN0YXJ0aW5nIGZyb20gdGhlIHplcm8gcG9pbnQgb2YgdGhlXG4gICAgICAgICAgICB0YXJnZXQgU2NlbmUuIEl0IGNhbid0IGJlIG5lZ2F0aXZlXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSBzY2VuZUlkIC0gdGhlIHNjZW5lSWQgdG8gd2hpY2ggd2Ugd2FudCB0byBwdXQgdGhlIG5ldyBJbmNpZGVudC4gSXQgaXMgb3B0aW9uYWwgYW5kIGlmIGl0IGlzIG5vdCBzcGVjaWZpZWQgdGhlXG4gICAgICAgICAgICB0YXJnZXQgU2NlbmUgaXMgdGhlIGN1cnJlbnQgb25lXG4gICAgICAgIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gb25lIG9mIFwiYWxsLW9yLW5vdGhpbmdcIiAvIFwia2VlcC1wYXNzaW5nXCJcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluY2lkZW50KGluY2lkZW50LCBtaWxsaXNlY29uZCwgc2NlbmVJZCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiYWxsLW9yLW5vdGhpbmdcIjtcblxuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdtaW51cyBtaWxsaXNlY29uZCB2aW9sYXRpb24nXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZCAqIDE7IC8vIGEgYmFja3VwIHZhcmlhYmxlIGhvbGRpbmcgdGhlIG9yaWdpbmFsIG1pbGxpc2Vjb25kIHBhc3NlZCBhc1xuICAgICAgICAgICAgLy8gdGhpcyBtaWdodCBjaGFuZ2UgZHVyaW5nIHBvdGVudGlhbCBsZWZ0IGV4cGFuc2lvbiBtYW5pcHVsYXRpb25cblxuICAgICAgICAgICAgaWYgKCFzY2VuZUlkIHx8IHNjZW5lSWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnQgPSB0aGlzLl9wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbihpbmNpZGVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyB3aGVuIGFkZGluZyBoZWFkbGVzcyBDbGlwcyB0byBhIGdyb3VwIHRoYXQgaGFzIGNvbnRleHQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdGhlIGNsaXAgaXRzZWxmIG9yIGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyBpdCBiZWxvbmdzIHRvIGEgY2xpcCB0aGF0IGhhcyBjb250ZXh0KSB3ZSBuZWVkIHRvIHJ1biBmbGFzaCB0aGUgbmV3bHkgZW50ZXJlZCBncm91cCdzIGRvbSBzbyBpdCBjcmVhdGVzXG4gICAgICAgICAgICAgICAgLy8gaXRzIGVsZW1lbnRJbmNpZGVudHNcbiAgICAgICAgICAgICAgICB2YXIgZmxhc2hJbmNpZGVudHNET01BZnRlckVudGVyID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5jaWRlbnQuaGFzSW5jaWRlbnRzICYmIGluY2lkZW50LmlzSGVhZGxlc3NDbGlwICYmIHRoaXMuY29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGZsYXNoSW5jaWRlbnRzRE9NQWZ0ZXJFbnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQuc2V0UGFyZW50U2NlbmUodGhhdCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgSW5jaWRlbnQgaXMgZWxpZ2libGUgZm9yIGFkZGl0aW9uXG4gICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uQ2hlY2sgPSB0aGlzLmNoZWNrQWRkaXRpb24oaW5jaWRlbnQsIG1pbGxpc2Vjb25kLCB0eXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkaXRpb25DaGVjay5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRpdGlvbkNoZWNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGRpdGlvbkNoZWNrLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgICAgIC8vIGluZGV4aW5nIHN0YXJ0XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpbmNpZGVudC5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGluY2lkZW50LFxuICAgICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWRbaW5jaWRlbnQuaWRdID0gaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGtleWZyYW1lX3NlY19rZXkgPSBjb25mLmtleWZyYW1lX3NlY19rZXkgKyBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMua2V5ZnJhbWVzLmhhc093blByb3BlcnR5KGtleWZyYW1lX3NlY19rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldID0ge307XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldW2luY2lkZW50LmlkXSA9IGluY2lkZW50O1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzS2V5ZnJhbWVLZXlzW2luY2lkZW50LmlkXSA9IGtleWZyYW1lX3NlY19rZXk7XG4gICAgICAgICAgICAgICAgLy8gaW5kZXhpbmcgZW5kXG5cbiAgICAgICAgICAgICAgICBpbmNpZGVudC5leGVjdXRpb25TcGVlZCA9IHRoaXMuc3BlZWQ7XG5cbiAgICAgICAgICAgICAgICAvLyBzdWJzY3JpYmUgSW5jaWRlbnQgc3RhcnQgb24gdGhlIGxpc3RlbmVyc1xuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRNaWxsaXNlY29uZDogdGhlIG1pbGxpc2Vjb25kIHRoZSBHcm91cCBpcyBvblxuICAgICAgICAgICAgICAgIC8vIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgd2Ugc2V0IG91ciBJbmNpZGVudCB0byBnZXQgZXhlY3V0ZWQgb24gdGhlIEdyb3VwJ3MgdGltZWxpbmVcbiAgICAgICAgICAgICAgICB2YXIgZnVuY3QgPSBmdW5jdGlvbiBmdW5jdChjdXJyZW50TWlsbGlzZWNvbmQsIHByZXZpb3VzVGltZVN0YW1wLCBzY2VuZVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmNpZGVudC5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TWlsbGlzZWNvbmQgPj0gbWlsbGlzZWNvbmQgJiYgY3VycmVudE1pbGxpc2Vjb25kIDw9IG1pbGxpc2Vjb25kICsgaW5jaWRlbnQuZHVyYXRpb24gfHwgaW5jaWRlbnQuc3RhdGUgPT09ICdpZGxlJyAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPiBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dyZWF0ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5wbGF5KHsgc3RhcnRGcm9tOiBjdXJyZW50TWlsbGlzZWNvbmQgLSBtaWxsaXNlY29uZCwgcHJldmlvdXNUaW1lU3RhbXA6IHByZXZpb3VzVGltZVN0YW1wIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRNaWxsaXNlY29uZCA+PSBtaWxsaXNlY29uZCAmJiBjdXJyZW50TWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQgKyBpbmNpZGVudC5kdXJhdGlvbiB8fCBpbmNpZGVudC5zdGF0ZSA9PT0gJ2NvbXBsZXRlZCcgJiYgY3VycmVudE1pbGxpc2Vjb25kIDwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdncmVhdGVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQucGxheSh7IHN0YXJ0RnJvbTogY3VycmVudE1pbGxpc2Vjb25kIC0gbWlsbGlzZWNvbmQsIHByZXZpb3VzVGltZVN0YW1wOiBwcmV2aW91c1RpbWVTdGFtcCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZShpbmNpZGVudC5pZCwgZnVuY3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWRkZWQobWlsbGlzZWNvbmQsIGluY2lkZW50LmR1cmF0aW9uKTtcblxuICAgICAgICAgICAgICAgIGlmIChmbGFzaEluY2lkZW50c0RPTUFmdGVyRW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGluY2lkZW50LmZsYXNoRE9NKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZmFpbGVkQWRkaXRpb25zLmxlbmd0aCA+IDAgJiYgdHlwZSA9PT0gXCJhbGwtb3Itbm90aGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUluY2lkZW50KGluY2lkZW50LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IHJlc3VsdC5mYWlsZWRBZGRpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBmbGFzaGluZyBpbmNpZGVudCdzIERPTSBwYXNzZXMgbGV0IHRoZSBJbmNpZGVudCBrbm93IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IG5vdyBoYXMgY29udGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25BZGRJbmNpZGVudChpbmNpZGVudCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgnaW5jaWRlbnQgYWRkZWQnKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQWRkSW5jaWRlbnQoaW5jaWRlbnQsIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgnaW5jaWRlbnQgYWRkZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5hZGRJbmNpZGVudChpbmNpZGVudCwgbWlsbGlzZWNvbmQgLSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCwgc2NlbmVJZCkucmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGlmIGl0IHJlYWNoZXMgdGhlIGVuZCBvZiB0aGUgbG9vcCB3aXRob3V0IGhhdmluZyByZXR1cm5lZCB0cnVlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEFueSBTY2VuZSBjYW4gcmVjZWl2ZSB0aGUgZWRpdEluY2lkZW50IGNvbW1hbmQgaW4gb3JkZXIgdG8gc2V0IGEgbmV3IHN0YXJ0aW5nIHBvaW50IGZvciBvbmUgb2YgaXRzIG93biBJbmNpZGVudHMgb3IgdG9cbiAgICAgICAgcGFzcyB0aGUgY29tbWFuZCBkZWVwZXIgZG93biB0byBpdHMgY2hpbGRyZW4gU2NlbmVzIHNvIHRoZSBwYXJlbnQgb2YgaXQgY2FuIHRha2UgY2FyZSBvZiBpdC5cbiAgICAgICAgVGhlIEluY2lkZW50IG9iamVjdCBhbmQgaWQgcmVtYWluIHRoZSBzYW1lIGFmdGVyIHRoZSBlZGl0LlxuICAgICAgICBObyBtYXR0ZXIgd2hpY2ggU2NlbmUgdGFrZXMgdGhlIGNvbW1hbmQsIGFsbCBQYXJlbnRzIGdldCBpbmZvbWVkIGFib3V0IHRoZSBlZGl0LlxuICAgICAgICAgSXQgdGFrZXMgdHdvIHBhcmFtczpcbiAgICAgICAgIEBwYXJhbSB7c3RyaW5nfSBpZCAtIHRoZSBpZCBvZiB0aGUgaW5jaWRlbnQgdG8gYmUgZWRpdGVkXG4gICAgICAgICBAcGFyYW0ge2ludH0gbmV3bWlsbGlzZWNvbmQgLSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBJbmNpZGVudCBjb21wYXJlZCB0byB0aGUgdGFyZ2V0IFNjZW5lIHN0YXJ0IChhbmQgbm90IHRvIHRoZSBTY2VuZSBpdCBiZWxvbmdzKVxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWRpdEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVkaXRJbmNpZGVudChpZCwgbmV3bWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBleHBhbnNpb25WYWxpZGF0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbE1pbGxpc2Vjb25kID0gbmV3bWlsbGlzZWNvbmQgKiAxO1xuXG4gICAgICAgICAgICBpZiAoIWhlbHBlci5pc1N0cmluZyhpZCkpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ2VkaXRJbmNpZGVudCBtZXRob2Qgb2YgR3JvdXAgZXhwZWN0cyBhcyBpdHMgZmlyc3QgYXJndW1lbnQgdGhlIGlkIG9mIHRoZSBJbmNpZGVudCB0byBlZGl0IGluIHN0cmluZyBmb3JtYXQuICcgKyAodHlwZW9mIGlkID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpZCkpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IFt7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnd3JvbmcgcGFyYW1ldGVyIHR5cGUnXG4gICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhpc3RpbmdNaWxsaXNlY29uZCA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpZCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kRGVsdGEgPSBuZXdtaWxsaXNlY29uZCAtIGV4aXN0aW5nTWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgLy8gZmlyc3QgY2hlY2sgZm9yIG1pbnVzIGV4cGFuc2lvblxuICAgICAgICAgICAgICAgIGlmIChuZXdtaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIFNjZW5lIGRvZXNuJ3QgaGF2ZSBhIHBhcmVudCB0aGVuIGl0IGlzIHRoZSByb290IGFuZCB0aHVzIGl0IGNhbid0IGV4cGFuZCB0byB0aGUgbGVmdFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3RzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnbWludXMgbWlsbGlzZWNvbmQgdmlvbGF0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZXhwYW5zaW9uVmFsaWRhdGlvbiA9IHRoaXMucGFyZW50U2NlbmVPYmplY3QuZXhwYW5kU2NlbmVUb1RoZUxlZnQoLW5ld21pbGxpc2Vjb25kLCB0aGlzLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuc2lvblZhbGlkYXRpb24ucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0czogW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ21pbnVzIG1pbGxpc2Vjb25kIHZpb2xhdGlvbidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld21pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gZW5kIG9mIGlmIG1pbGxpc2Vjb25kIDwgMFxuXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVkaXQgaXMgYWxsb3dlZCAodGh1cyB3ZSBjb21lIHRvIHRoYXQgcG9pbnQpIGFuZCB0aGUgb3JpZ2luYWxNaWxsaXNlY29uZCBpcyBsb3dlciB0aGFuIDBcbiAgICAgICAgICAgICAgICBpZiAob3JpZ2luYWxNaWxsaXNlY29uZCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5leHBhbmRTdGFydFBvaW50KC1vcmlnaW5hbE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c0J5SWRbaWRdLnN0b3AoKTtcblxuICAgICAgICAgICAgICAgIHZhciBlZGl0Q2hlY2sgPSB0aGlzLmNoZWNrRWRpdCh0aGlzLmluY2lkZW50c0J5SWRbaWRdLCBtaWxsaXNlY29uZERlbHRhKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKGVkaXRDaGVjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBhbnNpb25WYWxpZGF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbnNpb25WYWxpZGF0aW9uLnVuZG8oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kU3RhcnRQb2ludChvcmlnaW5hbE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdENoZWNrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVkaXRDaGVjay5leGVjdXRlKCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgZWRpdEluY2lkZW50U3RhcnRSZXN1bHQgPSB0aGlzLmNoYW5nZUluY2lkZW50c1N0YXJ0TWlsbGlzZWNvbmQobmV3bWlsbGlzZWNvbmQsIGlkKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMub25FZGl0SW5jaWRlbnQodGhpcy5pbmNpZGVudHNCeUlkW2lkXSwgZWRpdEluY2lkZW50U3RhcnRSZXN1bHQub2xkTWlsbGlzZWNvbmQsIG5ld21pbGxpc2Vjb25kKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5lZGl0SW5jaWRlbnQoaWQsIG5ld21pbGxpc2Vjb25kIC0gdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQpLnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBpZiBpdCByZWFjaGVzIHRoZSBlbmQgb2YgdGhlIGxvb3Agd2l0aG91dCBoYXZpbmcgcmV0dXJuZWQgdHJ1ZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICBBbnkgU2NlbmUgY2FuIHJlY2VpdmUgdGhlIHJlbW92ZUluY2lkZW50IGNvbW1hbmQgZWl0aGVyIGZvciByZW1vdmluZyBvbmUgb2YgaXRzIG93biBJbmNpZGVudHMgb3IgZm9yIHBhc3NpbmcgdGhlIGNvbW1hbmRcbiAgICAgICAgZGVlcGVyIGRvd24gdG8gaXRzIFNjZW5lcyB0cmVlIGFuZCBoYXZlIHRoZSBJbmNpZGVudCBkZWxldGVkIG5vIG1hdHRlciB0byB3aGljaCBjaGlsZCBTY2VuZSBpdCBiZWxvbmdzXG4gICAgICAgIE5vIG1hdHRlciB3aGljaCBTY2VuZSB0b29rIHRoZSBjb21tYW5kLCBhbGwgcGFyZW50IFNjZW5lcyBnZXQgaW5mb3JtZWRcbiAgICAgICAgIEl0IHRha2VzIGp1c3Qgb25lIGFyZ3VtZW50OlxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gaWQgLSB0aGUgaWQgb2YgdGhlIEluY2lkZW50IHRvIGJlIGRlbGV0ZWRcbiAgICAgICAgQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gaWYgcGFzc2VkIGl0IHN1cHBvcnRzIHRoZSBwcmV2ZW50U2xpcCBrZXkgd2hpY2ggaWYgZmFsc2UgdGhlIGNoYW5uZWwgc2hvdWxkIG5vdCBzbGlwLiBUaGlzIGNhc2UgaXMgZm9yIFxuICAgICAgICAgICAgZmxhc2hET00gb2YgRE9NQXdhcmVJbmNpZGVudHMgd2hlcmUgd2UgaGF2ZSBlbGVtZW50cyBkZWxldGVkIHNvIHNsaXBwaW5nIG9uIHRoZWlyIGxhbmVzIGlzIG5vdCB2YWxpZCBub3IgbmVjZXNzYXJ5XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmNpZGVudChpZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsZXRlQ2hlY2sgPSB0aGlzLmNoZWNrRGVsZXRlKGlkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKGRlbGV0ZUNoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKGRlbGV0ZUNoZWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZUNoZWNrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlbGV0ZUNoZWNrLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF0ubGFzdFdpc2goKTtcblxuICAgICAgICAgICAgICAgIHZhciBrZXlmcmFtZV9zZWNfa2V5ID0gdGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaWRdO1xuICAgICAgICAgICAgICAgIC8vT1BUSU1JWkUgZGVsZXRlIGlzIHNsb3cgb24gdjggZW5naW5lIHdlIHNob3VsZCBjaGVjayBpZiB3ZSBjYW4gYWNoaWV2ZSB0aGUgc2FtZSByZXN1bHQgYnkgc2V0dGluZyB0aGUgdmFsdWUgb2YgdGhlIGtleSB0byB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5pbmNpZGVudHNLZXlmcmFtZUtleXNbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmtleWZyYW1lc1trZXlmcmFtZV9zZWNfa2V5XVtpZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuaW5jaWRlbnRzQnlJZFtpZF07XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW2tleWZyYW1lX3NlY19rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5saXN0ZW5lcnNbaWRdOyAvLyBkZWxldGUgdGhlIGxpc3RlbmVyIHRoYXQgbWFuYWdlcyB0aGUgSW5jaWRlbnQncyBleGVjdXRpb25cblxuICAgICAgICAgICAgICAgIHZhciBkZWxldGVkSW5jaWRlbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVkSW5jaWRlbnQgPSB0aGlzLmluY2lkZW50cy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVtb3ZlSW5jaWRlbnQoZGVsZXRlZEluY2lkZW50WzBdKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c1tfaV0uaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbX2ldLmluY2lkZW50LnJlbW92ZUluY2lkZW50KGlkKS5yZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gLy8gaWYgaXQgcmVhY2hlcyB0aGUgZW5kIG9mIHRoZSBsb29wIHdpdGhvdXQgaGF2aW5nIHJldHVybmVkIHRydWVcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2hpY2ggaXMgcHJvdmlkZWQgb25seSBieSBHcm91cHMgYWNjZXB0cyBhbiBpbmNpZGVudElkIGFuZCBhIG5ldyBkdXJhdGlvbiBhbmQgXG4gICAgICAgICAqIGVkaXRzIHRoZSBkdXJhdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZyBpbmNpZGVudCBhY2NvcmRpbmdseVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5jaWRlbnRJZCAtIHRoZSBpZCBvZiB0aGUgaW5jaWRlbnQgdG8gcmVzaXplXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBuZXdEdXJhdGlvbiAtIHRoZSBuZXcgZHVyYXRpb24gb2YgdGhlIGluY2lkZW50IGluIG1pbGxpc2Vjb25kc1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNpemVJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVJbmNpZGVudChpbmNpZGVudElkLCBuZXdEdXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nSW5jaWRlbnQgPSB0aGlzLmdldEluY2lkZW50QnlJZChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0luY2lkZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgZXJyb3JzOiBbeyByZWFzb246ICdUaGUgaW5jaWRlbnQgd2l0aCBpZCAnICsgaW5jaWRlbnRJZCArICcgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBHcm91cCBvciBhbnkgb2YgaXRzIGNoaWxkIEdyb3VwcycgfV0gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0luY2lkZW50LnJlc2l6ZShuZXdEdXJhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2Qgd2hpY2ggaXMgcHJvdmlkZWQgb25seSBieSBHcm91cHMgYWNjZXB0cyBhbiBpbmNpZGVudElkIGFuZCBhIG5ldyBhdHRycyBvYmplY3QgXG4gICAgICAgICAqIGFuZCBlZGl0cyB0aGUgYXR0cmlidXRlcyBvZiB0aGUgY29ycmVzcG9uZGluZyBpbmNpZGVudCBhY2NvcmRpbmdseVxuICAgICAgICAgKiBJZiB0aGUgYXR0cmlidXRlIGVkaXRpbmcgZW5kcyB1cCB3aXRoIGNvbmZsaWN0cyB0aGUgZWRpdCBpcyBkaXNjYXJkZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbmNpZGVudElkIC0gdGhlIGlkIG9mIHRoZSBpbmNpZGVudCB0byByZXNpemVcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGF0dHJzIC0gdGhlIG5ldyBhdHRycyBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWRpdEluY2lkZW50QXR0cmlidXRlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0SW5jaWRlbnRBdHRyaWJ1dGVzKGluY2lkZW50SWQsIGF0dHJzKSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0UGFyZW50ID0gdGhpcy5fZ2V0RGlyZWN0UGFyZW50KGluY2lkZW50SWQpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogWydUaGUgSW5jaWRlbnQgd2l0aCBpZCAnICsgaW5jaWRlbnRJZCArICcgZG9lcyBub3QgYmVsb25nIHRvIHRoZSBHcm91cCBvciBhbnkgb2YgaXRzIGNoaWxkIEdyb3VwcyddXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkaXJlY3RQYXJlbnQuX2VkaXRDaGlsZEluY2lkZW50QXR0cmlidXRlcyhpbmNpZGVudElkLCBhdHRycyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQnkgdGhpcyBtZXRob2QgYSBHcm91cCB0cmllcyB0byBlZGl0IHRoZSBhdHRyaWJ1dGVzIG9mIG9uZSBvZiBpdHMgY2hpbGRyZW4uIFRoZSBwcm9jZXNzIGdvZXMgYXMgZm9sbG93czpcbiAgICAgICAgICogMS4gVGhlIEdyb3VwIGdldHMgYW4gZXhwb3J0IG9mIHRoZSBJbmNpZGVudCdzIHN0YXRlXG4gICAgICAgICAqIDIuIFRoZSBHcm91cCBkZWxldGVzIHRoZSBJbmNpZGVudFxuICAgICAgICAgKiAzLiBUaGUgR3JvdXAgdHJpZXMgdG8gY3JlYXRlIGEgbmV3IEluY2lkZW50IHdpdGggdGhlIHNhbWUgaWQgYXMgdGhlIG9sZCBvbmUgYW5kIHdpdGggdHlwZT1cImFsbC1vci1ub3RoaW5nXCJcbiAgICAgICAgICogNC5hLiBJZiB0aGUgbmV3IEluY2lkZW50IGdldHMgYWRkZWQgb2sgcHJvY2VzcyBmaW5pc2hlc1xuICAgICAgICAgKiA0LmIuIElmIHRoZSBuZXcgSW5jaWRlbnQgZG9lc24ndCBnZXQgYWRkZWQgYmVjYXVzZSBvZiBjb25mbGljdHMgdGhlIHByZXZpb3VzIEluY2lkZW50IGdldHMgYmFjayBpblxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5jaWRlbnRJZCAtIHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQgdG8gZWRpdCBpdHMgYXR0cnNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGF0dHJzIC0gdGhlIG5ldyBhdHRyaWJ1dGVzIG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZWRpdENoaWxkSW5jaWRlbnRBdHRyaWJ1dGVzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lZGl0Q2hpbGRJbmNpZGVudEF0dHJpYnV0ZXMoaW5jaWRlbnRJZCwgYXR0cnMpIHtcbiAgICAgICAgICAgIHZhciBpbmNpZGVudFRvRWRpdCA9IHRoaXMuZ2V0SW5jaWRlbnRCeUlkKGluY2lkZW50SWQpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nSW5jaWRlbnREZWZpbml0aW9uID0gaW5jaWRlbnRUb0VkaXQuZXhwb3J0U3RhdGUoKTtcbiAgICAgICAgICAgIHZhciBtaWxsaXNlY29uZCA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW5jaWRlbnQoaW5jaWRlbnRJZCk7XG4gICAgICAgICAgICB2YXIgbmV3SW5jaWRlbnRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nSW5jaWRlbnREZWZpbml0aW9uLnByb3BzKTtcbiAgICAgICAgICAgIHZhciBuZXdJbmNpZGVudCA9IG5ldyBleGlzdGluZ0luY2lkZW50RGVmaW5pdGlvbi5JbmNpZGVudChhdHRycywgbmV3SW5jaWRlbnRQcm9wcyk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5hZGRJbmNpZGVudChuZXdJbmNpZGVudCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG15T2xkSW5jaWRlbnQgPSBuZXcgZXhpc3RpbmdJbmNpZGVudERlZmluaXRpb24uSW5jaWRlbnQoZXhpc3RpbmdJbmNpZGVudERlZmluaXRpb24uYXR0cnMsIG5ld0luY2lkZW50UHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkSW5jaWRlbnQobXlPbGRJbmNpZGVudCwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnRpbmcgZnJvbSBpdHNlbGYgYW5kIGdvaW5nIGFsbCB0aGUgd2F5IGRvd24gdG8gZWFjaCBhbmQgZXZlcnkgbGVhZiBvZiBpdHMgdHJlZSBpdCBzeXN0b2xzL2RpYXN0b2xlcyB0aGVcbiAgICAgICAgICogSW5jaWRlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGR1cmF0aW9uRnJhY3Rpb24gdGhlIGZyYWN0aW9uIG9mIHRoZSBuZXcgZHVyYXRpb24gdG8gdGhlIGV4aXN0aW5nIGR1cmF0aW9uXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzeXN0b2xEaWFzdG9sZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xEaWFzdG9sZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbiA9IGR1cmF0aW9uRnJhY3Rpb24gKiB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSW5jaWRlbnRzU3RhcnRNaWxsaXNlY29uZCh0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb24sIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zeXN0b2xEaWFzdG9sZShkdXJhdGlvbkZyYWN0aW9uKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgaXQgaXMgYSBDbGlwIGFsbCBDaGFubmVscyBvZiBpdCBzaG91bGQgZ2V0IHJlc2l6ZWRcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVGhlQ2xpcCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHNba2V5XS5fcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRIRSBcIkVBUlNcIiBPRiBUSEUgU0NFTkUgVE8gSVRTIENISUxEIElOQ0lERU5UU1xuICAgICAgICAvKipcbiAgICAgICAgICAgICAgTkVXIFNUQVRFIENBTENVTEFUSU9OIFJVTEVTOlxuICAgICAgICAgICAgICBJZiBhIFNjZW5lIGhhcyBhdCBsZWFzdCBvbmUgY2xpcEJsb2NraW5nV2FpdGluZyAobWVhbmluZyB0aGUgZnVsbCBDbGlwIGlzIGhhbHRlZCBhdCB0aGUgbW9tZW50KSB0aGUgU2NlbmXigJlzIHN0YXRlIHdpbGwgYmUg4oCcY2xpcEJsb2NraW5nV2FpdGluZ+KAnSB1bmxlc3MgaXQgaXMgdGhlIENsaXAgc28gaXRzIHN0YXRlIHdpbGwgYmUg4oCcd2FpdGluZ+KAnS5cbiAgICAgICAgICAgICAgSWYgYSBTY2VuZSBoYXMgYWxsIGNoaWxkcmVuIG9uIHRoZSBjb21wbGV0ZWQgc3RhdGUsIHRoZSBTY2VuZSBoYXMgdGhlIGNvbXBsZXRlZCBzdGF0ZSBhcyB3ZWxsLlxuICAgICAgICAgICAgICBJZiBhIFNjZW5lIGhhcyBhdCBsZWFzdCBvbmUgb2YgaXRzIGNoaWxkcmVuIG9uIG9uZSBvZiB0aGUgZm9sbG93aW5nIHN0YXRlczpcbiAgICAgICAgICAgICAgICAgICAgd2FpdGluZyAgICAgaXQgaGFzIHN0YXJ0ZWQgcGxheWluZyBhbmQgaGFzIGJlZW4gaGFsdGVkIGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgcGxheWluZyAgICAgaXQgaGFzIHN0YXJ0ZWQgcGxheWluZ1xuICAgICAgICAgICAgICAgICAgICBpZGxlICAgICAgICAgICAgaXQgaGFzIG5vdCBiZWVuIGV4ZWN1dGVkIHlldFxuICAgICAgICAgICAgICB0aGUgU2NlbmUgaXMgb24gcGxheWluZyBzdGF0ZVxuICAgICAgICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaW5jaWRlbnRTdGF0ZUNoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNpZGVudFN0YXRlQ2hhbmdlKGlkLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09ICdjbGlwQmxvY2tpbmdXYWl0aW5nJyB8fCBuZXdTdGF0ZSA9PT0gJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9wc1RvUGFzcyA9IHByb3BzO1xuICAgICAgICAgICAgICAgIHByb3BzVG9QYXNzLmNhbGxlcklkID0gaWQ7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0YXRlID09PSAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0b3AgcHJvcGFnYXRpb24gYXMgdGhpcyBzaG91bGQgb25seSBhZmZlY3QgdGhlIFNjZW5lIGFuZCBub3QgaXRzIHBhcmVudHNcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9ICd3YWl0aW5nJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0KHByb3BzVG9QYXNzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3U3RhdGUgPT09ICdjb21wbGV0ZWQnICYmIHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnSW5jaWRlbnQgJyArIGlkICsgJyBnb3QgaW50byBjb21wbGV0ZWQgc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdJbmNpZGVudCAnICsgdGhpcy5pZCArICcgdGFrZXMgY2FyZSBvZiBpdCcpO1xuICAgICAgICAgICAgICAgIHZhciBhbGxDb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ2dvaW5nIHRvIGl0ZXJhdGUgb24gYWxsIEluY2lkZW50cycpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhcbiAgICAgICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmlkICsgJy5zdGF0ZSA9ICcgKyB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5zdGF0ZVxuICAgICAgICAgICAgICAgICAgICAvLyApO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuc3RhdGUgIT0gJ2NvbXBsZXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbENvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFsbENvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdTdGF0ZSA9PT0gJ2lkbGUnICYmIHRoaXMuc3BlZWQgPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnSW5jaWRlbnQgJyArIGlkICsgJyBnb3QgaW50byBjb21wbGV0ZWQgc3RhdGUnKTtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdJbmNpZGVudCAnICsgdGhpcy5pZCArICcgdGFrZXMgY2FyZSBvZiBpdCcpO1xuICAgICAgICAgICAgICAgIHZhciBfYWxsQ29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdnb2luZyB0byBpdGVyYXRlIG9uIGFsbCBJbmNpZGVudHMnKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLmluY2lkZW50c1tpXS5pbmNpZGVudC5pZCArICcuc3RhdGUgPSAnICsgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgLy8gKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzW19pMl0uaW5jaWRlbnQuc3RhdGUgIT0gJ2lkbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYWxsQ29tcGxldGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2FsbENvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHRoZSBjaGlsZCB3YXMgZWl0aGVyIG9uIHNjZW5lQmxvY2tpbmdXYWl0aW5nIG9yIGNsaXBCbG9ja2luZ1dhaXRpbmcgYW5kIG5vdyBpcyBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICBCTE9DSyBXQUlUSU5HUyBNQU5JUFVMQVRJT04gTUVUSE9EU1xuICAgICAgICAqL1xuICAgICAgICAvKipcbiAgICAgICAgQHBhcmFtIHtvYmplY3R9IHByb3BzIC1cbiAgICAgICAgdGhlIG5hdHVyZSBvZiBhIHdhaXRpbmcgbWlnaHQgYmU6XG4gICAgICAgICAgICAgLSBzY2hlZHVsZWQgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBkeW5hbWljXG4gICAgICAgICAgICAgLSBzeXN0ZW0tZXJyb3JcbiAgICAgICAgICB0aGUgd2FpdGluZ1N0YXRlTmFtZSBvZiBhIHdhaXRpbmcgY2FuIGJlOlxuICAgICAgICAgICAgIC0gd2FpdGluZyAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFxuICAgICAgICAgICAgIC0gc2NlbmVCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAtIGNoYW5uZWxCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAtIGNsaXBCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgaWQ6IHRoZSBpZCBvZiB0aGUgdHJpZ2dlcmluZyBJbmNpZGVudFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRCbG9ja1dhaXRpbmcnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QmxvY2tXYWl0aW5nKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdChwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy53YWl0aW5nU3RhdGVOYW1lID09PSAnY2hhbm5lbEJsb2NraW5nV2FpdGluZycgJiYgdGhpcy5pc0NoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXQocHJvcHMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ2NsaXBCbG9ja2luZ1dhaXRpbmcnICYmIHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWl0KHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MucHVzaChwcm9wcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLndhaXRpbmdTdGF0ZU5hbWUgPT09ICd3YWl0aW5nJyAmJiBwcm9wcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2FpdChwcm9wcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzLnB1c2gocHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5zZXRCbG9ja1dhaXRpbmcocHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgQHBhcmFtIHtvYmplY3R9IHByb3BzIC1cbiAgICAgICAgdGhlIG5hdHVyZSBvZiBhIHdhaXRpbmcgbWlnaHQgYmU6XG4gICAgICAgICAgICAgLSBzY2hlZHVsZWQgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBkeW5hbWljXG4gICAgICAgICAgICAgLSBzeXN0ZW0tZXJyb3JcbiAgICAgICAgICB0aGUgd2FpdGluZ1N0YXRlTmFtZSBvZiBhIHdhaXRpbmcgY2FuIGJlOlxuICAgICAgICAgICAgIC0gd2FpdGluZyAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFxuICAgICAgICAgICAgIC0gc2NlbmVCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAtIGNoYW5uZWxCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAtIGNsaXBCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgaWQ6IHRoZSBpZCBvZiB0aGUgdHJpZ2dlcmluZyBJbmNpZGVudFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd1bnNldEJsb2NrV2FpdGluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNldEJsb2NrV2FpdGluZyhwcm9wcykge1xuICAgICAgICAgICAgaWYgKHByb3BzLndhaXRpbmdTdGF0ZU5hbWUgPT09ICdzY2VuZUJsb2NraW5nV2FpdGluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUJsb2NrKHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ibG9ja2luZ1dhaXRpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb3BzLndhaXRpbmdTdGF0ZU5hbWUgPT09ICdjaGFubmVsQmxvY2tpbmdXYWl0aW5nJyAmJiB0aGlzLmlzQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQmxvY2socHJvcHMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5ibG9jaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ2NsaXBCbG9ja2luZ1dhaXRpbmcnICYmIHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVCbG9jayhwcm9wcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9wcy53YWl0aW5nU3RhdGVOYW1lID09PSAnd2FpdGluZycgJiYgcHJvcHMuaWQgPT09IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUJsb2NrKHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ibG9ja2luZ1dhaXRpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVuYmxvY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LnVuc2V0QmxvY2tXYWl0aW5nKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXQgY2hlY2tzIGlmIGEgYmxvY2sgd2l0aCB0aGUgcHJvdmlkZWQgcHJvcHMgZXhpc3RzIG9uIGl0cyBibG9ja2luZ1dhaXRpbmdzIGFycmF5XG4gICAgICAgICAqIGlmIGl0IGV4aXN0cyBpdCByZW1vdmVzIGl0LlxuICAgICAgICAgKiBJZiB0aGUgcmVtYWluaW5nIGJsb2NraW5nIHdhaXRpbmdzIGFyZSBlcXVhbCB0byAwIGl0IHJldHVybnMgdHJ1ZSBvdGhlcndpc2UgaXQgcmV0dXJucyBmYWxzZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVCbG9jaycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVCbG9jayhwcm9wcykge1xuICAgICAgICAgICAgdmFyIG5ld0Jsb2NraW5nV2FpdGluZ3MgPSBbXTtcbiAgICAgICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYldhaXRpbmcgPSB0aGlzLmJsb2NraW5nV2FpdGluZ3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKGJXYWl0aW5nLmlkID09PSBwcm9wcy5pZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdCbG9ja2luZ1dhaXRpbmdzLnB1c2godGhpcy5ibG9ja2luZ1dhaXRpbmdzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0gbmV3QmxvY2tpbmdXYWl0aW5ncztcbiAgICAgICAgICAgIHJldHVybiBmb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnb1RvIG1ldGhvZCBzaG91bGQgYWx3YXlzIGJlIGhhbmRsZWQgYnkgdGhlIENsaXAuIE5vIG90aGVyIEdyb3VwIG5vciBJbmNpZGVudCBjYW4gaGFuZGxlIGdvVG8gYWxvbmUuXG4gICAgICAgICAqIFRodXMsIGlmIHRoZSBHcm91cCBpcyBub3QgdGhlIENsaXAgaXQgcGFzc2VzIHRoZSBjb21tYW5kIHVwLiBJZiB0aGUgR3JvdXAgaXMgdGhlIENsaXAgdGhlbiBpdCBoYW5kbGVzIGdvVG9cbiAgICAgICAgICogYnkgcGFzc2luZyB0aGUgY29tbWFuZCB0byBpdHMgQ2hhbm5lbHMuXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnb1RvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdvVG8obWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGRlY2lkZSB0aGUgbWlsbGlzZWNvbmQgd2Ugd2FudCB0byBnb1RvXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPT09IG51bGwgfHwgbWlsbGlzZWNvbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ3JlbGF0aXZlVG8nKSkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kICs9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChwcm9wcy5yZWxhdGl2ZVRvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kID4gdGhpcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5kdXJhdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobWlsbGlzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVscykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbnRpYXRlZENoYW5uZWxzW2tleV0uZ29UbyhtaWxsaXNlY29uZCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hlYWRsZXNzQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcHMucmVsYXRpdmVUbyA9IHRoaXMuaWQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ29UbyhtaWxsaXNlY29uZCwgcHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiB3aGVuIHRoZSBHcm91cCBpcyBvbiB0ZXN0IG1vZGUgKHRoaXMuaXNPblRlc3RNb2RlID0gdHJ1ZSkgdGhlIGVtdWxhdGVTdGVwIG1ldGhvZFxuICAgICAgICAgKiBiZWNvbWVzIGZ1bmN0aW9uYWwuXG4gICAgICAgICAqIFRoZSBtZXRob2QgdGFrZXMgYXMgaW5wdXQgdGhlIG1pbGxpc2Vjb25kc0RlbHRhIGZyb20gdGhlIHByZXZpb3VzIHRpbWVzdGFtcCBhbmQgdHJpZ2dlcnNcbiAgICAgICAgICogdGhlIHN0ZXAgZnVuY3Rpb24gcGFzc2luZyBpbiBhIGJha2VkIHRpbWVzdGFtcCBzbyB0aGUgSW5jaWRlbnQgYmVoYXZlcyBleGFjdGx5IGFzIGlmIHRoZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgcnVuXG4gICAgICAgICAqIHBhc3NpbmcgYSB0aW1lc3RhbXAgdGhhdCBoYXMgZXhhY3RseSBtaWxsaXNlY29uZHNEZWx0YSBkaWZmZXJlbmNlIGZyb20gdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEgLSB0aGUgbWlsbGlzZWNvbmRzIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgcHJldmlvdXMgdGltZXN0YW1wIGFuZCB0aGUgbmV3IG9uZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbXVsYXRlU3RlcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbXVsYXRlU3RlcChtaWxsaXNlY29uZHNEZWx0YSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT25UZXN0TW9kZSkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignZW11bGF0ZVN0ZXAgbWV0aG9kIGNhbiBvbmx5IGJlIHVzZWQgb24gdGVzdCBtb2RlJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RlcCh0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wICsgbWlsbGlzZWNvbmRzRGVsdGEpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkSW5jaWRlbnQgPSB0aGlzLmluY2lkZW50c1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRJbmNpZGVudC5pbmNpZGVudC5zdGF0ZSA9PT0gXCJwbGF5aW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkSW5jaWRlbnQuaW5jaWRlbnQuZW11bGF0ZVN0ZXAoTWF0aC5hYnMoKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kIC0gY2hpbGRJbmNpZGVudC5taWxsaXNlY29uZCAtIGNoaWxkSW5jaWRlbnQuaW5jaWRlbnQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKSAvIHRoaXMuc3BlZWQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgU2NlbmUgcmVjZWl2ZXMgdGhpcyBjb21tYW5kIGZyb20gaXRzIGNoaWxyZW4gYW5kIHRoZSBwdXJwb3NlIG9mIGl0IGlzIHRvIGhlbHAgdGhlIGNhbGxlclxuICAgICAgICAgKiBpZGVudGlmeSB0aGUgbWlsbGlzZWNvbmRzIGRlbHRhIG9mIGl0cyBzdGFydCBjb21wYXJlZCB0byB0aGUgcm9vdCBTY2VuZSBvZiBpdC5cbiAgICAgICAgICogSW4gYSBtdWx0aS1sZXZlbCBzaXR1YXRpb24gd2l0aCBTY2VuZXMgd2l0aGluIHNjZW5lcyB0aGUgU2NlbmUgdGhhdCByZWNlaXZlcyB0aGlzIGNvbW1hbmQgbWlnaHQgbm90IG93blxuICAgICAgICAgKiB0aGUgSW5jaWRlbnQgdGhhdCB0cmlnZ2VyZWQgdGhpcyB0aHJlYWQgZGlyZWN0bHkuIFRoYXQncyB3aHkgd2UgdXNlIHRoZSBleHRyYURlbHRhIGhlbHBpbmcgcGFyYW1ldGVyIHRoYXRcbiAgICAgICAgICogYWN0dWFsbHkgZGVsaXZlcnMgbGV2ZWwgYnkgbGV2ZWwgdGhlIGRlbHRhIG9mIHRoZSB0cmlnZ2VyaW5nIEluY2lkZW50IHdpdGhpbiB0aGUgdHJlZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW5jaWRlbnRJZCA9IHRoZSBpZCBvZiB0aGUgY2hpbGQgaW5jaWRlbnQgb2YgdGhlIHNjZW5lIHRoYXQgdHJpZ2VycmVkIHRoZSBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGV4dHJhRGVsdGEgLSB0aGUgZXh0cmEgZGVsdGEgdG8gYWRkIHRvIHRoZSByZXN1bHRcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldFJvb3RDdXJyZW50TWlsbGlzZWNvbmREZWx0YUZyb21JbmNpZGVudHNTdGFydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSb290Q3VycmVudE1pbGxpc2Vjb25kRGVsdGFGcm9tSW5jaWRlbnRzU3RhcnQoaW5jaWRlbnRJZCkge1xuICAgICAgICAgICAgdmFyIGV4dHJhRGVsdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IHN0ZXAgZmluZCB0aGUgc3RhcnQgbWlsbGlzZWNvbmQgb2YgdGhlIGluY2lkZW50XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRNaWxsaXNlY29uZCA9IHRoaXMuZ2V0SW5jaWRlbnRNaWxsaXNlY29uZChpbmNpZGVudElkKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgLSBpbmNpZGVudE1pbGxpc2Vjb25kIC0gZXh0cmFEZWx0YTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbUluY2lkZW50c1N0YXJ0KHRoaXMuaWQsIGluY2lkZW50TWlsbGlzZWNvbmQgKyBleHRyYURlbHRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgIENBTExCQUNLUyBBRlRFUiBTVUNDRVNTRlVMIEFERElORyAvIEVESVRJTkcgLyBERUxFVElORyBBTiBJTkNJREVOVFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25BZGRJbmNpZGVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFkZEluY2lkZW50KGluY2lkZW50LCBtaWxsaXNlY29uZCkge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uRWRpdEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uRWRpdEluY2lkZW50KGluY2lkZW50LCBvbGRNaWxsaXNlY29uZCwgbmV3TWlsbGlzZWNvbmQpIHt9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblJlbW92ZUluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVtb3ZlSW5jaWRlbnQoaW5jaWRlbnQpIHt9XG5cbiAgICAgICAgLy8gb24gR3JvdXBzIHRoZXJlIGlzIG5vIG5lZWQgdG8gcHJldmVudCByZS1pbnZva2luZyB0aGUgb25HZXRDb250ZXh0IG1ldGhvZFxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfb25HZXRDb250ZXh0T25jZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HZXRDb250ZXh0T25jZSgpIHtcbiAgICAgICAgICAgIHRoaXMub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0uaW5jaWRlbnQuX29uR2V0Q29udGV4dE9uY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHVyYXRpb24nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGN1bGF0ZWREdXJhdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuY2FsY3VsYXRlZER1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dyb3VwVHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwicGxhaW5cIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHJvamVjdGVkSW5jaWRlbnRzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQcm9qZWN0ZWRJbmNpZGVudHMoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhlY3V0aW9uU3BlZWQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcGVlZCkge1xuICAgICAgICAgICAgaGVscGVyLm5vdGljZSh0aGlzLmlkICsgJyBpcyBzZXR0aW5nIGl0cyBleGVjdXRpb24gc3BlZWQgdG86ICcgKyBzcGVlZCArICcgd2hpbGUgb24gbWlsbGlzZWNvbmQ6ICcgKyB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICBpZiAoc3BlZWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoXCJTcGVlZCBjYW4ndCBiZSAwXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmV4ZWN1dGlvblNwZWVkID0gc3BlZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzSGVhZGxlc3NDbGlwJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpICYmICF0aGlzLmlzVGhlQ2xpcDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29udGV4dCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3duQ29udGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hlYWRsZXNzQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5jb250ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEdyb3VwO1xufShUaW1lZEluY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHcm91cDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar checkTransition = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").checkTransition;\nvar helper = new Helper();\nvar Channel = __webpack_require__(/*! ../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\n\n/** @classdesc\n * Incidents are all events that should happen on a specific time on the timeline. An incident can have parametric\n      execution behaviour based on the times it has been executed and (might be) on other parameters.\n\n      The state an Incident can have is one of the following:\n                 idle\n                 playing\n                 waiting\n                 sceneBlockingWaiting\n                 clipBlockingWaiting\n                 blocked    // in the case the Incident is blocked / paused by a waiting\n                 completed\n\n      Each Incident has the obligation to inform the Scene about its state changes.\n      For this Incident provides the method “setParentScene” which takes just one argument a Timer object.\n      Timer provides the method “incidentStateChange” which lets the Incidents change their state by\n      providing their id and their new state.\n * */\n\nvar Incident = function () {\n    /**\n     It takes just one argument, \"props\". Props pass data useful only for the following:\n     An incident can be set to be either inexhaustible (meaning it can be executed again and again infinite times -- default)\n     or finite meaning it can only be executed a limited (specific) number of times. This info can be found on the maxLifeCycles\n     Of course the incident can be reset to its initial condition at any time through the \"reset\" method it provides.\n      As a luxuriousness, and along WITH the maxLifeCycles parameter, the Incident also provides the executionPattern parameter\n     through which the programmer / user can define a more complex behaviour of the Incident execution depending on the number times\n     the incident has alrady be executed ( is the 1st time, the 2nd time, the 3rd time etc) and any custom parameter it\n     holds. The execution times are held on the \"executionTimes\" attribute of the class.\n      props:\n     {\n        id: if passed that's the id of the Incident. If not we create a new one\n        plugin_channel_class - if passed gets set to it\n        mc_plugin_npm_name - if passed gets set to it\n     }\n        @param {object} props */\n    function Incident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, Incident);\n\n        this.attrs = attrs;\n        this.props = props;\n        this.id = props.id || helper.getAnId();\n\n        // this parameter is initialised to false. Once the onGetContext method gets invoked this parameter\n        // is set to true so we prevent multiple executions of the onGetContext method\n        this.gotContext = false;\n\n        /*\n        these are the default values that define channeling for the default Incidents. These values get ovewriden through\n        the loadPlugin method of MC with the values found on the main.js file of the plugin\n        */\n        this.plugin_channel_class = Channel;\n        this.mc_plugin_npm_name = \"motor-cortex-js\";\n        if (props.hasOwnProperty('plugin_channel_class')) {\n            this.plugin_channel_class = props.plugin_channel_class;\n        }\n        if (props.hasOwnProperty('mc_plugin_npm_name')) {\n            this.mc_plugin_npm_name = props.mc_plugin_npm_name;\n        }\n\n        /* \n        The following two properties (\"statusBeforeHalt\" and \"stateBeforeStop\") which have stupidly \n        used \"status\" in the one case and \"state\" in the other\n        act as the memory of the Incident in the case of a stop or\n        a halting command (wait or block), storing the state of it just before any of the two get \n        executed. \n        These properties can be used in various ways in the program\n        and they do not target specific functionality.\n        */\n        // the status of the Incident before it got halted by either the block or the wait command\n        this.statusBeforeHalt = 'idle';\n        // holds the state of the Incident before the stop command\n        this.stateBeforeStop = 'idle';\n\n        this.timesExecuted = 0;\n        this.parentSceneObject = null;\n\n        this.runTimeInfo = {\n            state: 'idle' // one of \"idle\", \"playing\", \"waiting\"\n        };\n\n        this.bitIncident = true;\n        this.hasIncidents = false;\n\n        /* an array holding all  */\n        this.eventsSubscriptions = {};\n\n        /*\n        Right now many keys of the Incident (such as \"props\", \"attrs\", etc) are already been used by the Incident \n        class. The final users of the library (the plugin developers) might want to keep special / specific data\n        on their Incidents and:\n        a) they might don't know which keys are already taken and which are not\n        b) might use an already used key and ruin the functionality\n        c) so they feel unsafe keeping data and it's not safe for the lib too\n        For this reason we have a blank object reserved for them, the \"customParams\", in order for them to \n        put anything they want and we encourage them to use the built-in methods:\n        setParam\n        getParam\n        setParams\n        for this job\n        */\n        this.customParams = {};\n\n        this.speed = 1;\n\n        /*\n        initialValues is an object holding the autmatically computed initial values of the animatedAttrs \n        (if any). The initialValues are calculated by the AttributesChannel (only Incidents belonging to \n        an AttributesChannel have initialValues).\n        The keys set of this object is identical to the object attrs.animatedAttrs \n        The only thing the generic AttributesChannel can't calculate is the initial value of an animated attr\n        of a specific element when there are no other Incidents entered on its lanes yet. These values are\n        the \"scratchValues\" and they are strongly dependend on the nature of the lib. E.g. for a CSS animation\n        what we are looking for can be found on the computedStyle.\n        */\n        this.initialValues = {};\n\n        /*\n        The user has the ability to explicitely define the initial values for any of the animatedAttrs. The user\n        can do that by providing the initialValues object on the attrs of the constructor.\n        */\n        this.userDefinedInitialValues = {};\n        if (attrs != null && attrs != undefined) {\n            if (attrs.hasOwnProperty('initialValues')) {\n                this.userDefinedInitialValues = attrs.initialValues;\n            }\n        }\n\n        /*\n        blockingWaitings is an array, a collection, of blocing waitings that have the Scene as target.\n        The logic is simple:\n        - if the scene receives a \"sceneBlockingWaiting\" then it is the target and it adopts it\n        - if the scene receives a \"channelBlockingWaiting\" then if it is a channel it adopts it otherwise it tries to\n            pass it further up until it finds a channel\n        - if the scene receives a \"clipBlockingWaiting\" if it is the Clip it adopts it otherwise it tries to pass it\n            further up until it reaches the clip\n        Each object on this array represents a blocking waiting triggered by a child of the Scene\n            and which targets the Scene itself.\n        Each child signs the blocking waiting by assigning its own id to it. Each child can only assign just one\n            blocking waiting at a time.\n        The structure of each blocking waiting appearing on this array is the following:\n        {\n            id: the-signature-of-the-triggering-incident,\n            type: any of the sceneBlockingWaiting / channelBlockingWaiting / ClipBlockingWaiting,\n            nature: any of the scheduled / dynamic / system-problem\n        }\n        */\n        this.blockingWaitings = [];\n\n        /**\n        * @member {boolean} - if testingMode is set to true the requestAnimationFrame method is not going\n        * to get executed automatically but instead the emaulateStep method will start functioning allowing\n        * developers to pass the milliseconds difference from the previous timestamp manually\n        **/\n        this.testMode = false;\n        if (props.hasOwnProperty('testMode')) {\n            this.testMode = props.testMode;\n        }\n\n        this.onInitialise(attrs, props);\n    }\n\n    _createClass(Incident, [{\n        key: 'getScratchValue',\n\n\n        /**\n        This method shoudl be overwritten by the Incidents of the plugins. The method accepts\n        as arguments the mcid (an element) and the attribue (one of the animatedAttrs, if any)\n        and return the initial value of them as the library calculates / defines them. The \n        returned value represents the very initial value of the element's attribute before\n        any Incident that alters it gets added.\n        @param {string} mcid\n        @param {string} attribute\n        @returns {mixed} - the initial value of the element's attribute just when the HTML & CSS\n        of the Clip gets rendered\n        */\n        value: function getScratchValue(mcid, attribute) {\n            return 0;\n        }\n    }, {\n        key: 'getElementAttribute',\n        value: function getElementAttribute(attr) {\n            return this.element.getAttribute(attr);\n        }\n    }, {\n        key: 'getElementByMCID',\n        value: function getElementByMCID(mcid) {\n            if (this.context === null) {\n                return null;\n            }\n\n            return helper.getElementByMCID(this.context, mcid);\n        }\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            return {\n                failedAdditions: []\n            };\n        }\n    }, {\n        key: 'turnIncidentToMC',\n        value: function turnIncidentToMC() {\n            this.plugin_channel_class = Channel;\n            this.mc_plugin_npm_name = \"motor-cortex-js\";\n        }\n    }, {\n        key: 'resetState',\n        value: function resetState() {}\n    }, {\n        key: 'getIncidentsByPlugin',\n\n\n        /**\n         * Returns an object with keys the keys of all the plugins Incidents of which appear in the\n         * tree of the Group. All Incidents are projected to the Group's timeline.\n         * The array includes the Group's projection too\n        */\n        value: function getIncidentsByPlugin() {\n            var adjustMillisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n            var incidentsByPlugin = {};\n            incidentsByPlugin[this.mc_plugin_npm_name] = [{\n                millisecond: adjustMillisecond,\n                incident: this,\n                id: this.id\n            }];\n            return incidentsByPlugin;\n        }\n    }, {\n        key: 'setParam',\n        value: function setParam(param, value) {\n            this.customParams[param] = value;\n        }\n    }, {\n        key: 'getParam',\n        value: function getParam(param) {\n            return this.customParams[param];\n        }\n    }, {\n        key: 'setParams',\n        value: function setParams() {\n            var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            this.customParams = params;\n        }\n\n        /** *************************************************\n        HELPER FUNCTIONS\n        checks if the parent Scene object has been defined */\n\n    }, {\n        key: 'checkParentScene',\n        value: function checkParentScene() {\n            if (this.parentSceneObject === null) {\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }, {\n        key: 'checkStateTransition',\n        value: function checkStateTransition(targetState) {\n            // we prevent play (and thus any other transition) in cases the Incident has no parent\n            // group. The method changes on Group\n            if (this.checkParentScene()) {\n                if (checkTransition(this.runTimeInfo.state, targetState, this.direction)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: '_hasUserDefinedInitialValue',\n        value: function _hasUserDefinedInitialValue(attr) {\n            return this.userDefinedInitialValues.hasOwnProperty(attr);\n        }\n    }, {\n        key: '_getUserDefinedInitialValue',\n        value: function _getUserDefinedInitialValue(attr) {\n            return this.userDefinedInitialValues[attr];\n        }\n    }, {\n        key: 'setInitialValue',\n        value: function setInitialValue(attr, value) {\n            if (this._hasUserDefinedInitialValue(attr)) {\n                helper.notice('Incident with id ' + this.id + ' has initial value defined for ' + attr + ' and no change is allowed on it');\n                return;\n            }\n            this.initialValues[attr] = value;\n        }\n    }, {\n        key: 'hasInitialValue',\n        value: function hasInitialValue(attr) {\n            return this._hasUserDefinedInitialValue(attr) || this.initialValues.hasOwnProperty(attr);\n        }\n    }, {\n        key: 'getInitialValue',\n        value: function getInitialValue(attr) {\n            if (this._hasUserDefinedInitialValue(attr)) {\n                return this._getUserDefinedInitialValue(attr);\n            }\n            return this.initialValues[attr];\n        }\n    }, {\n        key: 'setParentScene',\n        value: function setParentScene(parentSceneObject) {\n            this.parentSceneObject = parentSceneObject;\n        }\n\n        /* *************************************************\n        STATE CHANGING FUNCTION\n        method from which we can set the state of the Incident.\n        this method should never be invoked directly from code outside the core definition of Incident. All state changes\n        should occur through the corresponding built-in functions (play, wait, etc) */\n\n    }, {\n        key: '_setState',\n        value: function _setState(state) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var oldState = this.runTimeInfo.state;\n            this.runTimeInfo.state = state;\n\n            if (this.checkParentScene() && state === 'completed' && this.speed > 0) {\n                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);\n            } else if (this.checkParentScene() && state === 'idle' && this.speed < 0) {\n                this.parentSceneObject.incidentStateChange(this.id, oldState, state, props);\n            }\n\n            var newState = state;\n            if ((state === 'waiting' || state === 'blocked') && props.waitingStateName != 'waiting') {\n                newState = props.waitingStateName;\n            }\n            this.broadcastEvent('state-change', { oldState: oldState, newState: newState });\n        }\n    }, {\n        key: 'setCurrentMillisecond',\n        value: function setCurrentMillisecond(millisecond) {\n            this.runTimeInfo.currentMillisecond = millisecond;\n        }\n\n        /**\n         * sets the state of the Incident silently without broadcasting the event nor informing the parent Incident\n         */\n\n    }, {\n        key: '_dontTellMamaStateChange',\n        value: function _dontTellMamaStateChange(state) {\n            if (this.checkStateTransition(state)) {\n                // helper.log('setting state of ' + this.id + ' to ' + state);\n                var oldState = this.runTimeInfo.state;\n                this.runTimeInfo.state = state;\n                this.broadcastEvent('state-change', { oldState: oldState, newState: state });\n            }\n        }\n\n        /** *************************************************\n        EXECUTION FUNCTIONS\n        sets state to \"playing\" */\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('playing')) {\n                return false;\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.statusBeforeHalt = 'playing';\n                return false;\n            }\n\n            this.timesExecuted += 1;\n            this.onPlay(props);\n            this._setState('playing');\n\n            if (this.bitIncident) {\n                this.complete();\n            }\n            return true;\n        }\n\n        /**\n         wait method can be invoked by the object itself or by its parent Scene. No children are allowd to call the wait\n         method.\n          the nature of a waiting might be:\n             - scheduled    *                               default\n             - dynamic\n             - system-error\n          the waitingStateName of a waiting can be:\n             - waiting *                                    default\n             - sceneBlockingWaiting\n             - clipBlockingWaiting\n          An Incident can only exit waiting mode through the resume method\n          */\n\n    }, {\n        key: 'wait',\n        value: function wait(props) {\n            if (!props.waitingStateName) {\n                props = { nature: 'scheduled', waitingStateName: 'waiting' };\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.blockingWaitings = [];\n            } else if (!this.checkStateTransition('waiting')) {\n                return false;\n            }\n\n            this.statusBeforeHalt = this.runTimeInfo.state;\n            this._setState('waiting', props);\n            this.onWait(props);\n            return true;\n        }\n    }, {\n        key: 'setBlockWaiting',\n        value: function setBlockWaiting(props) {\n            if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.blockingWaitings.push(props);\n                this.wait();\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.setBlockWaiting(props);\n                }\n            }\n        }\n    }, {\n        key: 'unsetBlockWaiting',\n        value: function unsetBlockWaiting(props) {\n            if (props.waitingStateName === 'waiting' && props.id === this.id) {\n                this.blockingWaitings = [];\n                this.unblock();\n            } else {\n                if (this.checkParentScene()) {\n                    this.parentSceneObject.unsetBlockWaiting(props);\n                }\n            }\n        }\n    }, {\n        key: 'unblock',\n        value: function unblock() {\n            if (this.statusBeforeHalt === 'playing') {\n                this.resume();\n            }\n        }\n\n        /**\n         block and unblock methods can only be invoked by a parent of the Incident. No children (in the case of a Scene) nor\n         the Incident itself can block or unblock itself.\n          */\n\n    }, {\n        key: 'block',\n        value: function block() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('blocked')) {\n                return false;\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.statusBeforeHalt = 'blocked';\n                return false;\n            }\n\n            this.statusBeforeHalt = this.runTimeInfo.state;\n            this._setState('blocked', props);\n            this.onBlock(props);\n            return true;\n        }\n    }, {\n        key: 'resume',\n        value: function resume() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition(this.statusBeforeHalt)) {\n                return false;\n            }\n\n            if (this.blockingWaitings.length > 0) {\n                this.statusBeforeHalt = 'playing';\n                return false;\n            }\n\n            this.onResume(props);\n            this._setState(this.statusBeforeHalt);\n\n            return true;\n        }\n    }, {\n        key: 'reset',\n        value: function reset() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            // this.stop();\n            if (!this.checkStateTransition('idle')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this.timesExecuted = 0;\n            this._setState('idle');\n            this.onReset(props);\n            return true;\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.speed > 0) {\n                if (!this.checkStateTransition('completed')) {\n                    return false;\n                }\n            } else {\n                if (!this.checkStateTransition('idle')) {\n                    return false;\n                }\n            }\n\n            this.onBeforeComplete(props);\n\n            if (this.speed > 0) {\n                this._setState('completed');\n            } else {\n                this._setState('idle');\n            }\n\n            if (this.speed > 0) {\n                this.runTimeInfo.currentMillisecond = this.duration;\n            } else {\n                this.runTimeInfo.currentMillisecond = 0;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'stop',\n        value: function stop() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('transitional')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this.stateBeforeStop = this.state + \"\";\n            this._setState('transitional');\n            this.onStop(props);\n            return true;\n        }\n\n        /**\n         * Restores the execution of the Incident after a stop\n        **/\n\n    }, {\n        key: 'restore',\n        value: function restore() {\n            if ((this.state === 'waiting' || this.state === 'blocked') && this.stateBeforeStop === 'playing') {\n                this.resume();\n            }\n        }\n    }, {\n        key: 'arm',\n        value: function arm() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('waiting')) {\n                return false;\n            }\n\n            this.blockingWaitings = [];\n\n            this._dontTellMamaStateChange('waiting');\n            this.onArm(props);\n            return true;\n        }\n\n        /**\n         * There are various events happening on the scope of an Incident. Any class extending Incident might have / define its own\n         * events.\n         *\n         * The \"broadcastEvent\" method of the Incident allows the Incident (of any type, even on classes extending it) broadcast\n         * events on any of the interested parties that have subscribed to it.\n         *\n         * The \"subscribeToEvents\" method allows any third party subscribe and listen to events' broadcasts by any Incident\n         *\n         * @param {string} id - the unique id of the event listener\n         * @param {function} fnct - a function to get executed whenever an event gets broadcasted by the specific Incident. The\n         *  fnct will be executed on all events' broadcasts and it will receive the event object as argument. The event object is\n         *  of format:\n         *  {\n                name: the name of the event,\n                meta: an object holding all the meta-info of the event\n            }\n         }\n        */\n\n    }, {\n        key: 'subscribeToEvents',\n        value: function subscribeToEvents(id, fnct) {\n            this.eventsSubscriptions[id] = fnct;\n        }\n\n        /**\n         * unsubscribes any subscribed listener to the Incident's events broadcasting\n         * @param {string} id\n         */\n\n    }, {\n        key: 'unsubscribeFromEvents',\n        value: function unsubscribeFromEvents(id) {\n            if (this.eventsSubscriptions[id]) {\n                delete this.eventsSubscriptions[id];\n            }\n        }\n\n        /**\n         * broadcasts any event\n         * @param {string} eventName\n         * @param {object} meta\n         */\n\n    }, {\n        key: 'broadcastEvent',\n        value: function broadcastEvent(eventName, meta) {\n            for (var key in this.eventsSubscriptions) {\n                this.eventsSubscriptions[key](eventName, meta);\n            }\n        }\n\n        /**\n         * This method's (which should be called whenever a slip ends) purpose is to calculate and set\n         * the right state of the Incident based on the target millisecond.\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n         */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState(targetMillisecondDeltaFromStart) {\n            if (targetMillisecondDeltaFromStart >= 0) {\n                // if it ends before the target millisecond\n                this._dontTellMamaStateChange('completed');\n            } else {\n                // if it has been completed on targetMillisecond\n                this._dontTellMamaStateChange('idle');\n            }\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            return true;\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            return {\n                id: this.id,\n                duration: this.duration,\n                class: this.constructor.name,\n                mc_plugin_npm_name: this.mc_plugin_npm_name,\n                plugin_channel_class: this.plugin_channel_class,\n                state: this.state,\n                customParams: this.customParams,\n                attrs: Object.assign({}, this.attrs),\n                props: Object.assign({}, this.props),\n                Incident: this.constructor\n            };\n        }\n\n        // *************************************************\n        /* PIPES SYSTEM\n            The Pipes system is a vertical interconnection system that runs out the full Incidents tree and connects all of them.\n            Through Pipes any Incident can communicate anything to all of its children or parents.\n            \n            In order to initialise a pipe message the user should use the putMessageOnPipe method. This method is exposed by all\n                Incidents, of all types, and it is first been processed by the receiver Incident and then passed further down to\n                its children (if any).\n            This method takes exactly 5 arguments:\n            - name (the name of the command). This should be unique among the full MC ecosystem including native message names & \n                plugins' message names. In order to avoid conflicts is good to use the convention: <plugin_npm_name>.<message_name>\n            - parameters (an object holding the parameters of the command)\n            - selfExecute (true/false) - If true the Incident will try to process the pipe command before further passing further up or down\n            - direction (default \"down\") - defines the direction of the pipe command. It can be either \"down\" so it passes it down to \n                its children or \"up\" so it passes it up to its parents\n            - target. The target defines / describes the receivers of the pipe message. This might be:\n                - null (default) - targets all incidents\n                - type: \"group\" - targets only groups (including clips)\n                - type: \"clip\" - targets only clips\n                - type: \"rootClip\" - targets only the root clip of the tree\n                - id: \"<id>\" - targets a specific incident with specific id\n                - plugin: \"<plugin_npm_name>\" - targets only Incidents of a specific plugin\n            \n            Handling pipe messages:\n            The putMessageOnPipe method decides whether it should be processed or\n            not by the Incident depending on the target. This method is the _processPipeMessage. If the Incident should process the \n            pipe message the _processPipeMessage method calls the \"handlePipeMessage\" method passing the name and the parameters.\n            The \"handlePipeMessage\" is a built in method as well and the developers should just overwrite it so they handle the \n            various pipes messages based on their names.\n        */\n\n    }, {\n        key: 'putMessageOnPipe',\n        value: function putMessageOnPipe(name, params, selfExecute, direction) {\n            var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            if (selfExecute) {\n                if (target === null) {\n                    this.handlePipeMessage(name, params);\n                } else {\n                    if (target.hasOwnProperty('type')) {\n                        if (target.type === 'group' && this.hasIncidents) {\n                            this.handlePipeMessage(name, params);\n                        } else if (target.type === 'clip' && this.isTheClip) {\n                            this.handlePipeMessage(name, params);\n                        } else if (target.type === \"rootClip\" && this.isTheClip && !this.checkParentScene()) {\n                            this.handlePipeMessage(name, params);\n                            return;\n                        }\n                    } else if (target.hasOwnProperty('id')) {\n                        if (this.id === target.id) {\n                            this.handlePipeMessage(name, params);\n                            return;\n                        }\n                    } else if (target.hasOwnProperty('plugin')) {\n                        if (this.mc_plugin_npm_name === target.plugin) {\n                            this.handlePipeMessage(name, params);\n                        }\n                    }\n                }\n            }\n\n            if (direction === \"down\" && this.hasIncidents) {\n                for (var i = 0; i < this.incidents.length; i++) {\n                    this.incidents[i].incident.putMessageOnPipe(name, params, true, direction, target);\n                }\n            } else if (direction === \"up\" && this.checkParentScene()) {\n                this.parentSceneObject.putMessageOnPipe(name, params, true, direction, target);\n            }\n        }\n    }, {\n        key: 'handlePipeMessage',\n        value: function handlePipeMessage(name, params) {}\n        // Plugins developers can overwrite this method so they can handle pipe messages per name\n\n\n        // *************************************************\n        // ACTUAL BAHAVIOUR FUNCTIONS THAT SHOULD BE IMPLEMENTED BY ALL CLASSES EXTENDING INCIDENT\n\n    }, {\n        key: 'onPlay',\n        value: function onPlay(props) {\n            helper.info('Overwritte the \"onPlay\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onResume',\n        value: function onResume(props) {\n            helper.info('Overwritte the \"onResume\" method with the code you want to get executed', 'info');\n        }\n\n        /**\n         * Helper function that normalises the millisecond to pass to the Incidents on goTo\n         * If millisecond < 0 it makes it 0\n         * If millisecond > duration of the Incident it makes it equals to the duration\n         * @param {int} millisecond - the millisecond to normalise. It represents the distance of the time to go to from\n         *  the start of the Incident\n         * @returns {int} - the normalised millisecond\n        **/\n\n    }, {\n        key: 'normaliseGoToTarget',\n        value: function normaliseGoToTarget(millisecond) {\n            if (millisecond < 0) {\n                millisecond = 0;\n            } else if (millisecond > this.duration) {\n                millisecond = this.duration;\n            }\n\n            return millisecond;\n        }\n\n        /**\n         * goTo on the Incident level implements the logic of passing the authority of execution to its parent\n         * (if there is any)\n         * Incidents that implement their own goTo logic should overwrite the goTo method otherwise the goTo\n         * will be passed up until either it reaches a context owner or a tree root\n         * @param {int} millisecond - (optional) the millisecond where we want to goTo. If not provided we use the current millisecond of the Incident\n         * @returns {boolean} - if the context owner of the Incident actually executes the goTo command the\n         *  method returns true otherwise it returns false\n        **/\n\n    }, {\n        key: 'goTo',\n        value: function goTo(millisedond) {\n            // if the incident has a parent scene\n            if (this.checkParentScene()) {\n                if (this.parentSceneObject.goTo(millisedond, { relativeTo: this.id })) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Returns the milliseconds delta between the Incident's start point and its root Scene's current millisecond.\n         * If the result is negative it means the root scene's current millisecond is prior to the Incident's start point\n         * @returns {int}\n        **/\n\n    }, {\n        key: 'getRootCurrentMillisecondDeltaFromStart',\n        value: function getRootCurrentMillisecondDeltaFromStart() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.getRootCurrentMillisecondDeltaFromIncidentsStart(this.id);\n            } else {\n                return this.runTimeInfo.currentMillisecond;\n            }\n        }\n    }, {\n        key: 'beOn',\n        value: function beOn(millisecond) {\n            var goTo = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n            var previousState = this.state + \"\";\n            this.stop();\n            if (goTo) {\n                this.goTo(millisecond);\n            }\n            this.setCurrentMillisecond(millisecond);\n            this.recalcState(millisecond);\n            var newState = this.state + \"\";\n            return {\n                previousState: previousState,\n                newState: newState\n            };\n        }\n    }, {\n        key: '_onGetContextOnce',\n        value: function _onGetContextOnce() {\n            if (!this.gotContext) {\n                this.onGetContext();\n                this.gotContext = true;\n            }\n        }\n    }, {\n        key: 'onGetContext',\n        value: function onGetContext() {\n            helper.info('Overwritte the \"onGetContext\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onStop',\n        value: function onStop(props) {\n            helper.info('Overwritte the \"onBeforeStop\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onReset',\n        value: function onReset(props) {\n            helper.info('Overwritte the \"onReset\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBeforeComplete',\n        value: function onBeforeComplete(props) {\n            helper.info('Overwritte the \"onBeforeEnd\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onBlock',\n        value: function onBlock(props) {\n            helper.info('Overwritte the \"onBlock\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onUnblock',\n        value: function onUnblock(props) {\n            helper.info('Overwritte the \"onUnblock\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onWait',\n        value: function onWait(props) {\n            helper.info('Overwritte the \"onWait\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'onArm',\n        value: function onArm(props) {\n            helper.info('Overwritte the \"onArm\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            this.stop();\n        }\n    }, {\n        key: 'onInitialise',\n        value: function onInitialise(attrs, props) {\n            helper.info('Overwritte the \"onInialise\" method with the code you want to get executed', 'info');\n        }\n    }, {\n        key: 'isOnTestMode',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.isOnTestMode;\n            } else {\n                return this.testMode;\n            }\n        }\n    }, {\n        key: 'selector',\n        get: function get() {\n            return this.props.selector;\n        }\n\n        /* shortcuts for attrs.attrs and attrs.animatedAttrs */\n\n    }, {\n        key: 'animAttributes',\n        get: function get() {\n            return this.attrs.animatedAttrs;\n        }\n    }, {\n        key: 'confAttributes',\n        get: function get() {\n            return this.attrs.attrs;\n        }\n    }, {\n        key: 'element',\n        get: function get() {\n            if (this.contex === null) {\n                return [];\n            }\n            return this.context.getElements(this.selector)[0];\n        }\n\n        /*\n        returns the initialised channel by the Clip the Incident belongs to\n        */\n\n    }, {\n        key: 'channel',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject._getChannel(this.mc_plugin_npm_name);\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'elements',\n        get: function get() {\n            if (this.contex === null) {\n                return [];\n            }\n            return this.context.getElements(this.selector);\n        }\n    }, {\n        key: 'executionSpeed',\n        set: function set(speed) {\n            this.speed = speed;\n            // this.beOn(this.runTimeInfo.currentMillisecond);\n        }\n\n        /**\n         * gets the Incident's duration. This method should be overwriten accordingly by all Incidents\n         */\n\n    }, {\n        key: 'duration',\n        get: function get() {\n            return 0;\n        },\n        set: function set(duration) {\n            ;\n        }\n    }, {\n        key: 'state',\n        get: function get() {\n            return this.runTimeInfo.state;\n        }\n    }, {\n        key: 'context',\n        get: function get() {\n            if (this.checkParentScene()) {\n                return this.parentSceneObject.context;\n            } else {\n                return null;\n            }\n        }\n    }, {\n        key: 'direction',\n        get: function get() {\n            return this.speed > 0 ? \"forwards\" : \"backwards\";\n        }\n    }]);\n\n    return Incident;\n}();\n\nmodule.exports = Incident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9JbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0Jhc2VDbGFzc2VzL0luY2lkZW50LmpzP2Q2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBjaGVja1RyYW5zaXRpb24gPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2FsbG93ZWRTdGF0ZUNoYW5nZXMnKS5jaGVja1RyYW5zaXRpb247XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi9fQ2hhbm5lbHMvQ2hhbm5lbCcpO1xuXG4vKiogQGNsYXNzZGVzY1xuICogSW5jaWRlbnRzIGFyZSBhbGwgZXZlbnRzIHRoYXQgc2hvdWxkIGhhcHBlbiBvbiBhIHNwZWNpZmljIHRpbWUgb24gdGhlIHRpbWVsaW5lLiBBbiBpbmNpZGVudCBjYW4gaGF2ZSBwYXJhbWV0cmljXG4gICAgICBleGVjdXRpb24gYmVoYXZpb3VyIGJhc2VkIG9uIHRoZSB0aW1lcyBpdCBoYXMgYmVlbiBleGVjdXRlZCBhbmQgKG1pZ2h0IGJlKSBvbiBvdGhlciBwYXJhbWV0ZXJzLlxuXG4gICAgICBUaGUgc3RhdGUgYW4gSW5jaWRlbnQgY2FuIGhhdmUgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAgICAgIGlkbGVcbiAgICAgICAgICAgICAgICAgcGxheWluZ1xuICAgICAgICAgICAgICAgICB3YWl0aW5nXG4gICAgICAgICAgICAgICAgIHNjZW5lQmxvY2tpbmdXYWl0aW5nXG4gICAgICAgICAgICAgICAgIGNsaXBCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAgICAgYmxvY2tlZCAgICAvLyBpbiB0aGUgY2FzZSB0aGUgSW5jaWRlbnQgaXMgYmxvY2tlZCAvIHBhdXNlZCBieSBhIHdhaXRpbmdcbiAgICAgICAgICAgICAgICAgY29tcGxldGVkXG5cbiAgICAgIEVhY2ggSW5jaWRlbnQgaGFzIHRoZSBvYmxpZ2F0aW9uIHRvIGluZm9ybSB0aGUgU2NlbmUgYWJvdXQgaXRzIHN0YXRlIGNoYW5nZXMuXG4gICAgICBGb3IgdGhpcyBJbmNpZGVudCBwcm92aWRlcyB0aGUgbWV0aG9kIOKAnHNldFBhcmVudFNjZW5l4oCdIHdoaWNoIHRha2VzIGp1c3Qgb25lIGFyZ3VtZW50IGEgVGltZXIgb2JqZWN0LlxuICAgICAgVGltZXIgcHJvdmlkZXMgdGhlIG1ldGhvZCDigJxpbmNpZGVudFN0YXRlQ2hhbmdl4oCdIHdoaWNoIGxldHMgdGhlIEluY2lkZW50cyBjaGFuZ2UgdGhlaXIgc3RhdGUgYnlcbiAgICAgIHByb3ZpZGluZyB0aGVpciBpZCBhbmQgdGhlaXIgbmV3IHN0YXRlLlxuICogKi9cblxudmFyIEluY2lkZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICBJdCB0YWtlcyBqdXN0IG9uZSBhcmd1bWVudCwgXCJwcm9wc1wiLiBQcm9wcyBwYXNzIGRhdGEgdXNlZnVsIG9ubHkgZm9yIHRoZSBmb2xsb3dpbmc6XG4gICAgIEFuIGluY2lkZW50IGNhbiBiZSBzZXQgdG8gYmUgZWl0aGVyIGluZXhoYXVzdGlibGUgKG1lYW5pbmcgaXQgY2FuIGJlIGV4ZWN1dGVkIGFnYWluIGFuZCBhZ2FpbiBpbmZpbml0ZSB0aW1lcyAtLSBkZWZhdWx0KVxuICAgICBvciBmaW5pdGUgbWVhbmluZyBpdCBjYW4gb25seSBiZSBleGVjdXRlZCBhIGxpbWl0ZWQgKHNwZWNpZmljKSBudW1iZXIgb2YgdGltZXMuIFRoaXMgaW5mbyBjYW4gYmUgZm91bmQgb24gdGhlIG1heExpZmVDeWNsZXNcbiAgICAgT2YgY291cnNlIHRoZSBpbmNpZGVudCBjYW4gYmUgcmVzZXQgdG8gaXRzIGluaXRpYWwgY29uZGl0aW9uIGF0IGFueSB0aW1lIHRocm91Z2ggdGhlIFwicmVzZXRcIiBtZXRob2QgaXQgcHJvdmlkZXMuXG4gICAgICBBcyBhIGx1eHVyaW91c25lc3MsIGFuZCBhbG9uZyBXSVRIIHRoZSBtYXhMaWZlQ3ljbGVzIHBhcmFtZXRlciwgdGhlIEluY2lkZW50IGFsc28gcHJvdmlkZXMgdGhlIGV4ZWN1dGlvblBhdHRlcm4gcGFyYW1ldGVyXG4gICAgIHRocm91Z2ggd2hpY2ggdGhlIHByb2dyYW1tZXIgLyB1c2VyIGNhbiBkZWZpbmUgYSBtb3JlIGNvbXBsZXggYmVoYXZpb3VyIG9mIHRoZSBJbmNpZGVudCBleGVjdXRpb24gZGVwZW5kaW5nIG9uIHRoZSBudW1iZXIgdGltZXNcbiAgICAgdGhlIGluY2lkZW50IGhhcyBhbHJhZHkgYmUgZXhlY3V0ZWQgKCBpcyB0aGUgMXN0IHRpbWUsIHRoZSAybmQgdGltZSwgdGhlIDNyZCB0aW1lIGV0YykgYW5kIGFueSBjdXN0b20gcGFyYW1ldGVyIGl0XG4gICAgIGhvbGRzLiBUaGUgZXhlY3V0aW9uIHRpbWVzIGFyZSBoZWxkIG9uIHRoZSBcImV4ZWN1dGlvblRpbWVzXCIgYXR0cmlidXRlIG9mIHRoZSBjbGFzcy5cbiAgICAgIHByb3BzOlxuICAgICB7XG4gICAgICAgIGlkOiBpZiBwYXNzZWQgdGhhdCdzIHRoZSBpZCBvZiB0aGUgSW5jaWRlbnQuIElmIG5vdCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHBsdWdpbl9jaGFubmVsX2NsYXNzIC0gaWYgcGFzc2VkIGdldHMgc2V0IHRvIGl0XG4gICAgICAgIG1jX3BsdWdpbl9ucG1fbmFtZSAtIGlmIHBhc3NlZCBnZXRzIHNldCB0byBpdFxuICAgICB9XG4gICAgICAgIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAqL1xuICAgIGZ1bmN0aW9uIEluY2lkZW50KCkge1xuICAgICAgICB2YXIgYXR0cnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmNpZGVudCk7XG5cbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBoZWxwZXIuZ2V0QW5JZCgpO1xuXG4gICAgICAgIC8vIHRoaXMgcGFyYW1ldGVyIGlzIGluaXRpYWxpc2VkIHRvIGZhbHNlLiBPbmNlIHRoZSBvbkdldENvbnRleHQgbWV0aG9kIGdldHMgaW52b2tlZCB0aGlzIHBhcmFtZXRlclxuICAgICAgICAvLyBpcyBzZXQgdG8gdHJ1ZSBzbyB3ZSBwcmV2ZW50IG11bHRpcGxlIGV4ZWN1dGlvbnMgb2YgdGhlIG9uR2V0Q29udGV4dCBtZXRob2RcbiAgICAgICAgdGhpcy5nb3RDb250ZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgLypcbiAgICAgICAgdGhlc2UgYXJlIHRoZSBkZWZhdWx0IHZhbHVlcyB0aGF0IGRlZmluZSBjaGFubmVsaW5nIGZvciB0aGUgZGVmYXVsdCBJbmNpZGVudHMuIFRoZXNlIHZhbHVlcyBnZXQgb3Zld3JpZGVuIHRocm91Z2hcbiAgICAgICAgdGhlIGxvYWRQbHVnaW4gbWV0aG9kIG9mIE1DIHdpdGggdGhlIHZhbHVlcyBmb3VuZCBvbiB0aGUgbWFpbi5qcyBmaWxlIG9mIHRoZSBwbHVnaW5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IENoYW5uZWw7XG4gICAgICAgIHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gXCJtb3Rvci1jb3J0ZXgtanNcIjtcbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdwbHVnaW5fY2hhbm5lbF9jbGFzcycpKSB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzID0gcHJvcHMucGx1Z2luX2NoYW5uZWxfY2xhc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdtY19wbHVnaW5fbnBtX25hbWUnKSkge1xuICAgICAgICAgICAgdGhpcy5tY19wbHVnaW5fbnBtX25hbWUgPSBwcm9wcy5tY19wbHVnaW5fbnBtX25hbWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBcbiAgICAgICAgVGhlIGZvbGxvd2luZyB0d28gcHJvcGVydGllcyAoXCJzdGF0dXNCZWZvcmVIYWx0XCIgYW5kIFwic3RhdGVCZWZvcmVTdG9wXCIpIHdoaWNoIGhhdmUgc3R1cGlkbHkgXG4gICAgICAgIHVzZWQgXCJzdGF0dXNcIiBpbiB0aGUgb25lIGNhc2UgYW5kIFwic3RhdGVcIiBpbiB0aGUgb3RoZXJcbiAgICAgICAgYWN0IGFzIHRoZSBtZW1vcnkgb2YgdGhlIEluY2lkZW50IGluIHRoZSBjYXNlIG9mIGEgc3RvcCBvclxuICAgICAgICBhIGhhbHRpbmcgY29tbWFuZCAod2FpdCBvciBibG9jayksIHN0b3JpbmcgdGhlIHN0YXRlIG9mIGl0IGp1c3QgYmVmb3JlIGFueSBvZiB0aGUgdHdvIGdldCBcbiAgICAgICAgZXhlY3V0ZWQuIFxuICAgICAgICBUaGVzZSBwcm9wZXJ0aWVzIGNhbiBiZSB1c2VkIGluIHZhcmlvdXMgd2F5cyBpbiB0aGUgcHJvZ3JhbVxuICAgICAgICBhbmQgdGhleSBkbyBub3QgdGFyZ2V0IHNwZWNpZmljIGZ1bmN0aW9uYWxpdHkuXG4gICAgICAgICovXG4gICAgICAgIC8vIHRoZSBzdGF0dXMgb2YgdGhlIEluY2lkZW50IGJlZm9yZSBpdCBnb3QgaGFsdGVkIGJ5IGVpdGhlciB0aGUgYmxvY2sgb3IgdGhlIHdhaXQgY29tbWFuZFxuICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSAnaWRsZSc7XG4gICAgICAgIC8vIGhvbGRzIHRoZSBzdGF0ZSBvZiB0aGUgSW5jaWRlbnQgYmVmb3JlIHRoZSBzdG9wIGNvbW1hbmRcbiAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVN0b3AgPSAnaWRsZSc7XG5cbiAgICAgICAgdGhpcy50aW1lc0V4ZWN1dGVkID0gMDtcbiAgICAgICAgdGhpcy5wYXJlbnRTY2VuZU9iamVjdCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5ydW5UaW1lSW5mbyA9IHtcbiAgICAgICAgICAgIHN0YXRlOiAnaWRsZScgLy8gb25lIG9mIFwiaWRsZVwiLCBcInBsYXlpbmdcIiwgXCJ3YWl0aW5nXCJcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmJpdEluY2lkZW50ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNJbmNpZGVudHMgPSBmYWxzZTtcblxuICAgICAgICAvKiBhbiBhcnJheSBob2xkaW5nIGFsbCAgKi9cbiAgICAgICAgdGhpcy5ldmVudHNTdWJzY3JpcHRpb25zID0ge307XG5cbiAgICAgICAgLypcbiAgICAgICAgUmlnaHQgbm93IG1hbnkga2V5cyBvZiB0aGUgSW5jaWRlbnQgKHN1Y2ggYXMgXCJwcm9wc1wiLCBcImF0dHJzXCIsIGV0YykgYXJlIGFscmVhZHkgYmVlbiB1c2VkIGJ5IHRoZSBJbmNpZGVudCBcbiAgICAgICAgY2xhc3MuIFRoZSBmaW5hbCB1c2VycyBvZiB0aGUgbGlicmFyeSAodGhlIHBsdWdpbiBkZXZlbG9wZXJzKSBtaWdodCB3YW50IHRvIGtlZXAgc3BlY2lhbCAvIHNwZWNpZmljIGRhdGFcbiAgICAgICAgb24gdGhlaXIgSW5jaWRlbnRzIGFuZDpcbiAgICAgICAgYSkgdGhleSBtaWdodCBkb24ndCBrbm93IHdoaWNoIGtleXMgYXJlIGFscmVhZHkgdGFrZW4gYW5kIHdoaWNoIGFyZSBub3RcbiAgICAgICAgYikgbWlnaHQgdXNlIGFuIGFscmVhZHkgdXNlZCBrZXkgYW5kIHJ1aW4gdGhlIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgYykgc28gdGhleSBmZWVsIHVuc2FmZSBrZWVwaW5nIGRhdGEgYW5kIGl0J3Mgbm90IHNhZmUgZm9yIHRoZSBsaWIgdG9vXG4gICAgICAgIEZvciB0aGlzIHJlYXNvbiB3ZSBoYXZlIGEgYmxhbmsgb2JqZWN0IHJlc2VydmVkIGZvciB0aGVtLCB0aGUgXCJjdXN0b21QYXJhbXNcIiwgaW4gb3JkZXIgZm9yIHRoZW0gdG8gXG4gICAgICAgIHB1dCBhbnl0aGluZyB0aGV5IHdhbnQgYW5kIHdlIGVuY291cmFnZSB0aGVtIHRvIHVzZSB0aGUgYnVpbHQtaW4gbWV0aG9kczpcbiAgICAgICAgc2V0UGFyYW1cbiAgICAgICAgZ2V0UGFyYW1cbiAgICAgICAgc2V0UGFyYW1zXG4gICAgICAgIGZvciB0aGlzIGpvYlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1c3RvbVBhcmFtcyA9IHt9O1xuXG4gICAgICAgIHRoaXMuc3BlZWQgPSAxO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGluaXRpYWxWYWx1ZXMgaXMgYW4gb2JqZWN0IGhvbGRpbmcgdGhlIGF1dG1hdGljYWxseSBjb21wdXRlZCBpbml0aWFsIHZhbHVlcyBvZiB0aGUgYW5pbWF0ZWRBdHRycyBcbiAgICAgICAgKGlmIGFueSkuIFRoZSBpbml0aWFsVmFsdWVzIGFyZSBjYWxjdWxhdGVkIGJ5IHRoZSBBdHRyaWJ1dGVzQ2hhbm5lbCAob25seSBJbmNpZGVudHMgYmVsb25naW5nIHRvIFxuICAgICAgICBhbiBBdHRyaWJ1dGVzQ2hhbm5lbCBoYXZlIGluaXRpYWxWYWx1ZXMpLlxuICAgICAgICBUaGUga2V5cyBzZXQgb2YgdGhpcyBvYmplY3QgaXMgaWRlbnRpY2FsIHRvIHRoZSBvYmplY3QgYXR0cnMuYW5pbWF0ZWRBdHRycyBcbiAgICAgICAgVGhlIG9ubHkgdGhpbmcgdGhlIGdlbmVyaWMgQXR0cmlidXRlc0NoYW5uZWwgY2FuJ3QgY2FsY3VsYXRlIGlzIHRoZSBpbml0aWFsIHZhbHVlIG9mIGFuIGFuaW1hdGVkIGF0dHJcbiAgICAgICAgb2YgYSBzcGVjaWZpYyBlbGVtZW50IHdoZW4gdGhlcmUgYXJlIG5vIG90aGVyIEluY2lkZW50cyBlbnRlcmVkIG9uIGl0cyBsYW5lcyB5ZXQuIFRoZXNlIHZhbHVlcyBhcmVcbiAgICAgICAgdGhlIFwic2NyYXRjaFZhbHVlc1wiIGFuZCB0aGV5IGFyZSBzdHJvbmdseSBkZXBlbmRlbmQgb24gdGhlIG5hdHVyZSBvZiB0aGUgbGliLiBFLmcuIGZvciBhIENTUyBhbmltYXRpb25cbiAgICAgICAgd2hhdCB3ZSBhcmUgbG9va2luZyBmb3IgY2FuIGJlIGZvdW5kIG9uIHRoZSBjb21wdXRlZFN0eWxlLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSB7fTtcblxuICAgICAgICAvKlxuICAgICAgICBUaGUgdXNlciBoYXMgdGhlIGFiaWxpdHkgdG8gZXhwbGljaXRlbHkgZGVmaW5lIHRoZSBpbml0aWFsIHZhbHVlcyBmb3IgYW55IG9mIHRoZSBhbmltYXRlZEF0dHJzLiBUaGUgdXNlclxuICAgICAgICBjYW4gZG8gdGhhdCBieSBwcm92aWRpbmcgdGhlIGluaXRpYWxWYWx1ZXMgb2JqZWN0IG9uIHRoZSBhdHRycyBvZiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzID0ge307XG4gICAgICAgIGlmIChhdHRycyAhPSBudWxsICYmIGF0dHJzICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGF0dHJzLmhhc093blByb3BlcnR5KCdpbml0aWFsVmFsdWVzJykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlcyA9IGF0dHJzLmluaXRpYWxWYWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICBibG9ja2luZ1dhaXRpbmdzIGlzIGFuIGFycmF5LCBhIGNvbGxlY3Rpb24sIG9mIGJsb2Npbmcgd2FpdGluZ3MgdGhhdCBoYXZlIHRoZSBTY2VuZSBhcyB0YXJnZXQuXG4gICAgICAgIFRoZSBsb2dpYyBpcyBzaW1wbGU6XG4gICAgICAgIC0gaWYgdGhlIHNjZW5lIHJlY2VpdmVzIGEgXCJzY2VuZUJsb2NraW5nV2FpdGluZ1wiIHRoZW4gaXQgaXMgdGhlIHRhcmdldCBhbmQgaXQgYWRvcHRzIGl0XG4gICAgICAgIC0gaWYgdGhlIHNjZW5lIHJlY2VpdmVzIGEgXCJjaGFubmVsQmxvY2tpbmdXYWl0aW5nXCIgdGhlbiBpZiBpdCBpcyBhIGNoYW5uZWwgaXQgYWRvcHRzIGl0IG90aGVyd2lzZSBpdCB0cmllcyB0b1xuICAgICAgICAgICAgcGFzcyBpdCBmdXJ0aGVyIHVwIHVudGlsIGl0IGZpbmRzIGEgY2hhbm5lbFxuICAgICAgICAtIGlmIHRoZSBzY2VuZSByZWNlaXZlcyBhIFwiY2xpcEJsb2NraW5nV2FpdGluZ1wiIGlmIGl0IGlzIHRoZSBDbGlwIGl0IGFkb3B0cyBpdCBvdGhlcndpc2UgaXQgdHJpZXMgdG8gcGFzcyBpdFxuICAgICAgICAgICAgZnVydGhlciB1cCB1bnRpbCBpdCByZWFjaGVzIHRoZSBjbGlwXG4gICAgICAgIEVhY2ggb2JqZWN0IG9uIHRoaXMgYXJyYXkgcmVwcmVzZW50cyBhIGJsb2NraW5nIHdhaXRpbmcgdHJpZ2dlcmVkIGJ5IGEgY2hpbGQgb2YgdGhlIFNjZW5lXG4gICAgICAgICAgICBhbmQgd2hpY2ggdGFyZ2V0cyB0aGUgU2NlbmUgaXRzZWxmLlxuICAgICAgICBFYWNoIGNoaWxkIHNpZ25zIHRoZSBibG9ja2luZyB3YWl0aW5nIGJ5IGFzc2lnbmluZyBpdHMgb3duIGlkIHRvIGl0LiBFYWNoIGNoaWxkIGNhbiBvbmx5IGFzc2lnbiBqdXN0IG9uZVxuICAgICAgICAgICAgYmxvY2tpbmcgd2FpdGluZyBhdCBhIHRpbWUuXG4gICAgICAgIFRoZSBzdHJ1Y3R1cmUgb2YgZWFjaCBibG9ja2luZyB3YWl0aW5nIGFwcGVhcmluZyBvbiB0aGlzIGFycmF5IGlzIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkOiB0aGUtc2lnbmF0dXJlLW9mLXRoZS10cmlnZ2VyaW5nLWluY2lkZW50LFxuICAgICAgICAgICAgdHlwZTogYW55IG9mIHRoZSBzY2VuZUJsb2NraW5nV2FpdGluZyAvIGNoYW5uZWxCbG9ja2luZ1dhaXRpbmcgLyBDbGlwQmxvY2tpbmdXYWl0aW5nLFxuICAgICAgICAgICAgbmF0dXJlOiBhbnkgb2YgdGhlIHNjaGVkdWxlZCAvIGR5bmFtaWMgLyBzeXN0ZW0tcHJvYmxlbVxuICAgICAgICB9XG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBtZW1iZXIge2Jvb2xlYW59IC0gaWYgdGVzdGluZ01vZGUgaXMgc2V0IHRvIHRydWUgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBtZXRob2QgaXMgbm90IGdvaW5nXG4gICAgICAgICogdG8gZ2V0IGV4ZWN1dGVkIGF1dG9tYXRpY2FsbHkgYnV0IGluc3RlYWQgdGhlIGVtYXVsYXRlU3RlcCBtZXRob2Qgd2lsbCBzdGFydCBmdW5jdGlvbmluZyBhbGxvd2luZ1xuICAgICAgICAqIGRldmVsb3BlcnMgdG8gcGFzcyB0aGUgbWlsbGlzZWNvbmRzIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXMgdGltZXN0YW1wIG1hbnVhbGx5XG4gICAgICAgICoqL1xuICAgICAgICB0aGlzLnRlc3RNb2RlID0gZmFsc2U7XG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgndGVzdE1vZGUnKSkge1xuICAgICAgICAgICAgdGhpcy50ZXN0TW9kZSA9IHByb3BzLnRlc3RNb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkluaXRpYWxpc2UoYXR0cnMsIHByb3BzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSW5jaWRlbnQsIFt7XG4gICAgICAgIGtleTogJ2dldFNjcmF0Y2hWYWx1ZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgVGhpcyBtZXRob2Qgc2hvdWRsIGJlIG92ZXJ3cml0dGVuIGJ5IHRoZSBJbmNpZGVudHMgb2YgdGhlIHBsdWdpbnMuIFRoZSBtZXRob2QgYWNjZXB0c1xuICAgICAgICBhcyBhcmd1bWVudHMgdGhlIG1jaWQgKGFuIGVsZW1lbnQpIGFuZCB0aGUgYXR0cmlidWUgKG9uZSBvZiB0aGUgYW5pbWF0ZWRBdHRycywgaWYgYW55KVxuICAgICAgICBhbmQgcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZW0gYXMgdGhlIGxpYnJhcnkgY2FsY3VsYXRlcyAvIGRlZmluZXMgdGhlbS4gVGhlIFxuICAgICAgICByZXR1cm5lZCB2YWx1ZSByZXByZXNlbnRzIHRoZSB2ZXJ5IGluaXRpYWwgdmFsdWUgb2YgdGhlIGVsZW1lbnQncyBhdHRyaWJ1dGUgYmVmb3JlXG4gICAgICAgIGFueSBJbmNpZGVudCB0aGF0IGFsdGVycyBpdCBnZXRzIGFkZGVkLlxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gbWNpZFxuICAgICAgICBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAgICAgIEByZXR1cm5zIHttaXhlZH0gLSB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZWxlbWVudCdzIGF0dHJpYnV0ZSBqdXN0IHdoZW4gdGhlIEhUTUwgJiBDU1NcbiAgICAgICAgb2YgdGhlIENsaXAgZ2V0cyByZW5kZXJlZFxuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2NyYXRjaFZhbHVlKG1jaWQsIGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRBdHRyaWJ1dGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudEF0dHJpYnV0ZShhdHRyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudEJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGhlbHBlci5nZXRFbGVtZW50QnlNQ0lEKHRoaXMuY29udGV4dCwgbWNpZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2ZsYXNoRE9NJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZsYXNoRE9NKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBmYWlsZWRBZGRpdGlvbnM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd0dXJuSW5jaWRlbnRUb01DJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHR1cm5JbmNpZGVudFRvTUMoKSB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzID0gQ2hhbm5lbDtcbiAgICAgICAgICAgIHRoaXMubWNfcGx1Z2luX25wbV9uYW1lID0gXCJtb3Rvci1jb3J0ZXgtanNcIjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzZXRTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFN0YXRlKCkge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluY2lkZW50c0J5UGx1Z2luJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGtleXMgdGhlIGtleXMgb2YgYWxsIHRoZSBwbHVnaW5zIEluY2lkZW50cyBvZiB3aGljaCBhcHBlYXIgaW4gdGhlXG4gICAgICAgICAqIHRyZWUgb2YgdGhlIEdyb3VwLiBBbGwgSW5jaWRlbnRzIGFyZSBwcm9qZWN0ZWQgdG8gdGhlIEdyb3VwJ3MgdGltZWxpbmUuXG4gICAgICAgICAqIFRoZSBhcnJheSBpbmNsdWRlcyB0aGUgR3JvdXAncyBwcm9qZWN0aW9uIHRvb1xuICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5jaWRlbnRzQnlQbHVnaW4oKSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgICAgICAgIHZhciBpbmNpZGVudHNCeVBsdWdpbiA9IHt9O1xuICAgICAgICAgICAgaW5jaWRlbnRzQnlQbHVnaW5bdGhpcy5tY19wbHVnaW5fbnBtX25hbWVdID0gW3tcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZDogYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgcmV0dXJuIGluY2lkZW50c0J5UGx1Z2luO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRQYXJhbScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRQYXJhbShwYXJhbSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tUGFyYW1zW3BhcmFtXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRQYXJhbScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXJhbShwYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tUGFyYW1zW3BhcmFtXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGFyYW1zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBhcmFtcygpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICB0aGlzLmN1c3RvbVBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgIEhFTFBFUiBGVU5DVElPTlNcbiAgICAgICAgY2hlY2tzIGlmIHRoZSBwYXJlbnQgU2NlbmUgb2JqZWN0IGhhcyBiZWVuIGRlZmluZWQgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tQYXJlbnRTY2VuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1BhcmVudFNjZW5lKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50U2NlbmVPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1N0YXRlVHJhbnNpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1N0YXRlVHJhbnNpdGlvbih0YXJnZXRTdGF0ZSkge1xuICAgICAgICAgICAgLy8gd2UgcHJldmVudCBwbGF5IChhbmQgdGh1cyBhbnkgb3RoZXIgdHJhbnNpdGlvbikgaW4gY2FzZXMgdGhlIEluY2lkZW50IGhhcyBubyBwYXJlbnRcbiAgICAgICAgICAgIC8vIGdyb3VwLiBUaGUgbWV0aG9kIGNoYW5nZXMgb24gR3JvdXBcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1RyYW5zaXRpb24odGhpcy5ydW5UaW1lSW5mby5zdGF0ZSwgdGFyZ2V0U3RhdGUsIHRoaXMuZGlyZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19oYXNVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFzVXNlckRlZmluZWRJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXNlckRlZmluZWRJbml0aWFsVmFsdWVzLmhhc093blByb3BlcnR5KGF0dHIpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZ2V0VXNlckRlZmluZWRJbml0aWFsVmFsdWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0SW5pdGlhbFZhbHVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluaXRpYWxWYWx1ZShhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLm5vdGljZSgnSW5jaWRlbnQgd2l0aCBpZCAnICsgdGhpcy5pZCArICcgaGFzIGluaXRpYWwgdmFsdWUgZGVmaW5lZCBmb3IgJyArIGF0dHIgKyAnIGFuZCBubyBjaGFuZ2UgaXMgYWxsb3dlZCBvbiBpdCcpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlc1thdHRyXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNJbml0aWFsVmFsdWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFzSW5pdGlhbFZhbHVlKGF0dHIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNVc2VyRGVmaW5lZEluaXRpYWxWYWx1ZShhdHRyKSB8fCB0aGlzLmluaXRpYWxWYWx1ZXMuaGFzT3duUHJvcGVydHkoYXR0cik7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluaXRpYWxWYWx1ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsVmFsdWUoYXR0cikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1VzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldFVzZXJEZWZpbmVkSW5pdGlhbFZhbHVlKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0UGFyZW50U2NlbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFyZW50U2NlbmUocGFyZW50U2NlbmVPYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QgPSBwYXJlbnRTY2VuZU9iamVjdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgU1RBVEUgQ0hBTkdJTkcgRlVOQ1RJT05cbiAgICAgICAgbWV0aG9kIGZyb20gd2hpY2ggd2UgY2FuIHNldCB0aGUgc3RhdGUgb2YgdGhlIEluY2lkZW50LlxuICAgICAgICB0aGlzIG1ldGhvZCBzaG91bGQgbmV2ZXIgYmUgaW52b2tlZCBkaXJlY3RseSBmcm9tIGNvZGUgb3V0c2lkZSB0aGUgY29yZSBkZWZpbml0aW9uIG9mIEluY2lkZW50LiBBbGwgc3RhdGUgY2hhbmdlc1xuICAgICAgICBzaG91bGQgb2NjdXIgdGhyb3VnaCB0aGUgY29ycmVzcG9uZGluZyBidWlsdC1pbiBmdW5jdGlvbnMgKHBsYXksIHdhaXQsIGV0YykgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3NldFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICAgICAgdmFyIG9sZFN0YXRlID0gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uc3RhdGUgPSBzdGF0ZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpICYmIHN0YXRlID09PSAnY29tcGxldGVkJyAmJiB0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuaW5jaWRlbnRTdGF0ZUNoYW5nZSh0aGlzLmlkLCBvbGRTdGF0ZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkgJiYgc3RhdGUgPT09ICdpZGxlJyAmJiB0aGlzLnNwZWVkIDwgMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuaW5jaWRlbnRTdGF0ZUNoYW5nZSh0aGlzLmlkLCBvbGRTdGF0ZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5ld1N0YXRlID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAoKHN0YXRlID09PSAnd2FpdGluZycgfHwgc3RhdGUgPT09ICdibG9ja2VkJykgJiYgcHJvcHMud2FpdGluZ1N0YXRlTmFtZSAhPSAnd2FpdGluZycpIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHByb3BzLndhaXRpbmdTdGF0ZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KCdzdGF0ZS1jaGFuZ2UnLCB7IG9sZFN0YXRlOiBvbGRTdGF0ZSwgbmV3U3RhdGU6IG5ld1N0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzZXRDdXJyZW50TWlsbGlzZWNvbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q3VycmVudE1pbGxpc2Vjb25kKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IG1pbGxpc2Vjb25kO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNldHMgdGhlIHN0YXRlIG9mIHRoZSBJbmNpZGVudCBzaWxlbnRseSB3aXRob3V0IGJyb2FkY2FzdGluZyB0aGUgZXZlbnQgbm9yIGluZm9ybWluZyB0aGUgcGFyZW50IEluY2lkZW50XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKHN0YXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbihzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdzZXR0aW5nIHN0YXRlIG9mICcgKyB0aGlzLmlkICsgJyB0byAnICsgc3RhdGUpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5zdGF0ZSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIHRoaXMuYnJvYWRjYXN0RXZlbnQoJ3N0YXRlLWNoYW5nZScsIHsgb2xkU3RhdGU6IG9sZFN0YXRlLCBuZXdTdGF0ZTogc3RhdGUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICBFWEVDVVRJT04gRlVOQ1RJT05TXG4gICAgICAgIHNldHMgc3RhdGUgdG8gXCJwbGF5aW5nXCIgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGxheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdwbGF5aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9ICdwbGF5aW5nJztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMudGltZXNFeGVjdXRlZCArPSAxO1xuICAgICAgICAgICAgdGhpcy5vblBsYXkocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3BsYXlpbmcnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuYml0SW5jaWRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgd2FpdCBtZXRob2QgY2FuIGJlIGludm9rZWQgYnkgdGhlIG9iamVjdCBpdHNlbGYgb3IgYnkgaXRzIHBhcmVudCBTY2VuZS4gTm8gY2hpbGRyZW4gYXJlIGFsbG93ZCB0byBjYWxsIHRoZSB3YWl0XG4gICAgICAgICBtZXRob2QuXG4gICAgICAgICAgdGhlIG5hdHVyZSBvZiBhIHdhaXRpbmcgbWlnaHQgYmU6XG4gICAgICAgICAgICAgLSBzY2hlZHVsZWQgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0XG4gICAgICAgICAgICAgLSBkeW5hbWljXG4gICAgICAgICAgICAgLSBzeXN0ZW0tZXJyb3JcbiAgICAgICAgICB0aGUgd2FpdGluZ1N0YXRlTmFtZSBvZiBhIHdhaXRpbmcgY2FuIGJlOlxuICAgICAgICAgICAgIC0gd2FpdGluZyAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFxuICAgICAgICAgICAgIC0gc2NlbmVCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICAgICAtIGNsaXBCbG9ja2luZ1dhaXRpbmdcbiAgICAgICAgICBBbiBJbmNpZGVudCBjYW4gb25seSBleGl0IHdhaXRpbmcgbW9kZSB0aHJvdWdoIHRoZSByZXN1bWUgbWV0aG9kXG4gICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd2FpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB3YWl0KHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIXByb3BzLndhaXRpbmdTdGF0ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm9wcyA9IHsgbmF0dXJlOiAnc2NoZWR1bGVkJywgd2FpdGluZ1N0YXRlTmFtZTogJ3dhaXRpbmcnIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignd2FpdGluZycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ3dhaXRpbmcnLCBwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLm9uV2FpdChwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0QmxvY2tXYWl0aW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEJsb2NrV2FpdGluZyhwcm9wcykge1xuICAgICAgICAgICAgaWYgKHByb3BzLndhaXRpbmdTdGF0ZU5hbWUgPT09ICd3YWl0aW5nJyAmJiBwcm9wcy5pZCA9PT0gdGhpcy5pZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncy5wdXNoKHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLndhaXQoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3Quc2V0QmxvY2tXYWl0aW5nKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Vuc2V0QmxvY2tXYWl0aW5nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2V0QmxvY2tXYWl0aW5nKHByb3BzKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMud2FpdGluZ1N0YXRlTmFtZSA9PT0gJ3dhaXRpbmcnICYmIHByb3BzLmlkID09PSB0aGlzLmlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja2luZ1dhaXRpbmdzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy51bmJsb2NrKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LnVuc2V0QmxvY2tXYWl0aW5nKHByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3VuYmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gdW5ibG9jaygpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgIGJsb2NrIGFuZCB1bmJsb2NrIG1ldGhvZHMgY2FuIG9ubHkgYmUgaW52b2tlZCBieSBhIHBhcmVudCBvZiB0aGUgSW5jaWRlbnQuIE5vIGNoaWxkcmVuIChpbiB0aGUgY2FzZSBvZiBhIFNjZW5lKSBub3JcbiAgICAgICAgIHRoZSBJbmNpZGVudCBpdHNlbGYgY2FuIGJsb2NrIG9yIHVuYmxvY2sgaXRzZWxmLlxuICAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Jsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdibG9ja2VkJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmJsb2NraW5nV2FpdGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9ICdibG9ja2VkJztcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc3RhdHVzQmVmb3JlSGFsdCA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnYmxvY2tlZCcsIHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMub25CbG9jayhwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzdW1lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbih0aGlzLnN0YXR1c0JlZm9yZUhhbHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5ibG9ja2luZ1dhaXRpbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSAncGxheWluZyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLm9uUmVzdW1lKHByb3BzKTtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKHRoaXMuc3RhdHVzQmVmb3JlSGFsdCk7XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIC8vIHRoaXMuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdpZGxlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYmxvY2tpbmdXYWl0aW5ncyA9IFtdO1xuXG4gICAgICAgICAgICB0aGlzLnRpbWVzRXhlY3V0ZWQgPSAwO1xuICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2lkbGUnKTtcbiAgICAgICAgICAgIHRoaXMub25SZXNldChwcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcGxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ2NvbXBsZXRlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignaWRsZScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMub25CZWZvcmVDb21wbGV0ZShwcm9wcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdjb21wbGV0ZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2lkbGUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdG9wJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hlY2tTdGF0ZVRyYW5zaXRpb24oJ3RyYW5zaXRpb25hbCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVN0b3AgPSB0aGlzLnN0YXRlICsgXCJcIjtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCd0cmFuc2l0aW9uYWwnKTtcbiAgICAgICAgICAgIHRoaXMub25TdG9wKHByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc3RvcmVzIHRoZSBleGVjdXRpb24gb2YgdGhlIEluY2lkZW50IGFmdGVyIGEgc3RvcFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzdG9yZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICAgICAgaWYgKCh0aGlzLnN0YXRlID09PSAnd2FpdGluZycgfHwgdGhpcy5zdGF0ZSA9PT0gJ2Jsb2NrZWQnKSAmJiB0aGlzLnN0YXRlQmVmb3JlU3RvcCA9PT0gJ3BsYXlpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXJtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFybSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignd2FpdGluZycpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmJsb2NraW5nV2FpdGluZ3MgPSBbXTtcblxuICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ3dhaXRpbmcnKTtcbiAgICAgICAgICAgIHRoaXMub25Bcm0ocHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlcmUgYXJlIHZhcmlvdXMgZXZlbnRzIGhhcHBlbmluZyBvbiB0aGUgc2NvcGUgb2YgYW4gSW5jaWRlbnQuIEFueSBjbGFzcyBleHRlbmRpbmcgSW5jaWRlbnQgbWlnaHQgaGF2ZSAvIGRlZmluZSBpdHMgb3duXG4gICAgICAgICAqIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIFwiYnJvYWRjYXN0RXZlbnRcIiBtZXRob2Qgb2YgdGhlIEluY2lkZW50IGFsbG93cyB0aGUgSW5jaWRlbnQgKG9mIGFueSB0eXBlLCBldmVuIG9uIGNsYXNzZXMgZXh0ZW5kaW5nIGl0KSBicm9hZGNhc3RcbiAgICAgICAgICogZXZlbnRzIG9uIGFueSBvZiB0aGUgaW50ZXJlc3RlZCBwYXJ0aWVzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHRvIGl0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgXCJzdWJzY3JpYmVUb0V2ZW50c1wiIG1ldGhvZCBhbGxvd3MgYW55IHRoaXJkIHBhcnR5IHN1YnNjcmliZSBhbmQgbGlzdGVuIHRvIGV2ZW50cycgYnJvYWRjYXN0cyBieSBhbnkgSW5jaWRlbnRcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gdGhlIHVuaXF1ZSBpZCBvZiB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZm5jdCAtIGEgZnVuY3Rpb24gdG8gZ2V0IGV4ZWN1dGVkIHdoZW5ldmVyIGFuIGV2ZW50IGdldHMgYnJvYWRjYXN0ZWQgYnkgdGhlIHNwZWNpZmljIEluY2lkZW50LiBUaGVcbiAgICAgICAgICogIGZuY3Qgd2lsbCBiZSBleGVjdXRlZCBvbiBhbGwgZXZlbnRzJyBicm9hZGNhc3RzIGFuZCBpdCB3aWxsIHJlY2VpdmUgdGhlIGV2ZW50IG9iamVjdCBhcyBhcmd1bWVudC4gVGhlIGV2ZW50IG9iamVjdCBpc1xuICAgICAgICAgKiAgb2YgZm9ybWF0OlxuICAgICAgICAgKiAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoZSBuYW1lIG9mIHRoZSBldmVudCxcbiAgICAgICAgICAgICAgICBtZXRhOiBhbiBvYmplY3QgaG9sZGluZyBhbGwgdGhlIG1ldGEtaW5mbyBvZiB0aGUgZXZlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3Vic2NyaWJlVG9FdmVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3Vic2NyaWJlVG9FdmVudHMoaWQsIGZuY3QpIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9uc1tpZF0gPSBmbmN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHVuc3Vic2NyaWJlcyBhbnkgc3Vic2NyaWJlZCBsaXN0ZW5lciB0byB0aGUgSW5jaWRlbnQncyBldmVudHMgYnJvYWRjYXN0aW5nXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndW5zdWJzY3JpYmVGcm9tRXZlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVuc3Vic2NyaWJlRnJvbUV2ZW50cyhpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzU3Vic2NyaXB0aW9uc1tpZF0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNTdWJzY3JpcHRpb25zW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBicm9hZGNhc3RzIGFueSBldmVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdicm9hZGNhc3RFdmVudCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBicm9hZGNhc3RFdmVudChldmVudE5hbWUsIG1ldGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmV2ZW50c1N1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c1N1YnNjcmlwdGlvbnNba2V5XShldmVudE5hbWUsIG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kJ3MgKHdoaWNoIHNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgYSBzbGlwIGVuZHMpIHB1cnBvc2UgaXMgdG8gY2FsY3VsYXRlIGFuZCBzZXRcbiAgICAgICAgICogdGhlIHJpZ2h0IHN0YXRlIG9mIHRoZSBJbmNpZGVudCBiYXNlZCBvbiB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kLlxuICAgICAgICAgKiBUaGUgcGFyYW1ldGVyIGl0IHRha2VzIGlzIHJlbGF0aXZlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIEluY2lkZW50IGl0c2VsZiBhbmQgaXQgbWlnaHQgYmUgbmVnYXRpdmVcbiAgICAgICAgICogTmVnYXRpdmUgdGFyZ2V0TWlsbGlzZWNvbmQgbWVhbnMgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBpcyBOIG1pbGxpc2Vjb25kcyBCRUZPUkUgdGhlIHN0YXJ0IG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCAtIHRoZSBkZWx0YSBvZiB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGNvbXBhcmVkIHRvIHRoZSBJbmNpZGVudCBzdGFydFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVjYWxjU3RhdGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVjYWxjU3RhdGUodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCkge1xuICAgICAgICAgICAgaWYgKHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPj0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGVuZHMgYmVmb3JlIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICB0aGlzLl9kb250VGVsbE1hbWFTdGF0ZUNoYW5nZSgnY29tcGxldGVkJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBiZWVuIGNvbXBsZXRlZCBvbiB0YXJnZXRNaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdpZGxlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBvcnRTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBleHBvcnRTdGF0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgY2xhc3M6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgICAgICBtY19wbHVnaW5fbnBtX25hbWU6IHRoaXMubWNfcGx1Z2luX25wbV9uYW1lLFxuICAgICAgICAgICAgICAgIHBsdWdpbl9jaGFubmVsX2NsYXNzOiB0aGlzLnBsdWdpbl9jaGFubmVsX2NsYXNzLFxuICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIGN1c3RvbVBhcmFtczogdGhpcy5jdXN0b21QYXJhbXMsXG4gICAgICAgICAgICAgICAgYXR0cnM6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYXR0cnMpLFxuICAgICAgICAgICAgICAgIHByb3BzOiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKSxcbiAgICAgICAgICAgICAgICBJbmNpZGVudDogdGhpcy5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLyogUElQRVMgU1lTVEVNXG4gICAgICAgICAgICBUaGUgUGlwZXMgc3lzdGVtIGlzIGEgdmVydGljYWwgaW50ZXJjb25uZWN0aW9uIHN5c3RlbSB0aGF0IHJ1bnMgb3V0IHRoZSBmdWxsIEluY2lkZW50cyB0cmVlIGFuZCBjb25uZWN0cyBhbGwgb2YgdGhlbS5cbiAgICAgICAgICAgIFRocm91Z2ggUGlwZXMgYW55IEluY2lkZW50IGNhbiBjb21tdW5pY2F0ZSBhbnl0aGluZyB0byBhbGwgb2YgaXRzIGNoaWxkcmVuIG9yIHBhcmVudHMuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIEluIG9yZGVyIHRvIGluaXRpYWxpc2UgYSBwaXBlIG1lc3NhZ2UgdGhlIHVzZXIgc2hvdWxkIHVzZSB0aGUgcHV0TWVzc2FnZU9uUGlwZSBtZXRob2QuIFRoaXMgbWV0aG9kIGlzIGV4cG9zZWQgYnkgYWxsXG4gICAgICAgICAgICAgICAgSW5jaWRlbnRzLCBvZiBhbGwgdHlwZXMsIGFuZCBpdCBpcyBmaXJzdCBiZWVuIHByb2Nlc3NlZCBieSB0aGUgcmVjZWl2ZXIgSW5jaWRlbnQgYW5kIHRoZW4gcGFzc2VkIGZ1cnRoZXIgZG93biB0b1xuICAgICAgICAgICAgICAgIGl0cyBjaGlsZHJlbiAoaWYgYW55KS5cbiAgICAgICAgICAgIFRoaXMgbWV0aG9kIHRha2VzIGV4YWN0bHkgNSBhcmd1bWVudHM6XG4gICAgICAgICAgICAtIG5hbWUgKHRoZSBuYW1lIG9mIHRoZSBjb21tYW5kKS4gVGhpcyBzaG91bGQgYmUgdW5pcXVlIGFtb25nIHRoZSBmdWxsIE1DIGVjb3N5c3RlbSBpbmNsdWRpbmcgbmF0aXZlIG1lc3NhZ2UgbmFtZXMgJiBcbiAgICAgICAgICAgICAgICBwbHVnaW5zJyBtZXNzYWdlIG5hbWVzLiBJbiBvcmRlciB0byBhdm9pZCBjb25mbGljdHMgaXMgZ29vZCB0byB1c2UgdGhlIGNvbnZlbnRpb246IDxwbHVnaW5fbnBtX25hbWU+LjxtZXNzYWdlX25hbWU+XG4gICAgICAgICAgICAtIHBhcmFtZXRlcnMgKGFuIG9iamVjdCBob2xkaW5nIHRoZSBwYXJhbWV0ZXJzIG9mIHRoZSBjb21tYW5kKVxuICAgICAgICAgICAgLSBzZWxmRXhlY3V0ZSAodHJ1ZS9mYWxzZSkgLSBJZiB0cnVlIHRoZSBJbmNpZGVudCB3aWxsIHRyeSB0byBwcm9jZXNzIHRoZSBwaXBlIGNvbW1hbmQgYmVmb3JlIGZ1cnRoZXIgcGFzc2luZyBmdXJ0aGVyIHVwIG9yIGRvd25cbiAgICAgICAgICAgIC0gZGlyZWN0aW9uIChkZWZhdWx0IFwiZG93blwiKSAtIGRlZmluZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcGlwZSBjb21tYW5kLiBJdCBjYW4gYmUgZWl0aGVyIFwiZG93blwiIHNvIGl0IHBhc3NlcyBpdCBkb3duIHRvIFxuICAgICAgICAgICAgICAgIGl0cyBjaGlsZHJlbiBvciBcInVwXCIgc28gaXQgcGFzc2VzIGl0IHVwIHRvIGl0cyBwYXJlbnRzXG4gICAgICAgICAgICAtIHRhcmdldC4gVGhlIHRhcmdldCBkZWZpbmVzIC8gZGVzY3JpYmVzIHRoZSByZWNlaXZlcnMgb2YgdGhlIHBpcGUgbWVzc2FnZS4gVGhpcyBtaWdodCBiZTpcbiAgICAgICAgICAgICAgICAtIG51bGwgKGRlZmF1bHQpIC0gdGFyZ2V0cyBhbGwgaW5jaWRlbnRzXG4gICAgICAgICAgICAgICAgLSB0eXBlOiBcImdyb3VwXCIgLSB0YXJnZXRzIG9ubHkgZ3JvdXBzIChpbmNsdWRpbmcgY2xpcHMpXG4gICAgICAgICAgICAgICAgLSB0eXBlOiBcImNsaXBcIiAtIHRhcmdldHMgb25seSBjbGlwc1xuICAgICAgICAgICAgICAgIC0gdHlwZTogXCJyb290Q2xpcFwiIC0gdGFyZ2V0cyBvbmx5IHRoZSByb290IGNsaXAgb2YgdGhlIHRyZWVcbiAgICAgICAgICAgICAgICAtIGlkOiBcIjxpZD5cIiAtIHRhcmdldHMgYSBzcGVjaWZpYyBpbmNpZGVudCB3aXRoIHNwZWNpZmljIGlkXG4gICAgICAgICAgICAgICAgLSBwbHVnaW46IFwiPHBsdWdpbl9ucG1fbmFtZT5cIiAtIHRhcmdldHMgb25seSBJbmNpZGVudHMgb2YgYSBzcGVjaWZpYyBwbHVnaW5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgSGFuZGxpbmcgcGlwZSBtZXNzYWdlczpcbiAgICAgICAgICAgIFRoZSBwdXRNZXNzYWdlT25QaXBlIG1ldGhvZCBkZWNpZGVzIHdoZXRoZXIgaXQgc2hvdWxkIGJlIHByb2Nlc3NlZCBvclxuICAgICAgICAgICAgbm90IGJ5IHRoZSBJbmNpZGVudCBkZXBlbmRpbmcgb24gdGhlIHRhcmdldC4gVGhpcyBtZXRob2QgaXMgdGhlIF9wcm9jZXNzUGlwZU1lc3NhZ2UuIElmIHRoZSBJbmNpZGVudCBzaG91bGQgcHJvY2VzcyB0aGUgXG4gICAgICAgICAgICBwaXBlIG1lc3NhZ2UgdGhlIF9wcm9jZXNzUGlwZU1lc3NhZ2UgbWV0aG9kIGNhbGxzIHRoZSBcImhhbmRsZVBpcGVNZXNzYWdlXCIgbWV0aG9kIHBhc3NpbmcgdGhlIG5hbWUgYW5kIHRoZSBwYXJhbWV0ZXJzLlxuICAgICAgICAgICAgVGhlIFwiaGFuZGxlUGlwZU1lc3NhZ2VcIiBpcyBhIGJ1aWx0IGluIG1ldGhvZCBhcyB3ZWxsIGFuZCB0aGUgZGV2ZWxvcGVycyBzaG91bGQganVzdCBvdmVyd3JpdGUgaXQgc28gdGhleSBoYW5kbGUgdGhlIFxuICAgICAgICAgICAgdmFyaW91cyBwaXBlcyBtZXNzYWdlcyBiYXNlZCBvbiB0aGVpciBuYW1lcy5cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHV0TWVzc2FnZU9uUGlwZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwdXRNZXNzYWdlT25QaXBlKG5hbWUsIHBhcmFtcywgc2VsZkV4ZWN1dGUsIGRpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHNlbGZFeGVjdXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBpcGVNZXNzYWdlKG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgndHlwZScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnR5cGUgPT09ICdncm91cCcgJiYgdGhpcy5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBpcGVNZXNzYWdlKG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC50eXBlID09PSAnY2xpcCcgJiYgdGhpcy5pc1RoZUNsaXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBpcGVNZXNzYWdlKG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC50eXBlID09PSBcInJvb3RDbGlwXCIgJiYgdGhpcy5pc1RoZUNsaXAgJiYgIXRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQaXBlTWVzc2FnZShuYW1lLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQuaGFzT3duUHJvcGVydHkoJ2lkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlkID09PSB0YXJnZXQuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBpcGVNZXNzYWdlKG5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldC5oYXNPd25Qcm9wZXJ0eSgncGx1Z2luJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSA9PT0gdGFyZ2V0LnBsdWdpbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJkb3duXCIgJiYgdGhpcy5oYXNJbmNpZGVudHMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LnB1dE1lc3NhZ2VPblBpcGUobmFtZSwgcGFyYW1zLCB0cnVlLCBkaXJlY3Rpb24sIHRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09IFwidXBcIiAmJiB0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QucHV0TWVzc2FnZU9uUGlwZShuYW1lLCBwYXJhbXMsIHRydWUsIGRpcmVjdGlvbiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlUGlwZU1lc3NhZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUGlwZU1lc3NhZ2UobmFtZSwgcGFyYW1zKSB7fVxuICAgICAgICAvLyBQbHVnaW5zIGRldmVsb3BlcnMgY2FuIG92ZXJ3cml0ZSB0aGlzIG1ldGhvZCBzbyB0aGV5IGNhbiBoYW5kbGUgcGlwZSBtZXNzYWdlcyBwZXIgbmFtZVxuXG5cbiAgICAgICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAvLyBBQ1RVQUwgQkFIQVZJT1VSIEZVTkNUSU9OUyBUSEFUIFNIT1VMRCBCRSBJTVBMRU1FTlRFRCBCWSBBTEwgQ0xBU1NFUyBFWFRFTkRJTkcgSU5DSURFTlRcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25QbGF5JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uUGxheShwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25QbGF5XCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25SZXN1bWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZXN1bWUocHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uUmVzdW1lXCIgbWV0aG9kIHdpdGggdGhlIGNvZGUgeW91IHdhbnQgdG8gZ2V0IGV4ZWN1dGVkJywgJ2luZm8nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBub3JtYWxpc2VzIHRoZSBtaWxsaXNlY29uZCB0byBwYXNzIHRvIHRoZSBJbmNpZGVudHMgb24gZ29Ub1xuICAgICAgICAgKiBJZiBtaWxsaXNlY29uZCA8IDAgaXQgbWFrZXMgaXQgMFxuICAgICAgICAgKiBJZiBtaWxsaXNlY29uZCA+IGR1cmF0aW9uIG9mIHRoZSBJbmNpZGVudCBpdCBtYWtlcyBpdCBlcXVhbHMgdG8gdGhlIGR1cmF0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSBtaWxsaXNlY29uZCB0byBub3JtYWxpc2UuIEl0IHJlcHJlc2VudHMgdGhlIGRpc3RhbmNlIG9mIHRoZSB0aW1lIHRvIGdvIHRvIGZyb21cbiAgICAgICAgICogIHRoZSBzdGFydCBvZiB0aGUgSW5jaWRlbnRcbiAgICAgICAgICogQHJldHVybnMge2ludH0gLSB0aGUgbm9ybWFsaXNlZCBtaWxsaXNlY29uZFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9ybWFsaXNlR29Ub1RhcmdldCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpc2VHb1RvVGFyZ2V0KG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgPCAwKSB7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtaWxsaXNlY29uZCA+IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBtaWxsaXNlY29uZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnb1RvIG9uIHRoZSBJbmNpZGVudCBsZXZlbCBpbXBsZW1lbnRzIHRoZSBsb2dpYyBvZiBwYXNzaW5nIHRoZSBhdXRob3JpdHkgb2YgZXhlY3V0aW9uIHRvIGl0cyBwYXJlbnRcbiAgICAgICAgICogKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgICogSW5jaWRlbnRzIHRoYXQgaW1wbGVtZW50IHRoZWlyIG93biBnb1RvIGxvZ2ljIHNob3VsZCBvdmVyd3JpdGUgdGhlIGdvVG8gbWV0aG9kIG90aGVyd2lzZSB0aGUgZ29Ub1xuICAgICAgICAgKiB3aWxsIGJlIHBhc3NlZCB1cCB1bnRpbCBlaXRoZXIgaXQgcmVhY2hlcyBhIGNvbnRleHQgb3duZXIgb3IgYSB0cmVlIHJvb3RcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gKG9wdGlvbmFsKSB0aGUgbWlsbGlzZWNvbmQgd2hlcmUgd2Ugd2FudCB0byBnb1RvLiBJZiBub3QgcHJvdmlkZWQgd2UgdXNlIHRoZSBjdXJyZW50IG1pbGxpc2Vjb25kIG9mIHRoZSBJbmNpZGVudFxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBpZiB0aGUgY29udGV4dCBvd25lciBvZiB0aGUgSW5jaWRlbnQgYWN0dWFsbHkgZXhlY3V0ZXMgdGhlIGdvVG8gY29tbWFuZCB0aGVcbiAgICAgICAgICogIG1ldGhvZCByZXR1cm5zIHRydWUgb3RoZXJ3aXNlIGl0IHJldHVybnMgZmFsc2VcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dvVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ29UbyhtaWxsaXNlZG9uZCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIGluY2lkZW50IGhhcyBhIHBhcmVudCBzY2VuZVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ29UbyhtaWxsaXNlZG9uZCwgeyByZWxhdGl2ZVRvOiB0aGlzLmlkIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgYmV0d2VlbiB0aGUgSW5jaWRlbnQncyBzdGFydCBwb2ludCBhbmQgaXRzIHJvb3QgU2NlbmUncyBjdXJyZW50IG1pbGxpc2Vjb25kLlxuICAgICAgICAgKiBJZiB0aGUgcmVzdWx0IGlzIG5lZ2F0aXZlIGl0IG1lYW5zIHRoZSByb290IHNjZW5lJ3MgY3VycmVudCBtaWxsaXNlY29uZCBpcyBwcmlvciB0byB0aGUgSW5jaWRlbnQncyBzdGFydCBwb2ludFxuICAgICAgICAgKiBAcmV0dXJucyB7aW50fVxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0Um9vdEN1cnJlbnRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJvb3RDdXJyZW50TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudFNjZW5lT2JqZWN0LmdldFJvb3RDdXJyZW50TWlsbGlzZWNvbmREZWx0YUZyb21JbmNpZGVudHNTdGFydCh0aGlzLmlkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdiZU9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlT24obWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBnb1RvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuXG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMuc3RhdGUgKyBcIlwiO1xuICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICBpZiAoZ29Ubykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ29UbyhtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnJlbnRNaWxsaXNlY29uZChtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB0aGlzLnJlY2FsY1N0YXRlKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUgKyBcIlwiO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1N0YXRlOiBwcmV2aW91c1N0YXRlLFxuICAgICAgICAgICAgICAgIG5ld1N0YXRlOiBuZXdTdGF0ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uR2V0Q29udGV4dE9uY2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uR2V0Q29udGV4dE9uY2UoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZ290Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMub25HZXRDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nb3RDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25HZXRDb250ZXh0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uR2V0Q29udGV4dCgpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uR2V0Q29udGV4dFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uU3RvcCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblN0b3AocHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uQmVmb3JlU3RvcFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uUmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25SZXNldChwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25SZXNldFwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ29uQmVmb3JlQ29tcGxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25CZWZvcmVDb21wbGV0ZShwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25CZWZvcmVFbmRcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkJsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9uQmxvY2socHJvcHMpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdPdmVyd3JpdHRlIHRoZSBcIm9uQmxvY2tcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvblVuYmxvY2snLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25VbmJsb2NrKHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvblVuYmxvY2tcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbldhaXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25XYWl0KHByb3BzKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnT3ZlcndyaXR0ZSB0aGUgXCJvbldhaXRcIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkFybScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkFybShwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25Bcm1cIiBtZXRob2Qgd2l0aCB0aGUgY29kZSB5b3Ugd2FudCB0byBnZXQgZXhlY3V0ZWQnLCAnaW5mbycpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYXN0V2lzaCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYXN0V2lzaCgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0aWFsaXNlKGF0dHJzLCBwcm9wcykge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ092ZXJ3cml0dGUgdGhlIFwib25JbmlhbGlzZVwiIG1ldGhvZCB3aXRoIHRoZSBjb2RlIHlvdSB3YW50IHRvIGdldCBleGVjdXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzT25UZXN0TW9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuaXNPblRlc3RNb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50ZXN0TW9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2VsZWN0b3InLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnNlbGVjdG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogc2hvcnRjdXRzIGZvciBhdHRycy5hdHRycyBhbmQgYXR0cnMuYW5pbWF0ZWRBdHRycyAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmltQXR0cmlidXRlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRycztcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29uZkF0dHJpYnV0ZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmF0dHJzLmF0dHJzO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbGVtZW50JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmdldEVsZW1lbnRzKHRoaXMuc2VsZWN0b3IpWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgcmV0dXJucyB0aGUgaW5pdGlhbGlzZWQgY2hhbm5lbCBieSB0aGUgQ2xpcCB0aGUgSW5jaWRlbnQgYmVsb25ncyB0b1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGFubmVsJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGVja1BhcmVudFNjZW5lKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5fZ2V0Q2hhbm5lbCh0aGlzLm1jX3BsdWdpbl9ucG1fbmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdlbGVtZW50cycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5nZXRFbGVtZW50cyh0aGlzLnNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZXhlY3V0aW9uU3BlZWQnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChzcGVlZCkge1xuICAgICAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xuICAgICAgICAgICAgLy8gdGhpcy5iZU9uKHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBnZXRzIHRoZSBJbmNpZGVudCdzIGR1cmF0aW9uLiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcndyaXRlbiBhY2NvcmRpbmdseSBieSBhbGwgSW5jaWRlbnRzXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkdXJhdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGR1cmF0aW9uKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0YXRlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ydW5UaW1lSW5mby5zdGF0ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29udGV4dCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuY29udGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2RpcmVjdGlvbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BlZWQgPiAwID8gXCJmb3J3YXJkc1wiIDogXCJiYWNrd2FyZHNcIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBJbmNpZGVudDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmNpZGVudDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Incident = __webpack_require__(/*! ./Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils//Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar isTimePausingState = __webpack_require__(/*! ../configuration/allowedStateChanges */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\").isTimePausingState;\n\n/** @classdesc\n * A TimedIncident is an incident that lasts some time. It has duration and a timer of its own. It can take all the states.\n *\n */\n\nvar TimedIncident = function (_Incident) {\n    _inherits(TimedIncident, _Incident);\n\n    function TimedIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, TimedIncident);\n\n        var _this = _possibleConstructorReturn(this, (TimedIncident.__proto__ || Object.getPrototypeOf(TimedIncident)).call(this, attrs, props));\n\n        _this.resetState();\n\n        /**\n          @member {object} - listeners are functions to be executed on time change of the Timed Incident. It has the following format:\n           listeners: {\n            listener_id: {\n                     funct : the function to be executed\n                     threshold : the threshold of delta\n                     roundTo : round millisecond\n                 },\n                 listener_id: {\n                     funct : the function to be executed\n                     threshold : the threshold of delta\n                     roundTo : round millisecond\n                 },\n                 ...\n           }\n           */\n        _this.listeners = {};\n\n        _this.bitIncident = false;\n        return _this;\n    }\n\n    _createClass(TimedIncident, [{\n        key: 'requestAnimaFrame',\n        value: function requestAnimaFrame(fn) {\n            /* if the Incident is on test mode we want to prevent requestAnimationFrame as execution\n                during testing is controlled through emulateStep method */\n            if (this.isOnTestMode) {\n                return function () {};\n            }\n\n            try {\n                return this.context.window.requestAnimationFrame(fn);\n            } catch (e) {\n                helper.error('Your browser does not support requestAnimationFrame');\n                return function (fn) {};\n            }\n        }\n\n        /**\n         * when the Incident is on test mode (this.isOnTestMode = true) the emulateStep method\n         * becomes functional.\n         * The method takes as input the millisecondsDelta from the previous timestamp and triggers\n         * the step function passing in a baked timestamp so the Incident behaves exactly as if the requestAnimationFrame run\n         * passing a timestamp that has exactly millisecondsDelta difference from the previous one\n         * @param {int} millisecondsDelta - the milliseconds difference between the previous timestamp and the new one\n        */\n\n    }, {\n        key: 'emulateStep',\n        value: function emulateStep(millisecondsDelta) {\n            if (!this.isOnTestMode) {\n                helper.error('emulateStep method can only be used on test mode');\n            } else {\n                this.step(this.runTimeInfo.previousTimeStamp + millisecondsDelta);\n            }\n        }\n\n        /**\n         * All TimedIncidents must implement the get duration method\n        **/\n\n    }, {\n        key: 'checkResizedIncident',\n\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n        **/\n        value: function checkResizedIncident(durationFraction, incident) {\n            var adjustMillisecond = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n            // IF THE GROUP HAS NO PARENTS (IS A CLIP)\n            if (this.isTheClip && incident.id != this.id) {\n                // get all incidents separated by plugin\n                var incidentsById = incident.getIncidentsByPlugin();\n\n                // prepare the return payload\n                var toReturnResult = true;\n                var toReturnErrors = [];\n                var toReturnExecutables = [];\n                // for each key of the incidentsById object perform the check\n\n                for (var key in incidentsById) {\n                    // perform the check\n                    var adjustedIncidents = helper.systoleDiastoleProjections(incidentsById[key], durationFraction, adjustMillisecond);\n                    var pluginResult = this.instantiatedChannels[key].checkResizedIncidents(adjustedIncidents);\n                    toReturnResult = toReturnResult && pluginResult.result;\n                    if (pluginResult.result === false) {\n                        toReturnErrors = toReturnErrors.concat(pluginResult.errors);\n                    } else {\n                        toReturnExecutables.push(pluginResult.execute);\n                    }\n                } // enf of iteration on the incidentsById keys\n\n                var toReturnExecute = function toReturnExecute() {\n                    for (var i = 0; i < toReturnExecutables.length; i++) {\n                        toReturnExecutables[i]();\n                    }\n                };\n\n                var editResult = {\n                    result: toReturnResult,\n                    errors: toReturnErrors,\n                    execute: toReturnExecute\n                };\n                return editResult;\n            } else if (this.isTheClip) {\n                return { result: true, execute: function execute() {} };\n                // the resizing of the internal Channels occurs on the systolDiastole method of the Groups when they identify that the Groups is actually a Clip\n            } else if (this.isHeadlessClip) {\n                return { result: true, execute: function execute() {} };\n            } else {\n                // IF THE GROUP HAS NO PARENT (ACT AS THE CLIP)\n                return this.parentSceneObject.checkResizedIncident(durationFraction, incident, adjustMillisecond + this.parentSceneObject.getIncidentMillisecond(this.id));\n            }\n        }\n\n        /**\n         * Edits the duration of the Incident\n         * @param {int} duration - the new duration in milliseconds\n        **/\n\n    }, {\n        key: 'resize',\n        value: function resize(duration) {\n            // console.trace();\n            // don't waste cpu resources if the new duration equals the current value\n            if (duration === this.duration) {\n                return { result: true };\n            } else if (duration <= 0) {\n                helper.error('resizeIncident method of Scene only accepts integers > 0 as the new duration of the Scene. ' + duration + ' provided.');\n                return {\n                    result: false\n                };\n            }\n            // stop the execution\n            this.stop();\n\n            var editCheck = this.checkResizedIncident(duration / this.duration, this);\n\n            if (editCheck.result === false) {\n                helper.error(editCheck);\n                return editCheck;\n            }\n\n            this.systolDiastole(duration / this.duration);\n            editCheck.execute();\n            var whereAmI = this.getRootCurrentMillisecondDeltaFromStart();\n            // whereAmI = this.normaliseGoToTarget(whereAmI);\n            // this.goTo(whereAmI);\n\n            if (this.checkParentScene()) {\n                this.parentSceneObject.getDurationAfterIncidentAffected();\n            }\n\n            return { result: true };\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            this.duration = this.duration * durationFraction;\n        }\n    }, {\n        key: 'resetState',\n        value: function resetState() {\n            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resetState', this).call(this);\n            // the current millisecond having as 0 the start of the animation\n            if (this.state === 'idle') this.runTimeInfo.currentMillisecond = 0; // the current millisecond of the incident as it's calculated based on the speed of the Incident\n            else if (this.state === 'completed') this.runTimeInfo.currentMillisecond = this.duration;\n            // in other words the millisecond that the Incident is on the UI\n            this.runTimeInfo.start = null; // the millisecond started as provided by requestAnimationFrame\n            this.runTimeInfo.previousTimeStamp = null; // the timestamp of the previous circle as provided by requestAnimationFrame\n            this.runTimeInfo.pauseMoment = null; // the pause moment as provided by new Date().getTime()\n            this.runTimeInfo.pauseMillisecond = 0; // the pauseMillisecond is the current millisecond at the pause moment\n            for (var key in this.listeners) {\n                this.listeners[key].cavaDelta = 0;\n            }\n        }\n\n        /**\n         * This method calculates the previousTimeStamp based on the target UI millisecond we want to go to and\n         * the speed of the Incident.\n         * E.g. if targetUIMillisecond = 2000 and speed =2 then we will take the timestamp from requestAnimationFrame (ra_stamp) and\n         * set the previousMillisecond to ra_stamp-1000\n         * @param {int} currentMIllisecond - the millisecond to which we want our Inicdent to be on\n        */\n\n    }, {\n        key: 'programmaticSetPreviousTimeStamp',\n        value: function programmaticSetPreviousTimeStamp(targetUIMillisecond) {\n            var _this2 = this;\n\n            var that = this;\n\n            if (this.isOnTestMode) {\n                that.runTimeInfo.previousTimeStamp = 0;\n            }\n\n            this.requestAnimaFrame(function (timestamp) {\n                that.runTimeInfo.previousTimeStamp = timestamp - targetUIMillisecond / _this2.speed;\n            });\n        }\n\n        // ******** INCIDENT METHODS IMPLEMENTATION **************\n        // *******************************************************\n\n    }, {\n        key: 'play',\n        value: function play() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (!this.checkStateTransition('playing')) {\n                return false;\n            }\n\n            var that = this;\n            this._setState('playing');\n            this.onPlay(props);\n\n            if (!this.isOnTestMode) {\n                this.requestAnimaFrame(function (timestamp) {\n                    that.step(timestamp, props);\n                }.bind(that));\n            } else {\n                this.runTimeInfo.previousTimeStamp = 0;\n                this.emulateStep(props.startFrom);\n            }\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'complete', this).call(this);\n            this.resetState();\n        }\n\n        // timer blocking\n\n    }, {\n        key: 'wait',\n        value: function wait(props, waitCallerId) {\n            var previousState = this.runTimeInfo.state;\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'wait', this).call(this, props, waitCallerId)) {\n                if (!isTimePausingState(previousState)) {\n                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                    this.runTimeInfo.pauseMoment = new Date().getTime();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        // timer blocking\n\n    }, {\n        key: 'block',\n        value: function block(props) {\n            var previousState = this.runTimeInfo.state;\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'block', this).call(this, props)) {\n                if (!isTimePausingState(previousState)) {\n                    this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                    this.runTimeInfo.pauseMoment = new Date().getTime();\n                }\n                return true;\n            }\n            return false;\n        }\n\n        // timer unblocking\n\n    }, {\n        key: 'resume',\n        value: function resume(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'resume', this).call(this, props)) {\n                var delta = new Date().getTime() - this.runTimeInfo.pauseMoment;\n                this.runTimeInfo.previousTimeStamp += delta;\n                this.requestAnimaFrame(this.step.bind(this));\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'reset',\n        value: function reset(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'reset', this).call(this, props)) {\n                this.resetState();\n            }\n\n            return false;\n        }\n    }, {\n        key: 'stop',\n        value: function stop(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'stop', this).call(this, props)) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: 'arm',\n        value: function arm(props) {\n            if (_get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'arm', this).call(this, props)) {\n                // sets the pause moment to the current time...\n                this.runTimeInfo.pauseMoment = new Date().getTime();\n                var that = this;\n\n                this.programmaticSetPreviousTimeStamp(0);\n                this.runTimeInfo.currentMillisecond = props.targetMillisecondDeltaFromStart;\n                this.runTimeInfo.pauseMillisecond = this.runTimeInfo.currentMillisecond * 1;\n                return true;\n            }\n            return false;\n        }\n\n        // *******************************************************\n        // STEP FUNCTION\n\n    }, {\n        key: 'step',\n        value: function step(timestamp) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n            var that = this;\n\n            // start from is the number of milliseconds elapsed from the actual starting point of the Incident caused mainly\n            // by CPU performance. (each requestAnimationFrame cirlce doesn't happen every one millisecond\n            // so an Incident that was supposed to start on millisecond 100 of a Group might get fired 10 milliseconds later than\n            // its actual starting point, so tth startFrom will be 10)\n            if (props != null) {\n                var startFrom = props.startFrom;\n                if (!props.hasOwnProperty('startFrom')) {\n                    if (this.direction === \"forwards\") {\n                        startFrom = 0;\n                    } else {\n                        startFrom = this.duration;\n                    }\n                }\n\n                if (this.speed > 0) {\n                    this.runTimeInfo.previousTimeStamp = timestamp - startFrom / this.speed;\n                } else {\n                    this.runTimeInfo.previousTimeStamp = timestamp - (this.duration - startFrom) / Math.abs(this.speed);\n                }\n            }\n\n            var informListeners = function informListeners(progress) {\n                for (var key in that.listeners) {\n                    var listner = that.listeners[key];\n                    if (Math.abs(progress.milliseconds + listner.cavaDelta - that.runTimeInfo.currentMillisecond) > listner.threshold) {\n                        listner.funct(progress.milliseconds, timestamp, helper.roundNumberTo(listner.roundTo));\n                        listner.cavaDelta = 0;\n                    } else {\n                        listner.cavaDelta += Math.abs(progress.milliseconds - that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            // helper.log('got into step on ' + this.id);\n            if (this.runTimeInfo.state !== 'playing') {\n                return;\n            }\n\n            // progressStep is the progress made from previousTimeStamp both in milliseconds and in fraction [0 to 1]\n            var progress = {\n                milliseconds: Math.round(this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed),\n                fraction: (this.runTimeInfo.currentMillisecond + (timestamp - this.runTimeInfo.previousTimeStamp) * this.speed) / this.duration\n            };\n            // helper.notice(`calculation properties of progress for ${this.id}`);\n            // helper.log(`this.runTimeInfo.currentMillisecond: ${this.runTimeInfo.currentMillisecond}, timestamp: ${timestamp}, this.runTimeInfo.previousTimeStamp: ${this.runTimeInfo.previousTimeStamp}`)\n\n            // helper.log(this.id, progress);\n\n            if (progress.fraction >= 1) {\n                this.onProgress(1, this.duration);\n                informListeners({ fraction: 1, milliseconds: this.duration });\n                this.complete();\n                return;\n            } else if (progress.fraction < 0) {\n                this.onProgress(0, 0);\n                informListeners({ fraction: 0, milliseconds: 0 });\n                this._dontTellMamaStateChange('idle');\n                this.broadcastEvent('state-change', { oldState: \"playing\", newState: \"idle\" });\n                this.resetState();\n                return;\n            }\n\n            this.onProgress(progress.fraction, progress.milliseconds);\n\n            // helper.log(this.id);\n            // helper.log(this.runTimeInfo.currentMillisecond);\n            // helper.log(this.id + ' progress: ', progress);\n            // handle listeners\n            informListeners(progress);\n\n            this.runTimeInfo.currentMillisecond = progress.milliseconds;\n            this.runTimeInfo.previousTimeStamp = timestamp;\n\n            // helper.log(this.runTimeInfo.currentMillisecond);\n\n            // helper.log('this.runtimeInfo.state on ' + this.id + ' = ' + this.runTimeInfo.state);\n            this.requestAnimaFrame(that.step.bind(that));\n        }\n\n        // ***** PUB SUB ***********\n        // *************************\n\n        /** Scene is responsible for knowing the time of it at any given moment. Also it acts as the single pipeline\n          that transfers play, wait, resume, goto requests from to its Incidents.\n          Scene is responsible for distributing the time information to any interested party\n           In order for any Class / module to be aware about the time of any Scene it should subscribe to its dispatch functions\n          By subscribing a module can get notified about changes on the Scene's time\n           subscribe method subscribes a function to the time change dispatcher. As Scene uses requestAnimationFrame for its timing\n          each cyrcle / step gets the current time and subtracts the previous time so it know how many milliseconds has elapsed\n          since last step. Subscribers can set to get informed about time changes only if the delta is greater than a given\n          number (e.g. greater than 300ms). That property is passed as the second argument \"threshold\".\n          Finally if any of the subscribers want the Scene to provide back a rounded number of the milliseconds. Options:\n            - 1 (round it on its actual units\n           - 10 (round it on tenths)\n           - 100 (round it on hundreds)\n           - 1000 (round it on thousands)\n           the first argument provides an id to the listener for future reference (deletion etc)\n          the second argument is a function that takes two arguments: millisecond, state (current millisecond of the Scene\n          and the state of it  */\n\n    }, {\n        key: 'subscribe',\n        value: function subscribe(id, funct, threshold, roundTo) {\n            if (!threshold) {\n                threshold = 0;\n            }\n            if (!roundTo) {\n                roundTo = 1; // round second to its units, meaning leave it as it is\n            }\n            this.listeners[id] = {\n                funct: funct,\n                threshold: threshold,\n                roundTo: roundTo,\n                cavaDelta: 0\n            };\n        }\n\n        /**\n         * This method's (which should be called whenever a slip ends) purpose is to calculate and set\n         * the right state of the Incident based on the target millisecond.\n         * The parameter it takes is relative to the beginning of the Incident itself and it might be negative\n         * Negative targetMillisecond means the target millisecond is N milliseconds BEFORE the start of the Incident\n         * @param {int} targetMillisecondDeltaFromStart - the delta of the target millisecond compared to the Incident start\n         */\n\n    }, {\n        key: 'recalcState',\n        value: function recalcState() {\n            var targetMillisecondDeltaFromStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (targetMillisecondDeltaFromStart === null) {\n                targetMillisecondDeltaFromStart = this.runTimeInfo.currentMillisecond;\n            }\n            // helper.log('recalculating state for Incident: ' + this.id, targetMillisecondDeltaFromStart);\n            if (targetMillisecondDeltaFromStart >= this.duration) {\n                // if it ends before the targetMillisecond\n                // helper.log('completes');\n                this.statusBeforeHalt = \"completed\";\n                this.runTimeInfo.currentMillisecond = this.duration;\n                this._dontTellMamaStateChange('completed');\n            } else if (targetMillisecondDeltaFromStart <= this.duration && targetMillisecondDeltaFromStart > 0) {\n                // if the targetMillisecond is in the middle of it\n                if (this.state === 'playing') {\n                    return;\n                }\n                this.statusBeforeHalt = \"playing\";\n                this.arm({ targetMillisecondDeltaFromStart: targetMillisecondDeltaFromStart });\n            } else if (targetMillisecondDeltaFromStart <= 0) {\n                // if it has been completed on targetMillisecond\n                // helper.log('resets to idle');\n                this.statusBeforeHalt = \"idle\";\n                this.runTimeInfo.currentMillisecond = 0;\n                this._dontTellMamaStateChange('idle');\n                this.resetState();\n            }\n        }\n\n        /**\n         * Method called on progress of the timed incident.\n         * @param {float} fraction - a number from 0 to 1 representing the fraction of duration covered\n         * @param {int} milliseconds - the number of milliseconds passed from start of the incident\n        */\n\n    }, {\n        key: 'onProgress',\n        value: function onProgress(fraction, milliseconds) {}\n    }, {\n        key: 'beOn',\n        value: function beOn(millisecond) {\n            var beOnResult = _get(TimedIncident.prototype.__proto__ || Object.getPrototypeOf(TimedIncident.prototype), 'beOn', this).call(this, millisecond);\n            if (beOnResult.previousState === \"playing\" && beOnResult.newState === \"waiting\") {\n                this.resume();\n                beOnResult.newState = \"playing\";\n            }\n            return beOnResult;\n        }\n    }, {\n        key: 'duration',\n        get: function get() {\n            return this.props.duration;\n        }\n\n        /**\n         * All TimedIncidents must implement the duration setter method\n        **/\n        ,\n        set: function set(duration) {\n            this.props.duration = duration;\n        }\n    }]);\n\n    return TimedIncident;\n}(Incident);\n\nmodule.exports = TimedIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19CYXNlQ2xhc3Nlcy9UaW1lZEluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQmFzZUNsYXNzZXMvVGltZWRJbmNpZGVudC5qcz83NGRmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBJbmNpZGVudCA9IHJlcXVpcmUoJy4vSW5jaWRlbnQnKTtcbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzLy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgaXNUaW1lUGF1c2luZ1N0YXRlID0gcmVxdWlyZSgnLi4vY29uZmlndXJhdGlvbi9hbGxvd2VkU3RhdGVDaGFuZ2VzJykuaXNUaW1lUGF1c2luZ1N0YXRlO1xuXG4vKiogQGNsYXNzZGVzY1xuICogQSBUaW1lZEluY2lkZW50IGlzIGFuIGluY2lkZW50IHRoYXQgbGFzdHMgc29tZSB0aW1lLiBJdCBoYXMgZHVyYXRpb24gYW5kIGEgdGltZXIgb2YgaXRzIG93bi4gSXQgY2FuIHRha2UgYWxsIHRoZSBzdGF0ZXMuXG4gKlxuICovXG5cbnZhciBUaW1lZEluY2lkZW50ID0gZnVuY3Rpb24gKF9JbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhUaW1lZEluY2lkZW50LCBfSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gVGltZWRJbmNpZGVudCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZWRJbmNpZGVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFRpbWVkSW5jaWRlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50KSkuY2FsbCh0aGlzLCBhdHRycywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5yZXNldFN0YXRlKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAgQG1lbWJlciB7b2JqZWN0fSAtIGxpc3RlbmVycyBhcmUgZnVuY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIG9uIHRpbWUgY2hhbmdlIG9mIHRoZSBUaW1lZCBJbmNpZGVudC4gSXQgaGFzIHRoZSBmb2xsb3dpbmcgZm9ybWF0OlxuICAgICAgICAgICBsaXN0ZW5lcnM6IHtcbiAgICAgICAgICAgIGxpc3RlbmVyX2lkOiB7XG4gICAgICAgICAgICAgICAgICAgICBmdW5jdCA6IHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkIDogdGhlIHRocmVzaG9sZCBvZiBkZWx0YVxuICAgICAgICAgICAgICAgICAgICAgcm91bmRUbyA6IHJvdW5kIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIGxpc3RlbmVyX2lkOiB7XG4gICAgICAgICAgICAgICAgICAgICBmdW5jdCA6IHRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgICAgICAgICAgICAgICAgICAgdGhyZXNob2xkIDogdGhlIHRocmVzaG9sZCBvZiBkZWx0YVxuICAgICAgICAgICAgICAgICAgICAgcm91bmRUbyA6IHJvdW5kIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgIC4uLlxuICAgICAgICAgICB9XG4gICAgICAgICAgICovXG4gICAgICAgIF90aGlzLmxpc3RlbmVycyA9IHt9O1xuXG4gICAgICAgIF90aGlzLmJpdEluY2lkZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZWRJbmNpZGVudCwgW3tcbiAgICAgICAga2V5OiAncmVxdWVzdEFuaW1hRnJhbWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdEFuaW1hRnJhbWUoZm4pIHtcbiAgICAgICAgICAgIC8qIGlmIHRoZSBJbmNpZGVudCBpcyBvbiB0ZXN0IG1vZGUgd2Ugd2FudCB0byBwcmV2ZW50IHJlcXVlc3RBbmltYXRpb25GcmFtZSBhcyBleGVjdXRpb25cbiAgICAgICAgICAgICAgICBkdXJpbmcgdGVzdGluZyBpcyBjb250cm9sbGVkIHRocm91Z2ggZW11bGF0ZVN0ZXAgbWV0aG9kICovXG4gICAgICAgICAgICBpZiAodGhpcy5pc09uVGVzdE1vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC53aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1lvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHJlcXVlc3RBbmltYXRpb25GcmFtZScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZm4pIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHdoZW4gdGhlIEluY2lkZW50IGlzIG9uIHRlc3QgbW9kZSAodGhpcy5pc09uVGVzdE1vZGUgPSB0cnVlKSB0aGUgZW11bGF0ZVN0ZXAgbWV0aG9kXG4gICAgICAgICAqIGJlY29tZXMgZnVuY3Rpb25hbC5cbiAgICAgICAgICogVGhlIG1ldGhvZCB0YWtlcyBhcyBpbnB1dCB0aGUgbWlsbGlzZWNvbmRzRGVsdGEgZnJvbSB0aGUgcHJldmlvdXMgdGltZXN0YW1wIGFuZCB0cmlnZ2Vyc1xuICAgICAgICAgKiB0aGUgc3RlcCBmdW5jdGlvbiBwYXNzaW5nIGluIGEgYmFrZWQgdGltZXN0YW1wIHNvIHRoZSBJbmNpZGVudCBiZWhhdmVzIGV4YWN0bHkgYXMgaWYgdGhlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBydW5cbiAgICAgICAgICogcGFzc2luZyBhIHRpbWVzdGFtcCB0aGF0IGhhcyBleGFjdGx5IG1pbGxpc2Vjb25kc0RlbHRhIGRpZmZlcmVuY2UgZnJvbSB0aGUgcHJldmlvdXMgb25lXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwcmV2aW91cyB0aW1lc3RhbXAgYW5kIHRoZSBuZXcgb25lXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2VtdWxhdGVTdGVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVtdWxhdGVTdGVwKG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNPblRlc3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdlbXVsYXRlU3RlcCBtZXRob2QgY2FuIG9ubHkgYmUgdXNlZCBvbiB0ZXN0IG1vZGUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwKHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgKyBtaWxsaXNlY29uZHNEZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIFRpbWVkSW5jaWRlbnRzIG11c3QgaW1wbGVtZW50IHRoZSBnZXQgZHVyYXRpb24gbWV0aG9kXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogY2hlY2tzIGlmIGEgZHVyYXRpb24gZWRpdCBpcyBmZWFzaWJsZSBhbmQgZG9lc24ndCBjYXVzZSBjb25mbGljdHNcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IGR1cmF0aW9uIC0gdGhlIG5ldyBkdXJhdGlvblxuICAgICAgICAqKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUmVzaXplZEluY2lkZW50KGR1cmF0aW9uRnJhY3Rpb24sIGluY2lkZW50KSB7XG4gICAgICAgICAgICB2YXIgYWRqdXN0TWlsbGlzZWNvbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG5cbiAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UUyAoSVMgQSBDTElQKVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNUaGVDbGlwICYmIGluY2lkZW50LmlkICE9IHRoaXMuaWQpIHtcbiAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIGluY2lkZW50cyBzZXBhcmF0ZWQgYnkgcGx1Z2luXG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50c0J5SWQgPSBpbmNpZGVudC5nZXRJbmNpZGVudHNCeVBsdWdpbigpO1xuXG4gICAgICAgICAgICAgICAgLy8gcHJlcGFyZSB0aGUgcmV0dXJuIHBheWxvYWRcbiAgICAgICAgICAgICAgICB2YXIgdG9SZXR1cm5SZXN1bHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkVycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciB0b1JldHVybkV4ZWN1dGFibGVzID0gW107XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2gga2V5IG9mIHRoZSBpbmNpZGVudHNCeUlkIG9iamVjdCBwZXJmb3JtIHRoZSBjaGVja1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGluY2lkZW50c0J5SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGVyZm9ybSB0aGUgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFkanVzdGVkSW5jaWRlbnRzID0gaGVscGVyLnN5c3RvbGVEaWFzdG9sZVByb2plY3Rpb25zKGluY2lkZW50c0J5SWRba2V5XSwgZHVyYXRpb25GcmFjdGlvbiwgYWRqdXN0TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGx1Z2luUmVzdWx0ID0gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1trZXldLmNoZWNrUmVzaXplZEluY2lkZW50cyhhZGp1c3RlZEluY2lkZW50cyk7XG4gICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuUmVzdWx0ID0gdG9SZXR1cm5SZXN1bHQgJiYgcGx1Z2luUmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpblJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkVycm9ycyA9IHRvUmV0dXJuRXJyb3JzLmNvbmNhdChwbHVnaW5SZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvUmV0dXJuRXhlY3V0YWJsZXMucHVzaChwbHVnaW5SZXN1bHQuZXhlY3V0ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVuZiBvZiBpdGVyYXRpb24gb24gdGhlIGluY2lkZW50c0J5SWQga2V5c1xuXG4gICAgICAgICAgICAgICAgdmFyIHRvUmV0dXJuRXhlY3V0ZSA9IGZ1bmN0aW9uIHRvUmV0dXJuRXhlY3V0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b1JldHVybkV4ZWN1dGFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b1JldHVybkV4ZWN1dGFibGVzW2ldKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIGVkaXRSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdG9SZXR1cm5SZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogdG9SZXR1cm5FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHRvUmV0dXJuRXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkaXRSZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNUaGVDbGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcmVzaXppbmcgb2YgdGhlIGludGVybmFsIENoYW5uZWxzIG9jY3VycyBvbiB0aGUgc3lzdG9sRGlhc3RvbGUgbWV0aG9kIG9mIHRoZSBHcm91cHMgd2hlbiB0aGV5IGlkZW50aWZ5IHRoYXQgdGhlIEdyb3VwcyBpcyBhY3R1YWxseSBhIENsaXBcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0hlYWRsZXNzQ2xpcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElGIFRIRSBHUk9VUCBIQVMgTk8gUEFSRU5UIChBQ1QgQVMgVEhFIENMSVApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50U2NlbmVPYmplY3QuY2hlY2tSZXNpemVkSW5jaWRlbnQoZHVyYXRpb25GcmFjdGlvbiwgaW5jaWRlbnQsIGFkanVzdE1pbGxpc2Vjb25kICsgdGhpcy5wYXJlbnRTY2VuZU9iamVjdC5nZXRJbmNpZGVudE1pbGxpc2Vjb25kKHRoaXMuaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZGl0cyB0aGUgZHVyYXRpb24gb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBkdXJhdGlvbiAtIHRoZSBuZXcgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGR1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLnRyYWNlKCk7XG4gICAgICAgICAgICAvLyBkb24ndCB3YXN0ZSBjcHUgcmVzb3VyY2VzIGlmIHRoZSBuZXcgZHVyYXRpb24gZXF1YWxzIHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICAgICAgICBpZiAoZHVyYXRpb24gPT09IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUgfTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZHVyYXRpb24gPD0gMCkge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcigncmVzaXplSW5jaWRlbnQgbWV0aG9kIG9mIFNjZW5lIG9ubHkgYWNjZXB0cyBpbnRlZ2VycyA+IDAgYXMgdGhlIG5ldyBkdXJhdGlvbiBvZiB0aGUgU2NlbmUuICcgKyBkdXJhdGlvbiArICcgcHJvdmlkZWQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzdG9wIHRoZSBleGVjdXRpb25cbiAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xuXG4gICAgICAgICAgICB2YXIgZWRpdENoZWNrID0gdGhpcy5jaGVja1Jlc2l6ZWRJbmNpZGVudChkdXJhdGlvbiAvIHRoaXMuZHVyYXRpb24sIHRoaXMpO1xuXG4gICAgICAgICAgICBpZiAoZWRpdENoZWNrLnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoZWRpdENoZWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdENoZWNrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN5c3RvbERpYXN0b2xlKGR1cmF0aW9uIC8gdGhpcy5kdXJhdGlvbik7XG4gICAgICAgICAgICBlZGl0Q2hlY2suZXhlY3V0ZSgpO1xuICAgICAgICAgICAgdmFyIHdoZXJlQW1JID0gdGhpcy5nZXRSb290Q3VycmVudE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQoKTtcbiAgICAgICAgICAgIC8vIHdoZXJlQW1JID0gdGhpcy5ub3JtYWxpc2VHb1RvVGFyZ2V0KHdoZXJlQW1JKTtcbiAgICAgICAgICAgIC8vIHRoaXMuZ29Ubyh3aGVyZUFtSSk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrUGFyZW50U2NlbmUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50U2NlbmVPYmplY3QuZ2V0RHVyYXRpb25BZnRlckluY2lkZW50QWZmZWN0ZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uICogZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzZXRTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFN0YXRlKCkge1xuICAgICAgICAgICAgX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ3Jlc2V0U3RhdGUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgaGF2aW5nIGFzIDAgdGhlIHN0YXJ0IG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnaWRsZScpIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gMDsgLy8gdGhlIGN1cnJlbnQgbWlsbGlzZWNvbmQgb2YgdGhlIGluY2lkZW50IGFzIGl0J3MgY2FsY3VsYXRlZCBiYXNlZCBvbiB0aGUgc3BlZWQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnY29tcGxldGVkJykgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgLy8gaW4gb3RoZXIgd29yZHMgdGhlIG1pbGxpc2Vjb25kIHRoYXQgdGhlIEluY2lkZW50IGlzIG9uIHRoZSBVSVxuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5zdGFydCA9IG51bGw7IC8vIHRoZSBtaWxsaXNlY29uZCBzdGFydGVkIGFzIHByb3ZpZGVkIGJ5IHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IG51bGw7IC8vIHRoZSB0aW1lc3RhbXAgb2YgdGhlIHByZXZpb3VzIGNpcmNsZSBhcyBwcm92aWRlZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNb21lbnQgPSBudWxsOyAvLyB0aGUgcGF1c2UgbW9tZW50IGFzIHByb3ZpZGVkIGJ5IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnBhdXNlTWlsbGlzZWNvbmQgPSAwOyAvLyB0aGUgcGF1c2VNaWxsaXNlY29uZCBpcyB0aGUgY3VycmVudCBtaWxsaXNlY29uZCBhdCB0aGUgcGF1c2UgbW9tZW50XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1trZXldLmNhdmFEZWx0YSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QgY2FsY3VsYXRlcyB0aGUgcHJldmlvdXNUaW1lU3RhbXAgYmFzZWQgb24gdGhlIHRhcmdldCBVSSBtaWxsaXNlY29uZCB3ZSB3YW50IHRvIGdvIHRvIGFuZFxuICAgICAgICAgKiB0aGUgc3BlZWQgb2YgdGhlIEluY2lkZW50LlxuICAgICAgICAgKiBFLmcuIGlmIHRhcmdldFVJTWlsbGlzZWNvbmQgPSAyMDAwIGFuZCBzcGVlZCA9MiB0aGVuIHdlIHdpbGwgdGFrZSB0aGUgdGltZXN0YW1wIGZyb20gcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyYV9zdGFtcCkgYW5kXG4gICAgICAgICAqIHNldCB0aGUgcHJldmlvdXNNaWxsaXNlY29uZCB0byByYV9zdGFtcC0xMDAwXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBjdXJyZW50TUlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdG8gd2hpY2ggd2Ugd2FudCBvdXIgSW5pY2RlbnQgdG8gYmUgb25cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncHJvZ3JhbW1hdGljU2V0UHJldmlvdXNUaW1lU3RhbXAnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZ3JhbW1hdGljU2V0UHJldmlvdXNUaW1lU3RhbXAodGFyZ2V0VUlNaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKHRoaXMuaXNPblRlc3RNb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCA9IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hRnJhbWUoZnVuY3Rpb24gKHRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoYXQucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXAgLSB0YXJnZXRVSU1pbGxpc2Vjb25kIC8gX3RoaXMyLnNwZWVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAqKioqKioqKiBJTkNJREVOVCBNRVRIT0RTIElNUExFTUVOVEFUSU9OICoqKioqKioqKioqKioqXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncGxheScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwbGF5KCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdwbGF5aW5nJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdwbGF5aW5nJyk7XG4gICAgICAgICAgICB0aGlzLm9uUGxheShwcm9wcyk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5pc09uVGVzdE1vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYUZyYW1lKGZ1bmN0aW9uICh0aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGVwKHRpbWVzdGFtcCwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIH0uYmluZCh0aGF0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuZW11bGF0ZVN0ZXAocHJvcHMuc3RhcnRGcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY29tcGxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgICAgICBfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAnY29tcGxldGUnLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lciBibG9ja2luZ1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICd3YWl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHdhaXQocHJvcHMsIHdhaXRDYWxsZXJJZCkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU3RhdGUgPSB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlO1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICd3YWl0JywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcywgd2FpdENhbGxlcklkKSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNUaW1lUGF1c2luZ1N0YXRlKHByZXZpb3VzU3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRpbWVyIGJsb2NraW5nXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Jsb2NrJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJsb2NrKHByb3BzKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTdGF0ZSA9IHRoaXMucnVuVGltZUluZm8uc3RhdGU7XG4gICAgICAgICAgICBpZiAoX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ2Jsb2NrJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVGltZVBhdXNpbmdTdGF0ZShwcmV2aW91c1N0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLnBhdXNlTWlsbGlzZWNvbmQgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAqIDE7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNb21lbnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aW1lciB1bmJsb2NraW5nXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3Jlc3VtZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAncmVzdW1lJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMucnVuVGltZUluZm8ucGF1c2VNb21lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RBbmltYUZyYW1lKHRoaXMuc3RlcC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVzZXQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQocHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChfZ2V0KFRpbWVkSW5jaWRlbnQucHJvdG90eXBlLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGltZWRJbmNpZGVudC5wcm90b3R5cGUpLCAncmVzZXQnLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N0b3AnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RvcChwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdzdG9wJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXJtJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFybShwcm9wcykge1xuICAgICAgICAgICAgaWYgKF9nZXQoVGltZWRJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihUaW1lZEluY2lkZW50LnByb3RvdHlwZSksICdhcm0nLCB0aGlzKS5jYWxsKHRoaXMsIHByb3BzKSkge1xuICAgICAgICAgICAgICAgIC8vIHNldHMgdGhlIHBhdXNlIG1vbWVudCB0byB0aGUgY3VycmVudCB0aW1lLi4uXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5wYXVzZU1vbWVudCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHRoaXMucHJvZ3JhbW1hdGljU2V0UHJldmlvdXNUaW1lU3RhbXAoMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBwcm9wcy50YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucGF1c2VNaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kICogMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgLy8gU1RFUCBGVU5DVElPTlxuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdGVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0ZXAodGltZXN0YW1wKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgLy8gc3RhcnQgZnJvbSBpcyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBlbGFwc2VkIGZyb20gdGhlIGFjdHVhbCBzdGFydGluZyBwb2ludCBvZiB0aGUgSW5jaWRlbnQgY2F1c2VkIG1haW5seVxuICAgICAgICAgICAgLy8gYnkgQ1BVIHBlcmZvcm1hbmNlLiAoZWFjaCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2lybGNlIGRvZXNuJ3QgaGFwcGVuIGV2ZXJ5IG9uZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgLy8gc28gYW4gSW5jaWRlbnQgdGhhdCB3YXMgc3VwcG9zZWQgdG8gc3RhcnQgb24gbWlsbGlzZWNvbmQgMTAwIG9mIGEgR3JvdXAgbWlnaHQgZ2V0IGZpcmVkIDEwIG1pbGxpc2Vjb25kcyBsYXRlciB0aGFuXG4gICAgICAgICAgICAvLyBpdHMgYWN0dWFsIHN0YXJ0aW5nIHBvaW50LCBzbyB0dGggc3RhcnRGcm9tIHdpbGwgYmUgMTApXG4gICAgICAgICAgICBpZiAocHJvcHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEZyb20gPSBwcm9wcy5zdGFydEZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnc3RhcnRGcm9tJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZGlyZWN0aW9uID09PSBcImZvcndhcmRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydEZyb20gPSB0aGlzLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXAgLSBzdGFydEZyb20gLyB0aGlzLnNwZWVkO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXAgLSAodGhpcy5kdXJhdGlvbiAtIHN0YXJ0RnJvbSkgLyBNYXRoLmFicyh0aGlzLnNwZWVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmZvcm1MaXN0ZW5lcnMgPSBmdW5jdGlvbiBpbmZvcm1MaXN0ZW5lcnMocHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhhdC5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RuZXIgPSB0aGF0Lmxpc3RlbmVyc1trZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMocHJvZ3Jlc3MubWlsbGlzZWNvbmRzICsgbGlzdG5lci5jYXZhRGVsdGEgLSB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCkgPiBsaXN0bmVyLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdG5lci5mdW5jdChwcm9ncmVzcy5taWxsaXNlY29uZHMsIHRpbWVzdGFtcCwgaGVscGVyLnJvdW5kTnVtYmVyVG8obGlzdG5lci5yb3VuZFRvKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0bmVyLmNhdmFEZWx0YSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0bmVyLmNhdmFEZWx0YSArPSBNYXRoLmFicyhwcm9ncmVzcy5taWxsaXNlY29uZHMgLSB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdnb3QgaW50byBzdGVwIG9uICcgKyB0aGlzLmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJ1blRpbWVJbmZvLnN0YXRlICE9PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHByb2dyZXNzU3RlcCBpcyB0aGUgcHJvZ3Jlc3MgbWFkZSBmcm9tIHByZXZpb3VzVGltZVN0YW1wIGJvdGggaW4gbWlsbGlzZWNvbmRzIGFuZCBpbiBmcmFjdGlvbiBbMCB0byAxXVxuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0ge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kczogTWF0aC5yb3VuZCh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCArICh0aW1lc3RhbXAgLSB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wKSAqIHRoaXMuc3BlZWQpLFxuICAgICAgICAgICAgICAgIGZyYWN0aW9uOiAodGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKyAodGltZXN0YW1wIC0gdGhpcy5ydW5UaW1lSW5mby5wcmV2aW91c1RpbWVTdGFtcCkgKiB0aGlzLnNwZWVkKSAvIHRoaXMuZHVyYXRpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBoZWxwZXIubm90aWNlKGBjYWxjdWxhdGlvbiBwcm9wZXJ0aWVzIG9mIHByb2dyZXNzIGZvciAke3RoaXMuaWR9YCk7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKGB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDogJHt0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZH0sIHRpbWVzdGFtcDogJHt0aW1lc3RhbXB9LCB0aGlzLnJ1blRpbWVJbmZvLnByZXZpb3VzVGltZVN0YW1wOiAke3RoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXB9YClcblxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLmlkLCBwcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcy5mcmFjdGlvbiA+PSAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKDEsIHRoaXMuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIGluZm9ybUxpc3RlbmVycyh7IGZyYWN0aW9uOiAxLCBtaWxsaXNlY29uZHM6IHRoaXMuZHVyYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvZ3Jlc3MuZnJhY3Rpb24gPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKDAsIDApO1xuICAgICAgICAgICAgICAgIGluZm9ybUxpc3RlbmVycyh7IGZyYWN0aW9uOiAwLCBtaWxsaXNlY29uZHM6IDAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ2lkbGUnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJyb2FkY2FzdEV2ZW50KCdzdGF0ZS1jaGFuZ2UnLCB7IG9sZFN0YXRlOiBcInBsYXlpbmdcIiwgbmV3U3RhdGU6IFwiaWRsZVwiIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHByb2dyZXNzLmZyYWN0aW9uLCBwcm9ncmVzcy5taWxsaXNlY29uZHMpO1xuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMuaWQpO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyh0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMuaWQgKyAnIHByb2dyZXNzOiAnLCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbGlzdGVuZXJzXG4gICAgICAgICAgICBpbmZvcm1MaXN0ZW5lcnMocHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHByb2dyZXNzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8ucHJldmlvdXNUaW1lU3RhbXAgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2codGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuXG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCd0aGlzLnJ1bnRpbWVJbmZvLnN0YXRlIG9uICcgKyB0aGlzLmlkICsgJyA9ICcgKyB0aGlzLnJ1blRpbWVJbmZvLnN0YXRlKTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hRnJhbWUodGhhdC5zdGVwLmJpbmQodGhhdCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gKioqKiogUFVCIFNVQiAqKioqKioqKioqKlxuICAgICAgICAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqXG5cbiAgICAgICAgLyoqIFNjZW5lIGlzIHJlc3BvbnNpYmxlIGZvciBrbm93aW5nIHRoZSB0aW1lIG9mIGl0IGF0IGFueSBnaXZlbiBtb21lbnQuIEFsc28gaXQgYWN0cyBhcyB0aGUgc2luZ2xlIHBpcGVsaW5lXG4gICAgICAgICAgdGhhdCB0cmFuc2ZlcnMgcGxheSwgd2FpdCwgcmVzdW1lLCBnb3RvIHJlcXVlc3RzIGZyb20gdG8gaXRzIEluY2lkZW50cy5cbiAgICAgICAgICBTY2VuZSBpcyByZXNwb25zaWJsZSBmb3IgZGlzdHJpYnV0aW5nIHRoZSB0aW1lIGluZm9ybWF0aW9uIHRvIGFueSBpbnRlcmVzdGVkIHBhcnR5XG4gICAgICAgICAgIEluIG9yZGVyIGZvciBhbnkgQ2xhc3MgLyBtb2R1bGUgdG8gYmUgYXdhcmUgYWJvdXQgdGhlIHRpbWUgb2YgYW55IFNjZW5lIGl0IHNob3VsZCBzdWJzY3JpYmUgdG8gaXRzIGRpc3BhdGNoIGZ1bmN0aW9uc1xuICAgICAgICAgIEJ5IHN1YnNjcmliaW5nIGEgbW9kdWxlIGNhbiBnZXQgbm90aWZpZWQgYWJvdXQgY2hhbmdlcyBvbiB0aGUgU2NlbmUncyB0aW1lXG4gICAgICAgICAgIHN1YnNjcmliZSBtZXRob2Qgc3Vic2NyaWJlcyBhIGZ1bmN0aW9uIHRvIHRoZSB0aW1lIGNoYW5nZSBkaXNwYXRjaGVyLiBBcyBTY2VuZSB1c2VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3IgaXRzIHRpbWluZ1xuICAgICAgICAgIGVhY2ggY3lyY2xlIC8gc3RlcCBnZXRzIHRoZSBjdXJyZW50IHRpbWUgYW5kIHN1YnRyYWN0cyB0aGUgcHJldmlvdXMgdGltZSBzbyBpdCBrbm93IGhvdyBtYW55IG1pbGxpc2Vjb25kcyBoYXMgZWxhcHNlZFxuICAgICAgICAgIHNpbmNlIGxhc3Qgc3RlcC4gU3Vic2NyaWJlcnMgY2FuIHNldCB0byBnZXQgaW5mb3JtZWQgYWJvdXQgdGltZSBjaGFuZ2VzIG9ubHkgaWYgdGhlIGRlbHRhIGlzIGdyZWF0ZXIgdGhhbiBhIGdpdmVuXG4gICAgICAgICAgbnVtYmVyIChlLmcuIGdyZWF0ZXIgdGhhbiAzMDBtcykuIFRoYXQgcHJvcGVydHkgaXMgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgXCJ0aHJlc2hvbGRcIi5cbiAgICAgICAgICBGaW5hbGx5IGlmIGFueSBvZiB0aGUgc3Vic2NyaWJlcnMgd2FudCB0aGUgU2NlbmUgdG8gcHJvdmlkZSBiYWNrIGEgcm91bmRlZCBudW1iZXIgb2YgdGhlIG1pbGxpc2Vjb25kcy4gT3B0aW9uczpcbiAgICAgICAgICAgIC0gMSAocm91bmQgaXQgb24gaXRzIGFjdHVhbCB1bml0c1xuICAgICAgICAgICAtIDEwIChyb3VuZCBpdCBvbiB0ZW50aHMpXG4gICAgICAgICAgIC0gMTAwIChyb3VuZCBpdCBvbiBodW5kcmVkcylcbiAgICAgICAgICAgLSAxMDAwIChyb3VuZCBpdCBvbiB0aG91c2FuZHMpXG4gICAgICAgICAgIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlcyBhbiBpZCB0byB0aGUgbGlzdGVuZXIgZm9yIGZ1dHVyZSByZWZlcmVuY2UgKGRlbGV0aW9uIGV0YylcbiAgICAgICAgICB0aGUgc2Vjb25kIGFyZ3VtZW50IGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyB0d28gYXJndW1lbnRzOiBtaWxsaXNlY29uZCwgc3RhdGUgKGN1cnJlbnQgbWlsbGlzZWNvbmQgb2YgdGhlIFNjZW5lXG4gICAgICAgICAgYW5kIHRoZSBzdGF0ZSBvZiBpdCAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc3Vic2NyaWJlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZShpZCwgZnVuY3QsIHRocmVzaG9sZCwgcm91bmRUbykge1xuICAgICAgICAgICAgaWYgKCF0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyb3VuZFRvKSB7XG4gICAgICAgICAgICAgICAgcm91bmRUbyA9IDE7IC8vIHJvdW5kIHNlY29uZCB0byBpdHMgdW5pdHMsIG1lYW5pbmcgbGVhdmUgaXQgYXMgaXQgaXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW2lkXSA9IHtcbiAgICAgICAgICAgICAgICBmdW5jdDogZnVuY3QsXG4gICAgICAgICAgICAgICAgdGhyZXNob2xkOiB0aHJlc2hvbGQsXG4gICAgICAgICAgICAgICAgcm91bmRUbzogcm91bmRUbyxcbiAgICAgICAgICAgICAgICBjYXZhRGVsdGE6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtZXRob2QncyAod2hpY2ggc2hvdWxkIGJlIGNhbGxlZCB3aGVuZXZlciBhIHNsaXAgZW5kcykgcHVycG9zZSBpcyB0byBjYWxjdWxhdGUgYW5kIHNldFxuICAgICAgICAgKiB0aGUgcmlnaHQgc3RhdGUgb2YgdGhlIEluY2lkZW50IGJhc2VkIG9uIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQuXG4gICAgICAgICAqIFRoZSBwYXJhbWV0ZXIgaXQgdGFrZXMgaXMgcmVsYXRpdmUgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgSW5jaWRlbnQgaXRzZWxmIGFuZCBpdCBtaWdodCBiZSBuZWdhdGl2ZVxuICAgICAgICAgKiBOZWdhdGl2ZSB0YXJnZXRNaWxsaXNlY29uZCBtZWFucyB0aGUgdGFyZ2V0IG1pbGxpc2Vjb25kIGlzIE4gbWlsbGlzZWNvbmRzIEJFRk9SRSB0aGUgc3RhcnQgb2YgdGhlIEluY2lkZW50XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IC0gdGhlIGRlbHRhIG9mIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgY29tcGFyZWQgdG8gdGhlIEluY2lkZW50IHN0YXJ0XG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdyZWNhbGNTdGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWNhbGNTdGF0ZSgpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3JlY2FsY3VsYXRpbmcgc3RhdGUgZm9yIEluY2lkZW50OiAnICsgdGhpcy5pZCwgdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA+PSB0aGlzLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgZW5kcyBiZWZvcmUgdGhlIHRhcmdldE1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnY29tcGxldGVzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gXCJjb21wbGV0ZWRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9udFRlbGxNYW1hU3RhdGVDaGFuZ2UoJ2NvbXBsZXRlZCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRNaWxsaXNlY29uZERlbHRhRnJvbVN0YXJ0IDw9IHRoaXMuZHVyYXRpb24gJiYgdGFyZ2V0TWlsbGlzZWNvbmREZWx0YUZyb21TdGFydCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFyZ2V0TWlsbGlzZWNvbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0JlZm9yZUhhbHQgPSBcInBsYXlpbmdcIjtcbiAgICAgICAgICAgICAgICB0aGlzLmFybSh7IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQ6IHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldE1pbGxpc2Vjb25kRGVsdGFGcm9tU3RhcnQgPD0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBiZWVuIGNvbXBsZXRlZCBvbiB0YXJnZXRNaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3Jlc2V0cyB0byBpZGxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXNCZWZvcmVIYWx0ID0gXCJpZGxlXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RvbnRUZWxsTWFtYVN0YXRlQ2hhbmdlKCdpZGxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldFN0YXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIGNhbGxlZCBvbiBwcm9ncmVzcyBvZiB0aGUgdGltZWQgaW5jaWRlbnQuXG4gICAgICAgICAqIEBwYXJhbSB7ZmxvYXR9IGZyYWN0aW9uIC0gYSBudW1iZXIgZnJvbSAwIHRvIDEgcmVwcmVzZW50aW5nIHRoZSBmcmFjdGlvbiBvZiBkdXJhdGlvbiBjb3ZlcmVkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHMgLSB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBwYXNzZWQgZnJvbSBzdGFydCBvZiB0aGUgaW5jaWRlbnRcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnb25Qcm9ncmVzcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvblByb2dyZXNzKGZyYWN0aW9uLCBtaWxsaXNlY29uZHMpIHt9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdiZU9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlT24obWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBiZU9uUmVzdWx0ID0gX2dldChUaW1lZEluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbWVkSW5jaWRlbnQucHJvdG90eXBlKSwgJ2JlT24nLCB0aGlzKS5jYWxsKHRoaXMsIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIGlmIChiZU9uUmVzdWx0LnByZXZpb3VzU3RhdGUgPT09IFwicGxheWluZ1wiICYmIGJlT25SZXN1bHQubmV3U3RhdGUgPT09IFwid2FpdGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWUoKTtcbiAgICAgICAgICAgICAgICBiZU9uUmVzdWx0Lm5ld1N0YXRlID0gXCJwbGF5aW5nXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmVPblJlc3VsdDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZHVyYXRpb24nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLmR1cmF0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBUaW1lZEluY2lkZW50cyBtdXN0IGltcGxlbWVudCB0aGUgZHVyYXRpb24gc2V0dGVyIG1ldGhvZFxuICAgICAgICAqKi9cbiAgICAgICAgLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChkdXJhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wcm9wcy5kdXJhdGlvbiA9IGR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVkSW5jaWRlbnQ7XG59KEluY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lZEluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Channel = function () {\n    function Channel(props) {\n        _classCallCheck(this, Channel);\n\n        this.runTimeInfo = props.runTimeInfo;\n        this.context = props.context;\n        this.onInitialise();\n        // this.type = \"plain\";\n    }\n\n    _createClass(Channel, [{\n        key: 'onInitialise',\n        value: function onInitialise() {\n            ;\n        }\n    }, {\n        key: '_resize',\n        value: function _resize() {\n            helper.log('Please overwite the _resize method of the Channel');\n        }\n\n        /**\n         * @param {array} incidents - A collection of Incidents in the form:\n         * {\n         *  millisecond\n         *  incident\n         *  id\n         * }\n         * @returns either:\n         *   {\n         *       result:true,\n         *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n         *   }\n         *   or\n         *   {\n         *       result: false,\n         *       errors\n         *   }\n        */\n\n    }, {\n        key: 'addIncidents',\n        value: function addIncidents(incidents) {\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkAddition(incidents);\n\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n         * that apply the change\n         * @param {array} incidents - the list of the incidents to edit in an array format [object, object, ...]\n         * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n         * @returns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n        key: 'editIncidents',\n        value: function editIncidents(incidents, millisecondsDelta, instantiatedChannels) {\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkEdit(incidents, millisecondsDelta);\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * Method to remove incidents\n         * @param {array} incidents - the ids of the incidents to remove in an array format\n         * @param {object} props - if passed it supports the preventSlip key which if false the channel should not slip. This case is for \n            flashDOM of DOMAwareIncidents where we have elements deleted so slipping on their lanes is not valid nor necessaryi\n         * @retuns {object} -\n         * either:\n         {\n            result: true,\n            execute: // array of functions to be executed in order to apply the edit\n         }\n         or\n         {\n             result: false,\n             errors: // an array including all the errors / conflicts found on edit\n         }\n        */\n\n    }, {\n        key: 'removeIncidents',\n        value: function removeIncidents(incidents) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first check the Incidents addition directly using the checkAddition method of the class\n            var result = this.checkDelete(incidents, props);\n            if (result.result === false) {\n                return {\n                    result: false,\n                    errors: result.errors\n                };\n            } else {\n                return {\n                    result: true,\n                    execute: result.execute\n                };\n            }\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentIds) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            return { result: true, execute: function execute() {} };\n        }\n    }, {\n        key: 'goTo',\n        value: function goTo(millisecond) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // first decide the millisecond we want to goTo\n            if (millisecond === null || millisecond === undefined) {\n                millisecond = this.runTimeInfo.currentMillisecond;\n            }\n            if (props.hasOwnProperty('relativeTo')) {\n                millisecond += this.getIncidentMillisecond(props.relativeTo);\n            }\n\n            var startFrom = this.runTimeInfo.currentMillisecond;\n            if (props.hasOwnProperty('previousStop')) {\n                startFrom = props.previousStop;\n            }\n\n            this.moveTo(startFrom, millisecond);\n        }\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            ;\n        }\n    }], [{\n        key: 'type',\n        get: function get() {\n            return \"plain\";\n        }\n    }]);\n\n    return Channel;\n}();\n\nmodule.exports = Channel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9DaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fQ2hhbm5lbHMvQ2hhbm5lbC5qcz9lMzQyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBDaGFubmVsID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5uZWwocHJvcHMpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENoYW5uZWwpO1xuXG4gICAgICAgIHRoaXMucnVuVGltZUluZm8gPSBwcm9wcy5ydW5UaW1lSW5mbztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gcHJvcHMuY29udGV4dDtcbiAgICAgICAgdGhpcy5vbkluaXRpYWxpc2UoKTtcbiAgICAgICAgLy8gdGhpcy50eXBlID0gXCJwbGFpblwiO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhDaGFubmVsLCBbe1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25Jbml0aWFsaXNlKCkge1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcmVzaXplJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemUoKSB7XG4gICAgICAgICAgICBoZWxwZXIubG9nKCdQbGVhc2Ugb3ZlcndpdGUgdGhlIF9yZXNpemUgbWV0aG9kIG9mIHRoZSBDaGFubmVsJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gQSBjb2xsZWN0aW9uIG9mIEluY2lkZW50cyBpbiB0aGUgZm9ybTpcbiAgICAgICAgICoge1xuICAgICAgICAgKiAgbWlsbGlzZWNvbmRcbiAgICAgICAgICogIGluY2lkZW50XG4gICAgICAgICAqICBpZFxuICAgICAgICAgKiB9XG4gICAgICAgICAqIEByZXR1cm5zIGVpdGhlcjpcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgKiAgICAgICBleGVjdXRlOiAvLyBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAqICAgfVxuICAgICAgICAgKiAgIG9yXG4gICAgICAgICAqICAge1xuICAgICAgICAgKiAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgKiAgICAgICBlcnJvcnNcbiAgICAgICAgICogICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmNpZGVudHMoaW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoZWNrQWRkaXRpb24oaW5jaWRlbnRzKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiByZXN1bHQuZXJyb3JzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiByZXN1bHQuZXhlY3V0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSXQgaW5pdGlhbGx5IGNoZWNrcyBpZiB0aGUgZWRpdCBpcyBhbGxvd2VkIGFuZCBpZiBpdCBpcyBpdCByZXR1bnMgYW4gYXJyYXkgb2YgZXhlY3V0YWJsZSBmdW5jdGlvbnNcbiAgICAgICAgICogdGhhdCBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBsaXN0IG9mIHRoZSBpbmNpZGVudHMgdG8gZWRpdCBpbiBhbiBhcnJheSBmb3JtYXQgW29iamVjdCwgb2JqZWN0LCAuLi5dXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgdG8gYXBwbHkgdG8gdGhlIGluY2lkZW50c1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtXG4gICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZCBpbiBvcmRlciB0byBhcHBseSB0aGUgZWRpdFxuICAgICAgICAgfVxuICAgICAgICAgb3JcbiAgICAgICAgIHtcbiAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZWRpdEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlZGl0SW5jaWRlbnRzKGluY2lkZW50cywgbWlsbGlzZWNvbmRzRGVsdGEsIGluc3RhbnRpYXRlZENoYW5uZWxzKSB7XG4gICAgICAgICAgICAvLyBmaXJzdCBjaGVjayB0aGUgSW5jaWRlbnRzIGFkZGl0aW9uIGRpcmVjdGx5IHVzaW5nIHRoZSBjaGVja0FkZGl0aW9uIG1ldGhvZCBvZiB0aGUgY2xhc3NcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNoZWNrRWRpdChpbmNpZGVudHMsIG1pbGxpc2Vjb25kc0RlbHRhKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogcmVzdWx0LmVycm9yc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogcmVzdWx0LmV4ZWN1dGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZW1vdmUgaW5jaWRlbnRzXG4gICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBpZHMgb2YgdGhlIGluY2lkZW50cyB0byByZW1vdmUgaW4gYW4gYXJyYXkgZm9ybWF0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyAtIGlmIHBhc3NlZCBpdCBzdXBwb3J0cyB0aGUgcHJldmVudFNsaXAga2V5IHdoaWNoIGlmIGZhbHNlIHRoZSBjaGFubmVsIHNob3VsZCBub3Qgc2xpcC4gVGhpcyBjYXNlIGlzIGZvciBcbiAgICAgICAgICAgIGZsYXNoRE9NIG9mIERPTUF3YXJlSW5jaWRlbnRzIHdoZXJlIHdlIGhhdmUgZWxlbWVudHMgZGVsZXRlZCBzbyBzbGlwcGluZyBvbiB0aGVpciBsYW5lcyBpcyBub3QgdmFsaWQgbm9yIG5lY2Vzc2FyeWlcbiAgICAgICAgICogQHJldHVucyB7b2JqZWN0fSAtXG4gICAgICAgICAqIGVpdGhlcjpcbiAgICAgICAgIHtcbiAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGFycmF5IG9mIGZ1bmN0aW9ucyB0byBiZSBleGVjdXRlZCBpbiBvcmRlciB0byBhcHBseSB0aGUgZWRpdFxuICAgICAgICAgfVxuICAgICAgICAgb3JcbiAgICAgICAgIHtcbiAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgIGVycm9yczogLy8gYW4gYXJyYXkgaW5jbHVkaW5nIGFsbCB0aGUgZXJyb3JzIC8gY29uZmxpY3RzIGZvdW5kIG9uIGVkaXRcbiAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5jaWRlbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluY2lkZW50cyhpbmNpZGVudHMpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IGNoZWNrIHRoZSBJbmNpZGVudHMgYWRkaXRpb24gZGlyZWN0bHkgdXNpbmcgdGhlIGNoZWNrQWRkaXRpb24gbWV0aG9kIG9mIHRoZSBjbGFzc1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuY2hlY2tEZWxldGUoaW5jaWRlbnRzLCBwcm9wcyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHJlc3VsdC5lcnJvcnNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IHJlc3VsdC5leGVjdXRlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPbiB0aGlzIG1ldGhvZCB0aGUgdXNlciBkZWZpbmVzIHRoZSBzcGVjaWZpYyBydWxlcyB0aGF0IGFwcGx5IG9uIHRoZSBwbHVnaW4gaXRzZWxmIGFuZCBvbiB0aGUgSW5jaWRlbnRzIG9mIHRoZSBwbHVnaW4gaXRzZWxmXG4gICAgICAgICAqIFRoZSBtZXRob2Qgc2hvdWxkIGVpdGhlciByZXR1cm4ge3Jlc3VsdDogdHJ1ZX0gb3Ige3Jlc3VsdDogZmFsc2UsIGVycm9yczpbe2Vycm9yLW9iamVjdH1dfSwgd2hlcmUgZXJyb3Itb2JqZWN0IGhhcyB0aGUgc3RydWN0dXJlOlxuICAgICAgICAgKiAge1xuICAgICAgICAgICAgICAgIGluY2lkZW50OiAvLyByZWZlcmVuY2UgdG8gdGhlIEluY2lkZW50IG9iamVjdCB0aGF0IGhhcyBiZWUgZGlzY2FyZGVkXG4gICAgICAgICAgICAgICAgZXJyb3I6IC8vIHRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBhIGNvbGxlY2l0b24gb2YgYWxsIGluY2lkZW50cyB0byBiZSBhZGRlZCBvbiB0aGUgZm9ybTpcbiAgICAgICAgKlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICAgICAgfVxuICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYSBmdW5jdGlvbiB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHNBcnJheSwgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZnVuY3Rpb24gZXhlY3V0ZSgpIHt9IH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKGluY2lkZW50SWRzKSB7XG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGZ1bmN0aW9uIGV4ZWN1dGUoKSB7fSB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBmdW5jdGlvbiBleGVjdXRlKCkge30gfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ29UbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnb1RvKG1pbGxpc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICAvLyBmaXJzdCBkZWNpZGUgdGhlIG1pbGxpc2Vjb25kIHdlIHdhbnQgdG8gZ29Ub1xuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kID09PSBudWxsIHx8IG1pbGxpc2Vjb25kID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCA9IHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCdyZWxhdGl2ZVRvJykpIHtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZCArPSB0aGlzLmdldEluY2lkZW50TWlsbGlzZWNvbmQocHJvcHMucmVsYXRpdmVUbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzdGFydEZyb20gPSB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgncHJldmlvdXNTdG9wJykpIHtcbiAgICAgICAgICAgICAgICBzdGFydEZyb20gPSBwcm9wcy5wcmV2aW91c1N0b3A7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubW92ZVRvKHN0YXJ0RnJvbSwgbWlsbGlzZWNvbmQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvKSB7XG4gICAgICAgICAgICA7XG4gICAgICAgIH1cbiAgICB9XSwgW3tcbiAgICAgICAga2V5OiAndHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwicGxhaW5cIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDaGFubmVsO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENoYW5uZWw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Channel = __webpack_require__(/*! ../Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\n\nvar lanesHandler = __webpack_require__(/*! ./LanesHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\");\n\nvar AttributeChannel = function (_Channel) {\n    _inherits(AttributeChannel, _Channel);\n\n    function AttributeChannel(props) {\n        _classCallCheck(this, AttributeChannel);\n\n        /*\n        comboAttributes are attributes of type object, holding a number of other attributes.\n        E.g. CSS \"transform\" attribute is a combo that holds a number of other attributes such as:\n        translateX, translateY, etc. The lanes handler keeps just one lane for the combo attrs \n        in an object format keeping the value of each attribute at any given point.\n        Combo attributes are passed on the constructor of the Channel in the format:\n        props.comboAttributes: {\n            transition: ['translateX', 'translateY', ...],\n            <something_else>: ['<attrName1>', '<attrName2>', ...]\n        }\n        */\n        var _this = _possibleConstructorReturn(this, (AttributeChannel.__proto__ || Object.getPrototypeOf(AttributeChannel)).call(this, props));\n\n        _this.comboAttributes = {};\n\n        /**\n         * For incidents that do not have animatedAttrs there should be only one lane per element. \n         * The attributes Channel will use a default (fake), fixed attribute for this cases so it always ends\n         * up with just one lane per element: <element_id>_<this.fixedAttributeName>\n        */\n        _this.fixedAttributeName = \"_\";\n\n        if (props.comboAttributes != null) {\n            _this.comboAttributes = props.comboAttributes;\n        }\n\n        _this.LanesHandler = new lanesHandler({ comboAttributes: _this.comboAttributes });\n        // this.type = \"attributes\";\n        return _this;\n    }\n\n    _createClass(AttributeChannel, [{\n        key: 'setComboAttributes',\n        value: function setComboAttributes(comboAttributes) {\n            this.comboAttributes = comboAttributes;\n            this.LanesHandler = new lanesHandler({ comboAttributes: this.comboAttributes });\n        }\n    }, {\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            this.LanesHandler._resize(durationFraction);\n        }\n\n        /**\n         * Checks whether the incident has animatedAttrs or not. \n        **/\n\n    }, {\n        key: '_incidentHasAnimatedAttrs',\n        value: function _incidentHasAnimatedAttrs(incident) {\n            if (incident.attrs.hasOwnProperty('animatedAttrs')) {\n                return true;\n            }\n            return false;\n        }\n\n        /* *******************************************************\n         DECISION METHODS\n         ********************************************************/\n\n        /**\n         * All of the incidents coming to this method are element-attribute incidents meaning that they only\n         * target just one element and also they include just a single attribute on the incident.attrs.animatedAttrs\n         * object\n         *\n         * @param {array} incidents - A collection of Incidents in the form:\n         * {\n         *  millisecond\n         *  incident\n         *  id\n         * }\n         * @param {string} type - can be either \"all-or-nothing\" (default) or \"keep-passing\". If type = \"all-or-nothing\"\n         *  the addition passes only if all incidents pass. If type = \"keep-passing\" the method will still return true\n         *  but will also include an errors array on its return and also will only include the success callbacks on \n         *  the execute key of its return\n         * @returns either:\n         *   {\n         *       result:true,\n         *       execute: // an array of functions that when executed it will add the Incidents on the Channels\n         *   }\n         *   or\n         *   {\n         *       result: false,\n         *       errors\n         *   }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var _this2 = this;\n\n            var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"all-or-nothing\";\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n            /* an array where we keep all affected lanes so we can slip on them at the end. \n            The format for each affected lane we keep is:\n            {\n                mcid: mcid,\n                attribute: attribute\n            }\n            */\n            var affectedLanes = [];\n\n            // while the LanesHandlerSanbox adds lane items it makes decisions of which permanent changes should be made to\n            // the permanent and pre-existing objects it handles, such as changes on the initial values of existing animations.\n            // Because of the fact the LanesSandboxHandler is only there for testing we don't want to execute these changes\n            // during checks but still we need to know them on success. For this, the onSuccessActions array holds all executable\n            // functions retured by various LanesHandlerSanbox functions so it can execute them on success.\n            var onSuccessActions = [];\n\n            var conflicts = [];\n\n            var _loop = function _loop(i) {\n                var incidentConflicts = false; // a boolean that keeps the information whether the incident conflicts or not\n                var laneItem = incidents[i];\n                var incident = laneItem.incident;\n\n                var mcid = _this2.context.getMCID(incident.element);\n\n                // console.log(\"the incident\",incident)\n                var attribute = _this2.fixedAttributeName;\n                if (_this2._incidentHasAnimatedAttrs(incident)) {\n                    attribute = Object.keys(incident.attrs.animatedAttrs)[0];\n                }\n\n                LanesHandlerSandbox.laneExists(mcid, attribute, true); // create the lane if it doesn't exist already\n\n                affectedLanes.push({\n                    mcid: mcid,\n                    attribute: attribute\n                });\n\n                if (LanesHandlerSandbox.animationIDExists(mcid, attribute, incident.id)) {\n                    incidentConflicts = true;\n                    conflicts.push({\n                        type: 'duplicate Animation id',\n                        meta: {\n                            id: incident.id\n                        }\n                    });\n                }\n\n                // **** if the lane did exist before the new addition check for conflicts\n                var overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(laneItem, mcid, attribute);\n\n                // helper.log(overlappingAnim)\n                if (overlappingAnims.length > 0) {\n                    incidentConflicts = true;\n                    conflicts.push({\n                        type: 'unauthorised, overlapping incidents on the same element',\n                        meta: {\n                            element_mcid: mcid,\n                            attribute: attribute,\n                            incident: laneItem,\n                            overlappingAnims: overlappingAnims\n                        }\n                    });\n                }\n\n                if (!incidentConflicts) {\n                    onSuccessActions.push(function () {\n                        LanesHandlerSandbox.addElementToLane(mcid, attribute, laneItem.millisecond, incident);\n                        incident._onGetContextOnce();\n                    });\n                }\n            };\n\n            for (var i = 0; i < incidents.length; i++) {\n                _loop(i);\n            } // end for each incident\n\n            // if we have conflicts and the type = \"all-or-nothing\"\n            if (conflicts.length > 0 && type === \"all-or-nothing\") {\n                return {\n                    result: false,\n                    errors: conflicts\n                };\n            } else {\n                // as soon as we want all passing additions to get applied the Lanes Handler will create a callback that will be passed to the result.\n                // This callback will apply all passing additions.\n\n                // success message\n                var that = this;\n                var exec = function exec() {\n                    that.LanesHandler.applySandboxChanges(LanesHandlerSandbox);\n                    for (var i = 0; i < onSuccessActions.length; i++) {\n                        onSuccessActions[i]();\n                    }\n\n                    // TODO how exactly are we handling slipping?\n                    for (var _i = 0; _i < affectedLanes.length; _i++) {\n                        var affectedLane = affectedLanes[_i];\n                        that.slipIntoLaneForwards(that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute), affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                };\n\n                return {\n                    result: true,\n                    errors: conflicts,\n                    execute: exec\n                };\n            }\n        }\n\n        /**\n        * It initially checks if the edit is allowed and if it is it retuns an array of executable functions\n        * that apply the change\n        * @param {array} incidents - the list of the lane items to edit in an array format [object, object, ...]\n        * @param {int} millisecondsDelta - the milliseconds delta to apply to the incidents\n        * @returns {object} -\n        * either:\n        {\n           result: true,\n           execute: // array of functions to be executed in order to apply the edit\n        }\n        or\n        {\n            result: false,\n            errors: // an array including all the errors / conflicts found on edit\n        }\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidents, millisecondsDelta) {\n\n            var affectedIncidentIds = [];\n            for (var i = 0; i < incidents.length; i++) {\n                affectedIncidentIds.push(incidents[i].id);\n            }\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n\n            var conflicts = [];\n            var affectedLanes = [];\n\n            // for each of the affectedAnimations\n            for (var _i2 = 0; _i2 < incidents.length; _i2++) {\n                var _incident = incidents[_i2].incident;\n                var incidentId = _incident.id;\n                var _mcid = this.context.getMCID(_incident.element);\n                var _attribute = this.fixedAttributeName;\n                if (this._incidentHasAnimatedAttrs(_incident)) {\n                    _attribute = Object.keys(_incident.attrs.animatedAttrs)[0];\n                }\n                var lane = LanesHandlerSandbox.getLane(_mcid, _attribute);\n                var laneAttrs = {\n                    mcid: _mcid,\n                    attribute: _attribute\n\n                    // check for conflicts and edit lane items millisecond\n                };for (var k = 0; k < lane.length; k++) {\n                    if (lane[k].incident.id === incidentId) {\n                        affectedLanes.push(laneAttrs);\n                        var affectedAnim = lane[k];\n                        var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                        testLaneElement.millisecond += millisecondsDelta;\n                        var _overlappingAnims = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, _mcid, _attribute, affectedIncidentIds);\n\n                        if (_overlappingAnims.length > 0) {\n                            conflicts.push({\n                                type: 'anauthorised, overlapping animations on the same element',\n                                meta: {\n                                    element_mcid: _mcid,\n                                    attribute: _attribute,\n                                    newAnimation: testLaneElement,\n                                    overlappingAnims: _overlappingAnims\n                                }\n                            });\n                        }\n\n                        break;\n                    } // end of if we found the specific animation on the lane's sequence\n                } // end of each lane's item\n\n            } // end for each affected animation's id\n\n            if (conflicts.length > 0) {\n                return {\n                    result: false,\n                    errors: conflicts\n                };\n            } else {\n                var that = this;\n                var exec = function exec() {\n                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n                    // success message\n                    that.LanesHandler.updateLane(affectedIncidentIds, millisecondsDelta);\n\n                    for (var _i3 = 0; _i3 < affectedLanes.length; _i3++) {\n                        var affectedLane = affectedLanes[_i3];\n                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);\n                        that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                };\n                return {\n                    result: true,\n                    execute: exec\n                };\n            }\n        }\n\n        /**\n         * @param {array} affectedAnimations - [{id, start, end, startDelta}]\n         * @param {boolean} fullChannelResize - if set to true then the full html channel is resizing. This is a special case as in\n         *  that case no checks should be actually perfomed nor the projected candidate should be applied directly\n        **/\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(affectedAnimations) {\n            var fullChannelResize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n            var excludeIdsFromCheck = [];\n            for (var i = 0; i < affectedAnimations.length; i++) {\n                excludeIdsFromCheck.push(affectedAnimations[i].id);\n            }\n\n            var LanesHandlerSandbox = this.LanesHandler.createTestLanesSanbox();\n\n            var conflicts = [];\n            var affectedLanes = [];\n\n            // for each of the affectedAnimations\n            for (var _i4 = 0; _i4 < affectedAnimations.length; _i4++) {\n                var belongingLanes = LanesHandlerSandbox.belongingLaneKeysByAnimationId[affectedAnimations[_i4].id];\n                var testDuration = affectedAnimations[_i4].end - affectedAnimations[_i4].start;\n\n                // for each lane the affected Animation appears in\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var lane = LanesHandlerSandbox.lanes[belongingLanes[j]];\n                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n                    // check for conflicts and edit lane items millisecond\n                    for (var k = 0; k < lane.length; k++) {\n                        if (lane[k].incident.id === affectedAnimations[_i4].id) {\n                            affectedLanes.push(laneData);\n                            if (fullChannelResize === false) {\n                                var affectedAnim = lane[k];\n                                var testLaneElement = LanesHandlerSandbox.getLaneElementsClone(affectedAnim);\n                                testLaneElement.millisecond += affectedAnimations[_i4].startDelta;\n                                var _overlappingAnims2 = LanesHandlerSandbox.getOverlappingAnims(testLaneElement, laneData.mcid, laneData.attribute, excludeIdsFromCheck, testDuration);\n\n                                if (_overlappingAnims2.length > 0) {\n                                    conflicts.push({\n                                        type: 'anauthorised overlapping animations on the same element',\n                                        meta: {\n                                            element_mcid: laneData.mcid,\n                                            attribute: laneData.attribute,\n                                            newAnimation: testLaneElement,\n                                            overlappingAnims: _overlappingAnims2\n                                        }\n                                    });\n                                }\n                            }\n\n                            break;\n                        } // end of if we found the specific animation on the lane's sequence\n                    } // end of each lane's item\n\n                } // end of each belonging lane\n            } // end for each affected animation's id\n\n            if (conflicts.length > 0) {\n                return {\n                    result: false,\n                    conflicts: conflicts\n                };\n            } else {\n                // unlike the case of editing the start millisecond of a Scene / Incident on editing the duration of a Scene\n                // or an Incident slipping to lanes should occur depends not only on the positioning of the Animations on\n                // the lanes but also on their duration. Editing the duration occurs on the Scene that received the editDuration\n                // command and thus at that point the HTMLChannel (and its LanesHaldler) is not ready to slip as the affected\n                // Animations still have the old (un-edited) duration.\n                // For this reason and only on the case of duration edit slip to lanes will take place not here and not now\n                // but on the scope of the Scene that got the command, at the point it receives the success ({result:true}).\n                // For this we will create a callback function which holds the slipping to lanes commands and pass it on the\n                // \"callback\" key of the result object ({success:true, callback:function(){that slips into lanes}})\n                var that = this;\n\n                var exec = function exec() {\n                    var slippingCommands = []; // an array that will hold all of the slipping commands in all of the affected lanes\n\n                    // updateLanes (only this time animation by animation as the milliseconds delta is not standard for all)\n                    // as soon as there are no conflicts the Lanes Handler applies the changes before sending over the\n                    // success message\n                    for (var _i5 = 0; _i5 < affectedAnimations.length; _i5++) {\n                        that.LanesHandler.updateLane([affectedAnimations[_i5].id], affectedAnimations[_i5].startDelta);\n                    }\n\n                    var _loop2 = function _loop2(_i6) {\n                        var affectedLane = affectedLanes[_i6];\n                        var theActualLane = that.LanesHandler.getLane(affectedLane.mcid, affectedLane.attribute);\n                        // put the slip command on the slippingCommands array\n                        slippingCommands.push(function () {\n                            that.slipIntoLaneForwards(theActualLane, affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                        });\n                    };\n\n                    for (var _i6 = 0; _i6 < affectedLanes.length; _i6++) {\n                        _loop2(_i6);\n                    }\n\n                    for (var _i7 = 0; _i7 < slippingCommands.length; _i7++) {\n                        slippingCommands[_i7]();\n                    }\n                };\n\n                return {\n                    execute: exec,\n                    result: true\n                };\n            }\n        }\n\n        /**\n         * \n        */\n\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(removedAnimations) {\n            var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            var removedAnimationIds = [];\n            for (var i = 0; i < removedAnimations.length; i++) {\n                removedAnimationIds.push(removedAnimations[i].id);\n            }\n\n            // no slipping is needed as on deletion the Animations set their elements to their initial values\n            var that = this;\n            var exec = function exec() {\n                var affectedLanes = that.LanesHandler.deleteAnimations(removedAnimationIds, that.runTimeInfo.currentMillisecond);\n                for (var laneKey in affectedLanes) {\n                    var _affectedLane = affectedLanes[laneKey];\n                    var _theActualLane = that.LanesHandler.getLane(_affectedLane.mcid, _affectedLane.attribute);\n                    if (props.preventSlip != true) {\n                        that.slipIntoLaneForwards(_theActualLane, _affectedLane, 0, that.runTimeInfo.currentMillisecond);\n                    }\n                }\n            };\n\n            return {\n                result: true,\n                execute: exec\n            };\n        }\n\n        /**\n         * checks if a duration edit is feasible and doesn't cause conflicts\n         * @param {int} duration - the new duration\n         * @param {array} ids - (optional) if provided it only checks resizes on the given ids (not all incidents have been re)\n        **/\n\n    }, {\n        key: 'checkDurationEdit',\n        value: function checkDurationEdit(durationFraction) {\n            var ids = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            // using ProjectionsHanlder it will create the candidates and the projections to pass up to the parent\n            // returned object keys: candidateOwnProjectedAnimations, affectedAnimations\n            var projectedAnimations = this.projectionsHandler.systoleDiastoleProjections(durationFraction, ids);\n            // once it gets the porojectedAnimations from its projections hanlder it will pass it up for check\n\n            // if the ids array is provided that means the checkDurationEdit is been used by an Animation directly\n            // belonging to the html channel, so it's not a full channel resize\n            var check = this.checkResizedAnimations(projectedAnimations.affectedAnimations, ids.length === 0 ? true : false);\n\n            return check;\n        }\n\n        /**\n         * Method that is invoked by Animation objects when one of their attributes value is edited\n         * The purpose of this method here on the HTMLChannel is to update the lanes accordingly and slip into the\n         * corresponding lanes\n         * @param {string} animationId - the id of the Animation object that has been edited\n         * @param {string} attr - the name of the attribute that has been edited\n         * @param {string} value - the new value of the edited attribute\n        */\n\n    }, {\n        key: 'animationAttributeValueChange',\n        value: function animationAttributeValueChange(animationId, attr, value) {\n            var affectedLanes = this.LanesHandler.updateAttributeOnLanes(animationId, attr, value);\n            for (var i = 0; i < affectedLanes.length; i++) {\n                var _affectedLane2 = affectedLanes[i];\n                var _theActualLane2 = this.LanesHandler.getLane(_affectedLane2.mcid, _affectedLane2.attribute);\n                this.slipIntoLaneForwards(_theActualLane2, _affectedLane2, 0, this.runTimeInfo.currentMillisecond);\n            }\n        }\n\n        /**\n         * Slips to just one lane forwards\n         * @param {array} lane - the lane to slip into\n         * @param {object} laneData - an object with keys: attribute & mcid\n         * @param {int} currentMillisecond - the millisecond the slip starts from\n         * @param {int} millisecond - the target millisecond of the slip\n         */\n\n    }, {\n        key: 'slipIntoLaneForwards',\n        value: function slipIntoLaneForwards(lane, laneData, currentMillisecond, millisecond) {\n            // helper.log(lane, currentMillisecond, millisecond);\n            var participatingAnims = _filter(lane, function (laneItem) {\n                return laneItem.millisecond + laneItem.incident.duration >= currentMillisecond && laneItem.millisecond + laneItem.incident.duration <= millisecond || // it ends after currentMillisecond and before target millisecond\n                laneItem.incident.duration + laneItem.millisecond >= millisecond && laneItem.millisecond <= millisecond; // or it ends after the target millisecond but also starts before it\n            });\n\n            if (participatingAnims.length == 0) {\n                return true;\n            }\n\n            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n                return laneItem.millisecond;\n            }]);\n\n            // now we have all participatingAnims of the slip action in chronological order\n            // our first job is to create a variable that will hold the last known value of the lane\n            var lastValue = null;\n            for (var i = 0; i < participatingAnims.length; i++) {\n                var participatingAnim = participatingAnims[i].incident;\n                var startMillisecond = participatingAnims[i].millisecond;\n\n                // if the animation has no start values go ahead and calculated them now\n                if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue === null) {\n                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, 'calculated');\n                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute);\n                } else if (!participatingAnim.hasInitialValue(laneData.attribute) && lastValue != null) {\n                    // helper.log('setting initial value: ', laneData.mcid, laneData.attribute, lastValue);\n                    participatingAnim.setInitialValue(laneData.mcid, laneData.attribute, lastValue);\n                }\n\n                // if the animation ends before the target millisecond\n                // helper.log('participatingAnim.duration + startMillisecond', participatingAnim.duration + startMillisecond, millisecond);\\\n\n                if (participatingAnim.duration + startMillisecond <= millisecond) {\n                    // helper.log('ends before target')\n                    lastValue = participatingAnim.attrs.animatedAttrs[laneData.attribute];\n                    if (i === participatingAnims.length - 1) {\n                        participatingAnim.onProgress(1, participatingAnim.duration);\n                    }\n                } else {\n                    // slip for the specific element and the specific attribute. Set the Animation as paused or playing a\n                    // and store this info somewhere\n                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n                    participatingAnim.onProgress(percentageComplete, millisecond);\n                }\n            }\n        }\n\n        /**\n         * Slips to just one lane backwards\n         * @param {array} lane - the lane to slip into\n         * @param {object} laneData - an object with keys: attribute & mcid\n         * @param {int} currentMillisecond - the millisecond the slip starts from\n         * @parama {int} millisecond - the target millisecond of the slip\n         */\n\n    }, {\n        key: 'slipToLaneBackwards',\n        value: function slipToLaneBackwards(lane, laneData, currentMillisecond, millisecond) {\n            // we take all Animations that are either currently running or\n            // they end after the destination point\n            // helper.log('<------');\n            var participatingAnims = _filter(lane, function (laneItem) {\n                var laneItemEnd = laneItem.incident.duration + laneItem.millisecond;\n                return laneItemEnd <= millisecond && laneItemEnd >= currentMillisecond || // they end in the hot area\n                laneItem.millisecond >= currentMillisecond && laneItem.millisecond <= millisecond || // they start in the hot area\n                laneItem.millisecond < currentMillisecond && laneItemEnd > millisecond; // they overlap the hot area\n            });\n\n            if (participatingAnims.length == 0) {\n                return true;\n            }\n\n            participatingAnims = _sortBy(participatingAnims, [function (laneItem) {\n                return laneItem.millisecond;\n            }]);\n\n            var lastValue = null;\n            for (var i = participatingAnims.length - 1; i >= 0; i--) {\n                var participatingAnim = participatingAnims[i].incident;\n                var startMillisecond = participatingAnims[i].millisecond;\n                if (startMillisecond >= millisecond) {\n                    participatingAnim.onProgress(0, 0);\n                } else {\n                    var percentageComplete = (millisecond - startMillisecond) / participatingAnim.duration;\n\n                    participatingAnim.onProgress(percentageComplete, millisecond);\n                }\n            }\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            // step 1: iterate through all lanes\n            for (var laneid in this.lanes) {\n                var lane = this.lanes[laneid];\n                var laneData = helper.getMCIDandAttrOutOfLaneKey(laneid);\n                if (from < to) {\n                    // helper.log(laneid);\n                    this.slipIntoLaneForwards(lane, laneData, from, to);\n                } else if (from >= to) {\n                    this.slipToLaneBackwards(lane, laneData, from, to);\n                }\n            }\n        }\n    }, {\n        key: 'lanes',\n        get: function get() {\n            return this.LanesHandler.lanes;\n        }\n    }], [{\n        key: 'type',\n        get: function get() {\n            return \"attributes\";\n        }\n    }]);\n\n    return AttributeChannel;\n}(Channel);\n\nmodule.exports = AttributeChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwuanM/ODU1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi9DaGFubmVsJyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleCcpO1xudmFyIF9zb3J0QnkgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleCcpO1xuXG52YXIgbGFuZXNIYW5kbGVyID0gcmVxdWlyZSgnLi9MYW5lc0hhbmRsZXInKTtcblxudmFyIEF0dHJpYnV0ZUNoYW5uZWwgPSBmdW5jdGlvbiAoX0NoYW5uZWwpIHtcbiAgICBfaW5oZXJpdHMoQXR0cmlidXRlQ2hhbm5lbCwgX0NoYW5uZWwpO1xuXG4gICAgZnVuY3Rpb24gQXR0cmlidXRlQ2hhbm5lbChwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlQ2hhbm5lbCk7XG5cbiAgICAgICAgLypcbiAgICAgICAgY29tYm9BdHRyaWJ1dGVzIGFyZSBhdHRyaWJ1dGVzIG9mIHR5cGUgb2JqZWN0LCBob2xkaW5nIGEgbnVtYmVyIG9mIG90aGVyIGF0dHJpYnV0ZXMuXG4gICAgICAgIEUuZy4gQ1NTIFwidHJhbnNmb3JtXCIgYXR0cmlidXRlIGlzIGEgY29tYm8gdGhhdCBob2xkcyBhIG51bWJlciBvZiBvdGhlciBhdHRyaWJ1dGVzIHN1Y2ggYXM6XG4gICAgICAgIHRyYW5zbGF0ZVgsIHRyYW5zbGF0ZVksIGV0Yy4gVGhlIGxhbmVzIGhhbmRsZXIga2VlcHMganVzdCBvbmUgbGFuZSBmb3IgdGhlIGNvbWJvIGF0dHJzIFxuICAgICAgICBpbiBhbiBvYmplY3QgZm9ybWF0IGtlZXBpbmcgdGhlIHZhbHVlIG9mIGVhY2ggYXR0cmlidXRlIGF0IGFueSBnaXZlbiBwb2ludC5cbiAgICAgICAgQ29tYm8gYXR0cmlidXRlcyBhcmUgcGFzc2VkIG9uIHRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgQ2hhbm5lbCBpbiB0aGUgZm9ybWF0OlxuICAgICAgICBwcm9wcy5jb21ib0F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHRyYW5zaXRpb246IFsndHJhbnNsYXRlWCcsICd0cmFuc2xhdGVZJywgLi4uXSxcbiAgICAgICAgICAgIDxzb21ldGhpbmdfZWxzZT46IFsnPGF0dHJOYW1lMT4nLCAnPGF0dHJOYW1lMj4nLCAuLi5dXG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEF0dHJpYnV0ZUNoYW5uZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihBdHRyaWJ1dGVDaGFubmVsKSkuY2FsbCh0aGlzLCBwcm9wcykpO1xuXG4gICAgICAgIF90aGlzLmNvbWJvQXR0cmlidXRlcyA9IHt9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgaW5jaWRlbnRzIHRoYXQgZG8gbm90IGhhdmUgYW5pbWF0ZWRBdHRycyB0aGVyZSBzaG91bGQgYmUgb25seSBvbmUgbGFuZSBwZXIgZWxlbWVudC4gXG4gICAgICAgICAqIFRoZSBhdHRyaWJ1dGVzIENoYW5uZWwgd2lsbCB1c2UgYSBkZWZhdWx0IChmYWtlKSwgZml4ZWQgYXR0cmlidXRlIGZvciB0aGlzIGNhc2VzIHNvIGl0IGFsd2F5cyBlbmRzXG4gICAgICAgICAqIHVwIHdpdGgganVzdCBvbmUgbGFuZSBwZXIgZWxlbWVudDogPGVsZW1lbnRfaWQ+Xzx0aGlzLmZpeGVkQXR0cmlidXRlTmFtZT5cbiAgICAgICAgKi9cbiAgICAgICAgX3RoaXMuZml4ZWRBdHRyaWJ1dGVOYW1lID0gXCJfXCI7XG5cbiAgICAgICAgaWYgKHByb3BzLmNvbWJvQXR0cmlidXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5jb21ib0F0dHJpYnV0ZXMgPSBwcm9wcy5jb21ib0F0dHJpYnV0ZXM7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpcy5MYW5lc0hhbmRsZXIgPSBuZXcgbGFuZXNIYW5kbGVyKHsgY29tYm9BdHRyaWJ1dGVzOiBfdGhpcy5jb21ib0F0dHJpYnV0ZXMgfSk7XG4gICAgICAgIC8vIHRoaXMudHlwZSA9IFwiYXR0cmlidXRlc1wiO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEF0dHJpYnV0ZUNoYW5uZWwsIFt7XG4gICAgICAgIGtleTogJ3NldENvbWJvQXR0cmlidXRlcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21ib0F0dHJpYnV0ZXMoY29tYm9BdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbWJvQXR0cmlidXRlcyA9IGNvbWJvQXR0cmlidXRlcztcbiAgICAgICAgICAgIHRoaXMuTGFuZXNIYW5kbGVyID0gbmV3IGxhbmVzSGFuZGxlcih7IGNvbWJvQXR0cmlidXRlczogdGhpcy5jb21ib0F0dHJpYnV0ZXMgfSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19yZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLkxhbmVzSGFuZGxlci5fcmVzaXplKGR1cmF0aW9uRnJhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBpbmNpZGVudCBoYXMgYW5pbWF0ZWRBdHRycyBvciBub3QuIFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGluY2lkZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5jaWRlbnQuYXR0cnMuaGFzT3duUHJvcGVydHkoJ2FuaW1hdGVkQXR0cnMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgREVDSVNJT04gTUVUSE9EU1xuICAgICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBvZiB0aGUgaW5jaWRlbnRzIGNvbWluZyB0byB0aGlzIG1ldGhvZCBhcmUgZWxlbWVudC1hdHRyaWJ1dGUgaW5jaWRlbnRzIG1lYW5pbmcgdGhhdCB0aGV5IG9ubHlcbiAgICAgICAgICogdGFyZ2V0IGp1c3Qgb25lIGVsZW1lbnQgYW5kIGFsc28gdGhleSBpbmNsdWRlIGp1c3QgYSBzaW5nbGUgYXR0cmlidXRlIG9uIHRoZSBpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzXG4gICAgICAgICAqIG9iamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHMgLSBBIGNvbGxlY3Rpb24gb2YgSW5jaWRlbnRzIGluIHRoZSBmb3JtOlxuICAgICAgICAgKiB7XG4gICAgICAgICAqICBtaWxsaXNlY29uZFxuICAgICAgICAgKiAgaW5jaWRlbnRcbiAgICAgICAgICogIGlkXG4gICAgICAgICAqIH1cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBjYW4gYmUgZWl0aGVyIFwiYWxsLW9yLW5vdGhpbmdcIiAoZGVmYXVsdCkgb3IgXCJrZWVwLXBhc3NpbmdcIi4gSWYgdHlwZSA9IFwiYWxsLW9yLW5vdGhpbmdcIlxuICAgICAgICAgKiAgdGhlIGFkZGl0aW9uIHBhc3NlcyBvbmx5IGlmIGFsbCBpbmNpZGVudHMgcGFzcy4gSWYgdHlwZSA9IFwia2VlcC1wYXNzaW5nXCIgdGhlIG1ldGhvZCB3aWxsIHN0aWxsIHJldHVybiB0cnVlXG4gICAgICAgICAqICBidXQgd2lsbCBhbHNvIGluY2x1ZGUgYW4gZXJyb3JzIGFycmF5IG9uIGl0cyByZXR1cm4gYW5kIGFsc28gd2lsbCBvbmx5IGluY2x1ZGUgdGhlIHN1Y2Nlc3MgY2FsbGJhY2tzIG9uIFxuICAgICAgICAgKiAgdGhlIGV4ZWN1dGUga2V5IG9mIGl0cyByZXR1cm5cbiAgICAgICAgICogQHJldHVybnMgZWl0aGVyOlxuICAgICAgICAgKiAgIHtcbiAgICAgICAgICogICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAqICAgICAgIGV4ZWN1dGU6IC8vIGFuIGFycmF5IG9mIGZ1bmN0aW9ucyB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICogICB9XG4gICAgICAgICAqICAgb3JcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAqICAgICAgIGVycm9yc1xuICAgICAgICAgKiAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImFsbC1vci1ub3RoaW5nXCI7XG5cbiAgICAgICAgICAgIHZhciBMYW5lc0hhbmRsZXJTYW5kYm94ID0gdGhpcy5MYW5lc0hhbmRsZXIuY3JlYXRlVGVzdExhbmVzU2FuYm94KCk7XG4gICAgICAgICAgICAvKiBhbiBhcnJheSB3aGVyZSB3ZSBrZWVwIGFsbCBhZmZlY3RlZCBsYW5lcyBzbyB3ZSBjYW4gc2xpcCBvbiB0aGVtIGF0IHRoZSBlbmQuIFxuICAgICAgICAgICAgVGhlIGZvcm1hdCBmb3IgZWFjaCBhZmZlY3RlZCBsYW5lIHdlIGtlZXAgaXM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWNpZDogbWNpZCxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGF0dHJpYnV0ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmVzID0gW107XG5cbiAgICAgICAgICAgIC8vIHdoaWxlIHRoZSBMYW5lc0hhbmRsZXJTYW5ib3ggYWRkcyBsYW5lIGl0ZW1zIGl0IG1ha2VzIGRlY2lzaW9ucyBvZiB3aGljaCBwZXJtYW5lbnQgY2hhbmdlcyBzaG91bGQgYmUgbWFkZSB0b1xuICAgICAgICAgICAgLy8gdGhlIHBlcm1hbmVudCBhbmQgcHJlLWV4aXN0aW5nIG9iamVjdHMgaXQgaGFuZGxlcywgc3VjaCBhcyBjaGFuZ2VzIG9uIHRoZSBpbml0aWFsIHZhbHVlcyBvZiBleGlzdGluZyBhbmltYXRpb25zLlxuICAgICAgICAgICAgLy8gQmVjYXVzZSBvZiB0aGUgZmFjdCB0aGUgTGFuZXNTYW5kYm94SGFuZGxlciBpcyBvbmx5IHRoZXJlIGZvciB0ZXN0aW5nIHdlIGRvbid0IHdhbnQgdG8gZXhlY3V0ZSB0aGVzZSBjaGFuZ2VzXG4gICAgICAgICAgICAvLyBkdXJpbmcgY2hlY2tzIGJ1dCBzdGlsbCB3ZSBuZWVkIHRvIGtub3cgdGhlbSBvbiBzdWNjZXNzLiBGb3IgdGhpcywgdGhlIG9uU3VjY2Vzc0FjdGlvbnMgYXJyYXkgaG9sZHMgYWxsIGV4ZWN1dGFibGVcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9ucyByZXR1cmVkIGJ5IHZhcmlvdXMgTGFuZXNIYW5kbGVyU2FuYm94IGZ1bmN0aW9ucyBzbyBpdCBjYW4gZXhlY3V0ZSB0aGVtIG9uIHN1Y2Nlc3MuXG4gICAgICAgICAgICB2YXIgb25TdWNjZXNzQWN0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgY29uZmxpY3RzID0gW107XG5cbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5jaWRlbnRDb25mbGljdHMgPSBmYWxzZTsgLy8gYSBib29sZWFuIHRoYXQga2VlcHMgdGhlIGluZm9ybWF0aW9uIHdoZXRoZXIgdGhlIGluY2lkZW50IGNvbmZsaWN0cyBvciBub3RcbiAgICAgICAgICAgICAgICB2YXIgbGFuZUl0ZW0gPSBpbmNpZGVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50ID0gbGFuZUl0ZW0uaW5jaWRlbnQ7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWNpZCA9IF90aGlzMi5jb250ZXh0LmdldE1DSUQoaW5jaWRlbnQuZWxlbWVudCk7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcInRoZSBpbmNpZGVudFwiLGluY2lkZW50KVxuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBfdGhpczIuZml4ZWRBdHRyaWJ1dGVOYW1lO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpczIuX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycyhpbmNpZGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlID0gT2JqZWN0LmtleXMoaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRycylbMF07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgTGFuZXNIYW5kbGVyU2FuZGJveC5sYW5lRXhpc3RzKG1jaWQsIGF0dHJpYnV0ZSwgdHJ1ZSk7IC8vIGNyZWF0ZSB0aGUgbGFuZSBpZiBpdCBkb2Vzbid0IGV4aXN0IGFscmVhZHlcblxuICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1jaWQ6IG1jaWQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTGFuZXNIYW5kbGVyU2FuZGJveC5hbmltYXRpb25JREV4aXN0cyhtY2lkLCBhdHRyaWJ1dGUsIGluY2lkZW50LmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudENvbmZsaWN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkdXBsaWNhdGUgQW5pbWF0aW9uIGlkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaW5jaWRlbnQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gKioqKiBpZiB0aGUgbGFuZSBkaWQgZXhpc3QgYmVmb3JlIHRoZSBuZXcgYWRkaXRpb24gY2hlY2sgZm9yIGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIHZhciBvdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKGxhbmVJdGVtLCBtY2lkLCBhdHRyaWJ1dGUpO1xuXG4gICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhvdmVybGFwcGluZ0FuaW0pXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBwaW5nQW5pbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudENvbmZsaWN0cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICd1bmF1dGhvcmlzZWQsIG92ZXJsYXBwaW5nIGluY2lkZW50cyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IG1jaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBhdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGxhbmVJdGVtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBwaW5nQW5pbXM6IG92ZXJsYXBwaW5nQW5pbXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpbmNpZGVudENvbmZsaWN0cykge1xuICAgICAgICAgICAgICAgICAgICBvblN1Y2Nlc3NBY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgTGFuZXNIYW5kbGVyU2FuZGJveC5hZGRFbGVtZW50VG9MYW5lKG1jaWQsIGF0dHJpYnV0ZSwgbGFuZUl0ZW0ubWlsbGlzZWNvbmQsIGluY2lkZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2lkZW50Ll9vbkdldENvbnRleHRPbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBpbmNpZGVudFxuXG4gICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGNvbmZsaWN0cyBhbmQgdGhlIHR5cGUgPSBcImFsbC1vci1ub3RoaW5nXCJcbiAgICAgICAgICAgIGlmIChjb25mbGljdHMubGVuZ3RoID4gMCAmJiB0eXBlID09PSBcImFsbC1vci1ub3RoaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgd2Ugd2FudCBhbGwgcGFzc2luZyBhZGRpdGlvbnMgdG8gZ2V0IGFwcGxpZWQgdGhlIExhbmVzIEhhbmRsZXIgd2lsbCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSByZXN1bHQuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBjYWxsYmFjayB3aWxsIGFwcGx5IGFsbCBwYXNzaW5nIGFkZGl0aW9ucy5cblxuICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuTGFuZXNIYW5kbGVyLmFwcGx5U2FuZGJveENoYW5nZXMoTGFuZXNIYW5kbGVyU2FuZGJveCk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb25TdWNjZXNzQWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzQWN0aW9uc1tpXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBob3cgZXhhY3RseSBhcmUgd2UgaGFuZGxpbmcgc2xpcHBpbmc/XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhZmZlY3RlZExhbmVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zbGlwSW50b0xhbmVGb3J3YXJkcyh0aGF0LkxhbmVzSGFuZGxlci5nZXRMYW5lKGFmZmVjdGVkTGFuZS5tY2lkLCBhZmZlY3RlZExhbmUuYXR0cmlidXRlKSwgYWZmZWN0ZWRMYW5lLCAwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0cyxcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZTogZXhlY1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgKiBJdCBpbml0aWFsbHkgY2hlY2tzIGlmIHRoZSBlZGl0IGlzIGFsbG93ZWQgYW5kIGlmIGl0IGlzIGl0IHJldHVucyBhbiBhcnJheSBvZiBleGVjdXRhYmxlIGZ1bmN0aW9uc1xuICAgICAgICAqIHRoYXQgYXBwbHkgdGhlIGNoYW5nZVxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIHRoZSBsaXN0IG9mIHRoZSBsYW5lIGl0ZW1zIHRvIGVkaXQgaW4gYW4gYXJyYXkgZm9ybWF0IFtvYmplY3QsIG9iamVjdCwgLi4uXVxuICAgICAgICAqIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YSAtIHRoZSBtaWxsaXNlY29uZHMgZGVsdGEgdG8gYXBwbHkgdG8gdGhlIGluY2lkZW50c1xuICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC1cbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgIHtcbiAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICBleGVjdXRlOiAvLyBhcnJheSBvZiBmdW5jdGlvbnMgdG8gYmUgZXhlY3V0ZWQgaW4gb3JkZXIgdG8gYXBwbHkgdGhlIGVkaXRcbiAgICAgICAgfVxuICAgICAgICBvclxuICAgICAgICB7XG4gICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3JzOiAvLyBhbiBhcnJheSBpbmNsdWRpbmcgYWxsIHRoZSBlcnJvcnMgLyBjb25mbGljdHMgZm91bmQgb24gZWRpdFxuICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnRzLCBtaWxsaXNlY29uZHNEZWx0YSkge1xuXG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRJbmNpZGVudElkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIExhbmVzSGFuZGxlclNhbmRib3ggPSB0aGlzLkxhbmVzSGFuZGxlci5jcmVhdGVUZXN0TGFuZXNTYW5ib3goKTtcblxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkQW5pbWF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jaWRlbnRzLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgX2luY2lkZW50ID0gaW5jaWRlbnRzW19pMl0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50SWQgPSBfaW5jaWRlbnQuaWQ7XG4gICAgICAgICAgICAgICAgdmFyIF9tY2lkID0gdGhpcy5jb250ZXh0LmdldE1DSUQoX2luY2lkZW50LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBfYXR0cmlidXRlID0gdGhpcy5maXhlZEF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycyhfaW5jaWRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hdHRyaWJ1dGUgPSBPYmplY3Qua2V5cyhfaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRycylbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsYW5lID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lKF9tY2lkLCBfYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZUF0dHJzID0ge1xuICAgICAgICAgICAgICAgICAgICBtY2lkOiBfbWNpZCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBfYXR0cmlidXRlXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNvbmZsaWN0cyBhbmQgZWRpdCBsYW5lIGl0ZW1zIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgfTtmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVba10uaW5jaWRlbnQuaWQgPT09IGluY2lkZW50SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXMucHVzaChsYW5lQXR0cnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFmZmVjdGVkQW5pbSA9IGxhbmVba107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdExhbmVFbGVtZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lRWxlbWVudHNDbG9uZShhZmZlY3RlZEFuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdExhbmVFbGVtZW50Lm1pbGxpc2Vjb25kICs9IG1pbGxpc2Vjb25kc0RlbHRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vdmVybGFwcGluZ0FuaW1zID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRPdmVybGFwcGluZ0FuaW1zKHRlc3RMYW5lRWxlbWVudCwgX21jaWQsIF9hdHRyaWJ1dGUsIGFmZmVjdGVkSW5jaWRlbnRJZHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX292ZXJsYXBwaW5nQW5pbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2FuYXV0aG9yaXNlZCwgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvbiB0aGUgc2FtZSBlbGVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudF9tY2lkOiBfbWNpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogX2F0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FuaW1hdGlvbjogdGVzdExhbmVFbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBbmltczogX292ZXJsYXBwaW5nQW5pbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgaWYgd2UgZm91bmQgdGhlIHNwZWNpZmljIGFuaW1hdGlvbiBvbiB0aGUgbGFuZSdzIHNlcXVlbmNlXG4gICAgICAgICAgICAgICAgfSAvLyBlbmQgb2YgZWFjaCBsYW5lJ3MgaXRlbVxuXG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBhZmZlY3RlZCBhbmltYXRpb24ncyBpZFxuXG4gICAgICAgICAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgdGhlcmUgYXJlIG5vIGNvbmZsaWN0cyB0aGUgTGFuZXMgSGFuZGxlciBhcHBsaWVzIHRoZSBjaGFuZ2VzIGJlZm9yZSBzZW5kaW5nIG92ZXIgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3MgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci51cGRhdGVMYW5lKGFmZmVjdGVkSW5jaWRlbnRJZHMsIG1pbGxpc2Vjb25kc0RlbHRhKTtcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBhZmZlY3RlZExhbmVzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmUgPSBhZmZlY3RlZExhbmVzW19pM107XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQWN0dWFsTGFuZSA9IHRoYXQuTGFuZXNIYW5kbGVyLmdldExhbmUoYWZmZWN0ZWRMYW5lLm1jaWQsIGFmZmVjdGVkTGFuZS5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zbGlwSW50b0xhbmVGb3J3YXJkcyh0aGVBY3R1YWxMYW5lLCBhZmZlY3RlZExhbmUsIDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlOiBleGVjXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBhZmZlY3RlZEFuaW1hdGlvbnMgLSBbe2lkLCBzdGFydCwgZW5kLCBzdGFydERlbHRhfV1cbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBmdWxsQ2hhbm5lbFJlc2l6ZSAtIGlmIHNldCB0byB0cnVlIHRoZW4gdGhlIGZ1bGwgaHRtbCBjaGFubmVsIGlzIHJlc2l6aW5nLiBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIGFzIGluXG4gICAgICAgICAqICB0aGF0IGNhc2Ugbm8gY2hlY2tzIHNob3VsZCBiZSBhY3R1YWxseSBwZXJmb21lZCBub3IgdGhlIHByb2plY3RlZCBjYW5kaWRhdGUgc2hvdWxkIGJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrUmVzaXplZEluY2lkZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Jlc2l6ZWRJbmNpZGVudHMoYWZmZWN0ZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZnVsbENoYW5uZWxSZXNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgZXhjbHVkZUlkc0Zyb21DaGVjayA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZEFuaW1hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBleGNsdWRlSWRzRnJvbUNoZWNrLnB1c2goYWZmZWN0ZWRBbmltYXRpb25zW2ldLmlkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIExhbmVzSGFuZGxlclNhbmRib3ggPSB0aGlzLkxhbmVzSGFuZGxlci5jcmVhdGVUZXN0TGFuZXNTYW5ib3goKTtcblxuICAgICAgICAgICAgdmFyIGNvbmZsaWN0cyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSBbXTtcblxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIGFmZmVjdGVkQW5pbWF0aW9uc1xuICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgYWZmZWN0ZWRBbmltYXRpb25zLmxlbmd0aDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVsb25naW5nTGFuZXMgPSBMYW5lc0hhbmRsZXJTYW5kYm94LmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZFthZmZlY3RlZEFuaW1hdGlvbnNbX2k0XS5pZF07XG4gICAgICAgICAgICAgICAgdmFyIHRlc3REdXJhdGlvbiA9IGFmZmVjdGVkQW5pbWF0aW9uc1tfaTRdLmVuZCAtIGFmZmVjdGVkQW5pbWF0aW9uc1tfaTRdLnN0YXJ0O1xuXG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggbGFuZSB0aGUgYWZmZWN0ZWQgQW5pbWF0aW9uIGFwcGVhcnMgaW5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJlbG9uZ2luZ0xhbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW5lID0gTGFuZXNIYW5kbGVyU2FuZGJveC5sYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW5lRGF0YSA9IGhlbHBlci5nZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tqXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGNvbmZsaWN0cyBhbmQgZWRpdCBsYW5lIGl0ZW1zIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgbGFuZS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVba10uaW5jaWRlbnQuaWQgPT09IGFmZmVjdGVkQW5pbWF0aW9uc1tfaTRdLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lcy5wdXNoKGxhbmVEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVsbENoYW5uZWxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZEFuaW0gPSBsYW5lW2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdExhbmVFbGVtZW50ID0gTGFuZXNIYW5kbGVyU2FuZGJveC5nZXRMYW5lRWxlbWVudHNDbG9uZShhZmZlY3RlZEFuaW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0TGFuZUVsZW1lbnQubWlsbGlzZWNvbmQgKz0gYWZmZWN0ZWRBbmltYXRpb25zW19pNF0uc3RhcnREZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9vdmVybGFwcGluZ0FuaW1zMiA9IExhbmVzSGFuZGxlclNhbmRib3guZ2V0T3ZlcmxhcHBpbmdBbmltcyh0ZXN0TGFuZUVsZW1lbnQsIGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgZXhjbHVkZUlkc0Zyb21DaGVjaywgdGVzdER1cmF0aW9uKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX292ZXJsYXBwaW5nQW5pbXMyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYW5hdXRob3Jpc2VkIG92ZXJsYXBwaW5nIGFuaW1hdGlvbnMgb24gdGhlIHNhbWUgZWxlbWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50X21jaWQ6IGxhbmVEYXRhLm1jaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogbGFuZURhdGEuYXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdBbmltYXRpb246IHRlc3RMYW5lRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcHBpbmdBbmltczogX292ZXJsYXBwaW5nQW5pbXMyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZW5kIG9mIGlmIHdlIGZvdW5kIHRoZSBzcGVjaWZpYyBhbmltYXRpb24gb24gdGhlIGxhbmUncyBzZXF1ZW5jZVxuICAgICAgICAgICAgICAgICAgICB9IC8vIGVuZCBvZiBlYWNoIGxhbmUncyBpdGVtXG5cbiAgICAgICAgICAgICAgICB9IC8vIGVuZCBvZiBlYWNoIGJlbG9uZ2luZyBsYW5lXG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBhZmZlY3RlZCBhbmltYXRpb24ncyBpZFxuXG4gICAgICAgICAgICBpZiAoY29uZmxpY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjb25mbGljdHM6IGNvbmZsaWN0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVubGlrZSB0aGUgY2FzZSBvZiBlZGl0aW5nIHRoZSBzdGFydCBtaWxsaXNlY29uZCBvZiBhIFNjZW5lIC8gSW5jaWRlbnQgb24gZWRpdGluZyB0aGUgZHVyYXRpb24gb2YgYSBTY2VuZVxuICAgICAgICAgICAgICAgIC8vIG9yIGFuIEluY2lkZW50IHNsaXBwaW5nIHRvIGxhbmVzIHNob3VsZCBvY2N1ciBkZXBlbmRzIG5vdCBvbmx5IG9uIHRoZSBwb3NpdGlvbmluZyBvZiB0aGUgQW5pbWF0aW9ucyBvblxuICAgICAgICAgICAgICAgIC8vIHRoZSBsYW5lcyBidXQgYWxzbyBvbiB0aGVpciBkdXJhdGlvbi4gRWRpdGluZyB0aGUgZHVyYXRpb24gb2NjdXJzIG9uIHRoZSBTY2VuZSB0aGF0IHJlY2VpdmVkIHRoZSBlZGl0RHVyYXRpb25cbiAgICAgICAgICAgICAgICAvLyBjb21tYW5kIGFuZCB0aHVzIGF0IHRoYXQgcG9pbnQgdGhlIEhUTUxDaGFubmVsIChhbmQgaXRzIExhbmVzSGFsZGxlcikgaXMgbm90IHJlYWR5IHRvIHNsaXAgYXMgdGhlIGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgLy8gQW5pbWF0aW9ucyBzdGlsbCBoYXZlIHRoZSBvbGQgKHVuLWVkaXRlZCkgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgcmVhc29uIGFuZCBvbmx5IG9uIHRoZSBjYXNlIG9mIGR1cmF0aW9uIGVkaXQgc2xpcCB0byBsYW5lcyB3aWxsIHRha2UgcGxhY2Ugbm90IGhlcmUgYW5kIG5vdCBub3dcbiAgICAgICAgICAgICAgICAvLyBidXQgb24gdGhlIHNjb3BlIG9mIHRoZSBTY2VuZSB0aGF0IGdvdCB0aGUgY29tbWFuZCwgYXQgdGhlIHBvaW50IGl0IHJlY2VpdmVzIHRoZSBzdWNjZXNzICh7cmVzdWx0OnRydWV9KS5cbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhpcyB3ZSB3aWxsIGNyZWF0ZSBhIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGhvbGRzIHRoZSBzbGlwcGluZyB0byBsYW5lcyBjb21tYW5kcyBhbmQgcGFzcyBpdCBvbiB0aGVcbiAgICAgICAgICAgICAgICAvLyBcImNhbGxiYWNrXCIga2V5IG9mIHRoZSByZXN1bHQgb2JqZWN0ICh7c3VjY2Vzczp0cnVlLCBjYWxsYmFjazpmdW5jdGlvbigpe3RoYXQgc2xpcHMgaW50byBsYW5lc319KVxuICAgICAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgICAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNsaXBwaW5nQ29tbWFuZHMgPSBbXTsgLy8gYW4gYXJyYXkgdGhhdCB3aWxsIGhvbGQgYWxsIG9mIHRoZSBzbGlwcGluZyBjb21tYW5kcyBpbiBhbGwgb2YgdGhlIGFmZmVjdGVkIGxhbmVzXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlTGFuZXMgKG9ubHkgdGhpcyB0aW1lIGFuaW1hdGlvbiBieSBhbmltYXRpb24gYXMgdGhlIG1pbGxpc2Vjb25kcyBkZWx0YSBpcyBub3Qgc3RhbmRhcmQgZm9yIGFsbClcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgc29vbiBhcyB0aGVyZSBhcmUgbm8gY29uZmxpY3RzIHRoZSBMYW5lcyBIYW5kbGVyIGFwcGxpZXMgdGhlIGNoYW5nZXMgYmVmb3JlIHNlbmRpbmcgb3ZlciB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2VzcyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNSA9IDA7IF9pNSA8IGFmZmVjdGVkQW5pbWF0aW9ucy5sZW5ndGg7IF9pNSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LkxhbmVzSGFuZGxlci51cGRhdGVMYW5lKFthZmZlY3RlZEFuaW1hdGlvbnNbX2k1XS5pZF0sIGFmZmVjdGVkQW5pbWF0aW9uc1tfaTVdLnN0YXJ0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihfaTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmUgPSBhZmZlY3RlZExhbmVzW19pNl07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGhlQWN0dWFsTGFuZSA9IHRoYXQuTGFuZXNIYW5kbGVyLmdldExhbmUoYWZmZWN0ZWRMYW5lLm1jaWQsIGFmZmVjdGVkTGFuZS5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHV0IHRoZSBzbGlwIGNvbW1hbmQgb24gdGhlIHNsaXBwaW5nQ29tbWFuZHMgYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaXBwaW5nQ29tbWFuZHMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zbGlwSW50b0xhbmVGb3J3YXJkcyh0aGVBY3R1YWxMYW5lLCBhZmZlY3RlZExhbmUsIDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pNiA9IDA7IF9pNiA8IGFmZmVjdGVkTGFuZXMubGVuZ3RoOyBfaTYrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2xvb3AyKF9pNik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTcgPSAwOyBfaTcgPCBzbGlwcGluZ0NvbW1hbmRzLmxlbmd0aDsgX2k3KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaXBwaW5nQ29tbWFuZHNbX2k3XSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGU6IGV4ZWMsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRGVsZXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRGVsZXRlKHJlbW92ZWRBbmltYXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgICAgICAgICB2YXIgcmVtb3ZlZEFuaW1hdGlvbklkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlbW92ZWRBbmltYXRpb25JZHMucHVzaChyZW1vdmVkQW5pbWF0aW9uc1tpXS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5vIHNsaXBwaW5nIGlzIG5lZWRlZCBhcyBvbiBkZWxldGlvbiB0aGUgQW5pbWF0aW9ucyBzZXQgdGhlaXIgZWxlbWVudHMgdG8gdGhlaXIgaW5pdGlhbCB2YWx1ZXNcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IHRoYXQuTGFuZXNIYW5kbGVyLmRlbGV0ZUFuaW1hdGlvbnMocmVtb3ZlZEFuaW1hdGlvbklkcywgdGhhdC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxhbmVLZXkgaW4gYWZmZWN0ZWRMYW5lcykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2FmZmVjdGVkTGFuZSA9IGFmZmVjdGVkTGFuZXNbbGFuZUtleV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBfdGhlQWN0dWFsTGFuZSA9IHRoYXQuTGFuZXNIYW5kbGVyLmdldExhbmUoX2FmZmVjdGVkTGFuZS5tY2lkLCBfYWZmZWN0ZWRMYW5lLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wcy5wcmV2ZW50U2xpcCAhPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNsaXBJbnRvTGFuZUZvcndhcmRzKF90aGVBY3R1YWxMYW5lLCBfYWZmZWN0ZWRMYW5lLCAwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGVjdXRlOiBleGVjXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrcyBpZiBhIGR1cmF0aW9uIGVkaXQgaXMgZmVhc2libGUgYW5kIGRvZXNuJ3QgY2F1c2UgY29uZmxpY3RzXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBkdXJhdGlvbiAtIHRoZSBuZXcgZHVyYXRpb25cbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gaWRzIC0gKG9wdGlvbmFsKSBpZiBwcm92aWRlZCBpdCBvbmx5IGNoZWNrcyByZXNpemVzIG9uIHRoZSBnaXZlbiBpZHMgKG5vdCBhbGwgaW5jaWRlbnRzIGhhdmUgYmVlbiByZSlcbiAgICAgICAgKiovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRHVyYXRpb25FZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRHVyYXRpb25FZGl0KGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBpZHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuXG4gICAgICAgICAgICAvLyB1c2luZyBQcm9qZWN0aW9uc0hhbmxkZXIgaXQgd2lsbCBjcmVhdGUgdGhlIGNhbmRpZGF0ZXMgYW5kIHRoZSBwcm9qZWN0aW9ucyB0byBwYXNzIHVwIHRvIHRoZSBwYXJlbnRcbiAgICAgICAgICAgIC8vIHJldHVybmVkIG9iamVjdCBrZXlzOiBjYW5kaWRhdGVPd25Qcm9qZWN0ZWRBbmltYXRpb25zLCBhZmZlY3RlZEFuaW1hdGlvbnNcbiAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRBbmltYXRpb25zID0gdGhpcy5wcm9qZWN0aW9uc0hhbmRsZXIuc3lzdG9sZURpYXN0b2xlUHJvamVjdGlvbnMoZHVyYXRpb25GcmFjdGlvbiwgaWRzKTtcbiAgICAgICAgICAgIC8vIG9uY2UgaXQgZ2V0cyB0aGUgcG9yb2plY3RlZEFuaW1hdGlvbnMgZnJvbSBpdHMgcHJvamVjdGlvbnMgaGFubGRlciBpdCB3aWxsIHBhc3MgaXQgdXAgZm9yIGNoZWNrXG5cbiAgICAgICAgICAgIC8vIGlmIHRoZSBpZHMgYXJyYXkgaXMgcHJvdmlkZWQgdGhhdCBtZWFucyB0aGUgY2hlY2tEdXJhdGlvbkVkaXQgaXMgYmVlbiB1c2VkIGJ5IGFuIEFuaW1hdGlvbiBkaXJlY3RseVxuICAgICAgICAgICAgLy8gYmVsb25naW5nIHRvIHRoZSBodG1sIGNoYW5uZWwsIHNvIGl0J3Mgbm90IGEgZnVsbCBjaGFubmVsIHJlc2l6ZVxuICAgICAgICAgICAgdmFyIGNoZWNrID0gdGhpcy5jaGVja1Jlc2l6ZWRBbmltYXRpb25zKHByb2plY3RlZEFuaW1hdGlvbnMuYWZmZWN0ZWRBbmltYXRpb25zLCBpZHMubGVuZ3RoID09PSAwID8gdHJ1ZSA6IGZhbHNlKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0aGF0IGlzIGludm9rZWQgYnkgQW5pbWF0aW9uIG9iamVjdHMgd2hlbiBvbmUgb2YgdGhlaXIgYXR0cmlidXRlcyB2YWx1ZSBpcyBlZGl0ZWRcbiAgICAgICAgICogVGhlIHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaGVyZSBvbiB0aGUgSFRNTENoYW5uZWwgaXMgdG8gdXBkYXRlIHRoZSBsYW5lcyBhY2NvcmRpbmdseSBhbmQgc2xpcCBpbnRvIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIGxhbmVzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25JZCAtIHRoZSBpZCBvZiB0aGUgQW5pbWF0aW9uIG9iamVjdCB0aGF0IGhhcyBiZWVuIGVkaXRlZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciAtIHRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgdGhhdCBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdGhlIG5ldyB2YWx1ZSBvZiB0aGUgZWRpdGVkIGF0dHJpYnV0ZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhbmltYXRpb25BdHRyaWJ1dGVWYWx1ZUNoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRpb25BdHRyaWJ1dGVWYWx1ZUNoYW5nZShhbmltYXRpb25JZCwgYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmVzID0gdGhpcy5MYW5lc0hhbmRsZXIudXBkYXRlQXR0cmlidXRlT25MYW5lcyhhbmltYXRpb25JZCwgYXR0ciwgdmFsdWUpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZExhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hZmZlY3RlZExhbmUyID0gYWZmZWN0ZWRMYW5lc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgX3RoZUFjdHVhbExhbmUyID0gdGhpcy5MYW5lc0hhbmRsZXIuZ2V0TGFuZShfYWZmZWN0ZWRMYW5lMi5tY2lkLCBfYWZmZWN0ZWRMYW5lMi5hdHRyaWJ1dGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpcEludG9MYW5lRm9yd2FyZHMoX3RoZUFjdHVhbExhbmUyLCBfYWZmZWN0ZWRMYW5lMiwgMCwgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNsaXBzIHRvIGp1c3Qgb25lIGxhbmUgZm9yd2FyZHNcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gbGFuZSAtIHRoZSBsYW5lIHRvIHNsaXAgaW50b1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbGFuZURhdGEgLSBhbiBvYmplY3Qgd2l0aCBrZXlzOiBhdHRyaWJ1dGUgJiBtY2lkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBjdXJyZW50TWlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdGhlIHNsaXAgc3RhcnRzIGZyb21cbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kIC0gdGhlIHRhcmdldCBtaWxsaXNlY29uZCBvZiB0aGUgc2xpcFxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xpcEludG9MYW5lRm9yd2FyZHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2xpcEludG9MYW5lRm9yd2FyZHMobGFuZSwgbGFuZURhdGEsIGN1cnJlbnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2cobGFuZSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW1zID0gX2ZpbHRlcihsYW5lLCBmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyBsYW5lSXRlbS5pbmNpZGVudC5kdXJhdGlvbiA+PSBjdXJyZW50TWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgKyBsYW5lSXRlbS5pbmNpZGVudC5kdXJhdGlvbiA8PSBtaWxsaXNlY29uZCB8fCAvLyBpdCBlbmRzIGFmdGVyIGN1cnJlbnRNaWxsaXNlY29uZCBhbmQgYmVmb3JlIHRhcmdldCBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGxhbmVJdGVtLmluY2lkZW50LmR1cmF0aW9uICsgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPj0gbWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW0ubWlsbGlzZWNvbmQgPD0gbWlsbGlzZWNvbmQ7IC8vIG9yIGl0IGVuZHMgYWZ0ZXIgdGhlIHRhcmdldCBtaWxsaXNlY29uZCBidXQgYWxzbyBzdGFydHMgYmVmb3JlIGl0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbXMgPSBfc29ydEJ5KHBhcnRpY2lwYXRpbmdBbmltcywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgLy8gbm93IHdlIGhhdmUgYWxsIHBhcnRpY2lwYXRpbmdBbmltcyBvZiB0aGUgc2xpcCBhY3Rpb24gaW4gY2hyb25vbG9naWNhbCBvcmRlclxuICAgICAgICAgICAgLy8gb3VyIGZpcnN0IGpvYiBpcyB0byBjcmVhdGUgYSB2YXJpYWJsZSB0aGF0IHdpbGwgaG9sZCB0aGUgbGFzdCBrbm93biB2YWx1ZSBvZiB0aGUgbGFuZVxuICAgICAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRpY2lwYXRpbmdBbmltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0aWNpcGF0aW5nQW5pbSA9IHBhcnRpY2lwYXRpbmdBbmltc1tpXS5pbmNpZGVudDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRNaWxsaXNlY29uZCA9IHBhcnRpY2lwYXRpbmdBbmltc1tpXS5taWxsaXNlY29uZDtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaGFzIG5vIHN0YXJ0IHZhbHVlcyBnbyBhaGVhZCBhbmQgY2FsY3VsYXRlZCB0aGVtIG5vd1xuICAgICAgICAgICAgICAgIGlmICghcGFydGljaXBhdGluZ0FuaW0uaGFzSW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSkgJiYgbGFzdFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coJ3NldHRpbmcgaW5pdGlhbCB2YWx1ZTogJywgbGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlLCAnY2FsY3VsYXRlZCcpO1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFwYXJ0aWNpcGF0aW5nQW5pbS5oYXNJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlKSAmJiBsYXN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdzZXR0aW5nIGluaXRpYWwgdmFsdWU6ICcsIGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgbGFzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW0uc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSwgbGFzdFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgYW5pbWF0aW9uIGVuZHMgYmVmb3JlIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbiArIHN0YXJ0TWlsbGlzZWNvbmQnLCBwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbiArIHN0YXJ0TWlsbGlzZWNvbmQsIG1pbGxpc2Vjb25kKTtcXFxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRpY2lwYXRpbmdBbmltLmR1cmF0aW9uICsgc3RhcnRNaWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdlbmRzIGJlZm9yZSB0YXJnZXQnKVxuICAgICAgICAgICAgICAgICAgICBsYXN0VmFsdWUgPSBwYXJ0aWNpcGF0aW5nQW5pbS5hdHRycy5hbmltYXRlZEF0dHJzW2xhbmVEYXRhLmF0dHJpYnV0ZV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBwYXJ0aWNpcGF0aW5nQW5pbXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW0ub25Qcm9ncmVzcygxLCBwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBzbGlwIGZvciB0aGUgc3BlY2lmaWMgZWxlbWVudCBhbmQgdGhlIHNwZWNpZmljIGF0dHJpYnV0ZS4gU2V0IHRoZSBBbmltYXRpb24gYXMgcGF1c2VkIG9yIHBsYXlpbmcgYVxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgc3RvcmUgdGhpcyBpbmZvIHNvbWV3aGVyZVxuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudGFnZUNvbXBsZXRlID0gKG1pbGxpc2Vjb25kIC0gc3RhcnRNaWxsaXNlY29uZCkgLyBwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW0ub25Qcm9ncmVzcyhwZXJjZW50YWdlQ29tcGxldGUsIG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2xpcHMgdG8ganVzdCBvbmUgbGFuZSBiYWNrd2FyZHNcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gbGFuZSAtIHRoZSBsYW5lIHRvIHNsaXAgaW50b1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gbGFuZURhdGEgLSBhbiBvYmplY3Qgd2l0aCBrZXlzOiBhdHRyaWJ1dGUgJiBtY2lkXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBjdXJyZW50TWlsbGlzZWNvbmQgLSB0aGUgbWlsbGlzZWNvbmQgdGhlIHNsaXAgc3RhcnRzIGZyb21cbiAgICAgICAgICogQHBhcmFtYSB7aW50fSBtaWxsaXNlY29uZCAtIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIHNsaXBcbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NsaXBUb0xhbmVCYWNrd2FyZHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2xpcFRvTGFuZUJhY2t3YXJkcyhsYW5lLCBsYW5lRGF0YSwgY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgLy8gd2UgdGFrZSBhbGwgQW5pbWF0aW9ucyB0aGF0IGFyZSBlaXRoZXIgY3VycmVudGx5IHJ1bm5pbmcgb3JcbiAgICAgICAgICAgIC8vIHRoZXkgZW5kIGFmdGVyIHRoZSBkZXN0aW5hdGlvbiBwb2ludFxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZygnPC0tLS0tLScpO1xuICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbmdBbmltcyA9IF9maWx0ZXIobGFuZSwgZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVJdGVtRW5kID0gbGFuZUl0ZW0uaW5jaWRlbnQuZHVyYXRpb24gKyBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW1FbmQgPD0gbWlsbGlzZWNvbmQgJiYgbGFuZUl0ZW1FbmQgPj0gY3VycmVudE1pbGxpc2Vjb25kIHx8IC8vIHRoZXkgZW5kIGluIHRoZSBob3QgYXJlYVxuICAgICAgICAgICAgICAgIGxhbmVJdGVtLm1pbGxpc2Vjb25kID49IGN1cnJlbnRNaWxsaXNlY29uZCAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZCB8fCAvLyB0aGV5IHN0YXJ0IGluIHRoZSBob3QgYXJlYVxuICAgICAgICAgICAgICAgIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDwgY3VycmVudE1pbGxpc2Vjb25kICYmIGxhbmVJdGVtRW5kID4gbWlsbGlzZWNvbmQ7IC8vIHRoZXkgb3ZlcmxhcCB0aGUgaG90IGFyZWFcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAocGFydGljaXBhdGluZ0FuaW1zLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhcnRpY2lwYXRpbmdBbmltcyA9IF9zb3J0QnkocGFydGljaXBhdGluZ0FuaW1zLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgfV0pO1xuXG4gICAgICAgICAgICB2YXIgbGFzdFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBwYXJ0aWNpcGF0aW5nQW5pbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydGljaXBhdGluZ0FuaW0gPSBwYXJ0aWNpcGF0aW5nQW5pbXNbaV0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0TWlsbGlzZWNvbmQgPSBwYXJ0aWNpcGF0aW5nQW5pbXNbaV0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0TWlsbGlzZWNvbmQgPj0gbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGljaXBhdGluZ0FuaW0ub25Qcm9ncmVzcygwLCAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY2VudGFnZUNvbXBsZXRlID0gKG1pbGxpc2Vjb25kIC0gc3RhcnRNaWxsaXNlY29uZCkgLyBwYXJ0aWNpcGF0aW5nQW5pbS5kdXJhdGlvbjtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNpcGF0aW5nQW5pbS5vblByb2dyZXNzKHBlcmNlbnRhZ2VDb21wbGV0ZSwgbWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgQHBhcmFtIHtpbnR9IGZyb20gLSB0aGUgbWlsbGlzZWNvbmQgdG8gc3RhcnQgZnJvbVxuICAgICAgICAgQHBhcmFtIHtpbnR9IHRvIC0gdGhlIG1pbGxpc2Vjb25kIHRvIGdvIHRvXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdtb3ZlVG8nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbW92ZVRvKGZyb20sIHRvKSB7XG4gICAgICAgICAgICAvLyBzdGVwIDE6IGl0ZXJhdGUgdGhyb3VnaCBhbGwgbGFuZXNcbiAgICAgICAgICAgIGZvciAodmFyIGxhbmVpZCBpbiB0aGlzLmxhbmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxhbmUgPSB0aGlzLmxhbmVzW2xhbmVpZF07XG4gICAgICAgICAgICAgICAgdmFyIGxhbmVEYXRhID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGxhbmVpZCk7XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKGxhbmVpZCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpcEludG9MYW5lRm9yd2FyZHMobGFuZSwgbGFuZURhdGEsIGZyb20sIHRvKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZyb20gPj0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zbGlwVG9MYW5lQmFja3dhcmRzKGxhbmUsIGxhbmVEYXRhLCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdsYW5lcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTGFuZXNIYW5kbGVyLmxhbmVzO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ3R5cGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBcImF0dHJpYnV0ZXNcIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBdHRyaWJ1dGVDaGFubmVsO1xufShDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdHRyaWJ1dGVDaGFubmVsOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _cloneDeep = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.clonedeep/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _findIndex = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.findindex/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\");\nvar _find = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.find/index */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js\");\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar LanesHandler = function () {\n    function LanesHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, LanesHandler);\n\n        /*\n         * Keeps the lanes of the Channel in the form:\n         * {\n         *  <motorcortex-id>_<attribute>: [\n         *      {\n         *          millisecond: the millisecond of the channel this Animation (that affects the selector/attribute pair) runs\n         *          incident: Animation (the animation object that holds the affecting animation\n         *      }\n         *  ]\n         * }\n         /** @type {{}}\n         */\n        this.lanes = {};\n        if (props.lanes) {\n            this.lanes = props.lanes;\n        }\n\n        this.comboAttributes = {};\n        if (props.comboAttributes != null) {\n            this.comboAttributes = props.comboAttributes;\n        }\n\n        /*\n        Keeps an indexing of the lanes each Animation belongs to. The form is the following:\n        belongingLaneKeysByAnimationId: {\n            <animation_id>: [laneKey1, laneKey2, ...],\n            <animation_id>: [laneKey2, laneKey3, ...],\n            ...\n        }\n         */\n        this.belongingLaneKeysByAnimationId = {};\n        if (props.belongingLaneKeysByAnimationId) {\n            this.belongingLaneKeysByAnimationId = props.belongingLaneKeysByAnimationId;\n        }\n    }\n\n    /**\n     * This method resizes all the lanes of the Lanes Handler by the durationFraction provided.\n     * No checks are performed. \n     * This method is been invoked in cases where a full Clip gets resized, so no conflict checks need to\n     * run.\n     * @param {float} durationFration: the fraction between the new duration and the current\n    */\n\n\n    _createClass(LanesHandler, [{\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            for (var key in this.lanes) {\n                var theLane = this.lanes[key];\n                for (var i = 0; i < theLane.length; i++) {\n                    theLane[i].millisecond = theLane[i].millisecond * durationFraction;\n                }\n            }\n        }\n\n        /**\n         * it creates a new LanesHandler that acts as a sanbox for testing changes\n        */\n\n    }, {\n        key: 'createTestLanesSanbox',\n        value: function createTestLanesSanbox() {\n            var lanesToPass = {};\n            for (var key in this.lanes) {\n                lanesToPass[key] = [];\n                for (var i = 0; i < this.lanes[key].length; i++) {\n                    lanesToPass[key].push({\n                        id: this.lanes[key][i].id,\n                        incident: this.lanes[key][i].incident,\n                        millisecond: this.lanes[key][i].millisecond * 1\n                    });\n                }\n            }\n            var props = {\n                lanes: lanesToPass,\n                belongingLaneKeysByAnimationId: _cloneDeep(JSON.parse(JSON.stringify(this.belongingLaneKeysByAnimationId)))\n            };\n\n            if (this.comboAttributes) {\n                props.comboAttributes = this.comboAttributes;\n            }\n\n            return new LanesHandler(props);\n        }\n    }, {\n        key: 'getLanesCopy',\n        value: function getLanesCopy(lane) {\n            var laneToReturn = [];\n            for (var i = 0; i < lane.length; i++) {\n                laneToReturn.push({\n                    id: lane[i].id,\n                    incident: lane[i].incident,\n                    millisecond: lane[i].millisecond * 1\n                });\n            }\n            return laneToReturn;\n        }\n    }, {\n        key: 'getLaneElementsClone',\n        value: function getLaneElementsClone(laneElement) {\n            // return _cloneDeep(laneElement);\n            return {\n                id: laneElement.id,\n                millisecond: laneElement.millisecond * 1,\n                incident: {\n                    duration: laneElement.incident.duration * 1,\n                    id: laneElement.incident.id\n                }\n                // return JSON.parse(JSON.stringify(laneElement));\n            };\n        }\n    }, {\n        key: 'applySandboxChanges',\n        value: function applySandboxChanges(SanboxObject) {\n            this.lanes = SanboxObject.lanes;\n            this.belongingLaneKeysByAnimationId = SanboxObject.belongingLaneKeysByAnimationId;\n        }\n    }, {\n        key: 'getLane',\n        value: function getLane(mcid, attr) {\n            return this.lanes[helper.getLaneKey(mcid, attr)];\n        }\n\n        /**\n         * Checks whether the incident has animatedAttrs or not. \n        **/\n\n    }, {\n        key: '_incidentHasAnimatedAttrs',\n        value: function _incidentHasAnimatedAttrs(incident) {\n            if (incident.attrs.hasOwnProperty('animatedAttrs')) {\n                return true;\n            }\n            return false;\n        }\n\n        /**\n         * return true if lane exists or false otherwise\n         * @param {String} mcid\n         * @param {String} attr\n         * @param {boolean} ifNotCreateIt - if is set to true and the lane doesn't exist it creates it but still returning false\n        */\n\n    }, {\n        key: 'laneExists',\n        value: function laneExists(mcid, attr) {\n            var ifNotCreateIt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n            var laneKey = helper.getLaneKey(mcid, attr);\n            if (!this.lanes.hasOwnProperty(laneKey)) {\n                if (ifNotCreateIt) {\n                    this.lanes[laneKey] = [];\n                }\n                return false;\n            } else {\n                return true;\n            }\n        }\n    }, {\n        key: 'animationIDExists',\n        value: function animationIDExists(mcid, attr, animationID) {\n            if (this.belongingLaneKeysByAnimationId.hasOwnProperty(animationID)) {\n                if (this.belongingLaneKeysByAnimationId[animationID].indexOf(helper.getLaneKey(mcid, attr)) >= 0) {\n                    return true;\n                }\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * @param {Object} newAnim - an object of the form of a lane item (with keys \"millisecond\" and \"incident\"\n         * @param {string} mcid\n         * @param {String} attr\n         * @param {array} excludeIdsFromCheck - optional. If exists it excludes all the ids of this array from check. This\n         *  parameter has been added for the edit checks where an animation might overlap another animation that participates on\n         *  the move, something that should not happen as the edited animations pre-existed without conflicts and the move of all\n         *  of them together guarantees that there is going to be no conflict between them even after the edit\n         * @param {int} testDuration - optional. This parameter is used when the channel needs to check overlaps after duration\n         *  edits, so the testDuration is passed (we don't want to polute the original animation object as it refers to the real one)\n         * @retuns {array} - a list of all overlapping animations of the lane\n        */\n\n    }, {\n        key: 'getOverlappingAnims',\n        value: function getOverlappingAnims(newAnim, mcid, attr) {\n            var excludeIdsFromCheck = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n            var testDuration = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n            var overlappingAnims = _filter(this.lanes[helper.getLaneKey(mcid, attr)], function (existingAnim) {\n                var durationToUseOnChecks = newAnim.incident.duration;\n                if (testDuration != null) {\n                    durationToUseOnChecks = testDuration;\n                }\n\n                return existingAnim.incident.id != newAnim.incident.id && excludeIdsFromCheck.indexOf(existingAnim.incident.id) < 0 && (\n                // existing anim starts within the new anim's extend\n                existingAnim.millisecond >= newAnim.millisecond && existingAnim.millisecond < durationToUseOnChecks + newAnim.millisecond ||\n                // or ends within the new anim's extend\n                existingAnim.millisecond + existingAnim.incident.duration > newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration <= durationToUseOnChecks + newAnim.millisecond\n                // or it starts before and ends after the new anim's extend\n                || existingAnim.millisecond < newAnim.millisecond && existingAnim.millisecond + existingAnim.incident.duration > durationToUseOnChecks + newAnim.millisecond);\n            });\n\n            return overlappingAnims;\n        }\n\n        /**\n         * it justs adds the lane item to the lane and adjusts the initial values of the Anims in sequence\n         * No checks are performed, just execution.\n         * @param {String} mcid\n         * @param {String} attr\n         * @param {int} millisecond\n         * @param {Object} incident\n        */\n\n    }, {\n        key: 'addElementToLane',\n        value: function addElementToLane(mcid, attr, millisecond, incident) {\n\n            var laneKey = helper.getLaneKey(mcid, attr);\n            var theLane = this.lanes[laneKey];\n\n            var laneElement = {\n                millisecond: millisecond,\n                incident: incident,\n                id: incident.id\n            };\n\n            this.laneExists(mcid, attr, true);\n\n            theLane.push(laneElement);\n            theLane = _sortBy(theLane, ['millisecond']);\n\n            // indexing stuff\n            if (!this.belongingLaneKeysByAnimationId.hasOwnProperty(incident.id)) {\n                this.belongingLaneKeysByAnimationId[incident.id] = [];\n            }\n            this.belongingLaneKeysByAnimationId[incident.id].push(laneKey);\n            // indexing\n            var newAnimsIndex = _findIndex(theLane, function (item) {\n                return item.incident.id === incident.id;\n            });\n\n            /* if the incident has no animated attributes we don't need to work on start and final values */\n            if (!this._incidentHasAnimatedAttrs(incident)) {\n                return { onSuccessAction: function onSuccessAction() {} };\n            }\n\n            // helper.log(newAnimsIndex);\n            // step 1: set the intial values of the new Animation\n            if (newAnimsIndex === 0) {\n                // if the newly entered animation is the first of the lane\n                if (theLane.length > 1) {\n                    // and it has other animations too\n                    if (theLane[1].incident.hasInitialValue(attr)) {\n                        // if the initial value of the following animation\n                        // which used to be first is already calculated \"steal\" it\n                        incident.setInitialValue(attr, theLane[1].incident.getInitialValue(attr));\n                    }\n                } else {\n                    // else take it directly from the dom\n                    incident.setInitialValue(attr, incident.getScratchValue(mcid, attr));\n                }\n            } else {\n                incident.setInitialValue(attr, theLane[newAnimsIndex - 1].incident.attrs.animatedAttrs[attr]);\n            }\n\n            /* if the attribute of the lane is a compo attribute */\n            if (this.comboAttributes.hasOwnProperty(attr)) {\n                var incidentInitialValues = incident.getInitialValue(attr);\n                for (var key in incidentInitialValues) {\n                    if (!incident.attrs.animatedAttrs[attr].hasOwnProperty(key)) {\n                        incident.attrs.animatedAttrs[attr][key] = incidentInitialValues[key];\n                    }\n                }\n            }\n\n            var onSuccessAction = function onSuccessAction() {};\n            // step 2: set the inital values of the following Animation (if any)\n            if (newAnimsIndex + 1 < theLane.length) {\n                onSuccessAction = function onSuccessAction() {\n                    theLane[newAnimsIndex + 1].incident.setInitialValue(attr, incident.attrs.animatedAttrs[attr]);\n                };\n            }\n\n            return onSuccessAction;\n        }\n\n        /**\n         * it justs updates the lane\n         * No checks are performed, just execution\n         * @param {array} affectedAnimationsIds\n         * @param {String} attr\n         * @param {int} millisecondDelta\n        */\n\n    }, {\n        key: 'updateLane',\n        value: function updateLane(affectedAnimationsIds, millisecondsDelta) {\n            var _this = this;\n\n            // first we group the affected animations by lanes\n            var affectedLanes = {};\n            var that = this;\n            for (var i = 0; i < affectedAnimationsIds.length; i++) {\n                var belongingLanes = this.belongingLaneKeysByAnimationId[affectedAnimationsIds[i]];\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var laneKey = belongingLanes[j];\n                    if (!affectedLanes.hasOwnProperty(laneKey)) {\n                        affectedLanes[laneKey] = {\n                            animations: [],\n                            lane: that.lanes[laneKey],\n                            laneData: helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j])\n                        };\n                    }\n                    affectedLanes[laneKey].animations.push(affectedAnimationsIds[i]);\n                }\n            }\n\n            // for each of the affected lanes\n            for (var _laneKey in affectedLanes) {\n                var affectedLane = affectedLanes[_laneKey];\n                var lane = affectedLane.lane;\n                var laneData = affectedLane.laneData;\n                var laneBeforeEdit = _sortBy(this.getLanesCopy(lane), ['millisecond']);\n\n                // edit lane items millisecond\n                for (var k = 0; k < lane.length; k++) {\n                    if (affectedLane.animations.indexOf(lane[k].incident.id) >= 0) {\n                        lane[k].millisecond += millisecondsDelta;\n                    }\n                } // end for searching for the animations within the lane\n\n                var sortedLane = _sortBy(lane, ['millisecond']);\n                this.lanes[_laneKey] = sortedLane;\n                lane = sortedLane;\n                // console.log(this);\n\n                var _loop = function _loop(_i) {\n                    var animationToCheck = affectedLane.animations[_i];\n                    var animationIndexBeforeEdit = _findIndex(laneBeforeEdit, function (item) {\n                        return item.incident.id === animationToCheck;\n                    });\n                    var animationIndexAfterEdit = _findIndex(lane, function (item) {\n                        return item.incident.id === animationToCheck;\n                    });\n                    var animation = lane[animationIndexAfterEdit].incident;\n\n                    /**\n                     * if the first animation doesn't have animated attributes that means no one on this channel has. Brake\n                     * and exit the loop that handles start and end values\n                    */\n                    if (!_this._incidentHasAnimatedAttrs(animation)) {\n                        return 'break';\n                    }\n\n                    if (animationIndexBeforeEdit !== animationIndexAfterEdit || animationIndexAfterEdit > 1) {\n                        if (animationIndexBeforeEdit + 1 < lane.length) {\n                            // if the animation was not the last animation on the lane before the edit\n                            // we should take care of the initial values of the animation's previous successor\n                            if (animationIndexBeforeEdit === 0) {\n                                // if the edited animation was the first one before the edit\n                                // if it has initial values, pass them to its previous successor as its new initial values\n                                if (animation.hasInitialValue(laneData.attribute) !== false) {\n                                    // get the initial value of the edited animation and set it as initial value of the new 0 index\n                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, animation.getInitialValue(laneData.mcid, laneData.attribute));\n                                } else {\n                                    // otherwise calculate the initial value on the fly, out of the dom and set it to the new 0\n                                    laneBeforeEdit[1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[1].incident.getScratchValue(laneData.mcid, laneData.attribute));\n                                }\n                            } else {\n                                // else if the edited animation was not the first one before the edit\n                                // meaning its previous successor is not the first one on the lane after the edit\n                                // just grab the target value of the new previous animation of the animation's previous successor and set it as initial value\n                                laneBeforeEdit[animationIndexBeforeEdit + 1].incident.setInitialValue(laneData.attribute, laneBeforeEdit[animationIndexBeforeEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);\n                            }\n                        }\n\n                        // for the edited animation itself now:\n                        if (animationIndexAfterEdit === 0) {\n                            // is it the first one (after edit)?\n                            // does the previously zero index animation has initial value?\n                            if (laneBeforeEdit[0].incident.hasInitialValue(laneData.attribute)) {\n                                // get the initial values of the previously 0 indexed animation of the lane\n                                animation.setInitialValue(laneData.attribute, laneBeforeEdit[0].incident.getInitialValue(laneData.mcid, laneData.attribute));\n                            } else {\n                                // otherwise calculate the initial value on the fly, our of the dom\n                                animation.setInitialValue(laneData.mcid, laneData.attribute, animation.getScratchValue(laneData.mcid, laneData.attribute));\n                            }\n                        } else {\n                            // else if it is not the first one after edit\n                            // just grab the target value of the previous animation on the updated lane and set it as its initial value\n                            animation.setInitialValue(laneData.attribute, lane[animationIndexAfterEdit - 1].incident.attrs.animatedAttrs[laneData.attribute]);\n                        }\n\n                        // for its new next animation (if it has one)\n                        if (animationIndexAfterEdit + 1 < lane.length) {\n                            // set its initial value to equal the target value of the edited animation\n                            lane[animationIndexAfterEdit + 1].incident.setInitialValue(laneData.attribute, animation.attrs.animatedAttrs[laneData.attribute]);\n                        }\n                    }\n                };\n\n                for (var _i = 0; _i < affectedLane.animations.length; _i++) {\n                    var _ret = _loop(_i);\n\n                    if (_ret === 'break') break;\n                }\n            } // end for each of the belonging lanes of the animation\n        }\n\n        /**\n         * removes the list of animations as provided\n         * @param {array} removedAnimations - an array with the removed animations' ids\n        */\n\n    }, {\n        key: 'deleteAnimations',\n        value: function deleteAnimations(removedAnimations, currentMillisecond) {\n            var affectedLanes = {};\n\n            for (var i = 0; i < removedAnimations.length; i++) {\n                var id = removedAnimations[i];\n                // for each lane the affected Animation appears in\n                var belongingLanes = this.belongingLaneKeysByAnimationId[id];\n                for (var j = 0; j < belongingLanes.length; j++) {\n                    var lane = this.lanes[belongingLanes[j]];\n\n                    var _animationIndexBeforeEdit = -1;\n                    for (var k = 0; k < lane.length; k++) {\n                        if (lane[k].incident.id === id) {\n                            _animationIndexBeforeEdit = k;\n                            break;\n                        }\n                    }\n\n                    // helper.log(animationIndexBeforeEdit);\n                    var animationToDelete = Object.assign({}, lane[_animationIndexBeforeEdit]);\n                    var animationObjectToDelete = animationToDelete.incident;\n                    var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n\n                    // gets the lane without the removed animation\n                    var newLane = [];\n                    for (var _k = 0; _k < lane.length; _k++) {\n                        if (lane[_k].incident.id != id) {\n                            newLane.push(lane[_k]);\n                        }\n                    }\n                    this.lanes[belongingLanes[j]] = newLane;\n                    lane = this.lanes[belongingLanes[j]];\n\n                    if (lane.length === 0) {\n                        delete this.lanes[belongingLanes[j]];\n                        if (affectedLanes.hasOwnProperty(belongingLanes[j])) {\n                            delete affectedLanes[belongingLanes[j]];\n                        }\n                    } else {\n                        if (this._incidentHasAnimatedAttrs(animationToDelete.incident)) {\n                            affectedLanes[belongingLanes[j]] = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[j]);\n                            if (_animationIndexBeforeEdit < lane.length && animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute) !== false) {\n                                lane[_animationIndexBeforeEdit].incident.setInitialValue(laneData.attribute, animationToDelete.incident.getInitialValue(laneData.mcid, laneData.attribute));\n                            }\n                        }\n                    }\n                }\n                delete this.belongingLaneKeysByAnimationId[removedAnimations[i]];\n            }\n            return affectedLanes;\n        }\n\n        /**\n         * This method handles edits on the final value of a specific attribute of a specific animation object\n         * @param {string} animationId - the id of the Animation object that has been edited\n         * @param {string} attr - the name of the attribute that has been edited\n         * @param {string} value - the new value of the edited attribute\n        */\n\n    }, {\n        key: 'updateAttributeOnLanes',\n        value: function updateAttributeOnLanes(animationId, attr, value) {\n            var belongingLanes = this.belongingLaneKeysByAnimationId[animationId];\n            var affectedLanes = [];\n            for (var i = 0; i < belongingLanes.length; i++) {\n                var lane = this.lanes[belongingLanes[i]];\n                var laneData = helper.getMCIDandAttrOutOfLaneKey(belongingLanes[i]);\n\n                // get the index of the animation on the lane\n                var animationIndex = -1;\n                for (var k = 0; k < lane.length; k++) {\n                    if (lane[k].incident.id === animationId) {\n                        animationIndex = k;\n                        break;\n                    }\n                }\n\n                // if the animation is not the last one on the lane\n                if (lane.length - 1 != animationIndex) {\n                    lane[animationIndex + 1].incident.setInitialValue(laneData.mcid, laneData.attribute, value);\n                }\n\n                affectedLanes.push(laneData);\n            }\n\n            return affectedLanes;\n        }\n    }]);\n\n    return LanesHandler;\n}();\n\nmodule.exports = LanesHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19DaGFubmVscy9fQXR0cmlidXRlL0xhbmVzSGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvX0NoYW5uZWxzL19BdHRyaWJ1dGUvTGFuZXNIYW5kbGVyLmpzPzFmMjYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgX2Nsb25lRGVlcCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guY2xvbmVkZWVwL2luZGV4Jyk7XG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4Jyk7XG52YXIgX3NvcnRCeSA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4Jyk7XG52YXIgX2ZpbmRJbmRleCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZGluZGV4L2luZGV4Jyk7XG52YXIgX2ZpbmQgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmQvaW5kZXgnKTtcblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xuXG52YXIgTGFuZXNIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhbmVzSGFuZGxlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFuZXNIYW5kbGVyKTtcblxuICAgICAgICAvKlxuICAgICAgICAgKiBLZWVwcyB0aGUgbGFuZXMgb2YgdGhlIENoYW5uZWwgaW4gdGhlIGZvcm06XG4gICAgICAgICAqIHtcbiAgICAgICAgICogIDxtb3RvcmNvcnRleC1pZD5fPGF0dHJpYnV0ZT46IFtcbiAgICAgICAgICogICAgICB7XG4gICAgICAgICAqICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGUgbWlsbGlzZWNvbmQgb2YgdGhlIGNoYW5uZWwgdGhpcyBBbmltYXRpb24gKHRoYXQgYWZmZWN0cyB0aGUgc2VsZWN0b3IvYXR0cmlidXRlIHBhaXIpIHJ1bnNcbiAgICAgICAgICogICAgICAgICAgaW5jaWRlbnQ6IEFuaW1hdGlvbiAodGhlIGFuaW1hdGlvbiBvYmplY3QgdGhhdCBob2xkcyB0aGUgYWZmZWN0aW5nIGFuaW1hdGlvblxuICAgICAgICAgKiAgICAgIH1cbiAgICAgICAgICogIF1cbiAgICAgICAgICogfVxuICAgICAgICAgLyoqIEB0eXBlIHt7fX1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFuZXMgPSB7fTtcbiAgICAgICAgaWYgKHByb3BzLmxhbmVzKSB7XG4gICAgICAgICAgICB0aGlzLmxhbmVzID0gcHJvcHMubGFuZXM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbWJvQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBpZiAocHJvcHMuY29tYm9BdHRyaWJ1dGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY29tYm9BdHRyaWJ1dGVzID0gcHJvcHMuY29tYm9BdHRyaWJ1dGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLypcbiAgICAgICAgS2VlcHMgYW4gaW5kZXhpbmcgb2YgdGhlIGxhbmVzIGVhY2ggQW5pbWF0aW9uIGJlbG9uZ3MgdG8uIFRoZSBmb3JtIGlzIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgIGJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZDoge1xuICAgICAgICAgICAgPGFuaW1hdGlvbl9pZD46IFtsYW5lS2V5MSwgbGFuZUtleTIsIC4uLl0sXG4gICAgICAgICAgICA8YW5pbWF0aW9uX2lkPjogW2xhbmVLZXkyLCBsYW5lS2V5MywgLi4uXSxcbiAgICAgICAgICAgIC4uLlxuICAgICAgICB9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCA9IHt9O1xuICAgICAgICBpZiAocHJvcHMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkKSB7XG4gICAgICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZCA9IHByb3BzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJlc2l6ZXMgYWxsIHRoZSBsYW5lcyBvZiB0aGUgTGFuZXMgSGFuZGxlciBieSB0aGUgZHVyYXRpb25GcmFjdGlvbiBwcm92aWRlZC5cbiAgICAgKiBObyBjaGVja3MgYXJlIHBlcmZvcm1lZC4gXG4gICAgICogVGhpcyBtZXRob2QgaXMgYmVlbiBpbnZva2VkIGluIGNhc2VzIHdoZXJlIGEgZnVsbCBDbGlwIGdldHMgcmVzaXplZCwgc28gbm8gY29uZmxpY3QgY2hlY2tzIG5lZWQgdG9cbiAgICAgKiBydW4uXG4gICAgICogQHBhcmFtIHtmbG9hdH0gZHVyYXRpb25GcmF0aW9uOiB0aGUgZnJhY3Rpb24gYmV0d2VlbiB0aGUgbmV3IGR1cmF0aW9uIGFuZCB0aGUgY3VycmVudFxuICAgICovXG5cblxuICAgIF9jcmVhdGVDbGFzcyhMYW5lc0hhbmRsZXIsIFt7XG4gICAgICAgIGtleTogJ19yZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5sYW5lcykge1xuICAgICAgICAgICAgICAgIHZhciB0aGVMYW5lID0gdGhpcy5sYW5lc1trZXldO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhlTGFuZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGVMYW5lW2ldLm1pbGxpc2Vjb25kID0gdGhlTGFuZVtpXS5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGl0IGNyZWF0ZXMgYSBuZXcgTGFuZXNIYW5kbGVyIHRoYXQgYWN0cyBhcyBhIHNhbmJveCBmb3IgdGVzdGluZyBjaGFuZ2VzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NyZWF0ZVRlc3RMYW5lc1NhbmJveCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXN0TGFuZXNTYW5ib3goKSB7XG4gICAgICAgICAgICB2YXIgbGFuZXNUb1Bhc3MgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmxhbmVzKSB7XG4gICAgICAgICAgICAgICAgbGFuZXNUb1Bhc3Nba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sYW5lc1trZXldLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhbmVzVG9QYXNzW2tleV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5sYW5lc1trZXldW2ldLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMubGFuZXNba2V5XVtpXS5pbmNpZGVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiB0aGlzLmxhbmVzW2tleV1baV0ubWlsbGlzZWNvbmQgKiAxXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICAgICAgICBsYW5lczogbGFuZXNUb1Bhc3MsXG4gICAgICAgICAgICAgICAgYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkOiBfY2xvbmVEZWVwKEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQpKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbWJvQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIHByb3BzLmNvbWJvQXR0cmlidXRlcyA9IHRoaXMuY29tYm9BdHRyaWJ1dGVzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IExhbmVzSGFuZGxlcihwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldExhbmVzQ29weScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYW5lc0NvcHkobGFuZSkge1xuICAgICAgICAgICAgdmFyIGxhbmVUb1JldHVybiA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5lLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFuZVRvUmV0dXJuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbGFuZVtpXS5pZCxcbiAgICAgICAgICAgICAgICAgICAgaW5jaWRlbnQ6IGxhbmVbaV0uaW5jaWRlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBsYW5lW2ldLm1pbGxpc2Vjb25kICogMVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxhbmVUb1JldHVybjtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TGFuZUVsZW1lbnRzQ2xvbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZUVsZW1lbnRzQ2xvbmUobGFuZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBfY2xvbmVEZWVwKGxhbmVFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGxhbmVFbGVtZW50LmlkLFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBsYW5lRWxlbWVudC5taWxsaXNlY29uZCAqIDEsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGxhbmVFbGVtZW50LmluY2lkZW50LmR1cmF0aW9uICogMSxcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGxhbmVFbGVtZW50LmluY2lkZW50LmlkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGxhbmVFbGVtZW50KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdhcHBseVNhbmRib3hDaGFuZ2VzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5U2FuZGJveENoYW5nZXMoU2FuYm94T2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLmxhbmVzID0gU2FuYm94T2JqZWN0LmxhbmVzO1xuICAgICAgICAgICAgdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWQgPSBTYW5ib3hPYmplY3QuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRMYW5lJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhbmUobWNpZCwgYXR0cikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFuZXNbaGVscGVyLmdldExhbmVLZXkobWNpZCwgYXR0cildO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBpbmNpZGVudCBoYXMgYW5pbWF0ZWRBdHRycyBvciBub3QuIFxuICAgICAgICAqKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGluY2lkZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5jaWRlbnQuYXR0cnMuaGFzT3duUHJvcGVydHkoJ2FuaW1hdGVkQXR0cnMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJldHVybiB0cnVlIGlmIGxhbmUgZXhpc3RzIG9yIGZhbHNlIG90aGVyd2lzZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlmTm90Q3JlYXRlSXQgLSBpZiBpcyBzZXQgdG8gdHJ1ZSBhbmQgdGhlIGxhbmUgZG9lc24ndCBleGlzdCBpdCBjcmVhdGVzIGl0IGJ1dCBzdGlsbCByZXR1cm5pbmcgZmFsc2VcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbGFuZUV4aXN0cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsYW5lRXhpc3RzKG1jaWQsIGF0dHIpIHtcbiAgICAgICAgICAgIHZhciBpZk5vdENyZWF0ZUl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGxhbmVLZXkgPSBoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5sYW5lcy5oYXNPd25Qcm9wZXJ0eShsYW5lS2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChpZk5vdENyZWF0ZUl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFuZXNbbGFuZUtleV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYW5pbWF0aW9uSURFeGlzdHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0aW9uSURFeGlzdHMobWNpZCwgYXR0ciwgYW5pbWF0aW9uSUQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5oYXNPd25Qcm9wZXJ0eShhbmltYXRpb25JRCkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWRbYW5pbWF0aW9uSURdLmluZGV4T2YoaGVscGVyLmdldExhbmVLZXkobWNpZCwgYXR0cikpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG5ld0FuaW0gLSBhbiBvYmplY3Qgb2YgdGhlIGZvcm0gb2YgYSBsYW5lIGl0ZW0gKHdpdGgga2V5cyBcIm1pbGxpc2Vjb25kXCIgYW5kIFwiaW5jaWRlbnRcIlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBleGNsdWRlSWRzRnJvbUNoZWNrIC0gb3B0aW9uYWwuIElmIGV4aXN0cyBpdCBleGNsdWRlcyBhbGwgdGhlIGlkcyBvZiB0aGlzIGFycmF5IGZyb20gY2hlY2suIFRoaXNcbiAgICAgICAgICogIHBhcmFtZXRlciBoYXMgYmVlbiBhZGRlZCBmb3IgdGhlIGVkaXQgY2hlY2tzIHdoZXJlIGFuIGFuaW1hdGlvbiBtaWdodCBvdmVybGFwIGFub3RoZXIgYW5pbWF0aW9uIHRoYXQgcGFydGljaXBhdGVzIG9uXG4gICAgICAgICAqICB0aGUgbW92ZSwgc29tZXRoaW5nIHRoYXQgc2hvdWxkIG5vdCBoYXBwZW4gYXMgdGhlIGVkaXRlZCBhbmltYXRpb25zIHByZS1leGlzdGVkIHdpdGhvdXQgY29uZmxpY3RzIGFuZCB0aGUgbW92ZSBvZiBhbGxcbiAgICAgICAgICogIG9mIHRoZW0gdG9nZXRoZXIgZ3VhcmFudGVlcyB0aGF0IHRoZXJlIGlzIGdvaW5nIHRvIGJlIG5vIGNvbmZsaWN0IGJldHdlZW4gdGhlbSBldmVuIGFmdGVyIHRoZSBlZGl0XG4gICAgICAgICAqIEBwYXJhbSB7aW50fSB0ZXN0RHVyYXRpb24gLSBvcHRpb25hbC4gVGhpcyBwYXJhbWV0ZXIgaXMgdXNlZCB3aGVuIHRoZSBjaGFubmVsIG5lZWRzIHRvIGNoZWNrIG92ZXJsYXBzIGFmdGVyIGR1cmF0aW9uXG4gICAgICAgICAqICBlZGl0cywgc28gdGhlIHRlc3REdXJhdGlvbiBpcyBwYXNzZWQgKHdlIGRvbid0IHdhbnQgdG8gcG9sdXRlIHRoZSBvcmlnaW5hbCBhbmltYXRpb24gb2JqZWN0IGFzIGl0IHJlZmVycyB0byB0aGUgcmVhbCBvbmUpXG4gICAgICAgICAqIEByZXR1bnMge2FycmF5fSAtIGEgbGlzdCBvZiBhbGwgb3ZlcmxhcHBpbmcgYW5pbWF0aW9ucyBvZiB0aGUgbGFuZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRPdmVybGFwcGluZ0FuaW1zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE92ZXJsYXBwaW5nQW5pbXMobmV3QW5pbSwgbWNpZCwgYXR0cikge1xuICAgICAgICAgICAgdmFyIGV4Y2x1ZGVJZHNGcm9tQ2hlY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFtdO1xuICAgICAgICAgICAgdmFyIHRlc3REdXJhdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogbnVsbDtcblxuICAgICAgICAgICAgdmFyIG92ZXJsYXBwaW5nQW5pbXMgPSBfZmlsdGVyKHRoaXMubGFuZXNbaGVscGVyLmdldExhbmVLZXkobWNpZCwgYXR0cildLCBmdW5jdGlvbiAoZXhpc3RpbmdBbmltKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR1cmF0aW9uVG9Vc2VPbkNoZWNrcyA9IG5ld0FuaW0uaW5jaWRlbnQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHRlc3REdXJhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uVG9Vc2VPbkNoZWNrcyA9IHRlc3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdBbmltLmluY2lkZW50LmlkICE9IG5ld0FuaW0uaW5jaWRlbnQuaWQgJiYgZXhjbHVkZUlkc0Zyb21DaGVjay5pbmRleE9mKGV4aXN0aW5nQW5pbS5pbmNpZGVudC5pZCkgPCAwICYmIChcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyBhbmltIHN0YXJ0cyB3aXRoaW4gdGhlIG5ldyBhbmltJ3MgZXh0ZW5kXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kID49IG5ld0FuaW0ubWlsbGlzZWNvbmQgJiYgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kIDwgZHVyYXRpb25Ub1VzZU9uQ2hlY2tzICsgbmV3QW5pbS5taWxsaXNlY29uZCB8fFxuICAgICAgICAgICAgICAgIC8vIG9yIGVuZHMgd2l0aGluIHRoZSBuZXcgYW5pbSdzIGV4dGVuZFxuICAgICAgICAgICAgICAgIGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCArIGV4aXN0aW5nQW5pbS5pbmNpZGVudC5kdXJhdGlvbiA+IG5ld0FuaW0ubWlsbGlzZWNvbmQgJiYgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kICsgZXhpc3RpbmdBbmltLmluY2lkZW50LmR1cmF0aW9uIDw9IGR1cmF0aW9uVG9Vc2VPbkNoZWNrcyArIG5ld0FuaW0ubWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAvLyBvciBpdCBzdGFydHMgYmVmb3JlIGFuZCBlbmRzIGFmdGVyIHRoZSBuZXcgYW5pbSdzIGV4dGVuZFxuICAgICAgICAgICAgICAgIHx8IGV4aXN0aW5nQW5pbS5taWxsaXNlY29uZCA8IG5ld0FuaW0ubWlsbGlzZWNvbmQgJiYgZXhpc3RpbmdBbmltLm1pbGxpc2Vjb25kICsgZXhpc3RpbmdBbmltLmluY2lkZW50LmR1cmF0aW9uID4gZHVyYXRpb25Ub1VzZU9uQ2hlY2tzICsgbmV3QW5pbS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIG92ZXJsYXBwaW5nQW5pbXM7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogaXQganVzdHMgYWRkcyB0aGUgbGFuZSBpdGVtIHRvIHRoZSBsYW5lIGFuZCBhZGp1c3RzIHRoZSBpbml0aWFsIHZhbHVlcyBvZiB0aGUgQW5pbXMgaW4gc2VxdWVuY2VcbiAgICAgICAgICogTm8gY2hlY2tzIGFyZSBwZXJmb3JtZWQsIGp1c3QgZXhlY3V0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWNpZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGluY2lkZW50XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEVsZW1lbnRUb0xhbmUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWxlbWVudFRvTGFuZShtY2lkLCBhdHRyLCBtaWxsaXNlY29uZCwgaW5jaWRlbnQpIHtcblxuICAgICAgICAgICAgdmFyIGxhbmVLZXkgPSBoZWxwZXIuZ2V0TGFuZUtleShtY2lkLCBhdHRyKTtcbiAgICAgICAgICAgIHZhciB0aGVMYW5lID0gdGhpcy5sYW5lc1tsYW5lS2V5XTtcblxuICAgICAgICAgICAgdmFyIGxhbmVFbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kOiBtaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogaW5jaWRlbnQsXG4gICAgICAgICAgICAgICAgaWQ6IGluY2lkZW50LmlkXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmxhbmVFeGlzdHMobWNpZCwgYXR0ciwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIHRoZUxhbmUucHVzaChsYW5lRWxlbWVudCk7XG4gICAgICAgICAgICB0aGVMYW5lID0gX3NvcnRCeSh0aGVMYW5lLCBbJ21pbGxpc2Vjb25kJ10pO1xuXG4gICAgICAgICAgICAvLyBpbmRleGluZyBzdHVmZlxuICAgICAgICAgICAgaWYgKCF0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZC5oYXNPd25Qcm9wZXJ0eShpbmNpZGVudC5pZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZFtpbmNpZGVudC5pZF0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkW2luY2lkZW50LmlkXS5wdXNoKGxhbmVLZXkpO1xuICAgICAgICAgICAgLy8gaW5kZXhpbmdcbiAgICAgICAgICAgIHZhciBuZXdBbmltc0luZGV4ID0gX2ZpbmRJbmRleCh0aGVMYW5lLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmluY2lkZW50LmlkID09PSBpbmNpZGVudC5pZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvKiBpZiB0aGUgaW5jaWRlbnQgaGFzIG5vIGFuaW1hdGVkIGF0dHJpYnV0ZXMgd2UgZG9uJ3QgbmVlZCB0byB3b3JrIG9uIHN0YXJ0IGFuZCBmaW5hbCB2YWx1ZXMgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy5faW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGluY2lkZW50KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG9uU3VjY2Vzc0FjdGlvbjogZnVuY3Rpb24gb25TdWNjZXNzQWN0aW9uKCkge30gfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhuZXdBbmltc0luZGV4KTtcbiAgICAgICAgICAgIC8vIHN0ZXAgMTogc2V0IHRoZSBpbnRpYWwgdmFsdWVzIG9mIHRoZSBuZXcgQW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAobmV3QW5pbXNJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBuZXdseSBlbnRlcmVkIGFuaW1hdGlvbiBpcyB0aGUgZmlyc3Qgb2YgdGhlIGxhbmVcbiAgICAgICAgICAgICAgICBpZiAodGhlTGFuZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpdCBoYXMgb3RoZXIgYW5pbWF0aW9ucyB0b29cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoZUxhbmVbMV0uaW5jaWRlbnQuaGFzSW5pdGlhbFZhbHVlKGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgZm9sbG93aW5nIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggdXNlZCB0byBiZSBmaXJzdCBpcyBhbHJlYWR5IGNhbGN1bGF0ZWQgXCJzdGVhbFwiIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5zZXRJbml0aWFsVmFsdWUoYXR0ciwgdGhlTGFuZVsxXS5pbmNpZGVudC5nZXRJbml0aWFsVmFsdWUoYXR0cikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZWxzZSB0YWtlIGl0IGRpcmVjdGx5IGZyb20gdGhlIGRvbVxuICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5zZXRJbml0aWFsVmFsdWUoYXR0ciwgaW5jaWRlbnQuZ2V0U2NyYXRjaFZhbHVlKG1jaWQsIGF0dHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGluY2lkZW50LnNldEluaXRpYWxWYWx1ZShhdHRyLCB0aGVMYW5lW25ld0FuaW1zSW5kZXggLSAxXS5pbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyogaWYgdGhlIGF0dHJpYnV0ZSBvZiB0aGUgbGFuZSBpcyBhIGNvbXBvIGF0dHJpYnV0ZSAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tYm9BdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGluY2lkZW50SW5pdGlhbFZhbHVlcyA9IGluY2lkZW50LmdldEluaXRpYWxWYWx1ZShhdHRyKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gaW5jaWRlbnRJbml0aWFsVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNpZGVudC5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJdW2tleV0gPSBpbmNpZGVudEluaXRpYWxWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG9uU3VjY2Vzc0FjdGlvbiA9IGZ1bmN0aW9uIG9uU3VjY2Vzc0FjdGlvbigpIHt9O1xuICAgICAgICAgICAgLy8gc3RlcCAyOiBzZXQgdGhlIGluaXRhbCB2YWx1ZXMgb2YgdGhlIGZvbGxvd2luZyBBbmltYXRpb24gKGlmIGFueSlcbiAgICAgICAgICAgIGlmIChuZXdBbmltc0luZGV4ICsgMSA8IHRoZUxhbmUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgb25TdWNjZXNzQWN0aW9uID0gZnVuY3Rpb24gb25TdWNjZXNzQWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGVMYW5lW25ld0FuaW1zSW5kZXggKyAxXS5pbmNpZGVudC5zZXRJbml0aWFsVmFsdWUoYXR0ciwgaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyXSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG9uU3VjY2Vzc0FjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpdCBqdXN0cyB1cGRhdGVzIHRoZSBsYW5lXG4gICAgICAgICAqIE5vIGNoZWNrcyBhcmUgcGVyZm9ybWVkLCBqdXN0IGV4ZWN1dGlvblxuICAgICAgICAgKiBAcGFyYW0ge2FycmF5fSBhZmZlY3RlZEFuaW1hdGlvbnNJZHNcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHJcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IG1pbGxpc2Vjb25kRGVsdGFcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndXBkYXRlTGFuZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVMYW5lKGFmZmVjdGVkQW5pbWF0aW9uc0lkcywgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGZpcnN0IHdlIGdyb3VwIHRoZSBhZmZlY3RlZCBhbmltYXRpb25zIGJ5IGxhbmVzXG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRMYW5lcyA9IHt9O1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZmZlY3RlZEFuaW1hdGlvbnNJZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgYmVsb25naW5nTGFuZXMgPSB0aGlzLmJlbG9uZ2luZ0xhbmVLZXlzQnlBbmltYXRpb25JZFthZmZlY3RlZEFuaW1hdGlvbnNJZHNbaV1dO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmVLZXkgPSBiZWxvbmdpbmdMYW5lc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhZmZlY3RlZExhbmVzLmhhc093blByb3BlcnR5KGxhbmVLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZExhbmVzW2xhbmVLZXldID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmU6IHRoYXQubGFuZXNbbGFuZUtleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZURhdGE6IGhlbHBlci5nZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tqXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYWZmZWN0ZWRMYW5lc1tsYW5lS2V5XS5hbmltYXRpb25zLnB1c2goYWZmZWN0ZWRBbmltYXRpb25zSWRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGZvciBlYWNoIG9mIHRoZSBhZmZlY3RlZCBsYW5lc1xuICAgICAgICAgICAgZm9yICh2YXIgX2xhbmVLZXkgaW4gYWZmZWN0ZWRMYW5lcykge1xuICAgICAgICAgICAgICAgIHZhciBhZmZlY3RlZExhbmUgPSBhZmZlY3RlZExhbmVzW19sYW5lS2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IGFmZmVjdGVkTGFuZS5sYW5lO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lRGF0YSA9IGFmZmVjdGVkTGFuZS5sYW5lRGF0YTtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZUJlZm9yZUVkaXQgPSBfc29ydEJ5KHRoaXMuZ2V0TGFuZXNDb3B5KGxhbmUpLCBbJ21pbGxpc2Vjb25kJ10pO1xuXG4gICAgICAgICAgICAgICAgLy8gZWRpdCBsYW5lIGl0ZW1zIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYW5lLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZmZlY3RlZExhbmUuYW5pbWF0aW9ucy5pbmRleE9mKGxhbmVba10uaW5jaWRlbnQuaWQpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVba10ubWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzRGVsdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIGVuZCBmb3Igc2VhcmNoaW5nIGZvciB0aGUgYW5pbWF0aW9ucyB3aXRoaW4gdGhlIGxhbmVcblxuICAgICAgICAgICAgICAgIHZhciBzb3J0ZWRMYW5lID0gX3NvcnRCeShsYW5lLCBbJ21pbGxpc2Vjb25kJ10pO1xuICAgICAgICAgICAgICAgIHRoaXMubGFuZXNbX2xhbmVLZXldID0gc29ydGVkTGFuZTtcbiAgICAgICAgICAgICAgICBsYW5lID0gc29ydGVkTGFuZTtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhbmltYXRpb25Ub0NoZWNrID0gYWZmZWN0ZWRMYW5lLmFuaW1hdGlvbnNbX2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXhCZWZvcmVFZGl0ID0gX2ZpbmRJbmRleChsYW5lQmVmb3JlRWRpdCwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmluY2lkZW50LmlkID09PSBhbmltYXRpb25Ub0NoZWNrO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID0gX2ZpbmRJbmRleChsYW5lLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uaW5jaWRlbnQuaWQgPT09IGFuaW1hdGlvblRvQ2hlY2s7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gbGFuZVthbmltYXRpb25JbmRleEFmdGVyRWRpdF0uaW5jaWRlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIGlmIHRoZSBmaXJzdCBhbmltYXRpb24gZG9lc24ndCBoYXZlIGFuaW1hdGVkIGF0dHJpYnV0ZXMgdGhhdCBtZWFucyBubyBvbmUgb24gdGhpcyBjaGFubmVsIGhhcy4gQnJha2VcbiAgICAgICAgICAgICAgICAgICAgICogYW5kIGV4aXQgdGhlIGxvb3AgdGhhdCBoYW5kbGVzIHN0YXJ0IGFuZCBlbmQgdmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMuX2luY2lkZW50SGFzQW5pbWF0ZWRBdHRycyhhbmltYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ2JyZWFrJztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgIT09IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0IHx8IGFuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0ID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCArIDEgPCBsYW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gd2FzIG5vdCB0aGUgbGFzdCBhbmltYXRpb24gb24gdGhlIGxhbmUgYmVmb3JlIHRoZSBlZGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIHRha2UgY2FyZSBvZiB0aGUgaW5pdGlhbCB2YWx1ZXMgb2YgdGhlIGFuaW1hdGlvbidzIHByZXZpb3VzIHN1Y2Nlc3NvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVkaXRlZCBhbmltYXRpb24gd2FzIHRoZSBmaXJzdCBvbmUgYmVmb3JlIHRoZSBlZGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBpbml0aWFsIHZhbHVlcywgcGFzcyB0aGVtIHRvIGl0cyBwcmV2aW91cyBzdWNjZXNzb3IgYXMgaXRzIG5ldyBpbml0aWFsIHZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uLmhhc0luaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZ2V0IHRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBlZGl0ZWQgYW5pbWF0aW9uIGFuZCBzZXQgaXQgYXMgaW5pdGlhbCB2YWx1ZSBvZiB0aGUgbmV3IDAgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVCZWZvcmVFZGl0WzFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGFuaW1hdGlvbi5nZXRJbml0aWFsVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2FsY3VsYXRlIHRoZSBpbml0aWFsIHZhbHVlIG9uIHRoZSBmbHksIG91dCBvZiB0aGUgZG9tIGFuZCBzZXQgaXQgdG8gdGhlIG5ldyAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5lQmVmb3JlRWRpdFsxXS5pbmNpZGVudC5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlLCBsYW5lQmVmb3JlRWRpdFsxXS5pbmNpZGVudC5nZXRTY3JhdGNoVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmIHRoZSBlZGl0ZWQgYW5pbWF0aW9uIHdhcyBub3QgdGhlIGZpcnN0IG9uZSBiZWZvcmUgdGhlIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVhbmluZyBpdHMgcHJldmlvdXMgc3VjY2Vzc29yIGlzIG5vdCB0aGUgZmlyc3Qgb25lIG9uIHRoZSBsYW5lIGFmdGVyIHRoZSBlZGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgZ3JhYiB0aGUgdGFyZ2V0IHZhbHVlIG9mIHRoZSBuZXcgcHJldmlvdXMgYW5pbWF0aW9uIG9mIHRoZSBhbmltYXRpb24ncyBwcmV2aW91cyBzdWNjZXNzb3IgYW5kIHNldCBpdCBhcyBpbml0aWFsIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCArIDFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGxhbmVCZWZvcmVFZGl0W2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCAtIDFdLmluY2lkZW50LmF0dHJzLmFuaW1hdGVkQXR0cnNbbGFuZURhdGEuYXR0cmlidXRlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdGhlIGVkaXRlZCBhbmltYXRpb24gaXRzZWxmIG5vdzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25JbmRleEFmdGVyRWRpdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIGl0IHRoZSBmaXJzdCBvbmUgKGFmdGVyIGVkaXQpP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvZXMgdGhlIHByZXZpb3VzbHkgemVybyBpbmRleCBhbmltYXRpb24gaGFzIGluaXRpYWwgdmFsdWU/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVCZWZvcmVFZGl0WzBdLmluY2lkZW50Lmhhc0luaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUgaW5pdGlhbCB2YWx1ZXMgb2YgdGhlIHByZXZpb3VzbHkgMCBpbmRleGVkIGFuaW1hdGlvbiBvZiB0aGUgbGFuZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uc2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLmF0dHJpYnV0ZSwgbGFuZUJlZm9yZUVkaXRbMF0uaW5jaWRlbnQuZ2V0SW5pdGlhbFZhbHVlKGxhbmVEYXRhLm1jaWQsIGxhbmVEYXRhLmF0dHJpYnV0ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjYWxjdWxhdGUgdGhlIGluaXRpYWwgdmFsdWUgb24gdGhlIGZseSwgb3VyIG9mIHRoZSBkb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uLnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUsIGFuaW1hdGlvbi5nZXRTY3JhdGNoVmFsdWUobGFuZURhdGEubWNpZCwgbGFuZURhdGEuYXR0cmlidXRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmIGl0IGlzIG5vdCB0aGUgZmlyc3Qgb25lIGFmdGVyIGVkaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGdyYWIgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIG9uIHRoZSB1cGRhdGVkIGxhbmUgYW5kIHNldCBpdCBhcyBpdHMgaW5pdGlhbCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbi5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlLCBsYW5lW2FuaW1hdGlvbkluZGV4QWZ0ZXJFZGl0IC0gMV0uaW5jaWRlbnQuYXR0cnMuYW5pbWF0ZWRBdHRyc1tsYW5lRGF0YS5hdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yIGl0cyBuZXcgbmV4dCBhbmltYXRpb24gKGlmIGl0IGhhcyBvbmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgKyAxIDwgbGFuZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaXRzIGluaXRpYWwgdmFsdWUgdG8gZXF1YWwgdGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgZWRpdGVkIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhbmVbYW5pbWF0aW9uSW5kZXhBZnRlckVkaXQgKyAxXS5pbmNpZGVudC5zZXRJbml0aWFsVmFsdWUobGFuZURhdGEuYXR0cmlidXRlLCBhbmltYXRpb24uYXR0cnMuYW5pbWF0ZWRBdHRyc1tsYW5lRGF0YS5hdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYWZmZWN0ZWRMYW5lLmFuaW1hdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmV0ID0gX2xvb3AoX2kpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmV0ID09PSAnYnJlYWsnKSBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIGVuZCBmb3IgZWFjaCBvZiB0aGUgYmVsb25naW5nIGxhbmVzIG9mIHRoZSBhbmltYXRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiByZW1vdmVzIHRoZSBsaXN0IG9mIGFuaW1hdGlvbnMgYXMgcHJvdmlkZWRcbiAgICAgICAgICogQHBhcmFtIHthcnJheX0gcmVtb3ZlZEFuaW1hdGlvbnMgLSBhbiBhcnJheSB3aXRoIHRoZSByZW1vdmVkIGFuaW1hdGlvbnMnIGlkc1xuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdkZWxldGVBbmltYXRpb25zJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlbGV0ZUFuaW1hdGlvbnMocmVtb3ZlZEFuaW1hdGlvbnMsIGN1cnJlbnRNaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZW1vdmVkQW5pbWF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IHJlbW92ZWRBbmltYXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIC8vIGZvciBlYWNoIGxhbmUgdGhlIGFmZmVjdGVkIEFuaW1hdGlvbiBhcHBlYXJzIGluXG4gICAgICAgICAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWRbaWRdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhbmUgPSB0aGlzLmxhbmVzW2JlbG9uZ2luZ0xhbmVzW2pdXTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgX2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYW5lW2tdLmluY2lkZW50LmlkID09PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hbmltYXRpb25JbmRleEJlZm9yZUVkaXQgPSBrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhhbmltYXRpb25JbmRleEJlZm9yZUVkaXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uVG9EZWxldGUgPSBPYmplY3QuYXNzaWduKHt9LCBsYW5lW19hbmltYXRpb25JbmRleEJlZm9yZUVkaXRdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk9iamVjdFRvRGVsZXRlID0gYW5pbWF0aW9uVG9EZWxldGUuaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYW5lRGF0YSA9IGhlbHBlci5nZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tqXSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZ2V0cyB0aGUgbGFuZSB3aXRob3V0IHRoZSByZW1vdmVkIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3TGFuZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGFuZS5sZW5ndGg7IF9rKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYW5lW19rXS5pbmNpZGVudC5pZCAhPSBpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0xhbmUucHVzaChsYW5lW19rXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV0gPSBuZXdMYW5lO1xuICAgICAgICAgICAgICAgICAgICBsYW5lID0gdGhpcy5sYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5sYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZmZWN0ZWRMYW5lcy5oYXNPd25Qcm9wZXJ0eShiZWxvbmdpbmdMYW5lc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWZmZWN0ZWRMYW5lc1tiZWxvbmdpbmdMYW5lc1tqXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faW5jaWRlbnRIYXNBbmltYXRlZEF0dHJzKGFuaW1hdGlvblRvRGVsZXRlLmluY2lkZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkTGFuZXNbYmVsb25naW5nTGFuZXNbal1dID0gaGVscGVyLmdldE1DSURhbmRBdHRyT3V0T2ZMYW5lS2V5KGJlbG9uZ2luZ0xhbmVzW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2FuaW1hdGlvbkluZGV4QmVmb3JlRWRpdCA8IGxhbmUubGVuZ3RoICYmIGFuaW1hdGlvblRvRGVsZXRlLmluY2lkZW50LmdldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5lW19hbmltYXRpb25JbmRleEJlZm9yZUVkaXRdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5hdHRyaWJ1dGUsIGFuaW1hdGlvblRvRGVsZXRlLmluY2lkZW50LmdldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmVsb25naW5nTGFuZUtleXNCeUFuaW1hdGlvbklkW3JlbW92ZWRBbmltYXRpb25zW2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhZmZlY3RlZExhbmVzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgbWV0aG9kIGhhbmRsZXMgZWRpdHMgb24gdGhlIGZpbmFsIHZhbHVlIG9mIGEgc3BlY2lmaWMgYXR0cmlidXRlIG9mIGEgc3BlY2lmaWMgYW5pbWF0aW9uIG9iamVjdFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uSWQgLSB0aGUgaWQgb2YgdGhlIEFuaW1hdGlvbiBvYmplY3QgdGhhdCBoYXMgYmVlbiBlZGl0ZWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHIgLSB0aGUgbmFtZSBvZiB0aGUgYXR0cmlidXRlIHRoYXQgaGFzIGJlZW4gZWRpdGVkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSAtIHRoZSBuZXcgdmFsdWUgb2YgdGhlIGVkaXRlZCBhdHRyaWJ1dGVcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAndXBkYXRlQXR0cmlidXRlT25MYW5lcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGVPbkxhbmVzKGFuaW1hdGlvbklkLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGJlbG9uZ2luZ0xhbmVzID0gdGhpcy5iZWxvbmdpbmdMYW5lS2V5c0J5QW5pbWF0aW9uSWRbYW5pbWF0aW9uSWRdO1xuICAgICAgICAgICAgdmFyIGFmZmVjdGVkTGFuZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmVsb25naW5nTGFuZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFuZSA9IHRoaXMubGFuZXNbYmVsb25naW5nTGFuZXNbaV1dO1xuICAgICAgICAgICAgICAgIHZhciBsYW5lRGF0YSA9IGhlbHBlci5nZXRNQ0lEYW5kQXR0ck91dE9mTGFuZUtleShiZWxvbmdpbmdMYW5lc1tpXSk7XG5cbiAgICAgICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBhbmltYXRpb24gb24gdGhlIGxhbmVcbiAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGxhbmUubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhbmVba10uaW5jaWRlbnQuaWQgPT09IGFuaW1hdGlvbklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25JbmRleCA9IGs7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBhbmltYXRpb24gaXMgbm90IHRoZSBsYXN0IG9uZSBvbiB0aGUgbGFuZVxuICAgICAgICAgICAgICAgIGlmIChsYW5lLmxlbmd0aCAtIDEgIT0gYW5pbWF0aW9uSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZVthbmltYXRpb25JbmRleCArIDFdLmluY2lkZW50LnNldEluaXRpYWxWYWx1ZShsYW5lRGF0YS5tY2lkLCBsYW5lRGF0YS5hdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBhZmZlY3RlZExhbmVzLnB1c2gobGFuZURhdGEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWZmZWN0ZWRMYW5lcztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBMYW5lc0hhbmRsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGFuZXNIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/LanesHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** @classdesc Helper maintains a number of helpful functions in a single point  */\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar Helper = function () {\n    function Helper(configuration) {\n        _classCallCheck(this, Helper);\n\n        var logLevel = 2;\n        if (configuration) {\n            if (configuration.hasOwnProperty('logLevel')) {\n                logLevel = configuration.logLevel;\n            }\n        }\n\n        this.lanesMCIDattrsSeperator = '___';\n\n        for (var i = 0; i < conf.logTypes.length; i++) {\n            var logType = conf.logTypes[i];\n            if (logLevel >= logType.level) this[logType.key] = window.console.log.bind(window.console, \"MotorCortex - %c%s\", logType.style);else this[logType.key] = function () {};\n        }\n\n        if (logLevel >= 3) this.log = window.console.log.bind(window.console, \"MotorCortex - \");else this.log = function () {};\n    }\n\n    _createClass(Helper, [{\n        key: 'renderTemplate',\n        value: function renderTemplate(templateString, templateVars) {\n            return new Function(\"return `\" + templateString + \"`;\").call(templateVars);\n        }\n\n        /**\n         * @returns {string} in the form \"1bc45f78-ab23-jl59\"\n         */\n\n    }, {\n        key: 'getAnId',\n        value: function getAnId() {\n            var underscore = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n            var specialChar = '-';\n            if (underscore) {\n                specialChar = '_';\n            }\n            function s4() {\n                return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n            }\n            return s4() + s4() + specialChar + s4() + specialChar + s4();\n        }\n    }, {\n        key: 'getLaneKey',\n        value: function getLaneKey(mcid, attribute) {\n            return mcid + this.lanesMCIDattrsSeperator + attribute;\n        }\n    }, {\n        key: 'getMCIDandAttrOutOfLaneKey',\n        value: function getMCIDandAttrOutOfLaneKey(laneKey) {\n            var laneArray = laneKey.split(this.lanesMCIDattrsSeperator);\n            return {\n                mcid: laneArray[0],\n                attribute: laneArray[1]\n            };\n        }\n    }, {\n        key: 'getElementByMCID',\n        value: function getElementByMCID(context, mcid) {\n            return context.document.querySelectorAll('[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]')[0];\n        }\n    }, {\n        key: 'getMCIDOfElement',\n        value: function getMCIDOfElement(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n\n        /**\n        subdivision might be rounding the number to its:\n        - units (subdivision = 1)\n        - tenths (subdivision = 10)\n        - hundreds (subdivision = 100)\n        - thousands (subdivision = 1000)\n         @param {string} int\n         @param {subdivision} int\n         @returns {int} the rounded number\n        */\n\n    }, {\n        key: 'roundNumberTo',\n        value: function roundNumberTo(number, subdivision) {\n            return Math.round(number / subdivision) * subdivision;\n        }\n    }, {\n        key: 'isInteger',\n        value: function isInteger(number) {\n            if (number === parseInt(number, 10)) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'isString',\n        value: function isString(test) {\n            if (typeof test === 'string' || test instanceof String) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    }, {\n        key: 'isObject',\n        value: function isObject(test) {\n            return (typeof test === 'undefined' ? 'undefined' : _typeof(test)) === \"object\";\n        }\n    }, {\n        key: 'isArray',\n        value: function isArray(test) {\n            return Array.isArray(test);\n        }\n    }, {\n        key: 'isFunction',\n        value: function isFunction(functionToCheck) {\n            return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n        }\n    }, {\n        key: 'addClass',\n        value: function addClass(el, className) {\n            if (el.classList) el.classList.add(className);else el.className += ' ' + className;\n        }\n    }, {\n        key: 'removeClass',\n        value: function removeClass(el, className) {\n            if (el.classList) el.classList.remove(className);else el.className = el.className.replace(new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n        }\n    }, {\n        key: 'addStyle',\n        value: function addStyle(el, style) {\n            for (var key in style) {\n                el.style[key] = style[key];\n            }\n        }\n\n        /**\n         * systole / diastole of the projections\n         * @param {float} fraction - the duration fraction of the parent Scene\n         * @returns {array} - collection of objects with keys: {id, start, end, startDelta}\n        **/\n\n    }, {\n        key: 'systoleDiastoleProjections',\n        value: function systoleDiastoleProjections(projections, durationFraction, adjustMillisecond) {\n            var alteredProjections = [];\n\n            for (var i = 0; i < projections.length; i++) {\n                var projectedIncident = projections[i];\n\n                if (durationFraction != 1) {\n                    alteredProjections.push({\n                        id: projectedIncident.incident.id,\n                        start: projectedIncident.millisecond * durationFraction + adjustMillisecond,\n                        end: projectedIncident.millisecond * durationFraction + projectedIncident.incident.duration * durationFraction + adjustMillisecond,\n                        startDelta: projectedIncident.millisecond * durationFraction - projectedIncident.millisecond\n                    });\n                }\n            }\n\n            return alteredProjections;\n        }\n    }]);\n\n    return Helper;\n}();\n\nmodule.exports = Helper;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvSGVscGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fY29yZVV0aWxzL0hlbHBlci5qcz85ZDBiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKiogQGNsYXNzZGVzYyBIZWxwZXIgbWFpbnRhaW5zIGEgbnVtYmVyIG9mIGhlbHBmdWwgZnVuY3Rpb25zIGluIGEgc2luZ2xlIHBvaW50ICAqL1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBIZWxwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSGVscGVyKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcik7XG5cbiAgICAgICAgdmFyIGxvZ0xldmVsID0gMjtcbiAgICAgICAgaWYgKGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChjb25maWd1cmF0aW9uLmhhc093blByb3BlcnR5KCdsb2dMZXZlbCcpKSB7XG4gICAgICAgICAgICAgICAgbG9nTGV2ZWwgPSBjb25maWd1cmF0aW9uLmxvZ0xldmVsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvciA9ICdfX18nO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29uZi5sb2dUeXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvZ1R5cGUgPSBjb25mLmxvZ1R5cGVzW2ldO1xuICAgICAgICAgICAgaWYgKGxvZ0xldmVsID49IGxvZ1R5cGUubGV2ZWwpIHRoaXNbbG9nVHlwZS5rZXldID0gd2luZG93LmNvbnNvbGUubG9nLmJpbmQod2luZG93LmNvbnNvbGUsIFwiTW90b3JDb3J0ZXggLSAlYyVzXCIsIGxvZ1R5cGUuc3R5bGUpO2Vsc2UgdGhpc1tsb2dUeXBlLmtleV0gPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2dMZXZlbCA+PSAzKSB0aGlzLmxvZyA9IHdpbmRvdy5jb25zb2xlLmxvZy5iaW5kKHdpbmRvdy5jb25zb2xlLCBcIk1vdG9yQ29ydGV4IC0gXCIpO2Vsc2UgdGhpcy5sb2cgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoSGVscGVyLCBbe1xuICAgICAgICBrZXk6ICdyZW5kZXJUZW1wbGF0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJUZW1wbGF0ZSh0ZW1wbGF0ZVN0cmluZywgdGVtcGxhdGVWYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIGBcIiArIHRlbXBsYXRlU3RyaW5nICsgXCJgO1wiKS5jYWxsKHRlbXBsYXRlVmFycyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gaW4gdGhlIGZvcm0gXCIxYmM0NWY3OC1hYjIzLWpsNTlcIlxuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0QW5JZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBbklkKCkge1xuICAgICAgICAgICAgdmFyIHVuZGVyc2NvcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICAgICAgICB2YXIgc3BlY2lhbENoYXIgPSAnLSc7XG4gICAgICAgICAgICBpZiAodW5kZXJzY29yZSkge1xuICAgICAgICAgICAgICAgIHNwZWNpYWxDaGFyID0gJ18nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gczQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKDEgKyBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gczQoKSArIHM0KCkgKyBzcGVjaWFsQ2hhciArIHM0KCkgKyBzcGVjaWFsQ2hhciArIHM0KCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldExhbmVLZXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFuZUtleShtY2lkLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIHJldHVybiBtY2lkICsgdGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvciArIGF0dHJpYnV0ZTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUNJRGFuZEF0dHJPdXRPZkxhbmVLZXkobGFuZUtleSkge1xuICAgICAgICAgICAgdmFyIGxhbmVBcnJheSA9IGxhbmVLZXkuc3BsaXQodGhpcy5sYW5lc01DSURhdHRyc1NlcGVyYXRvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1jaWQ6IGxhbmVBcnJheVswXSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IGxhbmVBcnJheVsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudEJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50QnlNQ0lEKGNvbnRleHQsIG1jaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lICsgJz1cIicgKyBtY2lkICsgJ1wiXScpWzBdO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNQ0lET2ZFbGVtZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSURPZkVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgc3ViZGl2aXNpb24gbWlnaHQgYmUgcm91bmRpbmcgdGhlIG51bWJlciB0byBpdHM6XG4gICAgICAgIC0gdW5pdHMgKHN1YmRpdmlzaW9uID0gMSlcbiAgICAgICAgLSB0ZW50aHMgKHN1YmRpdmlzaW9uID0gMTApXG4gICAgICAgIC0gaHVuZHJlZHMgKHN1YmRpdmlzaW9uID0gMTAwKVxuICAgICAgICAtIHRob3VzYW5kcyAoc3ViZGl2aXNpb24gPSAxMDAwKVxuICAgICAgICAgQHBhcmFtIHtzdHJpbmd9IGludFxuICAgICAgICAgQHBhcmFtIHtzdWJkaXZpc2lvbn0gaW50XG4gICAgICAgICBAcmV0dXJucyB7aW50fSB0aGUgcm91bmRlZCBudW1iZXJcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncm91bmROdW1iZXJUbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByb3VuZE51bWJlclRvKG51bWJlciwgc3ViZGl2aXNpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKG51bWJlciAvIHN1YmRpdmlzaW9uKSAqIHN1YmRpdmlzaW9uO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc0ludGVnZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNJbnRlZ2VyKG51bWJlcikge1xuICAgICAgICAgICAgaWYgKG51bWJlciA9PT0gcGFyc2VJbnQobnVtYmVyLCAxMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N0cmluZyh0ZXN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRlc3QgPT09ICdzdHJpbmcnIHx8IHRlc3QgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdpc09iamVjdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc09iamVjdCh0ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKHR5cGVvZiB0ZXN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih0ZXN0KSkgPT09IFwib2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2lzQXJyYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaXNBcnJheSh0ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0ZXN0KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaXNGdW5jdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiB7fS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZENsYXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZENsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIGVsLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtlbHNlIGVsLmNsYXNzTmFtZSArPSAnICcgKyBjbGFzc05hbWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUNsYXNzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGVsLCBjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChlbC5jbGFzc0xpc3QpIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKTtlbHNlIGVsLmNsYXNzTmFtZSA9IGVsLmNsYXNzTmFtZS5yZXBsYWNlKG5ldyBSZWdFeHAoJyhefFxcXFxiKScgKyBjbGFzc05hbWUuc3BsaXQoJyAnKS5qb2luKCd8JykgKyAnKFxcXFxifCQpJywgJ2dpJyksICcgJyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZFN0eWxlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0eWxlKGVsLCBzdHlsZSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHN0eWxlKSB7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGVba2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogc3lzdG9sZSAvIGRpYXN0b2xlIG9mIHRoZSBwcm9qZWN0aW9uc1xuICAgICAgICAgKiBAcGFyYW0ge2Zsb2F0fSBmcmFjdGlvbiAtIHRoZSBkdXJhdGlvbiBmcmFjdGlvbiBvZiB0aGUgcGFyZW50IFNjZW5lXG4gICAgICAgICAqIEByZXR1cm5zIHthcnJheX0gLSBjb2xsZWN0aW9uIG9mIG9iamVjdHMgd2l0aCBrZXlzOiB7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XG4gICAgICAgICoqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzeXN0b2xlRGlhc3RvbGVQcm9qZWN0aW9ucycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzeXN0b2xlRGlhc3RvbGVQcm9qZWN0aW9ucyhwcm9qZWN0aW9ucywgZHVyYXRpb25GcmFjdGlvbiwgYWRqdXN0TWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIHZhciBhbHRlcmVkUHJvamVjdGlvbnMgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9qZWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0ZWRJbmNpZGVudCA9IHByb2plY3Rpb25zW2ldO1xuXG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uRnJhY3Rpb24gIT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBhbHRlcmVkUHJvamVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcHJvamVjdGVkSW5jaWRlbnQuaW5jaWRlbnQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydDogcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uICsgYWRqdXN0TWlsbGlzZWNvbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByb2plY3RlZEluY2lkZW50Lm1pbGxpc2Vjb25kICogZHVyYXRpb25GcmFjdGlvbiArIHByb2plY3RlZEluY2lkZW50LmluY2lkZW50LmR1cmF0aW9uICogZHVyYXRpb25GcmFjdGlvbiArIGFkanVzdE1pbGxpc2Vjb25kLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnREZWx0YTogcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmQgKiBkdXJhdGlvbkZyYWN0aW9uIC0gcHJvamVjdGVkSW5jaWRlbnQubWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWx0ZXJlZFByb2plY3Rpb25zO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIEhlbHBlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBIZWxwZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar Journey = function () {\n    function Journey(props) {\n        _classCallCheck(this, Journey);\n\n        if (!props.hasOwnProperty('incident')) {\n            helper.error('Journey constructor expects an Incident on its properties on the key \"incident\"');\n            return false;\n        }\n\n        this.memory = props.calpuleMemory;\n        this.stations = [];\n\n        this.incident = props.incident;\n        this.startMillisecond = this.incident.runTimeInfo.currentMillisecond * 1;\n        this.startState = this.incident.state + \"\";\n        this.incident.stop();\n    }\n\n    _createClass(Journey, [{\n        key: 'station',\n        value: function station(millisecond) {\n            var props = {};\n            if (this.stations.length > 0) {\n                props.previousStop = this.stations[this.stations.length - 1];\n            }\n            this.stations.push(millisecond);\n            // helper.log(`CAPSULE passes as previousStop: ${props.previousStop}`);\n            // helper.log(this.stations);\n            this.incident.goTo(millisecond, props);\n        }\n    }, {\n        key: 'destination',\n        value: function destination() {\n            var millisecond = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n            if (millisecond != null) {\n                this.station(millisecond);\n            } else {\n                millisecond = this.stations[this.stations.length - 1];\n            }\n            this.incident.beOn(millisecond, false);\n            if (this.startState === 'playing') {\n                this.incident.resume();\n            }\n            this.memory.push(this.exportJourneyLog);\n        }\n    }, {\n        key: 'exportJourneyLog',\n        value: function exportJourneyLog() {\n            return {\n                startMillisecond: this.startMillisecond,\n                startState: this.startState,\n                incident: this.incident.exportState(),\n                stations: this.stations\n            };\n        }\n    }]);\n\n    return Journey;\n}();\n\nvar TimeCapsule = function () {\n    function TimeCapsule() {\n        _classCallCheck(this, TimeCapsule);\n\n        this.memory = [];\n    }\n\n    _createClass(TimeCapsule, [{\n        key: 'startJourney',\n        value: function startJourney(incident) {\n            if (!incident) {\n                helper.error('startJourney expects an Incident as an argument');\n                return false;\n            }\n\n            return new Journey({ incident: incident, calpuleMemory: this.memory });\n        }\n    }]);\n\n    return TimeCapsule;\n}();\n\nmodule.exports = TimeCapsule;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvVGltZUNhcHN1bGUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19jb3JlVXRpbHMvVGltZUNhcHN1bGUuanM/YmIyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcblxudmFyIEpvdXJuZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSm91cm5leShwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSm91cm5leSk7XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaW5jaWRlbnQnKSkge1xuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdKb3VybmV5IGNvbnN0cnVjdG9yIGV4cGVjdHMgYW4gSW5jaWRlbnQgb24gaXRzIHByb3BlcnRpZXMgb24gdGhlIGtleSBcImluY2lkZW50XCInKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWVtb3J5ID0gcHJvcHMuY2FscHVsZU1lbW9yeTtcbiAgICAgICAgdGhpcy5zdGF0aW9ucyA9IFtdO1xuXG4gICAgICAgIHRoaXMuaW5jaWRlbnQgPSBwcm9wcy5pbmNpZGVudDtcbiAgICAgICAgdGhpcy5zdGFydE1pbGxpc2Vjb25kID0gdGhpcy5pbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgKiAxO1xuICAgICAgICB0aGlzLnN0YXJ0U3RhdGUgPSB0aGlzLmluY2lkZW50LnN0YXRlICsgXCJcIjtcbiAgICAgICAgdGhpcy5pbmNpZGVudC5zdG9wKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEpvdXJuZXksIFt7XG4gICAgICAgIGtleTogJ3N0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc3RhdGlvbihtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0ge307XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMucHJldmlvdXNTdG9wID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0aW9ucy5wdXNoKG1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYENBUFNVTEUgcGFzc2VzIGFzIHByZXZpb3VzU3RvcDogJHtwcm9wcy5wcmV2aW91c1N0b3B9YCk7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKHRoaXMuc3RhdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudC5nb1RvKG1pbGxpc2Vjb25kLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3RpbmF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RpbmF0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAobWlsbGlzZWNvbmQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGlvbihtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gdGhpcy5zdGF0aW9uc1t0aGlzLnN0YXRpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbmNpZGVudC5iZU9uKG1pbGxpc2Vjb25kLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydFN0YXRlID09PSAncGxheWluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluY2lkZW50LnJlc3VtZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tZW1vcnkucHVzaCh0aGlzLmV4cG9ydEpvdXJuZXlMb2cpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdleHBvcnRKb3VybmV5TG9nJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydEpvdXJuZXlMb2coKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXJ0TWlsbGlzZWNvbmQ6IHRoaXMuc3RhcnRNaWxsaXNlY29uZCxcbiAgICAgICAgICAgICAgICBzdGFydFN0YXRlOiB0aGlzLnN0YXJ0U3RhdGUsXG4gICAgICAgICAgICAgICAgaW5jaWRlbnQ6IHRoaXMuaW5jaWRlbnQuZXhwb3J0U3RhdGUoKSxcbiAgICAgICAgICAgICAgICBzdGF0aW9uczogdGhpcy5zdGF0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBKb3VybmV5O1xufSgpO1xuXG52YXIgVGltZUNhcHN1bGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGltZUNhcHN1bGUoKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaW1lQ2Fwc3VsZSk7XG5cbiAgICAgICAgdGhpcy5tZW1vcnkgPSBbXTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZUNhcHN1bGUsIFt7XG4gICAgICAgIGtleTogJ3N0YXJ0Sm91cm5leScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdGFydEpvdXJuZXkoaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ3N0YXJ0Sm91cm5leSBleHBlY3RzIGFuIEluY2lkZW50IGFzIGFuIGFyZ3VtZW50Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEpvdXJuZXkoeyBpbmNpZGVudDogaW5jaWRlbnQsIGNhbHB1bGVNZW1vcnk6IHRoaXMubWVtb3J5IH0pO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVDYXBzdWxlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVDYXBzdWxlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar AttributesAwareIncident = function (_Group) {\n    _inherits(AttributesAwareIncident, _Group);\n\n    function AttributesAwareIncident(incident) {\n        _classCallCheck(this, AttributesAwareIncident);\n\n        var _this = _possibleConstructorReturn(this, (AttributesAwareIncident.__proto__ || Object.getPrototypeOf(AttributesAwareIncident)).call(this, incident.attrs, incident.props));\n\n        _this.setUp(incident);\n        return _this;\n    }\n\n    _createClass(AttributesAwareIncident, [{\n        key: 'setUp',\n        value: function setUp(incident) {\n            this.IncidentClass = incident.constructor;\n            this.toPassToElementIncidents = {\n                plugin_channel_class: incident.plugin_channel_class,\n                mc_plugin_npm_name: incident.mc_plugin_npm_name\n            };\n            this.attributeIncidentsByAttribute = {};\n            this.cleanProps = Object.assign({}, this.props);\n            this.cleanAttrs = Object.assign({}, this.attrs);\n            delete this.cleanProps.id;\n            this.cleanAttrs.animatedAttrs = {};\n\n            for (var attr in this.attrs.animatedAttrs) {\n                this._createAttributeIncident(attr);\n            }\n        }\n\n        /**\n        * attribute groups\n        Can have on their timeline:\n        - An incident\n        Can’t have on their timeline:\n        - A plain group\n        - A dom group\n        - Another attribute group\n        */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.hasIncidents) {\n                // if it is not a group\n                return incident;\n            } else {\n                helper.error(\"attribute groups can not accept groups on their timeline\");\n                return null;\n            }\n        }\n    }, {\n        key: '_createAttributeIncident',\n        value: function _createAttributeIncident(attribute) {\n            var propsToPass = Object.assign({}, this.cleanProps);\n            var attrsToPass = Object.assign({}, this.cleanAttrs);\n            attrsToPass.animatedAttrs = {};\n            if (_typeof(this.attrs.animatedAttrs[attribute]) === 'object' && !Array.isArray(this.attrs.animatedAttrs[attribute])) {\n                attrsToPass.animatedAttrs[attribute] = Object.assign({}, this.attrs.animatedAttrs[attribute]);\n            } else if (_typeof(this.attrs.animatedAttrs[attribute]) === 'object' && Array.isArray(this.attrs.animatedAttrs[attribute])) {\n                attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute].splice(0);\n            } else {\n                attrsToPass.animatedAttrs[attribute] = this.attrs.animatedAttrs[attribute];\n            }\n\n            propsToPass.id = this.id + '_' + attribute;\n\n            var attributeIncident = new this.IncidentClass(attrsToPass, propsToPass);\n            attributeIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;\n            attributeIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;\n            this.addIncident(attributeIncident, 0);\n            this.attributeIncidentsByAttribute[attribute] = attributeIncident;\n        }\n    }, {\n        key: 'attributesChange',\n        value: function attributesChange(newAttrs) {\n            for (var i = 0; i < this.incidents; i++) {\n                // TODO execute attribute change by passing down the command\n            }\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"attribute\";\n        }\n    }]);\n\n    return AttributesAwareIncident;\n}(Group);\n\nmodule.exports = AttributesAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9BdHRyaWJ1dGVBd2FyZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvQXR0cmlidXRlQXdhcmVJbmNpZGVudC5qcz81MjQ1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudCA9IGZ1bmN0aW9uIChfR3JvdXApIHtcbiAgICBfaW5oZXJpdHMoQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQsIF9Hcm91cCk7XG5cbiAgICBmdW5jdGlvbiBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudChpbmNpZGVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50KSkuY2FsbCh0aGlzLCBpbmNpZGVudC5hdHRycywgaW5jaWRlbnQucHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zZXRVcChpbmNpZGVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoQXR0cmlidXRlc0F3YXJlSW5jaWRlbnQsIFt7XG4gICAgICAgIGtleTogJ3NldFVwJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVwKGluY2lkZW50KSB7XG4gICAgICAgICAgICB0aGlzLkluY2lkZW50Q2xhc3MgPSBpbmNpZGVudC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzID0ge1xuICAgICAgICAgICAgICAgIHBsdWdpbl9jaGFubmVsX2NsYXNzOiBpbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcyxcbiAgICAgICAgICAgICAgICBtY19wbHVnaW5fbnBtX25hbWU6IGluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlSW5jaWRlbnRzQnlBdHRyaWJ1dGUgPSB7fTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW5Qcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5jbGVhbkF0dHJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5hdHRycyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jbGVhblByb3BzLmlkO1xuICAgICAgICAgICAgdGhpcy5jbGVhbkF0dHJzLmFuaW1hdGVkQXR0cnMgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiB0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jcmVhdGVBdHRyaWJ1dGVJbmNpZGVudChhdHRyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIGF0dHJpYnV0ZSBncm91cHNcbiAgICAgICAgQ2FuIGhhdmUgb24gdGhlaXIgdGltZWxpbmU6XG4gICAgICAgIC0gQW4gaW5jaWRlbnRcbiAgICAgICAgQ2Fu4oCZdCBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAtIEEgcGxhaW4gZ3JvdXBcbiAgICAgICAgLSBBIGRvbSBncm91cFxuICAgICAgICAtIEFub3RoZXIgYXR0cmlidXRlIGdyb3VwXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19wcmVwYXJlSW5pY2RlbnRGb3JBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24oaW5jaWRlbnQpIHtcbiAgICAgICAgICAgIGlmICghaW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgbm90IGEgZ3JvdXBcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcihcImF0dHJpYnV0ZSBncm91cHMgY2FuIG5vdCBhY2NlcHQgZ3JvdXBzIG9uIHRoZWlyIHRpbWVsaW5lXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfY3JlYXRlQXR0cmlidXRlSW5jaWRlbnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUF0dHJpYnV0ZUluY2lkZW50KGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbGVhblByb3BzKTtcbiAgICAgICAgICAgIHZhciBhdHRyc1RvUGFzcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2xlYW5BdHRycyk7XG4gICAgICAgICAgICBhdHRyc1RvUGFzcy5hbmltYXRlZEF0dHJzID0ge307XG4gICAgICAgICAgICBpZiAoX3R5cGVvZih0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdKSkge1xuICAgICAgICAgICAgICAgIGF0dHJzVG9QYXNzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZih0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXSkgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodGhpcy5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0pKSB7XG4gICAgICAgICAgICAgICAgYXR0cnNUb1Bhc3MuYW5pbWF0ZWRBdHRyc1thdHRyaWJ1dGVdID0gdGhpcy5hdHRycy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0uc3BsaWNlKDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyc1RvUGFzcy5hbmltYXRlZEF0dHJzW2F0dHJpYnV0ZV0gPSB0aGlzLmF0dHJzLmFuaW1hdGVkQXR0cnNbYXR0cmlidXRlXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcHNUb1Bhc3MuaWQgPSB0aGlzLmlkICsgJ18nICsgYXR0cmlidXRlO1xuXG4gICAgICAgICAgICB2YXIgYXR0cmlidXRlSW5jaWRlbnQgPSBuZXcgdGhpcy5JbmNpZGVudENsYXNzKGF0dHJzVG9QYXNzLCBwcm9wc1RvUGFzcyk7XG4gICAgICAgICAgICBhdHRyaWJ1dGVJbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgICAgICAgYXR0cmlidXRlSW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lID0gdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMubWNfcGx1Z2luX25wbV9uYW1lO1xuICAgICAgICAgICAgdGhpcy5hZGRJbmNpZGVudChhdHRyaWJ1dGVJbmNpZGVudCwgMCk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZUluY2lkZW50c0J5QXR0cmlidXRlW2F0dHJpYnV0ZV0gPSBhdHRyaWJ1dGVJbmNpZGVudDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYXR0cmlidXRlc0NoYW5nZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhdHRyaWJ1dGVzQ2hhbmdlKG5ld0F0dHJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGV4ZWN1dGUgYXR0cmlidXRlIGNoYW5nZSBieSBwYXNzaW5nIGRvd24gdGhlIGNvbW1hbmRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ3JvdXBUeXBlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJhdHRyaWJ1dGVcIjtcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBBdHRyaWJ1dGVzQXdhcmVJbmNpZGVudDtcbn0oR3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZXNBd2FyZUluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Group = __webpack_require__(/*! ../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar DOMAwareIncident = function (_Group) {\n    _inherits(DOMAwareIncident, _Group);\n\n    function DOMAwareIncident(incident) {\n        _classCallCheck(this, DOMAwareIncident);\n\n        var _this = _possibleConstructorReturn(this, (DOMAwareIncident.__proto__ || Object.getPrototypeOf(DOMAwareIncident)).call(this, incident.attrs, incident.props));\n\n        _this.setUp(incident);\n        return _this;\n    }\n\n    _createClass(DOMAwareIncident, [{\n        key: 'setUp',\n\n\n        // props must have the elements collection and the millisecond\n        // id is also mandatory\n        value: function setUp(incident) {\n            this.originalIncident = incident;\n            this.IncidentClass = incident.constructor;\n            this.toPassToElementIncidents = {\n                plugin_channel_class: incident.plugin_channel_class,\n                mc_plugin_npm_name: incident.mc_plugin_npm_name\n            };\n            this.elementIncidentsByMCID = {};\n            this.cleanProps = Object.assign({}, this.props);\n            delete this.cleanProps.id;\n\n            if (this.context) {\n                var elements = Array.from(this.context.document.querySelectorAll(this.props.selector));\n                for (var i = 0; i < elements.length; i++) {\n                    var element = elements[i];\n                    this._createElementIncident(element);\n                }\n            }\n        }\n    }, {\n        key: 'systolDiastole',\n        value: function systolDiastole(durationFraction) {\n            _get(DOMAwareIncident.prototype.__proto__ || Object.getPrototypeOf(DOMAwareIncident.prototype), 'systolDiastole', this).call(this, durationFraction);\n            this.originalIncident.props.duration *= durationFraction;\n        }\n\n        /**\n         * dom groups\n            Can have on their timeline:\n            - An incident with no animatedAttrs \n            - An attribute group (this method should actually turn any incident with animatedAttrs to one)\n            Can’t have on their timeline:\n            - A plain group\n            - Another dom group\n         */\n\n    }, {\n        key: '_prepareInicdentForAddition',\n        value: function _prepareInicdentForAddition(incident) {\n            if (!incident.attrs.hasOwnProperty('animatedAttrs') && !incident.hasIncidents) {\n                // if the incident is not a group and it has no animatedAttrs proceed normally\n                return incident;\n            } else if (incident.groupType === \"plain\") {\n                // if the Incident is a plain group proceed normally\n                helper.error(\"dom groups can not accept plain groups on their timeline\");\n                return null;\n            } else if (incident.groupType === \"dom\") {\n                helper.error(\"dom groups can not accept other dom groups on their timeline\");\n                return null;\n            }\n\n            // We need to turn the Incident to an AttrsAwareIncident\n            // before adding it to the group\n            var AttrsAwareIncident = __webpack_require__(/*! ./AttributeAwareIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/AttributeAwareIncident.js\");\n            var theAttrsAwareIncident = new AttrsAwareIncident(incident);\n            return theAttrsAwareIncident;\n        }\n    }, {\n        key: '_createElementIncident',\n        value: function _createElementIncident(element) {\n            var mcid = this.context.getMCID(element);\n            if (!mcid) {\n                mcid = helper.getAnId(true);\n                this.context.setMCID(element, mcid);\n            }\n\n            var propsToPass = Object.assign({}, this.cleanProps);\n            propsToPass.selector = this.context.getElementSelectorByMCID(mcid); // '[data-motorocortext2-id=\"mcid1\"]' querySelectorAll()\n            propsToPass.id = this.id + '_' + mcid;\n            var elementIncident = new this.IncidentClass(this.attrs, propsToPass);\n            elementIncident.plugin_channel_class = this.toPassToElementIncidents.plugin_channel_class;\n            elementIncident.mc_plugin_npm_name = this.toPassToElementIncidents.mc_plugin_npm_name;\n            var result = this.addIncident(elementIncident, 0);\n            if (result.result === true) {\n                this.elementIncidentsByMCID[mcid] = elementIncident;\n            }\n            return result;\n        }\n\n        /**\n         * flashDOM method expects the new elements collection and:\n         * 1. Identifies which of the existing elementIncidents should go (the dom element does not participate on the DOMAwareGroup any more)\n         * 2. Identifies which elements are new and add their elementIncident on the DOMAwareGroup\n         * @returns {object} - with keys additions and deletions each of which hold an array of functions that must be\n         *  executed for adding the new element incidents and deleting the element incidents that do not apply any more\n        */\n\n    }, {\n        key: 'flashDOM',\n        value: function flashDOM() {\n            var _this2 = this;\n\n            var elements = this.context.getElements(this.props.selector);\n\n            // deletions and additions of elementIncidents that should take place according to the new elements\n            var deletions = [];\n            var additions = [];\n\n            var that = this;\n\n            // an array that will keep all new elements' keys to be used later for identifying deletions\n            var stayingElementIncidents = [];\n            // first identify additions\n\n            var _loop = function _loop(i) {\n                // for each of the new elements\n                var element = elements[i];\n                var mcid = _this2.context.getMCID(element); // take its mcid\n\n                if (!mcid) {\n                    // if the element does not have an mcid yet that means it's a new one\n                    var addition = function addition() {\n                        return that._createElementIncident(element);\n                    };\n                    additions.push(addition);\n                } else if (!_this2.elementIncidentsByMCID.hasOwnProperty(mcid)) {\n                    // else if the element has an mcid that doesn't already exist on the elementIncidents\n                    var _addition = function _addition() {\n                        return that._createElementIncident(element);\n                    };\n                    additions.push(_addition);\n                } else {\n                    stayingElementIncidents.push(mcid);\n                }\n            };\n\n            for (var i = 0; i < elements.length; i++) {\n                _loop(i);\n            }\n\n            // next step is to compare the elementIncidents with the existing elements key to see which \n            // are missing from the new set and put them for delete\n            var alreadyExistingElementsKeys = Object.keys(this.elementIncidentsByMCID);\n            var underDeletion = alreadyExistingElementsKeys.filter(function (key) {\n                return stayingElementIncidents.indexOf(key) < 0;\n            });\n\n            var _loop2 = function _loop2(i) {\n                var deletion = function deletion() {\n                    that.removeIncident(that.elementIncidentsByMCID[underDeletion[i]].id, { preventSlip: true });\n                    delete that.elementIncidentsByMCID[that.elementIncidentsByMCID[underDeletion[i]].id];\n                };\n                deletions.push(deletion);\n            };\n\n            for (var i = 0; i < underDeletion.length; i++) {\n                _loop2(i);\n            }\n\n            var failedAdditions = [];\n            for (var i = 0; i < additions.length; i++) {\n                var additionResult = additions[i]();\n                if (additionResult.result === false) {\n                    failedAdditions.push(additionResult);\n                }\n            }\n\n            for (var _i = 0; _i < deletions.length; _i++) {\n                deletions[_i]();\n            }\n\n            return {\n                failedAdditions: failedAdditions\n\n                // return {\n                //     additions: additions,\n                //     deletions: deletions\n                // }\n            };\n        }\n    }, {\n        key: 'attributesChange',\n        value: function attributesChange(newAttrs) {\n            for (var i = 0; i < this.incidents; i++) {\n                // TODO execute attribute change by passing down the command\n            }\n        }\n    }, {\n        key: 'exportState',\n        value: function exportState() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (props.hasOwnProperty('unprocessed')) {\n                if (props.unprocessed === true) {\n                    return this.originalIncident.exportState();\n                }\n            }\n            return _get(DOMAwareIncident.prototype.__proto__ || Object.getPrototypeOf(DOMAwareIncident.prototype), 'exportState', this).call(this, props);\n        }\n    }, {\n        key: 'groupType',\n        get: function get() {\n            return \"dom\";\n        }\n    }]);\n\n    return DOMAwareIncident;\n}(Group);\n\nmodule.exports = DOMAwareIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L19yZXNwb25zaXZlbmVzcy9ET01Bd2FyZUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9fcmVzcG9uc2l2ZW5lc3MvRE9NQXdhcmVJbmNpZGVudC5qcz84MDY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQob2JqZWN0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IHJldHVybiBnZXQocGFyZW50LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpOyB9IH0gZWxzZSBpZiAoXCJ2YWx1ZVwiIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9O1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoJy4uL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBET01Bd2FyZUluY2lkZW50ID0gZnVuY3Rpb24gKF9Hcm91cCkge1xuICAgIF9pbmhlcml0cyhET01Bd2FyZUluY2lkZW50LCBfR3JvdXApO1xuXG4gICAgZnVuY3Rpb24gRE9NQXdhcmVJbmNpZGVudChpbmNpZGVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NQXdhcmVJbmNpZGVudCk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERPTUF3YXJlSW5jaWRlbnQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihET01Bd2FyZUluY2lkZW50KSkuY2FsbCh0aGlzLCBpbmNpZGVudC5hdHRycywgaW5jaWRlbnQucHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5zZXRVcChpbmNpZGVudCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoRE9NQXdhcmVJbmNpZGVudCwgW3tcbiAgICAgICAga2V5OiAnc2V0VXAnLFxuXG5cbiAgICAgICAgLy8gcHJvcHMgbXVzdCBoYXZlIHRoZSBlbGVtZW50cyBjb2xsZWN0aW9uIGFuZCB0aGUgbWlsbGlzZWNvbmRcbiAgICAgICAgLy8gaWQgaXMgYWxzbyBtYW5kYXRvcnlcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVwKGluY2lkZW50KSB7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsSW5jaWRlbnQgPSBpbmNpZGVudDtcbiAgICAgICAgICAgIHRoaXMuSW5jaWRlbnRDbGFzcyA9IGluY2lkZW50LmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgdGhpcy50b1Bhc3NUb0VsZW1lbnRJbmNpZGVudHMgPSB7XG4gICAgICAgICAgICAgICAgcGx1Z2luX2NoYW5uZWxfY2xhc3M6IGluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzLFxuICAgICAgICAgICAgICAgIG1jX3BsdWdpbl9ucG1fbmFtZTogaW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEID0ge307XG4gICAgICAgICAgICB0aGlzLmNsZWFuUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsZWFuUHJvcHMuaWQ7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudHMgPSBBcnJheS5mcm9tKHRoaXMuY29udGV4dC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMucHJvcHMuc2VsZWN0b3IpKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3N5c3RvbERpYXN0b2xlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN5c3RvbERpYXN0b2xlKGR1cmF0aW9uRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIF9nZXQoRE9NQXdhcmVJbmNpZGVudC5wcm90b3R5cGUuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihET01Bd2FyZUluY2lkZW50LnByb3RvdHlwZSksICdzeXN0b2xEaWFzdG9sZScsIHRoaXMpLmNhbGwodGhpcywgZHVyYXRpb25GcmFjdGlvbik7XG4gICAgICAgICAgICB0aGlzLm9yaWdpbmFsSW5jaWRlbnQucHJvcHMuZHVyYXRpb24gKj0gZHVyYXRpb25GcmFjdGlvbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBkb20gZ3JvdXBzXG4gICAgICAgICAgICBDYW4gaGF2ZSBvbiB0aGVpciB0aW1lbGluZTpcbiAgICAgICAgICAgIC0gQW4gaW5jaWRlbnQgd2l0aCBubyBhbmltYXRlZEF0dHJzIFxuICAgICAgICAgICAgLSBBbiBhdHRyaWJ1dGUgZ3JvdXAgKHRoaXMgbWV0aG9kIHNob3VsZCBhY3R1YWxseSB0dXJuIGFueSBpbmNpZGVudCB3aXRoIGFuaW1hdGVkQXR0cnMgdG8gb25lKVxuICAgICAgICAgICAgQ2Fu4oCZdCBoYXZlIG9uIHRoZWlyIHRpbWVsaW5lOlxuICAgICAgICAgICAgLSBBIHBsYWluIGdyb3VwXG4gICAgICAgICAgICAtIEFub3RoZXIgZG9tIGdyb3VwXG4gICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfcHJlcGFyZUluaWNkZW50Rm9yQWRkaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3ByZXBhcmVJbmljZGVudEZvckFkZGl0aW9uKGluY2lkZW50KSB7XG4gICAgICAgICAgICBpZiAoIWluY2lkZW50LmF0dHJzLmhhc093blByb3BlcnR5KCdhbmltYXRlZEF0dHJzJykgJiYgIWluY2lkZW50Lmhhc0luY2lkZW50cykge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBpbmNpZGVudCBpcyBub3QgYSBncm91cCBhbmQgaXQgaGFzIG5vIGFuaW1hdGVkQXR0cnMgcHJvY2VlZCBub3JtYWxseVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jaWRlbnQuZ3JvdXBUeXBlID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgSW5jaWRlbnQgaXMgYSBwbGFpbiBncm91cCBwcm9jZWVkIG5vcm1hbGx5XG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKFwiZG9tIGdyb3VwcyBjYW4gbm90IGFjY2VwdCBwbGFpbiBncm91cHMgb24gdGhlaXIgdGltZWxpbmVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2lkZW50Lmdyb3VwVHlwZSA9PT0gXCJkb21cIikge1xuICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcihcImRvbSBncm91cHMgY2FuIG5vdCBhY2NlcHQgb3RoZXIgZG9tIGdyb3VwcyBvbiB0aGVpciB0aW1lbGluZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB0dXJuIHRoZSBJbmNpZGVudCB0byBhbiBBdHRyc0F3YXJlSW5jaWRlbnRcbiAgICAgICAgICAgIC8vIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGdyb3VwXG4gICAgICAgICAgICB2YXIgQXR0cnNBd2FyZUluY2lkZW50ID0gcmVxdWlyZSgnLi9BdHRyaWJ1dGVBd2FyZUluY2lkZW50Jyk7XG4gICAgICAgICAgICB2YXIgdGhlQXR0cnNBd2FyZUluY2lkZW50ID0gbmV3IEF0dHJzQXdhcmVJbmNpZGVudChpbmNpZGVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhlQXR0cnNBd2FyZUluY2lkZW50O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdfY3JlYXRlRWxlbWVudEluY2lkZW50JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50SW5jaWRlbnQoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG1jaWQgPSB0aGlzLmNvbnRleHQuZ2V0TUNJRChlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICghbWNpZCkge1xuICAgICAgICAgICAgICAgIG1jaWQgPSBoZWxwZXIuZ2V0QW5JZCh0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQuc2V0TUNJRChlbGVtZW50LCBtY2lkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb3BzVG9QYXNzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbGVhblByb3BzKTtcbiAgICAgICAgICAgIHByb3BzVG9QYXNzLnNlbGVjdG9yID0gdGhpcy5jb250ZXh0LmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRChtY2lkKTsgLy8gJ1tkYXRhLW1vdG9yb2NvcnRleHQyLWlkPVwibWNpZDFcIl0nIHF1ZXJ5U2VsZWN0b3JBbGwoKVxuICAgICAgICAgICAgcHJvcHNUb1Bhc3MuaWQgPSB0aGlzLmlkICsgJ18nICsgbWNpZDtcbiAgICAgICAgICAgIHZhciBlbGVtZW50SW5jaWRlbnQgPSBuZXcgdGhpcy5JbmNpZGVudENsYXNzKHRoaXMuYXR0cnMsIHByb3BzVG9QYXNzKTtcbiAgICAgICAgICAgIGVsZW1lbnRJbmNpZGVudC5wbHVnaW5fY2hhbm5lbF9jbGFzcyA9IHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzLnBsdWdpbl9jaGFubmVsX2NsYXNzO1xuICAgICAgICAgICAgZWxlbWVudEluY2lkZW50Lm1jX3BsdWdpbl9ucG1fbmFtZSA9IHRoaXMudG9QYXNzVG9FbGVtZW50SW5jaWRlbnRzLm1jX3BsdWdpbl9ucG1fbmFtZTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmFkZEluY2lkZW50KGVsZW1lbnRJbmNpZGVudCwgMCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudEluY2lkZW50c0J5TUNJRFttY2lkXSA9IGVsZW1lbnRJbmNpZGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogZmxhc2hET00gbWV0aG9kIGV4cGVjdHMgdGhlIG5ldyBlbGVtZW50cyBjb2xsZWN0aW9uIGFuZDpcbiAgICAgICAgICogMS4gSWRlbnRpZmllcyB3aGljaCBvZiB0aGUgZXhpc3RpbmcgZWxlbWVudEluY2lkZW50cyBzaG91bGQgZ28gKHRoZSBkb20gZWxlbWVudCBkb2VzIG5vdCBwYXJ0aWNpcGF0ZSBvbiB0aGUgRE9NQXdhcmVHcm91cCBhbnkgbW9yZSlcbiAgICAgICAgICogMi4gSWRlbnRpZmllcyB3aGljaCBlbGVtZW50cyBhcmUgbmV3IGFuZCBhZGQgdGhlaXIgZWxlbWVudEluY2lkZW50IG9uIHRoZSBET01Bd2FyZUdyb3VwXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IC0gd2l0aCBrZXlzIGFkZGl0aW9ucyBhbmQgZGVsZXRpb25zIGVhY2ggb2Ygd2hpY2ggaG9sZCBhbiBhcnJheSBvZiBmdW5jdGlvbnMgdGhhdCBtdXN0IGJlXG4gICAgICAgICAqICBleGVjdXRlZCBmb3IgYWRkaW5nIHRoZSBuZXcgZWxlbWVudCBpbmNpZGVudHMgYW5kIGRlbGV0aW5nIHRoZSBlbGVtZW50IGluY2lkZW50cyB0aGF0IGRvIG5vdCBhcHBseSBhbnkgbW9yZVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdmbGFzaERPTScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmbGFzaERPTSgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmNvbnRleHQuZ2V0RWxlbWVudHModGhpcy5wcm9wcy5zZWxlY3Rvcik7XG5cbiAgICAgICAgICAgIC8vIGRlbGV0aW9ucyBhbmQgYWRkaXRpb25zIG9mIGVsZW1lbnRJbmNpZGVudHMgdGhhdCBzaG91bGQgdGFrZSBwbGFjZSBhY2NvcmRpbmcgdG8gdGhlIG5ldyBlbGVtZW50c1xuICAgICAgICAgICAgdmFyIGRlbGV0aW9ucyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFkZGl0aW9ucyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgICAgIC8vIGFuIGFycmF5IHRoYXQgd2lsbCBrZWVwIGFsbCBuZXcgZWxlbWVudHMnIGtleXMgdG8gYmUgdXNlZCBsYXRlciBmb3IgaWRlbnRpZnlpbmcgZGVsZXRpb25zXG4gICAgICAgICAgICB2YXIgc3RheWluZ0VsZW1lbnRJbmNpZGVudHMgPSBbXTtcbiAgICAgICAgICAgIC8vIGZpcnN0IGlkZW50aWZ5IGFkZGl0aW9uc1xuXG4gICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGVhY2ggb2YgdGhlIG5ldyBlbGVtZW50c1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIG1jaWQgPSBfdGhpczIuY29udGV4dC5nZXRNQ0lEKGVsZW1lbnQpOyAvLyB0YWtlIGl0cyBtY2lkXG5cbiAgICAgICAgICAgICAgICBpZiAoIW1jaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgaGF2ZSBhbiBtY2lkIHlldCB0aGF0IG1lYW5zIGl0J3MgYSBuZXcgb25lXG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGRpdGlvbiA9IGZ1bmN0aW9uIGFkZGl0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoYXQuX2NyZWF0ZUVsZW1lbnRJbmNpZGVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgYWRkaXRpb25zLnB1c2goYWRkaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIV90aGlzMi5lbGVtZW50SW5jaWRlbnRzQnlNQ0lELmhhc093blByb3BlcnR5KG1jaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFuIG1jaWQgdGhhdCBkb2Vzbid0IGFscmVhZHkgZXhpc3Qgb24gdGhlIGVsZW1lbnRJbmNpZGVudHNcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hZGRpdGlvbiA9IGZ1bmN0aW9uIF9hZGRpdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGF0Ll9jcmVhdGVFbGVtZW50SW5jaWRlbnQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9ucy5wdXNoKF9hZGRpdGlvbik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RheWluZ0VsZW1lbnRJbmNpZGVudHMucHVzaChtY2lkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIG5leHQgc3RlcCBpcyB0byBjb21wYXJlIHRoZSBlbGVtZW50SW5jaWRlbnRzIHdpdGggdGhlIGV4aXN0aW5nIGVsZW1lbnRzIGtleSB0byBzZWUgd2hpY2ggXG4gICAgICAgICAgICAvLyBhcmUgbWlzc2luZyBmcm9tIHRoZSBuZXcgc2V0IGFuZCBwdXQgdGhlbSBmb3IgZGVsZXRlXG4gICAgICAgICAgICB2YXIgYWxyZWFkeUV4aXN0aW5nRWxlbWVudHNLZXlzID0gT2JqZWN0LmtleXModGhpcy5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEKTtcbiAgICAgICAgICAgIHZhciB1bmRlckRlbGV0aW9uID0gYWxyZWFkeUV4aXN0aW5nRWxlbWVudHNLZXlzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXlpbmdFbGVtZW50SW5jaWRlbnRzLmluZGV4T2Yoa2V5KSA8IDA7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlbGV0aW9uID0gZnVuY3Rpb24gZGVsZXRpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVtb3ZlSW5jaWRlbnQodGhhdC5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEW3VuZGVyRGVsZXRpb25baV1dLmlkLCB7IHByZXZlbnRTbGlwOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5lbGVtZW50SW5jaWRlbnRzQnlNQ0lEW3RoYXQuZWxlbWVudEluY2lkZW50c0J5TUNJRFt1bmRlckRlbGV0aW9uW2ldXS5pZF07XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBkZWxldGlvbnMucHVzaChkZWxldGlvbik7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZGVyRGVsZXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfbG9vcDIoaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmYWlsZWRBZGRpdGlvbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkZGl0aW9uUmVzdWx0ID0gYWRkaXRpb25zW2ldKCk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uUmVzdWx0LnJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZmFpbGVkQWRkaXRpb25zLnB1c2goYWRkaXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRlbGV0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBkZWxldGlvbnNbX2ldKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmFpbGVkQWRkaXRpb25zOiBmYWlsZWRBZGRpdGlvbnNcblxuICAgICAgICAgICAgICAgIC8vIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGFkZGl0aW9uczogYWRkaXRpb25zLFxuICAgICAgICAgICAgICAgIC8vICAgICBkZWxldGlvbnM6IGRlbGV0aW9uc1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2F0dHJpYnV0ZXNDaGFuZ2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXR0cmlidXRlc0NoYW5nZShuZXdBdHRycykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBleGVjdXRlIGF0dHJpYnV0ZSBjaGFuZ2UgYnkgcGFzc2luZyBkb3duIHRoZSBjb21tYW5kXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V4cG9ydFN0YXRlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4cG9ydFN0YXRlKCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KCd1bnByb2Nlc3NlZCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3BzLnVucHJvY2Vzc2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsSW5jaWRlbnQuZXhwb3J0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2dldChET01Bd2FyZUluY2lkZW50LnByb3RvdHlwZS5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERPTUF3YXJlSW5jaWRlbnQucHJvdG90eXBlKSwgJ2V4cG9ydFN0YXRlJywgdGhpcykuY2FsbCh0aGlzLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dyb3VwVHlwZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIFwiZG9tXCI7XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gRE9NQXdhcmVJbmNpZGVudDtcbn0oR3JvdXApO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERPTUF3YXJlSW5jaWRlbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/_responsiveness/DOMAwareIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\n\nvar allowedStateChanges = {\n    // from which states an Incident can become one of the:\n\n    idle: {\n        forwards: ['transitional'], // only from transitional\n        backwards: ['transitional', 'playing']\n    },\n    transitional: {\n        forwards: ['idle', 'playing', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'completed', 'blocked'],\n        backwards: ['idle', 'playing', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'completed', 'blocked']\n    },\n    playing: {\n        forwards: ['idle', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked'],\n        backwards: ['completed', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting', 'blocked']\n    },\n    waiting: {\n        forwards: ['playing', 'blocked', 'transitional'],\n        backwards: ['playing', 'blocked', 'transitional']\n    },\n    sceneBlockingWaiting: {\n        forwards: ['playing', 'waiting', 'blocked'],\n        backwards: ['playing', 'waiting', 'blocked']\n    },\n    clipBlockingWaiting: {\n        forwards: ['playing', 'waiting', 'blocked'],\n        backwards: ['playing', 'waiting', 'blocked']\n    },\n    completed: {\n        forwards: ['transitional', 'playing'],\n        backwards: ['transitional']\n    },\n    blocked: {\n        forwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting'],\n        backwards: ['transitional', 'playing', 'waiting', 'sceneBlockingWaiting']\n    }\n};\n\nvar timePausingStates = ['blocked', 'waiting', 'sceneBlockingWaiting', 'clipBlockingWaiting'];\n\nvar checkTransition = function checkTransition(oldState, newState, direction) {\n    if (!allowedStateChanges.hasOwnProperty(oldState)) {\n        helper.error('The state ' + oldState + ' is not recognised as one of the supported Incident states');\n        return false;\n    } else if (!allowedStateChanges.hasOwnProperty(newState)) {\n        helper.error('The state ' + newState + ' is not recognised as one of the supported Incident states');\n        return false;\n    }\n\n    if (allowedStateChanges[newState][direction].indexOf(oldState) >= 0) {\n        return true;\n    } else {\n        // helper.error('The transition from ' + oldState + ' to ' + newState + ' is not allowed');\n        return false;\n    }\n};\n\nvar isTimePausingState = function isTimePausingState(state) {\n    return timePausingStates.indexOf(state) >= 0;\n};\n\nmodule.exports = { checkTransition: checkTransition, isTimePausingState: isTimePausingState };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vYWxsb3dlZFN0YXRlQ2hhbmdlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29uZmlndXJhdGlvbi9hbGxvd2VkU3RhdGVDaGFuZ2VzLmpzPzNhNjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG5cbnZhciBhbGxvd2VkU3RhdGVDaGFuZ2VzID0ge1xuICAgIC8vIGZyb20gd2hpY2ggc3RhdGVzIGFuIEluY2lkZW50IGNhbiBiZWNvbWUgb25lIG9mIHRoZTpcblxuICAgIGlkbGU6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsndHJhbnNpdGlvbmFsJ10sIC8vIG9ubHkgZnJvbSB0cmFuc2l0aW9uYWxcbiAgICAgICAgYmFja3dhcmRzOiBbJ3RyYW5zaXRpb25hbCcsICdwbGF5aW5nJ11cbiAgICB9LFxuICAgIHRyYW5zaXRpb25hbDoge1xuICAgICAgICBmb3J3YXJkczogWydpZGxlJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJywgJ2NvbXBsZXRlZCcsICdibG9ja2VkJ10sXG4gICAgICAgIGJhY2t3YXJkczogWydpZGxlJywgJ3BsYXlpbmcnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJywgJ2NvbXBsZXRlZCcsICdibG9ja2VkJ11cbiAgICB9LFxuICAgIHBsYXlpbmc6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsnaWRsZScsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJywgJ2NsaXBCbG9ja2luZ1dhaXRpbmcnLCAnYmxvY2tlZCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsnY29tcGxldGVkJywgJ3dhaXRpbmcnLCAnc2NlbmVCbG9ja2luZ1dhaXRpbmcnLCAnY2xpcEJsb2NraW5nV2FpdGluZycsICdibG9ja2VkJ11cbiAgICB9LFxuICAgIHdhaXRpbmc6IHtcbiAgICAgICAgZm9yd2FyZHM6IFsncGxheWluZycsICdibG9ja2VkJywgJ3RyYW5zaXRpb25hbCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsncGxheWluZycsICdibG9ja2VkJywgJ3RyYW5zaXRpb25hbCddXG4gICAgfSxcbiAgICBzY2VuZUJsb2NraW5nV2FpdGluZzoge1xuICAgICAgICBmb3J3YXJkczogWydwbGF5aW5nJywgJ3dhaXRpbmcnLCAnYmxvY2tlZCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsncGxheWluZycsICd3YWl0aW5nJywgJ2Jsb2NrZWQnXVxuICAgIH0sXG4gICAgY2xpcEJsb2NraW5nV2FpdGluZzoge1xuICAgICAgICBmb3J3YXJkczogWydwbGF5aW5nJywgJ3dhaXRpbmcnLCAnYmxvY2tlZCddLFxuICAgICAgICBiYWNrd2FyZHM6IFsncGxheWluZycsICd3YWl0aW5nJywgJ2Jsb2NrZWQnXVxuICAgIH0sXG4gICAgY29tcGxldGVkOiB7XG4gICAgICAgIGZvcndhcmRzOiBbJ3RyYW5zaXRpb25hbCcsICdwbGF5aW5nJ10sXG4gICAgICAgIGJhY2t3YXJkczogWyd0cmFuc2l0aW9uYWwnXVxuICAgIH0sXG4gICAgYmxvY2tlZDoge1xuICAgICAgICBmb3J3YXJkczogWyd0cmFuc2l0aW9uYWwnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJ10sXG4gICAgICAgIGJhY2t3YXJkczogWyd0cmFuc2l0aW9uYWwnLCAncGxheWluZycsICd3YWl0aW5nJywgJ3NjZW5lQmxvY2tpbmdXYWl0aW5nJ11cbiAgICB9XG59O1xuXG52YXIgdGltZVBhdXNpbmdTdGF0ZXMgPSBbJ2Jsb2NrZWQnLCAnd2FpdGluZycsICdzY2VuZUJsb2NraW5nV2FpdGluZycsICdjbGlwQmxvY2tpbmdXYWl0aW5nJ107XG5cbnZhciBjaGVja1RyYW5zaXRpb24gPSBmdW5jdGlvbiBjaGVja1RyYW5zaXRpb24ob2xkU3RhdGUsIG5ld1N0YXRlLCBkaXJlY3Rpb24pIHtcbiAgICBpZiAoIWFsbG93ZWRTdGF0ZUNoYW5nZXMuaGFzT3duUHJvcGVydHkob2xkU3RhdGUpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignVGhlIHN0YXRlICcgKyBvbGRTdGF0ZSArICcgaXMgbm90IHJlY29nbmlzZWQgYXMgb25lIG9mIHRoZSBzdXBwb3J0ZWQgSW5jaWRlbnQgc3RhdGVzJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKCFhbGxvd2VkU3RhdGVDaGFuZ2VzLmhhc093blByb3BlcnR5KG5ld1N0YXRlKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ1RoZSBzdGF0ZSAnICsgbmV3U3RhdGUgKyAnIGlzIG5vdCByZWNvZ25pc2VkIGFzIG9uZSBvZiB0aGUgc3VwcG9ydGVkIEluY2lkZW50IHN0YXRlcycpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ZWRTdGF0ZUNoYW5nZXNbbmV3U3RhdGVdW2RpcmVjdGlvbl0uaW5kZXhPZihvbGRTdGF0ZSkgPj0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBoZWxwZXIuZXJyb3IoJ1RoZSB0cmFuc2l0aW9uIGZyb20gJyArIG9sZFN0YXRlICsgJyB0byAnICsgbmV3U3RhdGUgKyAnIGlzIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG52YXIgaXNUaW1lUGF1c2luZ1N0YXRlID0gZnVuY3Rpb24gaXNUaW1lUGF1c2luZ1N0YXRlKHN0YXRlKSB7XG4gICAgcmV0dXJuIHRpbWVQYXVzaW5nU3RhdGVzLmluZGV4T2Yoc3RhdGUpID49IDA7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgY2hlY2tUcmFuc2l0aW9uOiBjaGVja1RyYW5zaXRpb24sIGlzVGltZVBhdXNpbmdTdGF0ZTogaXNUaW1lUGF1c2luZ1N0YXRlIH07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/allowedStateChanges.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\nknown events:\n- state-change / meta: the name of the new state\n- attribute-rejection / meta: animationID, attributes\n- animation-rejection / meta: animationID\n- conflicts-on-edit\n*/\n\nvar conf = {\n    keyframe_sec_key: 'sec_',\n    elements_data_attribute_name: 'data-motorcortex2-id',\n    selfContainedContextHandler: 'iframe',\n    getMillisecondFromKeyframeKey: function getMillisecondFromKeyframeKey(keyframeKey) {\n        return parseInt(keyframeKey.slice(conf.keyframe_sec_key.length));\n    },\n    logTypes: [{\n        key: 'info',\n        style: 'color: #666;',\n        level: 5\n    }, {\n        key: 'notice',\n        style: 'background: rgba(0, 0, 0, 0.8); color:white; padding:8px;',\n        level: 4\n    }, {\n        key: 'warning',\n        style: 'color: black; background: orange;',\n        level: 2\n    }, {\n        key: 'error',\n        style: 'color: black; background: red;',\n        level: 1\n    }]\n};\n\nmodule.exports = conf;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYuanM/MWUzOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qXG5rbm93biBldmVudHM6XG4tIHN0YXRlLWNoYW5nZSAvIG1ldGE6IHRoZSBuYW1lIG9mIHRoZSBuZXcgc3RhdGVcbi0gYXR0cmlidXRlLXJlamVjdGlvbiAvIG1ldGE6IGFuaW1hdGlvbklELCBhdHRyaWJ1dGVzXG4tIGFuaW1hdGlvbi1yZWplY3Rpb24gLyBtZXRhOiBhbmltYXRpb25JRFxuLSBjb25mbGljdHMtb24tZWRpdFxuKi9cblxudmFyIGNvbmYgPSB7XG4gICAga2V5ZnJhbWVfc2VjX2tleTogJ3NlY18nLFxuICAgIGVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWU6ICdkYXRhLW1vdG9yY29ydGV4Mi1pZCcsXG4gICAgc2VsZkNvbnRhaW5lZENvbnRleHRIYW5kbGVyOiAnaWZyYW1lJyxcbiAgICBnZXRNaWxsaXNlY29uZEZyb21LZXlmcmFtZUtleTogZnVuY3Rpb24gZ2V0TWlsbGlzZWNvbmRGcm9tS2V5ZnJhbWVLZXkoa2V5ZnJhbWVLZXkpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGtleWZyYW1lS2V5LnNsaWNlKGNvbmYua2V5ZnJhbWVfc2VjX2tleS5sZW5ndGgpKTtcbiAgICB9LFxuICAgIGxvZ1R5cGVzOiBbe1xuICAgICAgICBrZXk6ICdpbmZvJyxcbiAgICAgICAgc3R5bGU6ICdjb2xvcjogIzY2NjsnLFxuICAgICAgICBsZXZlbDogNVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm90aWNlJyxcbiAgICAgICAgc3R5bGU6ICdiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOCk7IGNvbG9yOndoaXRlOyBwYWRkaW5nOjhweDsnLFxuICAgICAgICBsZXZlbDogNFxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnd2FybmluZycsXG4gICAgICAgIHN0eWxlOiAnY29sb3I6IGJsYWNrOyBiYWNrZ3JvdW5kOiBvcmFuZ2U7JyxcbiAgICAgICAgbGV2ZWw6IDJcbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vycm9yJyxcbiAgICAgICAgc3R5bGU6ICdjb2xvcjogYmxhY2s7IGJhY2tncm91bmQ6IHJlZDsnLFxuICAgICAgICBsZXZlbDogMVxuICAgIH1dXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmY7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js ***!
  \**************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Channel = __webpack_require__(/*! ../../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar PIChannel = function (_Channel) {\n    _inherits(PIChannel, _Channel);\n\n    function PIChannel() {\n        _classCallCheck(this, PIChannel);\n\n        return _possibleConstructorReturn(this, (PIChannel.__proto__ || Object.getPrototypeOf(PIChannel)).apply(this, arguments));\n    }\n\n    _createClass(PIChannel, [{\n        key: 'onInitialise',\n\n        /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n        value: function onInitialise() {\n            this.incidents = [];\n            this.incidentsById = {};\n        }\n    }, {\n        key: 'slipToLaneForwards',\n        value: function slipToLaneForwards(currentMillisecond, millisecond) {\n            var participatinIncidents = _filter(this.incidents, function (laneItem) {\n                return laneItem.millisecond > currentMillisecond && laneItem.millisecond <= millisecond;\n            });\n            // helper.log(`participating incidents: `, participatinIncidents);\n\n            for (var i = 0; i < participatinIncidents.length; i++) {\n                participatinIncidents[i].incident.command.forwards();\n            }\n\n            // this.runTimeInfo.currentMillisecond = millisecond;\n        }\n    }, {\n        key: 'slipToLaneBackwards',\n        value: function slipToLaneBackwards(currentMillisecond, millisecond) {\n            // helper.log(`participating incidents: `, participatinIncidents);\n            var participatinIncidents = _filter(this.incidents, function (laneItem) {\n                return laneItem.millisecond > millisecond && laneItem.millisecond <= currentMillisecond;\n            });\n\n            for (var i = participatinIncidents.length - 1; i >= 0; i--) {\n                participatinIncidents[i].incident.command.backwards();\n            }\n\n            // this.runTimeInfo.currentMillisecond = millisecond;\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        *\n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} -\n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var errors = [];\n            var candidateIncidentsById = {};\n\n            for (var i = 0; i < incidents.length; i++) {\n                candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {\n                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');\n                    errors.push({\n                        type: 'Already existing id',\n                        meta: {\n                            id: incidents[i].id\n                        }\n                    });\n                }\n            }\n\n            if (errors.length > 0) {\n                return {\n                    result: false,\n                    errors: errors\n                };\n            }\n\n            var that = this;\n            var exec = function exec() {\n                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n                that.incidents = that.incidents.concat(incidents);\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidentsArray.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidentsArray[i].id) {\n                            that.incidents[j].millisecond += millisecondsDelta;\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentsArray) {\n            var that = this;\n            var incidentIds = [];\n            for (var i = 0; i < incidentsArray.length; i++) {\n                incidentIds.push(incidentsArray[i].id);\n            }\n\n            var exec = function exec() {\n                var newIncidents = _filter(that.incidents, function (incident) {\n                    return incidentIds.indexOf(incident.id) === -1;\n                });\n\n                that.incidents = newIncidents;\n                for (var _i = 0; _i < incidentIds.length; _i++) {\n                    delete that.incidentsById[incidentIds[_i]];\n                }\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        * @param {array} incidents - [{id, start, end, startDelta}]\n        */\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidents.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidents[i].id) {\n                            that.incidents[j].millisecond += incidents[i].startDelta;\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n\n                that.slipToLaneForwards(0, that.runTimeInfo.currentMillisecond);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            if (from < to) {\n                // helper.log(`slipping to lane frowards from ${from} to ${to}`);\n                this.slipToLaneForwards(from, to);\n            } else if (from >= to) {\n                // helper.log(`slipping to lane backwards from ${from} to ${to}`);\n                this.slipToLaneBackwards(from, to);\n            }\n        }\n    }]);\n\n    return PIChannel;\n}(Channel);\n\nmodule.exports = PIChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9DaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvQ2hhbm5lbC5qcz9mZmFmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi4vLi4vX0NoYW5uZWxzL0NoYW5uZWwnKTtcbnZhciBfc29ydEJ5ID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5zb3J0YnkvaW5kZXguanMnKTtcbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbG9kYXNoLWN1c3RvbS1idWlsZC9tb2R1bGFyaXplL2xvZGFzaC5maWx0ZXIvaW5kZXguanMnKTtcblxudmFyIFBJQ2hhbm5lbCA9IGZ1bmN0aW9uIChfQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhQSUNoYW5uZWwsIF9DaGFubmVsKTtcblxuICAgIGZ1bmN0aW9uIFBJQ2hhbm5lbCgpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBJQ2hhbm5lbCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQSUNoYW5uZWwuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihQSUNoYW5uZWwpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUElDaGFubmVsLCBbe1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuXG4gICAgICAgIC8qXG4gICAgICAgIHRoaXMuaW5jaWRlbnRzIGlzIGEgY29sbGVjdGlvbiBvZiB7aW5jaWRlbnQsIGlkLCBtaWxsaXNlY29uZH0gb2JqZWN0cyBhbHdheXMga2VwdCBpbiBvcmRlclxuICAgICAgICAgICAgZnJvbSBsb3dlciB0byBoaWdoZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgdGhpcy5pbmNpZGV0bnNCeUlkIGlzIGFuIGluZGV4IG9mIHRoZSBpbmNpZGVudHMga2VwdCBieSBpZCAodGhpcy5pbmNpZGVudHNbaW5jaWRlbnQtaWRdID0gSW5jaWRlbnQpXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkID0ge307XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NsaXBUb0xhbmVGb3J3YXJkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwVG9MYW5lRm9yd2FyZHMoY3VycmVudE1pbGxpc2Vjb25kLCBtaWxsaXNlY29uZCkge1xuICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbkluY2lkZW50cyA9IF9maWx0ZXIodGhpcy5pbmNpZGVudHMsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCA+IGN1cnJlbnRNaWxsaXNlY29uZCAmJiBsYW5lSXRlbS5taWxsaXNlY29uZCA8PSBtaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhgcGFydGljaXBhdGluZyBpbmNpZGVudHM6IGAsIHBhcnRpY2lwYXRpbkluY2lkZW50cyk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydGljaXBhdGluSW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhdGluSW5jaWRlbnRzW2ldLmluY2lkZW50LmNvbW1hbmQuZm9yd2FyZHMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSBtaWxsaXNlY29uZDtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2xpcFRvTGFuZUJhY2t3YXJkcycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzbGlwVG9MYW5lQmFja3dhcmRzKGN1cnJlbnRNaWxsaXNlY29uZCwgbWlsbGlzZWNvbmQpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHBhcnRpY2lwYXRpbmcgaW5jaWRlbnRzOiBgLCBwYXJ0aWNpcGF0aW5JbmNpZGVudHMpO1xuICAgICAgICAgICAgdmFyIHBhcnRpY2lwYXRpbkluY2lkZW50cyA9IF9maWx0ZXIodGhpcy5pbmNpZGVudHMsIGZ1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZCA+IG1pbGxpc2Vjb25kICYmIGxhbmVJdGVtLm1pbGxpc2Vjb25kIDw9IGN1cnJlbnRNaWxsaXNlY29uZDtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gcGFydGljaXBhdGluSW5jaWRlbnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgcGFydGljaXBhdGluSW5jaWRlbnRzW2ldLmluY2lkZW50LmNvbW1hbmQuYmFja3dhcmRzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT24gdGhpcyBtZXRob2QgdGhlIHVzZXIgZGVmaW5lcyB0aGUgc3BlY2lmaWMgcnVsZXMgdGhhdCBhcHBseSBvbiB0aGUgcGx1Z2luIGl0c2VsZiBhbmQgb24gdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2luIGl0c2VsZlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHNob3VsZCBlaXRoZXIgcmV0dXJuIHtyZXN1bHQ6IHRydWV9IG9yIHtyZXN1bHQ6IGZhbHNlLCBlcnJvcnM6W3tlcnJvci1vYmplY3R9XX0sIHdoZXJlIGVycm9yLW9iamVjdCBoYXMgdGhlIHN0cnVjdHVyZTpcbiAgICAgICAgICogIHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogLy8gcmVmZXJlbmNlIHRvIHRoZSBJbmNpZGVudCBvYmplY3QgdGhhdCBoYXMgYmVlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgIGVycm9yOiAvLyB0ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gYSBjb2xsZWNpdG9uIG9mIGFsbCBpbmNpZGVudHMgdG8gYmUgYWRkZWQgb24gdGhlIGZvcm06XG4gICAgICAgICpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSAtXG4gICAgICAgICogZWl0aGVyOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDp0cnVlLFxuICAgICAgICAgICAgICAgIGV4ZWN1dGU6IC8vIGEgZnVuY3Rpb24gdGhhdCB3aGVuIGV4ZWN1dGVkIGl0IHdpbGwgYWRkIHRoZSBJbmNpZGVudHMgb24gdGhlIENoYW5uZWxzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvclxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXJyb3JzXG4gICAgICAgICAgICB9XG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrQWRkaXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tBZGRpdGlvbihpbmNpZGVudHMpIHtcbiAgICAgICAgICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHZhciBjYW5kaWRhdGVJbmNpZGVudHNCeUlkID0ge307XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZFtpbmNpZGVudHNbaV0uaWRdID0gaW5jaWRlbnRzW2ldLmluY2lkZW50O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluY2lkZW50c0J5SWQuaGFzT3duUHJvcGVydHkoaW5jaWRlbnRzW2ldLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0luY2lkZW50IHdpdGggdGhlIGlkICcgKyBpbmNpZGVudHNbaV0uaWQgKyAnIGFscmVhZHkgZXhpc3RzLiBBZGRpdGlvbiBpcyByZWplY3RlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0FscmVhZHkgZXhpc3RpbmcgaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpbmNpZGVudHNbaV0uaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c0J5SWQgPSBPYmplY3QuYXNzaWduKHRoYXQuaW5jaWRlbnRzQnlJZCwgY2FuZGlkYXRlSW5jaWRlbnRzQnlJZCk7XG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSB0aGF0LmluY2lkZW50cy5jb25jYXQoaW5jaWRlbnRzKTtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgICAgICB0aGF0LnNsaXBUb0xhbmVGb3J3YXJkcygwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICBAcGFyYW0ge2FycmF5fSBpbmNpZGVudHNBcnJheSAtIEEgY29sbGVjdGlvbiBvZiB0aGUgSW5jaWRldG5zIHRvIGdldCBlZGl0ZWQgaW4gdGhlIGZvcm06XG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgfVxuICAgICAgICBAcGFyYW0ge2ludH0gbWlsbGlzZWNvbmRzRGVsdGEtIHRoZSBkZWx0YSBvZiB0aGUgc3RhciBwb2ludCBvZiB0aGUgcHJvdmlkZWQgaW5jaWRlbnRzXG4gICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2NoZWNrRWRpdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0VkaXQoaW5jaWRlbnRzQXJyYXksIG1pbGxpc2Vjb25kc0RlbHRhKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRoYXQuaW5jaWRlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5pbmNpZGVudHNbal0uaWQgPT09IGluY2lkZW50c0FycmF5W2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gbWlsbGlzZWNvbmRzRGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuc2xpcFRvTGFuZUZvcndhcmRzKDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja0RlbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0RlbGV0ZShpbmNpZGVudHNBcnJheSkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGluY2lkZW50SWRzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5jaWRlbnRJZHMucHVzaChpbmNpZGVudHNBcnJheVtpXS5pZCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3SW5jaWRlbnRzID0gX2ZpbHRlcih0aGF0LmluY2lkZW50cywgZnVuY3Rpb24gKGluY2lkZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmNpZGVudElkcy5pbmRleE9mKGluY2lkZW50LmlkKSA9PT0gLTE7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IG5ld0luY2lkZW50cztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgaW5jaWRlbnRJZHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0LmluY2lkZW50c0J5SWRbaW5jaWRlbnRJZHNbX2ldXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LnNsaXBUb0xhbmVGb3J3YXJkcygwLCB0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50cyAtIFt7aWQsIHN0YXJ0LCBlbmQsIHN0YXJ0RGVsdGF9XVxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW2ldLnN0YXJ0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IF9zb3J0QnkodGhhdC5pbmNpZGVudHMsIFtmdW5jdGlvbiAobGFuZUl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhbmVJdGVtLm1pbGxpc2Vjb25kO1xuICAgICAgICAgICAgICAgIH1dKTtcblxuICAgICAgICAgICAgICAgIHRoYXQuc2xpcFRvTGFuZUZvcndhcmRzKDAsIHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICBAcGFyYW0ge2ludH0gZnJvbSAtIHRoZSBtaWxsaXNlY29uZCB0byBzdGFydCBmcm9tXG4gICAgICAgICBAcGFyYW0ge2ludH0gdG8gLSB0aGUgbWlsbGlzZWNvbmQgdG8gZ28gdG9cbiAgICAgICAgICovXG5cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ21vdmVUbycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVG8oZnJvbSwgdG8pIHtcbiAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pIHtcbiAgICAgICAgICAgICAgICAvLyBoZWxwZXIubG9nKGBzbGlwcGluZyB0byBsYW5lIGZyb3dhcmRzIGZyb20gJHtmcm9tfSB0byAke3RvfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpcFRvTGFuZUZvcndhcmRzKGZyb20sIHRvKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJvbSA+PSB0bykge1xuICAgICAgICAgICAgICAgIC8vIGhlbHBlci5sb2coYHNsaXBwaW5nIHRvIGxhbmUgYmFja3dhcmRzIGZyb20gJHtmcm9tfSB0byAke3RvfWApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2xpcFRvTGFuZUJhY2t3YXJkcyhmcm9tLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUElDaGFubmVsO1xufShDaGFubmVsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQSUNoYW5uZWw7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar ProgrammaticIncident = __webpack_require__(/*! ./ProgrammaticIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\");\n\nvar DummyIncident = function (_ProgrammaticIncident) {\n    _inherits(DummyIncident, _ProgrammaticIncident);\n\n    function DummyIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, DummyIncident);\n\n        return _possibleConstructorReturn(this, (DummyIncident.__proto__ || Object.getPrototypeOf(DummyIncident)).call(this, {\n            command: function command() {} }, {\n            id: props.id\n        }));\n    }\n\n    return DummyIncident;\n}(ProgrammaticIncident);\n\nmodule.exports = DummyIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9EdW1teUluY2lkZW50LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvRHVtbXlJbmNpZGVudC5qcz8xZTJjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgUHJvZ3JhbW1hdGljSW5jaWRlbnQgPSByZXF1aXJlKCcuL1Byb2dyYW1tYXRpY0luY2lkZW50Jyk7XG5cbnZhciBEdW1teUluY2lkZW50ID0gZnVuY3Rpb24gKF9Qcm9ncmFtbWF0aWNJbmNpZGVudCkge1xuICAgIF9pbmhlcml0cyhEdW1teUluY2lkZW50LCBfUHJvZ3JhbW1hdGljSW5jaWRlbnQpO1xuXG4gICAgZnVuY3Rpb24gRHVtbXlJbmNpZGVudCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRHVtbXlJbmNpZGVudCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChEdW1teUluY2lkZW50Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoRHVtbXlJbmNpZGVudCkpLmNhbGwodGhpcywge1xuICAgICAgICAgICAgY29tbWFuZDogZnVuY3Rpb24gY29tbWFuZCgpIHt9IH0sIHtcbiAgICAgICAgICAgIGlkOiBwcm9wcy5pZFxuICAgICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIER1bW15SW5jaWRlbnQ7XG59KFByb2dyYW1tYXRpY0luY2lkZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEdW1teUluY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Incident = __webpack_require__(/*! ../../_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\n\nvar ProgrammaticIncident = function (_Incident) {\n    _inherits(ProgrammaticIncident, _Incident);\n\n    function ProgrammaticIncident() {\n        var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n        _classCallCheck(this, ProgrammaticIncident);\n\n        var _this = _possibleConstructorReturn(this, (ProgrammaticIncident.__proto__ || Object.getPrototypeOf(ProgrammaticIncident)).call(this, attrs, props));\n\n        _this.command = {\n            forwards: function forwards() {},\n            backwards: function backwards() {}\n        };\n\n        if (!attrs.hasOwnProperty('command')) {\n            var _ret;\n\n            helper.error('Programmatic Incidents must have the \"command\" included on the properties');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        } else {\n            // if the user passed an object as the command\n            if (helper.isObject(attrs.command)) {\n                // we expect to find two functions residing on the \"forwards\" and \"backwards\" keys\n                if (attrs.command.hasOwnProperty('forwards')) {\n                    if (helper.isFunction(attrs.command.forwards)) {\n                        _this.command.forwards = attrs.command.forwards;\n                    } else {\n                        var _ret2;\n\n                        helper.error('ProgrammaticIncident\\'s command.forwards key should hold a function. ' + _typeof(attrs.command.forwards) + ' passed');\n                        return _ret2 = false, _possibleConstructorReturn(_this, _ret2);\n                    }\n                }\n                if (attrs.command.hasOwnProperty('backwards')) {\n                    if (helper.isFunction(attrs.command.backwards)) {\n                        _this.command.backwards = attrs.command.backwards;\n                    } else {\n                        var _ret3;\n\n                        helper.error('ProgrammaticIncident\\'s command.backwards key should hold a function. ' + _typeof(attrs.command.backwards) + ' passed');\n                        return _ret3 = false, _possibleConstructorReturn(_this, _ret3);\n                    }\n                }\n            } else if (helper.isFunction(attrs.command)) {\n                // else if the passed argument is a function we only hold this as the forwards command\n                _this.command.forwards = attrs.command;\n            } else {\n                var _ret4;\n\n                // else if the passed argument is neither function nor object return false\n                helper.error('command key of ProgrammaticIncidents\\' construction properties must be either an object or a function. ' + _typeof(attrs.command) + ' passed');\n                return _ret4 = false, _possibleConstructorReturn(_this, _ret4);\n            }\n        }\n        return _this;\n    }\n\n    _createClass(ProgrammaticIncident, [{\n        key: 'onPlay',\n        value: function onPlay(props) {\n            if (this.speed > 0) {\n                this.command.forwards(props);\n            } else {\n                this.command.backwards(props);\n            }\n        }\n    }]);\n\n    return ProgrammaticIncident;\n}(Incident);\n\nmodule.exports = ProgrammaticIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9Qcm9ncmFtbWF0aWNJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvUHJvZ3JhbW1hdGljSW5jaWRlbnRzL1Byb2dyYW1tYXRpY0luY2lkZW50LmpzPzdiZDkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIEluY2lkZW50ID0gcmVxdWlyZSgnLi4vLi4vX0Jhc2VDbGFzc2VzL0luY2lkZW50Jyk7XG5cbnZhciBQcm9ncmFtbWF0aWNJbmNpZGVudCA9IGZ1bmN0aW9uIChfSW5jaWRlbnQpIHtcbiAgICBfaW5oZXJpdHMoUHJvZ3JhbW1hdGljSW5jaWRlbnQsIF9JbmNpZGVudCk7XG5cbiAgICBmdW5jdGlvbiBQcm9ncmFtbWF0aWNJbmNpZGVudCgpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3JhbW1hdGljSW5jaWRlbnQpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChQcm9ncmFtbWF0aWNJbmNpZGVudC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKFByb2dyYW1tYXRpY0luY2lkZW50KSkuY2FsbCh0aGlzLCBhdHRycywgcHJvcHMpKTtcblxuICAgICAgICBfdGhpcy5jb21tYW5kID0ge1xuICAgICAgICAgICAgZm9yd2FyZHM6IGZ1bmN0aW9uIGZvcndhcmRzKCkge30sXG4gICAgICAgICAgICBiYWNrd2FyZHM6IGZ1bmN0aW9uIGJhY2t3YXJkcygpIHt9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCFhdHRycy5oYXNPd25Qcm9wZXJ0eSgnY29tbWFuZCcpKSB7XG4gICAgICAgICAgICB2YXIgX3JldDtcblxuICAgICAgICAgICAgaGVscGVyLmVycm9yKCdQcm9ncmFtbWF0aWMgSW5jaWRlbnRzIG11c3QgaGF2ZSB0aGUgXCJjb21tYW5kXCIgaW5jbHVkZWQgb24gdGhlIHByb3BlcnRpZXMnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSB1c2VyIHBhc3NlZCBhbiBvYmplY3QgYXMgdGhlIGNvbW1hbmRcbiAgICAgICAgICAgIGlmIChoZWxwZXIuaXNPYmplY3QoYXR0cnMuY29tbWFuZCkpIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBleHBlY3QgdG8gZmluZCB0d28gZnVuY3Rpb25zIHJlc2lkaW5nIG9uIHRoZSBcImZvcndhcmRzXCIgYW5kIFwiYmFja3dhcmRzXCIga2V5c1xuICAgICAgICAgICAgICAgIGlmIChhdHRycy5jb21tYW5kLmhhc093blByb3BlcnR5KCdmb3J3YXJkcycpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoZWxwZXIuaXNGdW5jdGlvbihhdHRycy5jb21tYW5kLmZvcndhcmRzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tbWFuZC5mb3J3YXJkcyA9IGF0dHJzLmNvbW1hbmQuZm9yd2FyZHM7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3JldDI7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignUHJvZ3JhbW1hdGljSW5jaWRlbnRcXCdzIGNvbW1hbmQuZm9yd2FyZHMga2V5IHNob3VsZCBob2xkIGEgZnVuY3Rpb24uICcgKyBfdHlwZW9mKGF0dHJzLmNvbW1hbmQuZm9yd2FyZHMpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmV0MiA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhdHRycy5jb21tYW5kLmhhc093blByb3BlcnR5KCdiYWNrd2FyZHMnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGVscGVyLmlzRnVuY3Rpb24oYXR0cnMuY29tbWFuZC5iYWNrd2FyZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21tYW5kLmJhY2t3YXJkcyA9IGF0dHJzLmNvbW1hbmQuYmFja3dhcmRzO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXQzO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ1Byb2dyYW1tYXRpY0luY2lkZW50XFwncyBjb21tYW5kLmJhY2t3YXJkcyBrZXkgc2hvdWxkIGhvbGQgYSBmdW5jdGlvbi4gJyArIF90eXBlb2YoYXR0cnMuY29tbWFuZC5iYWNrd2FyZHMpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmV0MyA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChoZWxwZXIuaXNGdW5jdGlvbihhdHRycy5jb21tYW5kKSkge1xuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uIHdlIG9ubHkgaG9sZCB0aGlzIGFzIHRoZSBmb3J3YXJkcyBjb21tYW5kXG4gICAgICAgICAgICAgICAgX3RoaXMuY29tbWFuZC5mb3J3YXJkcyA9IGF0dHJzLmNvbW1hbmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfcmV0NDtcblxuICAgICAgICAgICAgICAgIC8vIGVsc2UgaWYgdGhlIHBhc3NlZCBhcmd1bWVudCBpcyBuZWl0aGVyIGZ1bmN0aW9uIG5vciBvYmplY3QgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdjb21tYW5kIGtleSBvZiBQcm9ncmFtbWF0aWNJbmNpZGVudHNcXCcgY29uc3RydWN0aW9uIHByb3BlcnRpZXMgbXVzdCBiZSBlaXRoZXIgYW4gb2JqZWN0IG9yIGEgZnVuY3Rpb24uICcgKyBfdHlwZW9mKGF0dHJzLmNvbW1hbmQpICsgJyBwYXNzZWQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JldDQgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFByb2dyYW1tYXRpY0luY2lkZW50LCBbe1xuICAgICAgICBrZXk6ICdvblBsYXknLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25QbGF5KHByb3BzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQuZm9yd2FyZHMocHJvcHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmQuYmFja3dhcmRzKHByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQcm9ncmFtbWF0aWNJbmNpZGVudDtcbn0oSW5jaWRlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyYW1tYXRpY0luY2lkZW50OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js ***!
  \***********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ProgrammaticIncident = __webpack_require__(/*! ./ProgrammaticIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/ProgrammaticIncident.js\");\nvar DummyIncident = __webpack_require__(/*! ./DummyIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/DummyIncident.js\");\nvar PIChannel = __webpack_require__(/*! ./Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/Channel.js\");\n\nmodule.exports = {\n    npm_name: \"@kissmybutton/programmatic-incidents\",\n    incidents: [{\n        exportable: ProgrammaticIncident\n    }, {\n        exportable: DummyIncident\n    }],\n    channel: PIChannel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1Byb2dyYW1tYXRpY0luY2lkZW50cy9tYWluLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvbWFpbi5qcz8zZjNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFByb2dyYW1tYXRpY0luY2lkZW50ID0gcmVxdWlyZSgnLi9Qcm9ncmFtbWF0aWNJbmNpZGVudCcpO1xudmFyIER1bW15SW5jaWRlbnQgPSByZXF1aXJlKCcuL0R1bW15SW5jaWRlbnQnKTtcbnZhciBQSUNoYW5uZWwgPSByZXF1aXJlKCcuL0NoYW5uZWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbnBtX25hbWU6IFwiQGtpc3NteWJ1dHRvbi9wcm9ncmFtbWF0aWMtaW5jaWRlbnRzXCIsXG4gICAgaW5jaWRlbnRzOiBbe1xuICAgICAgICBleHBvcnRhYmxlOiBQcm9ncmFtbWF0aWNJbmNpZGVudFxuICAgIH0sIHtcbiAgICAgICAgZXhwb3J0YWJsZTogRHVtbXlJbmNpZGVudFxuICAgIH1dLFxuICAgIGNoYW5uZWw6IFBJQ2hhbm5lbFxufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Clip = __webpack_require__(/*! ./SCGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\");\nvar Channel = __webpack_require__(/*! ./SCIChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\n\nfunction ClipFromDefinition(definition) {\n    if (definition === null) {\n        helper.error('ClipFromDefinition expects the defintion parameter');\n        return false;\n    }\n\n    var clip = new Clip(definition.attrs, definition.props);\n    clip.plugin_channel_class = Channel;\n    clip.mc_plugin_npm_name = \"@kissmybutton/self-contained-incidents\";\n    constructIncidents(clip, definition);\n\n    return clip;\n}\n\nfunction constructIncidents(parentIncident, incidentDefinition) {\n    if (parentIncident.hasIncidents) {\n        for (var i = 0; i < incidentDefinition.incidents.length; i++) {\n            var incidentItem = incidentDefinition.incidents[i];\n            // incidentItem is an object:\n            /*\n            {\n                id\n                millisecond\n                incident\n            }\n            */\n\n            var theNewIncident = new incidentItem.incident.Incident(incidentItem.incident.attrs, incidentItem.incident.props);\n            theNewIncident.plugin_channel_class = incidentItem.incident.plugin_channel_class;\n            theNewIncident.mc_plugin_npm_name = incidentItem.incident.mc_plugin_npm_name;\n            parentIncident.addIncident(theNewIncident, incidentItem.millisecond);\n            constructIncidents(theNewIncident, incidentItem.incident);\n        }\n    }\n}\n\nmodule.exports = ClipFromDefinition;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvQ2xpcEZyb21EZWZpbml0aW9uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL0NsaXBGcm9tRGVmaW5pdGlvbi5qcz82ODYzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIENsaXAgPSByZXF1aXJlKCcuL1NDR3JvdXAnKTtcbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi9TQ0lDaGFubmVsJyk7XG5cbmZ1bmN0aW9uIENsaXBGcm9tRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgaWYgKGRlZmluaXRpb24gPT09IG51bGwpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKCdDbGlwRnJvbURlZmluaXRpb24gZXhwZWN0cyB0aGUgZGVmaW50aW9uIHBhcmFtZXRlcicpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGNsaXAgPSBuZXcgQ2xpcChkZWZpbml0aW9uLmF0dHJzLCBkZWZpbml0aW9uLnByb3BzKTtcbiAgICBjbGlwLnBsdWdpbl9jaGFubmVsX2NsYXNzID0gQ2hhbm5lbDtcbiAgICBjbGlwLm1jX3BsdWdpbl9ucG1fbmFtZSA9IFwiQGtpc3NteWJ1dHRvbi9zZWxmLWNvbnRhaW5lZC1pbmNpZGVudHNcIjtcbiAgICBjb25zdHJ1Y3RJbmNpZGVudHMoY2xpcCwgZGVmaW5pdGlvbik7XG5cbiAgICByZXR1cm4gY2xpcDtcbn1cblxuZnVuY3Rpb24gY29uc3RydWN0SW5jaWRlbnRzKHBhcmVudEluY2lkZW50LCBpbmNpZGVudERlZmluaXRpb24pIHtcbiAgICBpZiAocGFyZW50SW5jaWRlbnQuaGFzSW5jaWRlbnRzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnREZWZpbml0aW9uLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGluY2lkZW50SXRlbSA9IGluY2lkZW50RGVmaW5pdGlvbi5pbmNpZGVudHNbaV07XG4gICAgICAgICAgICAvLyBpbmNpZGVudEl0ZW0gaXMgYW4gb2JqZWN0OlxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgaW5jaWRlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIHZhciB0aGVOZXdJbmNpZGVudCA9IG5ldyBpbmNpZGVudEl0ZW0uaW5jaWRlbnQuSW5jaWRlbnQoaW5jaWRlbnRJdGVtLmluY2lkZW50LmF0dHJzLCBpbmNpZGVudEl0ZW0uaW5jaWRlbnQucHJvcHMpO1xuICAgICAgICAgICAgdGhlTmV3SW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3MgPSBpbmNpZGVudEl0ZW0uaW5jaWRlbnQucGx1Z2luX2NoYW5uZWxfY2xhc3M7XG4gICAgICAgICAgICB0aGVOZXdJbmNpZGVudC5tY19wbHVnaW5fbnBtX25hbWUgPSBpbmNpZGVudEl0ZW0uaW5jaWRlbnQubWNfcGx1Z2luX25wbV9uYW1lO1xuICAgICAgICAgICAgcGFyZW50SW5jaWRlbnQuYWRkSW5jaWRlbnQodGhlTmV3SW5jaWRlbnQsIGluY2lkZW50SXRlbS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICBjb25zdHJ1Y3RJbmNpZGVudHModGhlTmV3SW5jaWRlbnQsIGluY2lkZW50SXRlbS5pbmNpZGVudCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpcEZyb21EZWZpbml0aW9uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js ***!
  \***************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar Group = __webpack_require__(/*! ../../_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\n// context handlers\nvar IframeContextHandler = __webpack_require__(/*! ./helpers/IframeContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js\");\nvar PlainContextHandler = __webpack_require__(/*! ./helpers/PlainContextHandler */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js\");\nvar OpenIframeContextHandler = __webpack_require__(/*! ./helpers/InheritStyleIframeContextHanlder */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js\");\n\nvar Clip = function (_Group) {\n    _inherits(Clip, _Group);\n\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n     * - type (optional, defaults to \"iframe\") the type of the Clip. It can be one of the:\n     *  - iframe \n     *  - plain\n    */\n    function Clip() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var oldProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        _classCallCheck(this, Clip);\n\n        var attrsToPass = void 0,\n            propsToUse = void 0;\n\n        /*\n        backwards compatibility. If the user doesn't pass a second argument on the constructor then this is \n        the new way of initialising a Group (only props).\n        */\n        if (oldProps === null) {\n            attrsToPass = {};\n            propsToUse = props;\n        } else {\n            // else, in case the user has passed two arguments then both should be used\n            attrsToPass = props;\n            propsToUse = oldProps;\n        }\n\n        if (!helper.isObject(propsToUse)) {\n            var _ret;\n\n            helper.error('Self Contained Incident expects an object on its second argument on the constructor. ' + (typeof propsToUse === 'undefined' ? 'undefined' : _typeof(propsToUse)) + ' passed');\n            return _ret = false, _possibleConstructorReturn(_this, _ret);\n        }\n\n        var clipType = conf.selfContainedContextHandler;\n        if (propsToUse.hasOwnProperty(\"type\")) {\n            clipType = propsToUse.type;\n        }\n\n        if (!propsToUse.hasOwnProperty('html') && (clipType === \"iframe\" || clipType === \"openiframe\")) {\n            var _ret2;\n\n            helper.error('Self Contained Incident expects the html key on its constructor properties which is missing');\n            return _ret2 = false, _possibleConstructorReturn(_this, _ret2);\n        }\n\n        if (!propsToUse.hasOwnProperty('css') && clipType === \"iframe\") {\n            var _ret3;\n\n            helper.error('Self Contained Incident expects the css key on its constructor properties which is missing');\n            return _ret3 = false, _possibleConstructorReturn(_this, _ret3);\n        }\n\n        if (!propsToUse.hasOwnProperty('host')) {\n            var _ret4;\n\n            helper.error('Self Contained Incident expects the host key on its constructor properties which is missing');\n            return _ret4 = false, _possibleConstructorReturn(_this, _ret4);\n        }\n\n        var ContextHanlder = null;\n        if (clipType === 'iframe') {\n            ContextHanlder = IframeContextHandler;\n        } else if (clipType === \"plain\") {\n            ContextHanlder = PlainContextHandler;\n        } else if (clipType === \"openiframe\") {\n            ContextHanlder = OpenIframeContextHandler;\n        } else {\n            var _ret5;\n\n            helper.error('Clip type ' + clipType + ' is not supported');\n            return _ret5 = false, _possibleConstructorReturn(_this, _ret5);\n        }\n\n        var contextHanlder = new ContextHanlder(propsToUse);\n\n        var _this = _possibleConstructorReturn(this, (Clip.__proto__ || Object.getPrototypeOf(Clip)).call(this, attrsToPass, propsToUse));\n\n        _this.ownContext = contextHanlder.context;\n        _this.isTheClip = true;\n        _this.onClipInitialise();\n        return _this;\n    }\n\n    _createClass(Clip, [{\n        key: 'onClipInitialise',\n        value: function onClipInitialise() {\n            // called when group gets initialised\n        }\n    }, {\n        key: '_getChannel',\n        value: function _getChannel(channelId) {\n            if (!this.instantiatedChannels.hasOwnProperty(channelId)) {\n                return null;\n            } else {\n                return this.instantiatedChannels[channelId];\n            }\n        }\n    }, {\n        key: 'complete',\n        value: function complete() {\n            var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n            if (this.speed > 0) {\n                if (!this.checkStateTransition('completed')) {\n                    return false;\n                }\n            } else {\n                if (!this.checkStateTransition('idle')) {\n                    return false;\n                }\n            }\n\n            this.onBeforeComplete(props);\n\n            if (this.speed > 0) {\n                if (this.checkParentScene()) {\n                    // if it has parent, so it's not the root Clip\n                    this.runTimeInfo.currentMillisecond = this.duration; // normal behaviour\n                } else {\n                    // if it is the root clip\n                    this.stop();\n                    this._setState('idle');\n                    this.setCurrentMillisecond(0);\n                }\n            } else {\n                this._setState('idle');\n            }\n\n            if (this.speed > 0) {\n                this.runTimeInfo.currentMillisecond = this.duration;\n            } else {\n                this.runTimeInfo.currentMillisecond = 0;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'lastWish',\n        value: function lastWish() {\n            this.ownContext.unmount();\n        }\n    }, {\n        key: 'renderHTML',\n        value: function renderHTML() {}\n    }, {\n        key: 'renderCSS',\n        value: function renderCSS() {}\n    }]);\n\n    return Clip;\n}(Group);\n\nmodule.exports = Clip;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvU0NHcm91cC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9TQ0dyb3VwLmpzP2I2M2IiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIEdyb3VwID0gcmVxdWlyZSgnLi4vLi4vX0Jhc2VDbGFzc2VzL0dyb3VwJyk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxuLy8gY29udGV4dCBoYW5kbGVyc1xudmFyIElmcmFtZUNvbnRleHRIYW5kbGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL0lmcmFtZUNvbnRleHRIYW5kbGVyJyk7XG52YXIgUGxhaW5Db250ZXh0SGFuZGxlciA9IHJlcXVpcmUoJy4vaGVscGVycy9QbGFpbkNvbnRleHRIYW5kbGVyJyk7XG52YXIgT3BlbklmcmFtZUNvbnRleHRIYW5kbGVyID0gcmVxdWlyZSgnLi9oZWxwZXJzL0luaGVyaXRTdHlsZUlmcmFtZUNvbnRleHRIYW5sZGVyJyk7XG5cbnZhciBDbGlwID0gZnVuY3Rpb24gKF9Hcm91cCkge1xuICAgIF9pbmhlcml0cyhDbGlwLCBfR3JvdXApO1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BzIC0gYW4gb2JqZWN0IHRoYXQgc2hvdWxkIGNvbnRhaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICAgKiAtIGh0bWwgKHRoZSBodG1sIHRlbXBsYXRlIHRvIHJlbmRlcilcbiAgICAgKiAtIGNzcyAodGhlIGNzcyB0ZW1wbGF0ZSBvZiB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGluaXRQYXJhbXMgKG9wdGlvbmFsIC8gdGhlIGluaXRpYWxpc2F0aW9uIHBhcmFtZXRlcmVzIHRoYXQgd2lsbCBiZSBwYXNzZWQgYm90aCBvbiB0aGUgY3NzIGFuZCB0aGUgaHRtbCB0ZW1wbGF0ZXMgaW4gb3JkZXIgdG8gcmVuZGVyKVxuICAgICAqIC0gaG9zdCAoYW4gRWxlbWVudCBvYmplY3QgdGhhdCB3aWxsIGhvc3QgdGhlIGlzb2xhdGVkIHRyZWUpXG4gICAgICogLSBjb250YWluZXJQYXJhbXMgKGFuIG9iamVjdCB0aGF0IGhvbGRzIHBhcmFtZXRlcnMgdG8gYWZmZWN0IHRoZSBjb250YWluZXIgb2YgdGhlIGlzb2xhdGVkIHRyZWUsIGUuZy4gd2lkdGgsIGhlaWdodCBldGMpXG4gICAgICogLSB0eXBlIChvcHRpb25hbCwgZGVmYXVsdHMgdG8gXCJpZnJhbWVcIikgdGhlIHR5cGUgb2YgdGhlIENsaXAuIEl0IGNhbiBiZSBvbmUgb2YgdGhlOlxuICAgICAqICAtIGlmcmFtZSBcbiAgICAgKiAgLSBwbGFpblxuICAgICovXG4gICAgZnVuY3Rpb24gQ2xpcCgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIG9sZFByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwKTtcblxuICAgICAgICB2YXIgYXR0cnNUb1Bhc3MgPSB2b2lkIDAsXG4gICAgICAgICAgICBwcm9wc1RvVXNlID0gdm9pZCAwO1xuXG4gICAgICAgIC8qXG4gICAgICAgIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBJZiB0aGUgdXNlciBkb2Vzbid0IHBhc3MgYSBzZWNvbmQgYXJndW1lbnQgb24gdGhlIGNvbnN0cnVjdG9yIHRoZW4gdGhpcyBpcyBcbiAgICAgICAgdGhlIG5ldyB3YXkgb2YgaW5pdGlhbGlzaW5nIGEgR3JvdXAgKG9ubHkgcHJvcHMpLlxuICAgICAgICAqL1xuICAgICAgICBpZiAob2xkUHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGF0dHJzVG9QYXNzID0ge307XG4gICAgICAgICAgICBwcm9wc1RvVXNlID0gcHJvcHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbHNlLCBpbiBjYXNlIHRoZSB1c2VyIGhhcyBwYXNzZWQgdHdvIGFyZ3VtZW50cyB0aGVuIGJvdGggc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIGF0dHJzVG9QYXNzID0gcHJvcHM7XG4gICAgICAgICAgICBwcm9wc1RvVXNlID0gb2xkUHJvcHM7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlbHBlci5pc09iamVjdChwcm9wc1RvVXNlKSkge1xuICAgICAgICAgICAgdmFyIF9yZXQ7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignU2VsZiBDb250YWluZWQgSW5jaWRlbnQgZXhwZWN0cyBhbiBvYmplY3Qgb24gaXRzIHNlY29uZCBhcmd1bWVudCBvbiB0aGUgY29uc3RydWN0b3IuICcgKyAodHlwZW9mIHByb3BzVG9Vc2UgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzVG9Vc2UpKSArICcgcGFzc2VkJyk7XG4gICAgICAgICAgICByZXR1cm4gX3JldCA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2xpcFR5cGUgPSBjb25mLnNlbGZDb250YWluZWRDb250ZXh0SGFuZGxlcjtcbiAgICAgICAgaWYgKHByb3BzVG9Vc2UuaGFzT3duUHJvcGVydHkoXCJ0eXBlXCIpKSB7XG4gICAgICAgICAgICBjbGlwVHlwZSA9IHByb3BzVG9Vc2UudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHNUb1VzZS5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpICYmIChjbGlwVHlwZSA9PT0gXCJpZnJhbWVcIiB8fCBjbGlwVHlwZSA9PT0gXCJvcGVuaWZyYW1lXCIpKSB7XG4gICAgICAgICAgICB2YXIgX3JldDI7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignU2VsZiBDb250YWluZWQgSW5jaWRlbnQgZXhwZWN0cyB0aGUgaHRtbCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXQyID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0Mik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzVG9Vc2UuaGFzT3duUHJvcGVydHkoJ2NzcycpICYmIGNsaXBUeXBlID09PSBcImlmcmFtZVwiKSB7XG4gICAgICAgICAgICB2YXIgX3JldDM7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignU2VsZiBDb250YWluZWQgSW5jaWRlbnQgZXhwZWN0cyB0aGUgY3NzIGtleSBvbiBpdHMgY29uc3RydWN0b3IgcHJvcGVydGllcyB3aGljaCBpcyBtaXNzaW5nJyk7XG4gICAgICAgICAgICByZXR1cm4gX3JldDMgPSBmYWxzZSwgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oX3RoaXMsIF9yZXQzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHNUb1VzZS5oYXNPd25Qcm9wZXJ0eSgnaG9zdCcpKSB7XG4gICAgICAgICAgICB2YXIgX3JldDQ7XG5cbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignU2VsZiBDb250YWluZWQgSW5jaWRlbnQgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIF9yZXQ0ID0gZmFsc2UsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKF90aGlzLCBfcmV0NCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgQ29udGV4dEhhbmxkZXIgPSBudWxsO1xuICAgICAgICBpZiAoY2xpcFR5cGUgPT09ICdpZnJhbWUnKSB7XG4gICAgICAgICAgICBDb250ZXh0SGFubGRlciA9IElmcmFtZUNvbnRleHRIYW5kbGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGNsaXBUeXBlID09PSBcInBsYWluXCIpIHtcbiAgICAgICAgICAgIENvbnRleHRIYW5sZGVyID0gUGxhaW5Db250ZXh0SGFuZGxlcjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGlwVHlwZSA9PT0gXCJvcGVuaWZyYW1lXCIpIHtcbiAgICAgICAgICAgIENvbnRleHRIYW5sZGVyID0gT3BlbklmcmFtZUNvbnRleHRIYW5kbGVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9yZXQ1O1xuXG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NsaXAgdHlwZSAnICsgY2xpcFR5cGUgKyAnIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBfcmV0NSA9IGZhbHNlLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihfdGhpcywgX3JldDUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRleHRIYW5sZGVyID0gbmV3IENvbnRleHRIYW5sZGVyKHByb3BzVG9Vc2UpO1xuXG4gICAgICAgIHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChDbGlwLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2xpcCkpLmNhbGwodGhpcywgYXR0cnNUb1Bhc3MsIHByb3BzVG9Vc2UpKTtcblxuICAgICAgICBfdGhpcy5vd25Db250ZXh0ID0gY29udGV4dEhhbmxkZXIuY29udGV4dDtcbiAgICAgICAgX3RoaXMuaXNUaGVDbGlwID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMub25DbGlwSW5pdGlhbGlzZSgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKENsaXAsIFt7XG4gICAgICAgIGtleTogJ29uQ2xpcEluaXRpYWxpc2UnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGlwSW5pdGlhbGlzZSgpIHtcbiAgICAgICAgICAgIC8vIGNhbGxlZCB3aGVuIGdyb3VwIGdldHMgaW5pdGlhbGlzZWRcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2dldENoYW5uZWwnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2dldENoYW5uZWwoY2hhbm5lbElkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFudGlhdGVkQ2hhbm5lbHMuaGFzT3duUHJvcGVydHkoY2hhbm5lbElkKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW50aWF0ZWRDaGFubmVsc1tjaGFubmVsSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjb21wbGV0ZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wbGV0ZSgpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jaGVja1N0YXRlVHJhbnNpdGlvbignY29tcGxldGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrU3RhdGVUcmFuc2l0aW9uKCdpZGxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5vbkJlZm9yZUNvbXBsZXRlKHByb3BzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuc3BlZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hlY2tQYXJlbnRTY2VuZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGhhcyBwYXJlbnQsIHNvIGl0J3Mgbm90IHRoZSByb290IENsaXBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQgPSB0aGlzLmR1cmF0aW9uOyAvLyBub3JtYWwgYmVoYXZpb3VyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgdGhlIHJvb3QgY2xpcFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2lkbGUnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50TWlsbGlzZWNvbmQoMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaWRsZScpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5zcGVlZCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCA9IHRoaXMuZHVyYXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2xhc3RXaXNoJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGxhc3RXaXNoKCkge1xuICAgICAgICAgICAgdGhpcy5vd25Db250ZXh0LnVubW91bnQoKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVySFRNTCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJIVE1MKCkge31cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbmRlckNTUycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDU1MoKSB7fVxuICAgIH1dKTtcblxuICAgIHJldHVybiBDbGlwO1xufShHcm91cCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xpcDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Helper = __webpack_require__(/*! ../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Channel = __webpack_require__(/*! ../../_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar _sortBy = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.sortby/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\");\nvar _filter = __webpack_require__(/*! ../../../lodash-custom-build/modularize/lodash.filter/index.js */ \"./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\");\n\nvar SCIChannel = function (_Channel) {\n    _inherits(SCIChannel, _Channel);\n\n    function SCIChannel() {\n        _classCallCheck(this, SCIChannel);\n\n        return _possibleConstructorReturn(this, (SCIChannel.__proto__ || Object.getPrototypeOf(SCIChannel)).apply(this, arguments));\n    }\n\n    _createClass(SCIChannel, [{\n        key: 'onInitialise',\n\n        /*\n        this.incidents is a collection of {incident, id, millisecond} objects always kept in order\n            from lower to higher millisecond\n        this.incidetnsById is an index of the incidents kept by id (this.incidents[incident-id] = Incident)\n        */\n        value: function onInitialise() {\n            this.incidents = [];\n            this.incidentsById = {};\n        }\n    }, {\n        key: '_resize',\n        value: function _resize(durationFraction) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].millisecond = this.incidents[i].millisecond * durationFraction;\n            }\n        }\n\n        /**\n         * On this method the user defines the specific rules that apply on the plugin itself and on the Incidents of the plugin itself\n         * The method should either return {result: true} or {result: false, errors:[{error-object}]}, where error-object has the structure:\n         *  {\n                incident: // reference to the Incident object that has bee discarded\n                error: // text\n            }\n        * @param {array} incidents - a colleciton of all incidents to be added on the form:\n        * \n            {\n                id\n                millisecond\n                incident\n            }\n        * @returns {object} - \n        * either:\n            {\n                result:true,\n                execute: // a function that when executed it will add the Incidents on the Channels\n            }\n            or\n            {\n                result: false,\n                errors\n            }\n        */\n\n    }, {\n        key: 'checkAddition',\n        value: function checkAddition(incidents) {\n            var errors = [];\n            var candidateIncidentsById = {};\n\n            for (var i = 0; i < incidents.length; i++) {\n                candidateIncidentsById[incidents[i].id] = incidents[i].incident;\n                if (this.incidentsById.hasOwnProperty(incidents[i].id)) {\n                    helper.error('Incident with the id ' + incidents[i].id + ' already exists. Addition is rejected.');\n                    errors.push({\n                        type: 'Already existing id',\n                        meta: {\n                            id: incidents[i].id\n                        }\n                    });\n                }\n            }\n\n            if (errors.length > 0) {\n                return {\n                    result: false,\n                    errors: errors\n                };\n            }\n\n            var that = this;\n            var exec = function exec() {\n                that.incidentsById = Object.assign(that.incidentsById, candidateIncidentsById);\n                that.incidents = that.incidents.concat(incidents);\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n                for (var _i = 0; _i < incidents.length; _i++) {\n                    incidents[_i].incident.goTo(that.runTimeInfo.currentMillisecond - incidents[_i].millisecond);\n                }\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        @param {array} incidentsArray - A collection of the Incidetns to get edited in the form:\n        {\n            id\n            millisecond\n            incident\n        }\n        @param {int} millisecondsDelta- the delta of the star point of the provided incidents\n        */\n\n    }, {\n        key: 'checkEdit',\n        value: function checkEdit(incidentsArray, millisecondsDelta) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidentsArray.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidentsArray[i].id) {\n                            that.incidents[j].millisecond += millisecondsDelta;\n                            that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n            };\n\n            return { result: true, execute: exec };\n        }\n    }, {\n        key: 'checkDelete',\n        value: function checkDelete(incidentsArray) {\n            var that = this;\n            var incidentIds = [];\n            for (var i = 0; i < incidentsArray.length; i++) {\n                incidentIds.push(incidentsArray[i].id);\n            }\n\n            var exec = function exec() {\n                var newIncidents = _filter(that.incidents, function (incident) {\n                    return incidentIds.indexOf(incident.id) === -1;\n                });\n\n                that.incidents = newIncidents;\n                for (var _i2 = 0; _i2 < incidentIds.length; _i2++) {\n                    delete that.incidentsById[incidentIds[_i2]];\n                }\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n        * @param {array} incidents - [{id, start, end, startDelta}] \n        */\n\n    }, {\n        key: 'checkResizedIncidents',\n        value: function checkResizedIncidents(incidents) {\n            var that = this;\n            var exec = function exec() {\n                for (var i = 0; i < incidents.length; i++) {\n                    for (var j = 0; j < that.incidents.length; j++) {\n                        if (that.incidents[j].id === incidents[i].id) {\n                            that.incidents[j].millisecond += incidents[i].startDelta;\n                            that.incidents[i].incident.goTo(that.runTimeInfo.currentMillisecond - that.incidents[i].millisecond);\n                            break;\n                        }\n                    }\n                }\n\n                that.incidents = _sortBy(that.incidents, [function (laneItem) {\n                    return laneItem.millisecond;\n                }]);\n            };\n\n            return { result: true, execute: exec };\n        }\n\n        /**\n         @param {int} from - the millisecond to start from\n         @param {int} to - the millisecond to go to\n         */\n\n    }, {\n        key: 'moveTo',\n        value: function moveTo(from, to) {\n            for (var i = 0; i < this.incidents.length; i++) {\n                this.incidents[i].incident.goTo(to - this.incidents[i].millisecond);\n            }\n        }\n    }]);\n\n    return SCIChannel;\n}(Channel);\n\nmodule.exports = SCIChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvU0NJQ2hhbm5lbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9TQ0lDaGFubmVsLmpzP2I4ODEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBIZWxwZXIgPSByZXF1aXJlKCcuLi8uLi9fY29yZVV0aWxzL0hlbHBlcicpO1xudmFyIGhlbHBlciA9IG5ldyBIZWxwZXIoKTtcbnZhciBjb25mID0gcmVxdWlyZSgnLi4vLi4vY29uZmlndXJhdGlvbi9nZW5lcmFsQ29uZicpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuLi8uLi9fQ2hhbm5lbHMvQ2hhbm5lbCcpO1xudmFyIF9zb3J0QnkgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcycpO1xudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleC5qcycpO1xuXG52YXIgU0NJQ2hhbm5lbCA9IGZ1bmN0aW9uIChfQ2hhbm5lbCkge1xuICAgIF9pbmhlcml0cyhTQ0lDaGFubmVsLCBfQ2hhbm5lbCk7XG5cbiAgICBmdW5jdGlvbiBTQ0lDaGFubmVsKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU0NJQ2hhbm5lbCk7XG5cbiAgICAgICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChTQ0lDaGFubmVsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoU0NJQ2hhbm5lbCkpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTQ0lDaGFubmVsLCBbe1xuICAgICAgICBrZXk6ICdvbkluaXRpYWxpc2UnLFxuXG4gICAgICAgIC8qXG4gICAgICAgIHRoaXMuaW5jaWRlbnRzIGlzIGEgY29sbGVjdGlvbiBvZiB7aW5jaWRlbnQsIGlkLCBtaWxsaXNlY29uZH0gb2JqZWN0cyBhbHdheXMga2VwdCBpbiBvcmRlclxuICAgICAgICAgICAgZnJvbSBsb3dlciB0byBoaWdoZXIgbWlsbGlzZWNvbmRcbiAgICAgICAgdGhpcy5pbmNpZGV0bnNCeUlkIGlzIGFuIGluZGV4IG9mIHRoZSBpbmNpZGVudHMga2VwdCBieSBpZCAodGhpcy5pbmNpZGVudHNbaW5jaWRlbnQtaWRdID0gSW5jaWRlbnQpXG4gICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBvbkluaXRpYWxpc2UoKSB7XG4gICAgICAgICAgICB0aGlzLmluY2lkZW50cyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNCeUlkID0ge307XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ19yZXNpemUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2l6ZShkdXJhdGlvbkZyYWN0aW9uKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQgPSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCAqIGR1cmF0aW9uRnJhY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogT24gdGhpcyBtZXRob2QgdGhlIHVzZXIgZGVmaW5lcyB0aGUgc3BlY2lmaWMgcnVsZXMgdGhhdCBhcHBseSBvbiB0aGUgcGx1Z2luIGl0c2VsZiBhbmQgb24gdGhlIEluY2lkZW50cyBvZiB0aGUgcGx1Z2luIGl0c2VsZlxuICAgICAgICAgKiBUaGUgbWV0aG9kIHNob3VsZCBlaXRoZXIgcmV0dXJuIHtyZXN1bHQ6IHRydWV9IG9yIHtyZXN1bHQ6IGZhbHNlLCBlcnJvcnM6W3tlcnJvci1vYmplY3R9XX0sIHdoZXJlIGVycm9yLW9iamVjdCBoYXMgdGhlIHN0cnVjdHVyZTpcbiAgICAgICAgICogIHtcbiAgICAgICAgICAgICAgICBpbmNpZGVudDogLy8gcmVmZXJlbmNlIHRvIHRoZSBJbmNpZGVudCBvYmplY3QgdGhhdCBoYXMgYmVlIGRpc2NhcmRlZFxuICAgICAgICAgICAgICAgIGVycm9yOiAvLyB0ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gYSBjb2xsZWNpdG9uIG9mIGFsbCBpbmNpZGVudHMgdG8gYmUgYWRkZWQgb24gdGhlIGZvcm06XG4gICAgICAgICogXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIGluY2lkZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICogQHJldHVybnMge29iamVjdH0gLSBcbiAgICAgICAgKiBlaXRoZXI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OnRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZTogLy8gYSBmdW5jdGlvbiB0aGF0IHdoZW4gZXhlY3V0ZWQgaXQgd2lsbCBhZGQgdGhlIEluY2lkZW50cyBvbiB0aGUgQ2hhbm5lbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9yXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBlcnJvcnNcbiAgICAgICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tBZGRpdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0FkZGl0aW9uKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGNhbmRpZGF0ZUluY2lkZW50c0J5SWQgPSB7fTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVJbmNpZGVudHNCeUlkW2luY2lkZW50c1tpXS5pZF0gPSBpbmNpZGVudHNbaV0uaW5jaWRlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5jaWRlbnRzQnlJZC5oYXNPd25Qcm9wZXJ0eShpbmNpZGVudHNbaV0uaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5lcnJvcignSW5jaWRlbnQgd2l0aCB0aGUgaWQgJyArIGluY2lkZW50c1tpXS5pZCArICcgYWxyZWFkeSBleGlzdHMuIEFkZGl0aW9uIGlzIHJlamVjdGVkLicpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQWxyZWFkeSBleGlzdGluZyBpZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGluY2lkZW50c1tpXS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzQnlJZCA9IE9iamVjdC5hc3NpZ24odGhhdC5pbmNpZGVudHNCeUlkLCBjYW5kaWRhdGVJbmNpZGVudHNCeUlkKTtcbiAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50cyA9IHRoYXQuaW5jaWRlbnRzLmNvbmNhdChpbmNpZGVudHMpO1xuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbmNpZGVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGluY2lkZW50c1tfaV0uaW5jaWRlbnQuZ29Ubyh0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAtIGluY2lkZW50c1tfaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgIEBwYXJhbSB7YXJyYXl9IGluY2lkZW50c0FycmF5IC0gQSBjb2xsZWN0aW9uIG9mIHRoZSBJbmNpZGV0bnMgdG8gZ2V0IGVkaXRlZCBpbiB0aGUgZm9ybTpcbiAgICAgICAge1xuICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICBpbmNpZGVudFxuICAgICAgICB9XG4gICAgICAgIEBwYXJhbSB7aW50fSBtaWxsaXNlY29uZHNEZWx0YS0gdGhlIGRlbHRhIG9mIHRoZSBzdGFyIHBvaW50IG9mIHRoZSBwcm92aWRlZCBpbmNpZGVudHNcbiAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tFZGl0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrRWRpdChpbmNpZGVudHNBcnJheSwgbWlsbGlzZWNvbmRzRGVsdGEpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBleGVjID0gZnVuY3Rpb24gZXhlYygpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluY2lkZW50c0FycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzQXJyYXlbaV0uaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tqXS5taWxsaXNlY29uZCArPSBtaWxsaXNlY29uZHNEZWx0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmluY2lkZW50c1tpXS5pbmNpZGVudC5nb1RvKHRoYXQucnVuVGltZUluZm8uY3VycmVudE1pbGxpc2Vjb25kIC0gdGhhdC5pbmNpZGVudHNbaV0ubWlsbGlzZWNvbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBfc29ydEJ5KHRoYXQuaW5jaWRlbnRzLCBbZnVuY3Rpb24gKGxhbmVJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5lSXRlbS5taWxsaXNlY29uZDtcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4geyByZXN1bHQ6IHRydWUsIGV4ZWN1dGU6IGV4ZWMgfTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnY2hlY2tEZWxldGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tEZWxldGUoaW5jaWRlbnRzQXJyYXkpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgICAgIHZhciBpbmNpZGVudElkcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmNpZGVudHNBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGluY2lkZW50SWRzLnB1c2goaW5jaWRlbnRzQXJyYXlbaV0uaWQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uIGV4ZWMoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0luY2lkZW50cyA9IF9maWx0ZXIodGhhdC5pbmNpZGVudHMsIGZ1bmN0aW9uIChpbmNpZGVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW5jaWRlbnRJZHMuaW5kZXhPZihpbmNpZGVudC5pZCkgPT09IC0xO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHMgPSBuZXdJbmNpZGVudHM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgaW5jaWRlbnRJZHMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhhdC5pbmNpZGVudHNCeUlkW2luY2lkZW50SWRzW19pMl1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybiB7IHJlc3VsdDogdHJ1ZSwgZXhlY3V0ZTogZXhlYyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICogQHBhcmFtIHthcnJheX0gaW5jaWRlbnRzIC0gW3tpZCwgc3RhcnQsIGVuZCwgc3RhcnREZWx0YX1dIFxuICAgICAgICAqL1xuXG4gICAgfSwge1xuICAgICAgICBrZXk6ICdjaGVja1Jlc2l6ZWRJbmNpZGVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tSZXNpemVkSW5jaWRlbnRzKGluY2lkZW50cykge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiBleGVjKCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5jaWRlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhhdC5pbmNpZGVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0LmluY2lkZW50c1tqXS5pZCA9PT0gaW5jaWRlbnRzW2ldLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbal0ubWlsbGlzZWNvbmQgKz0gaW5jaWRlbnRzW2ldLnN0YXJ0RGVsdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pbmNpZGVudHNbaV0uaW5jaWRlbnQuZ29Ubyh0aGF0LnJ1blRpbWVJbmZvLmN1cnJlbnRNaWxsaXNlY29uZCAtIHRoYXQuaW5jaWRlbnRzW2ldLm1pbGxpc2Vjb25kKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoYXQuaW5jaWRlbnRzID0gX3NvcnRCeSh0aGF0LmluY2lkZW50cywgW2Z1bmN0aW9uIChsYW5lSXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFuZUl0ZW0ubWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICAgICAgfV0pO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCBleGVjdXRlOiBleGVjIH07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgIEBwYXJhbSB7aW50fSBmcm9tIC0gdGhlIG1pbGxpc2Vjb25kIHRvIHN0YXJ0IGZyb21cbiAgICAgICAgIEBwYXJhbSB7aW50fSB0byAtIHRoZSBtaWxsaXNlY29uZCB0byBnbyB0b1xuICAgICAgICAgKi9cblxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnbW92ZVRvJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmVUbyhmcm9tLCB0bykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmluY2lkZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5jaWRlbnRzW2ldLmluY2lkZW50LmdvVG8odG8gLSB0aGlzLmluY2lkZW50c1tpXS5taWxsaXNlY29uZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gU0NJQ2hhbm5lbDtcbn0oQ2hhbm5lbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gU0NJQ2hhbm5lbDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar IframeContextHandler = function () {\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - css (the css template of the isolated tree)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n     * - containerParams (an object that holds parameters to affect the container of the isolated tree, e.g. width, height etc)\n    */\n    function IframeContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, IframeContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('html')) {\n            helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('css')) {\n            helper.error('ContextHandler expects the css key on its constructor properties which is missing');\n            return false;\n        }\n\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        this.isDOM = true;\n\n        var ownerDocument = props.host.ownerDocument;\n\n        if (!ownerDocument.getElementById(\"@kissmybutton/motorcortex/iframeContextHandler/css\")) {\n            var seamlessCSS = '\\n            iframe[seamless]{\\n                background-color: transparent;\\n                border: 0px none transparent;\\n                padding: 0px;\\n                overflow: hidden;\\n            }\\n            ';\n            var iframesCSS = ownerDocument.createElement('style');\n            iframesCSS.id = \"@kissmybutton/motorcortex/iframeContextHandler/css\";\n            iframesCSS.type = 'text/css';\n            var Head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n            if (iframesCSS.styleSheet) {\n                iframesCSS.styleSheet.cssText = seamlessCSS;\n            } else {\n                iframesCSS.appendChild(ownerDocument.createTextNode(seamlessCSS));\n            }\n\n            Head.appendChild(iframesCSS);\n        }\n\n        // Create an iframe:\n        var iframe = ownerDocument.createElement('iframe');\n        props.host.appendChild(iframe);\n        iframe.setAttribute(\"seamless\", \"seamless\");\n        if (props.hasOwnProperty('containerParams')) {\n            if (props.containerParams.hasOwnProperty('width')) {\n                iframe.setAttribute('width', props.containerParams.width);\n            }\n            if (props.containerParams.hasOwnProperty('height')) {\n                iframe.setAttribute('height', props.containerParams.height);\n            }\n        }\n        // Initialise the iframe\n        iframe.src = '';\n        // Put it in the document (but hidden):\n        var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n        if (iframeDocument.document) {\n            iframeDocument = iframeDocument.document;\n        }\n\n        iframeDocument.write(helper.renderTemplate(props.html, { params: props.initParams }));\n\n        var bodyFixCSS = '\\n        body{\\n            padding:0;\\n            margin:0;\\n        }\\n        ';\n\n        var styleTag = iframeDocument.createElement('style');\n        styleTag.type = 'text/css';\n        if (styleTag.styleSheet) {\n            styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: props.initParams }) + bodyFixCSS;\n        } else {\n            styleTag.appendChild(ownerDocument.createTextNode(props.css + bodyFixCSS));\n        }\n        var head = iframeDocument.head || iframeDocument.getElementsByTagName('head')[0];\n        head.appendChild(styleTag);\n\n        this.context = {\n            document: iframeDocument,\n            window: iframe.contentWindow || iframe,\n            rootElement: iframeDocument.body,\n            unmount: function unmount() {\n                props.host.removeChild(iframe);\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this)\n        };\n\n        iframeDocument.close();\n    }\n\n    _createClass(IframeContextHandler, [{\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.document.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return IframeContextHandler;\n}();\n\nmodule.exports = IframeContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9JZnJhbWVDb250ZXh0SGFuZGxlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9oZWxwZXJzL0lmcmFtZUNvbnRleHRIYW5kbGVyLmpzPzE5NzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qXG5pZnJhbWVbc2VhbWxlc3Nde1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogMHB4IG5vbmUgdHJhbnNwYXJlbnQ7XG4gICAgcGFkZGluZzogMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbm1pZ2h0IG5lZWQgbW9yZSB3b3JrIGZvciBJRS4gU2VlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yOTIwOTI0OFxuKi9cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBJZnJhbWVDb250ZXh0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgICAqIC0gY3NzICh0aGUgY3NzIHRlbXBsYXRlIG9mIHRoZSBpc29sYXRlZCB0cmVlKVxuICAgICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAgKiAtIGNvbnRhaW5lclBhcmFtcyAoYW4gb2JqZWN0IHRoYXQgaG9sZHMgcGFyYW1ldGVycyB0byBhZmZlY3QgdGhlIGNvbnRhaW5lciBvZiB0aGUgaXNvbGF0ZWQgdHJlZSwgZS5nLiB3aWR0aCwgaGVpZ2h0IGV0YylcbiAgICAqL1xuICAgIGZ1bmN0aW9uIElmcmFtZUNvbnRleHRIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZnJhbWVDb250ZXh0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2NzcycpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGNzcyBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluaXRQYXJhbXMgPSBwcm9wcy5pbml0UGFyYW1zO1xuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdpbml0UGFyYW1zJykpIHtcbiAgICAgICAgICAgIGhlbHBlci5pbmZvKCdDb250ZXh0SGFuZGxlciBnb3QgbnVsbCBpbml0UGFyYW1zJyk7XG4gICAgICAgICAgICBpbml0UGFyYW1zID0ge307XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KCdob3N0JykpIHtcbiAgICAgICAgICAgIGhlbHBlci5lcnJvcignQ29udGV4dEhhbmRsZXIgZXhwZWN0cyB0aGUgaG9zdCBrZXkgb24gaXRzIGNvbnN0cnVjdG9yIHByb3BlcnRpZXMgd2hpY2ggaXMgbWlzc2luZycpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0RPTSA9IHRydWU7XG5cbiAgICAgICAgdmFyIG93bmVyRG9jdW1lbnQgPSBwcm9wcy5ob3N0Lm93bmVyRG9jdW1lbnQ7XG5cbiAgICAgICAgaWYgKCFvd25lckRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9pZnJhbWVDb250ZXh0SGFuZGxlci9jc3NcIikpIHtcbiAgICAgICAgICAgIHZhciBzZWFtbGVzc0NTUyA9ICdcXG4gICAgICAgICAgICBpZnJhbWVbc2VhbWxlc3Nde1xcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAwcHggbm9uZSB0cmFuc3BhcmVudDtcXG4gICAgICAgICAgICAgICAgcGFkZGluZzogMHB4O1xcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAnO1xuICAgICAgICAgICAgdmFyIGlmcmFtZXNDU1MgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBpZnJhbWVzQ1NTLmlkID0gXCJAa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2lmcmFtZUNvbnRleHRIYW5kbGVyL2Nzc1wiO1xuICAgICAgICAgICAgaWZyYW1lc0NTUy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICAgIHZhciBIZWFkID0gb3duZXJEb2N1bWVudC5oZWFkIHx8IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgICAgIGlmIChpZnJhbWVzQ1NTLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWVzQ1NTLnN0eWxlU2hlZXQuY3NzVGV4dCA9IHNlYW1sZXNzQ1NTO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZnJhbWVzQ1NTLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VhbWxlc3NDU1MpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSGVhZC5hcHBlbmRDaGlsZChpZnJhbWVzQ1NTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpZnJhbWU6XG4gICAgICAgIHZhciBpZnJhbWUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBwcm9wcy5ob3N0LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZS5zZXRBdHRyaWJ1dGUoXCJzZWFtbGVzc1wiLCBcInNlYW1sZXNzXCIpO1xuICAgICAgICBpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoJ2NvbnRhaW5lclBhcmFtcycpKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuY29udGFpbmVyUGFyYW1zLmhhc093blByb3BlcnR5KCd3aWR0aCcpKSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBwcm9wcy5jb250YWluZXJQYXJhbXMud2lkdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3BzLmNvbnRhaW5lclBhcmFtcy5oYXNPd25Qcm9wZXJ0eSgnaGVpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBwcm9wcy5jb250YWluZXJQYXJhbXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSBpZnJhbWVcbiAgICAgICAgaWZyYW1lLnNyYyA9ICcnO1xuICAgICAgICAvLyBQdXQgaXQgaW4gdGhlIGRvY3VtZW50IChidXQgaGlkZGVuKTpcbiAgICAgICAgdmFyIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cgfHwgaWZyYW1lLmNvbnRlbnREb2N1bWVudDtcbiAgICAgICAgaWYgKGlmcmFtZURvY3VtZW50LmRvY3VtZW50KSB7XG4gICAgICAgICAgICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZURvY3VtZW50LmRvY3VtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWZyYW1lRG9jdW1lbnQud3JpdGUoaGVscGVyLnJlbmRlclRlbXBsYXRlKHByb3BzLmh0bWwsIHsgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zIH0pKTtcblxuICAgICAgICB2YXIgYm9keUZpeENTUyA9ICdcXG4gICAgICAgIGJvZHl7XFxuICAgICAgICAgICAgcGFkZGluZzowO1xcbiAgICAgICAgICAgIG1hcmdpbjowO1xcbiAgICAgICAgfVxcbiAgICAgICAgJztcblxuICAgICAgICB2YXIgc3R5bGVUYWcgPSBpZnJhbWVEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZVRhZy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlVGFnLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5jc3MsIHsgcGFyYW1zOiBwcm9wcy5pbml0UGFyYW1zIH0pICsgYm9keUZpeENTUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlVGFnLmFwcGVuZENoaWxkKG93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocHJvcHMuY3NzICsgYm9keUZpeENTUykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkID0gaWZyYW1lRG9jdW1lbnQuaGVhZCB8fCBpZnJhbWVEb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlVGFnKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICAgICAgICBkb2N1bWVudDogaWZyYW1lRG9jdW1lbnQsXG4gICAgICAgICAgICB3aW5kb3c6IGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZSxcbiAgICAgICAgICAgIHJvb3RFbGVtZW50OiBpZnJhbWVEb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgdW5tb3VudDogZnVuY3Rpb24gdW5tb3VudCgpIHtcbiAgICAgICAgICAgICAgICBwcm9wcy5ob3N0LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0RWxlbWVudHM6IHRoaXMuZ2V0RWxlbWVudHMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldE1DSUQ6IHRoaXMuZ2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgc2V0TUNJRDogdGhpcy5zZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQ6IHRoaXMuZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lELmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJZnJhbWVDb250ZXh0SGFuZGxlciwgW3tcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29udGV4dC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldE1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUNJRChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNQ0lEKGVsZW1lbnQsIG1jaWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSwgbWNpZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRTZWxlY3RvckJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSArICc9XCInICsgbWNpZCArICdcIl0nO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIElmcmFtZUNvbnRleHRIYW5kbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZUNvbnRleHRIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/IframeContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js":
/*!************************************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\niframe[seamless]{\n    background-color: transparent;\n    border: 0px none transparent;\n    padding: 0px;\n    overflow: hidden;\n}\n\nmight need more work for IE. See here: https://stackoverflow.com/a/29209248\n*/\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar IframeContextHandler = function () {\n    /**\n     * @param {object} props - an object that should contain all of the following keys:\n     * - html (the html template to render)\n     * - initParams (optional / the initialisation parameteres that will be passed both on the css and the html templates in order to render)\n     * - host (an Element object that will host the isolated tree)\n    */\n    function IframeContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, IframeContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('html')) {\n            helper.error('ContextHandler expects the html key on its constructor properties which is missing');\n            return false;\n        }\n\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        this.isDOM = true;\n\n        var ownerDocument = props.host.ownerDocument;\n\n        // Create an iframe:\n        var iframe = ownerDocument.createElement('iframe');\n        iframe.style.display = \"none\";\n        props.host.appendChild(iframe);\n        var iframeDocument = iframe.contentWindow || iframe.contentDocument;\n        if (iframeDocument.document) {\n            iframeDocument = iframeDocument.document;\n        }\n        var rootElement = void 0;\n\n        iframe.onload = function () {\n            iframe.onload = null;\n\n            iframeDocument.write('<mc_iframe_root_element>');\n            rootElement = iframeDocument.querySelector('mc_iframe_root_element');\n            props.host.appendChild(rootElement);\n            var html = helper.renderTemplate(props.html, { params: props.initParams });\n            iframeDocument.write(html);\n            iframeDocument.write('</mc_iframe_root_element>');\n            iframeDocument.close();\n        };\n\n        // Initialise the iframe\n        iframe.src = '';\n\n        this.context = {\n            document: iframeDocument,\n            window: iframe.contentWindow || iframe,\n            rootElement: rootElement,\n            unmount: function unmount() {\n                props.host.removeChild(iframe);\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this)\n        };\n    }\n\n    _createClass(IframeContextHandler, [{\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.document.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return IframeContextHandler;\n}();\n\nmodule.exports = IframeContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9Jbmhlcml0U3R5bGVJZnJhbWVDb250ZXh0SGFubGRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9oZWxwZXJzL0luaGVyaXRTdHlsZUlmcmFtZUNvbnRleHRIYW5sZGVyLmpzPzNiOTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qXG5pZnJhbWVbc2VhbWxlc3Nde1xuICAgIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgIGJvcmRlcjogMHB4IG5vbmUgdHJhbnNwYXJlbnQ7XG4gICAgcGFkZGluZzogMHB4O1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG59XG5cbm1pZ2h0IG5lZWQgbW9yZSB3b3JrIGZvciBJRS4gU2VlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yOTIwOTI0OFxuKi9cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uLy4uLy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi8uLi8uLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG5cbnZhciBJZnJhbWVDb250ZXh0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgLSBhbiBvYmplY3QgdGhhdCBzaG91bGQgY29udGFpbiBhbGwgb2YgdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgICAqIC0gaHRtbCAodGhlIGh0bWwgdGVtcGxhdGUgdG8gcmVuZGVyKVxuICAgICAqIC0gaW5pdFBhcmFtcyAob3B0aW9uYWwgLyB0aGUgaW5pdGlhbGlzYXRpb24gcGFyYW1ldGVyZXMgdGhhdCB3aWxsIGJlIHBhc3NlZCBib3RoIG9uIHRoZSBjc3MgYW5kIHRoZSBodG1sIHRlbXBsYXRlcyBpbiBvcmRlciB0byByZW5kZXIpXG4gICAgICogLSBob3N0IChhbiBFbGVtZW50IG9iamVjdCB0aGF0IHdpbGwgaG9zdCB0aGUgaXNvbGF0ZWQgdHJlZSlcbiAgICAqL1xuICAgIGZ1bmN0aW9uIElmcmFtZUNvbnRleHRIYW5kbGVyKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuXG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJZnJhbWVDb250ZXh0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGh0bWwga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbml0UGFyYW1zID0gcHJvcHMuaW5pdFBhcmFtcztcbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaW5pdFBhcmFtcycpKSB7XG4gICAgICAgICAgICBoZWxwZXIuaW5mbygnQ29udGV4dEhhbmRsZXIgZ290IG51bGwgaW5pdFBhcmFtcycpO1xuICAgICAgICAgICAgaW5pdFBhcmFtcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaG9zdCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGhvc3Qga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNET00gPSB0cnVlO1xuXG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gcHJvcHMuaG9zdC5vd25lckRvY3VtZW50O1xuXG4gICAgICAgIC8vIENyZWF0ZSBhbiBpZnJhbWU6XG4gICAgICAgIHZhciBpZnJhbWUgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBwcm9wcy5ob3N0LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICAgIHZhciBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93IHx8IGlmcmFtZS5jb250ZW50RG9jdW1lbnQ7XG4gICAgICAgIGlmIChpZnJhbWVEb2N1bWVudC5kb2N1bWVudCkge1xuICAgICAgICAgICAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWVEb2N1bWVudC5kb2N1bWVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcm9vdEVsZW1lbnQgPSB2b2lkIDA7XG5cbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuXG4gICAgICAgICAgICBpZnJhbWVEb2N1bWVudC53cml0ZSgnPG1jX2lmcmFtZV9yb290X2VsZW1lbnQ+Jyk7XG4gICAgICAgICAgICByb290RWxlbWVudCA9IGlmcmFtZURvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21jX2lmcmFtZV9yb290X2VsZW1lbnQnKTtcbiAgICAgICAgICAgIHByb3BzLmhvc3QuYXBwZW5kQ2hpbGQocm9vdEVsZW1lbnQpO1xuICAgICAgICAgICAgdmFyIGh0bWwgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuaHRtbCwgeyBwYXJhbXM6IHByb3BzLmluaXRQYXJhbXMgfSk7XG4gICAgICAgICAgICBpZnJhbWVEb2N1bWVudC53cml0ZShodG1sKTtcbiAgICAgICAgICAgIGlmcmFtZURvY3VtZW50LndyaXRlKCc8L21jX2lmcmFtZV9yb290X2VsZW1lbnQ+Jyk7XG4gICAgICAgICAgICBpZnJhbWVEb2N1bWVudC5jbG9zZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEluaXRpYWxpc2UgdGhlIGlmcmFtZVxuICAgICAgICBpZnJhbWUuc3JjID0gJyc7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IGlmcmFtZURvY3VtZW50LFxuICAgICAgICAgICAgd2luZG93OiBpZnJhbWUuY29udGVudFdpbmRvdyB8fCBpZnJhbWUsXG4gICAgICAgICAgICByb290RWxlbWVudDogcm9vdEVsZW1lbnQsXG4gICAgICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgICAgICAgICAgICAgIHByb3BzLmhvc3QucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFbGVtZW50czogdGhpcy5nZXRFbGVtZW50cy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0TUNJRDogdGhpcy5nZXRNQ0lELmJpbmQodGhpcyksXG4gICAgICAgICAgICBzZXRNQ0lEOiB0aGlzLnNldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRDogdGhpcy5nZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQuYmluZCh0aGlzKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhJZnJhbWVDb250ZXh0SGFuZGxlciwgW3tcbiAgICAgICAga2V5OiAnZ2V0RWxlbWVudHMnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY29udGV4dC5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldE1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TUNJRChlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoY29uZi5lbGVtZW50c19kYXRhX2F0dHJpYnV0ZV9uYW1lKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2V0TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNQ0lEKGVsZW1lbnQsIG1jaWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSwgbWNpZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRTZWxlY3RvckJ5TUNJRCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQobWNpZCkge1xuICAgICAgICAgICAgcmV0dXJuICdbJyArIGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSArICc9XCInICsgbWNpZCArICdcIl0nO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIElmcmFtZUNvbnRleHRIYW5kbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZUNvbnRleHRIYW5kbGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/InheritStyleIframeContextHanlder.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js":
/*!***********************************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js ***!
  \***********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../../../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../../../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\n\nvar PlainContextHandler = function () {\n    function PlainContextHandler() {\n        var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        _classCallCheck(this, PlainContextHandler);\n\n        if (!helper.isObject(props)) {\n            helper.error('ContextHandler expects an object on its constructor. ' + (typeof props === 'undefined' ? 'undefined' : _typeof(props)) + ' passed');\n            return false;\n        }\n\n        if (!props.hasOwnProperty('host')) {\n            helper.error('ContextHandler expects the host key on its constructor properties which is missing');\n            return false;\n        }\n\n        var ownerDocument = props.host.ownerDocument;\n        var initParams = props.initParams;\n        if (!props.hasOwnProperty('initParams')) {\n            helper.info('ContextHandler got null initParams');\n            initParams = {};\n        }\n\n        if (props.hasOwnProperty('html')) {\n            props.host.innerHTML = helper.renderTemplate(props.html, { params: initParams });\n        }\n\n        if (props.hasOwnProperty('css')) {\n            var styleTag = ownerDocument.createElement('style');\n            styleTag.type = 'text/css';\n            if (styleTag.styleSheet) {\n                styleTag.styleSheet.cssText = helper.renderTemplate(props.css, { params: initParams });\n            } else {\n                styleTag.appendChild(ownerDocument.createTextNode(props.css));\n            }\n            var head = ownerDocument.head || ownerDocument.getElementsByTagName('head')[0];\n            head.appendChild(styleTag);\n        }\n\n        this.isDOM = true;\n\n        this.context = {\n            document: ownerDocument,\n            window: ownerDocument.defaultView,\n            rootElement: props.host,\n            unmount: function unmount() {\n                props.host.innerHTML = \"\";\n            },\n            getElements: this.getElements.bind(this),\n            getMCID: this.getMCID.bind(this),\n            setMCID: this.setMCID.bind(this),\n            getElementSelectorByMCID: this.getElementSelectorByMCID.bind(this)\n        };\n    }\n\n    _createClass(PlainContextHandler, [{\n        key: 'getElements',\n        value: function getElements(selector) {\n            return Array.from(this.context.rootElement.querySelectorAll(selector));\n        }\n    }, {\n        key: 'getMCID',\n        value: function getMCID(element) {\n            return element.getAttribute(conf.elements_data_attribute_name);\n        }\n    }, {\n        key: 'setMCID',\n        value: function setMCID(element, mcid) {\n            element.setAttribute(conf.elements_data_attribute_name, mcid);\n        }\n    }, {\n        key: 'getElementSelectorByMCID',\n        value: function getElementSelectorByMCID(mcid) {\n            return '[' + conf.elements_data_attribute_name + '=\"' + mcid + '\"]';\n        }\n    }]);\n\n    return PlainContextHandler;\n}();\n\nmodule.exports = PlainContextHandler;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvaGVscGVycy9QbGFpbkNvbnRleHRIYW5kbGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC9jb3JlUGx1Z2lucy9TZWxmQ29udGFpbmVkSW5jaWRlbnRzL2hlbHBlcnMvUGxhaW5Db250ZXh0SGFuZGxlci5qcz82MjNlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSGVscGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vX2NvcmVVdGlscy9IZWxwZXInKTtcbnZhciBoZWxwZXIgPSBuZXcgSGVscGVyKCk7XG52YXIgY29uZiA9IHJlcXVpcmUoJy4uLy4uLy4uL2NvbmZpZ3VyYXRpb24vZ2VuZXJhbENvbmYnKTtcblxudmFyIFBsYWluQ29udGV4dEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhaW5Db250ZXh0SGFuZGxlcigpIHtcbiAgICAgICAgdmFyIHByb3BzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGxhaW5Db250ZXh0SGFuZGxlcik7XG5cbiAgICAgICAgaWYgKCFoZWxwZXIuaXNPYmplY3QocHJvcHMpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgYW4gb2JqZWN0IG9uIGl0cyBjb25zdHJ1Y3Rvci4gJyArICh0eXBlb2YgcHJvcHMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHByb3BzKSkgKyAnIHBhc3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaG9zdCcpKSB7XG4gICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0NvbnRleHRIYW5kbGVyIGV4cGVjdHMgdGhlIGhvc3Qga2V5IG9uIGl0cyBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIHdoaWNoIGlzIG1pc3NpbmcnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvd25lckRvY3VtZW50ID0gcHJvcHMuaG9zdC5vd25lckRvY3VtZW50O1xuICAgICAgICB2YXIgaW5pdFBhcmFtcyA9IHByb3BzLmluaXRQYXJhbXM7XG4gICAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkoJ2luaXRQYXJhbXMnKSkge1xuICAgICAgICAgICAgaGVscGVyLmluZm8oJ0NvbnRleHRIYW5kbGVyIGdvdCBudWxsIGluaXRQYXJhbXMnKTtcbiAgICAgICAgICAgIGluaXRQYXJhbXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnaHRtbCcpKSB7XG4gICAgICAgICAgICBwcm9wcy5ob3N0LmlubmVySFRNTCA9IGhlbHBlci5yZW5kZXJUZW1wbGF0ZShwcm9wcy5odG1sLCB7IHBhcmFtczogaW5pdFBhcmFtcyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eSgnY3NzJykpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZVRhZyA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgIHN0eWxlVGFnLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICAgICAgaWYgKHN0eWxlVGFnLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgICAgICBzdHlsZVRhZy5zdHlsZVNoZWV0LmNzc1RleHQgPSBoZWxwZXIucmVuZGVyVGVtcGxhdGUocHJvcHMuY3NzLCB7IHBhcmFtczogaW5pdFBhcmFtcyB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3R5bGVUYWcuYXBwZW5kQ2hpbGQob3duZXJEb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShwcm9wcy5jc3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoZWFkID0gb3duZXJEb2N1bWVudC5oZWFkIHx8IG93bmVyRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICAgICAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVUYWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pc0RPTSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgICAgICAgZG9jdW1lbnQ6IG93bmVyRG9jdW1lbnQsXG4gICAgICAgICAgICB3aW5kb3c6IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcsXG4gICAgICAgICAgICByb290RWxlbWVudDogcHJvcHMuaG9zdCxcbiAgICAgICAgICAgIHVubW91bnQ6IGZ1bmN0aW9uIHVubW91bnQoKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuaG9zdC5pbm5lckhUTUwgPSBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEVsZW1lbnRzOiB0aGlzLmdldEVsZW1lbnRzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBnZXRNQ0lEOiB0aGlzLmdldE1DSUQuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHNldE1DSUQ6IHRoaXMuc2V0TUNJRC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEOiB0aGlzLmdldEVsZW1lbnRTZWxlY3RvckJ5TUNJRC5iaW5kKHRoaXMpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBsYWluQ29udGV4dEhhbmRsZXIsIFt7XG4gICAgICAgIGtleTogJ2dldEVsZW1lbnRzJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNvbnRleHQucm9vdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRNQ0lEJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1DSUQoZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGNvbmYuZWxlbWVudHNfZGF0YV9hdHRyaWJ1dGVfbmFtZSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ3NldE1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TUNJRChlbGVtZW50LCBtY2lkKSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUsIG1jaWQpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRFbGVtZW50U2VsZWN0b3JCeU1DSUQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWxlbWVudFNlbGVjdG9yQnlNQ0lEKG1jaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAnWycgKyBjb25mLmVsZW1lbnRzX2RhdGFfYXR0cmlidXRlX25hbWUgKyAnPVwiJyArIG1jaWQgKyAnXCJdJztcbiAgICAgICAgfVxuICAgIH1dKTtcblxuICAgIHJldHVybiBQbGFpbkNvbnRleHRIYW5kbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYWluQ29udGV4dEhhbmRsZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/helpers/PlainContextHandler.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js ***!
  \************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar Clip = __webpack_require__(/*! ./SCGroup */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCGroup.js\");\nvar Channel = __webpack_require__(/*! ./SCIChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/SCIChannel.js\");\nvar ClipFromDefinition = __webpack_require__(/*! ./ClipFromDefinition */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\");\n\nmodule.exports = {\n    npm_name: \"@kissmybutton/self-contained-incidents\",\n    incidents: [{\n        exportable: Clip\n    }],\n    channel: Channel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2Rpc3QvY29yZVBsdWdpbnMvU2VsZkNvbnRhaW5lZEluY2lkZW50cy9tYWluLmpzPzc4ZmIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2xpcCA9IHJlcXVpcmUoJy4vU0NHcm91cCcpO1xudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuL1NDSUNoYW5uZWwnKTtcbnZhciBDbGlwRnJvbURlZmluaXRpb24gPSByZXF1aXJlKCcuL0NsaXBGcm9tRGVmaW5pdGlvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBucG1fbmFtZTogXCJAa2lzc215YnV0dG9uL3NlbGYtY29udGFpbmVkLWluY2lkZW50c1wiLFxuICAgIGluY2lkZW50czogW3tcbiAgICAgICAgZXhwb3J0YWJsZTogQ2xpcFxuICAgIH1dLFxuICAgIGNoYW5uZWw6IENoYW5uZWxcbn07Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/main.js":
/*!*************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/main.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Channel = __webpack_require__(/*! ./_Channels/Channel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/Channel.js\");\nvar Group = __webpack_require__(/*! ./_BaseClasses/Group */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Group.js\");\nvar Incident = __webpack_require__(/*! ./_BaseClasses/Incident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/Incident.js\");\nvar TimedIncident = __webpack_require__(/*! ./_BaseClasses/TimedIncident */ \"./node_modules/@kissmybutton/motorcortex/dist/_BaseClasses/TimedIncident.js\");\nvar Helper = __webpack_require__(/*! ./_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");var helper = new Helper();\nvar AttributeChannel = __webpack_require__(/*! ./_Channels/_Attribute/AttributeChannel */ \"./node_modules/@kissmybutton/motorcortex/dist/_Channels/_Attribute/AttributeChannel.js\");\nvar ClipFromDefinition = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/ClipFromDefinition */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/ClipFromDefinition.js\");\n\nvar conf = __webpack_require__(/*! ./configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Timer = __webpack_require__(/*! ./utils/Timer */ \"./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js\");\n\nvar checkPlugin = function checkPlugin(main) {\n    if (main.hasOwnProperty('default')) {\n        main = main.default;\n    }\n\n    var plugin_name = main.npm_name;\n    var check = true;\n\n    if (!main.hasOwnProperty('incidents')) {\n        helper.error('Error on plugin ' + plugin_name + '. A plugin must expose at least one Incident.\\n        Exposed plugin Incidents should be defined on the \"incidents\" key of the main.js file.');\n        check = false;\n    }\n\n    if (!helper.isArray(main.incidents)) {\n        helper.error('Error on plugin ' + plugin_name + '. thePlugin exposed Incidents are defined on the \"incidents\" key of the main.js file in array format.\\n        Please refer to the documentation');\n        check = false;\n    } else {\n        for (var i = 0; i < main.incidents.length; i++) {\n            var exposedIncidentDefinition = main.incidents[i];\n            if (_typeof(exposedIncidentDefinition.exportable) === \"object\") {\n                if (exposedIncidentDefinition.exportable.hasOwnProperty('default')) {\n                    exposedIncidentDefinition.exportable = exposedIncidentDefinition.exportable.default;\n                }\n            }\n            if (!(exposedIncidentDefinition.exportable.prototype instanceof Incident)) {\n                helper.error('Error on plugin ' + plugin_name + '. Exportable Incidents by any plugin must extend one of the base classes provided by MotorCortex.\\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\\'t.\\n                Please refer to documentation');\n                check = false;\n            }\n\n            if (!exposedIncidentDefinition.hasOwnProperty('propTypes')) {\n                helper.log('Warning on plugin ' + plugin_name + '.\\n                It\\'s always good for plugins to define the supported propTypes of their exposed Incidents\\' supported properties.\\n                ' + exposedIncidentDefinition.exportable.constructor.name + ' doesn\\'t.\\n                Please refer to documentation', 'warning');\n            }\n        }\n    }\n\n    if (!main.hasOwnProperty('channel')) {\n        helper.error('Error on plugin ' + plugin_name + '. A plugin must always define its Channel on the \"channel\" key of the main.js file.\\n        It\\'s missing. Please refer to documentation');\n        check = false;\n    } else {\n        if (_typeof(main.channel) === \"object\") {\n            if (main.channel.hasOwnProperty('default')) {\n                main.channel = main.channel.default;\n            }\n        }\n    }\n\n    return check;\n};\n\n// plugin_name is the unique name of the plugin\nfunction loadPlugin(plugin) {\n    if (plugin.hasOwnProperty('default')) {\n        plugin = plugin.default;\n    }\n\n    if (!plugin.hasOwnProperty('npm_name')) {\n        plugin.npm_name = 'plugin_' + new Date().getTime();\n    }\n\n    if (!plugin.hasOwnProperty('channel')) {\n        plugin.channel = Channel;\n    }\n    if (!checkPlugin(plugin)) {\n        return false;\n    } else {\n        // thePlugin is the plugin object which will hold on its keys\n        // the names of the exposed Incidents of its. The keys of this object\n        // are going to be identical with the names of the classes exposed\n        var thePlugin = {};\n\n        if (plugin.hasOwnProperty('clip')) {\n            if (_typeof(plugin.clip) === \"object\") {\n                if (plugin.clip.hasOwnProperty('default')) {\n                    plugin.clip = plugin.clip.default;\n                }\n            }\n            thePlugin.Clip = plugin.clip;\n        }\n\n        // for each of the exposed Incidents\n\n        var _loop = function _loop(i) {\n            var incidentClass = plugin.incidents[i].exportable;\n\n            // TODO hanlde the different css style isolation versions through the cssIsolation parameter of the containerParams of the incident\n\n            // dynamically assign getters on the Incident's name key of the thePlugin object\n            Object.defineProperty(thePlugin, incidentClass.name, {\n                get: function get() {\n                    // the getter will construct a wrapper class which on the constructor will instantiate an object of the\n                    // exposed class, set to it the plugin name and channel class parameters and return\n                    // it from the constructor\n                    var WrapperClass = function WrapperClass(attrs, props) {\n                        _classCallCheck(this, WrapperClass);\n\n                        var instantiatedIncident = new incidentClass(attrs, props);\n                        instantiatedIncident.plugin_channel_class = plugin.channel;\n                        instantiatedIncident.mc_plugin_npm_name = plugin.npm_name;\n\n                        if (plugin.channel.type === \"attributes\" && (!props.hasOwnProperty('selector') || props.selector === null || props.selector === undefined)) {\n                            helper.error('You tried to instantiate an Incident of plugin ' + plugin.npm_name + ' without passing props.selector. This plugin uses the AttributeChannel and thus all of its incidents must \\n                                    be initialised with a valid props.selector.');\n                            return false;\n                        }\n\n                        // it's a good idea to both validate the props here before returning the new object\n                        // also is a good idea to create a Proxy for the instantiated Incident to prevent setting:\n                        // id, plugin_channel_class, mc_plugin_npm_name\n\n                        return instantiatedIncident;\n                    };\n\n                    ;\n\n                    return WrapperClass;\n                }\n            });\n        };\n\n        for (var i = 0; i < plugin.incidents.length; i++) {\n            _loop(i);\n        }\n        return thePlugin;\n    }\n}\n\nvar ProgrammaticIncidentPluginDefinition = __webpack_require__(/*! ./corePlugins/ProgrammaticIncidents/main.js */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/ProgrammaticIncidents/main.js\");\nvar ProgrammaticIncidentPlugin = loadPlugin(ProgrammaticIncidentPluginDefinition);\n\nvar SelfContainedIncidentsPluginDefinition = __webpack_require__(/*! ./corePlugins/SelfContainedIncidents/main.js */ \"./node_modules/@kissmybutton/motorcortex/dist/corePlugins/SelfContainedIncidents/main.js\");\nvar SelfContainedIncidentsPlugin = loadPlugin(SelfContainedIncidentsPluginDefinition);\n\nvar TimeCapsule = __webpack_require__(/*! ./_coreUtils/TimeCapsule */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\n\nmodule.exports = {\n    Channel: Channel,\n    Group: Group,\n    Clip: SelfContainedIncidentsPlugin.Clip,\n    ClipFromDefinition: ClipFromDefinition,\n    Incident: Incident,\n    ProgrammaticIncident: ProgrammaticIncidentPlugin.ProgrammaticIncident,\n    DummyIncident: ProgrammaticIncidentPlugin.DummyIncident,\n    TimedIncident: TimedIncident,\n\n    // channels\n    AttributeChannel: AttributeChannel,\n\n    TimeCapsule: TimeCapsule,\n\n    conf: conf,\n    Timer: Timer,\n\n    Helper: Helper,\n\n    loadPlugin: loadPlugin\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L21haW4uanM/MzAyZCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIENoYW5uZWwgPSByZXF1aXJlKCcuL19DaGFubmVscy9DaGFubmVsJyk7XG52YXIgR3JvdXAgPSByZXF1aXJlKCcuL19CYXNlQ2xhc3Nlcy9Hcm91cCcpO1xudmFyIEluY2lkZW50ID0gcmVxdWlyZSgnLi9fQmFzZUNsYXNzZXMvSW5jaWRlbnQnKTtcbnZhciBUaW1lZEluY2lkZW50ID0gcmVxdWlyZSgnLi9fQmFzZUNsYXNzZXMvVGltZWRJbmNpZGVudCcpO1xudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4vX2NvcmVVdGlscy9IZWxwZXInKTt2YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIEF0dHJpYnV0ZUNoYW5uZWwgPSByZXF1aXJlKCcuL19DaGFubmVscy9fQXR0cmlidXRlL0F0dHJpYnV0ZUNoYW5uZWwnKTtcbnZhciBDbGlwRnJvbURlZmluaXRpb24gPSByZXF1aXJlKCcuL2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvQ2xpcEZyb21EZWZpbml0aW9uJyk7XG5cbnZhciBjb25mID0gcmVxdWlyZSgnLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgVGltZXIgPSByZXF1aXJlKCcuL3V0aWxzL1RpbWVyJyk7XG5cbnZhciBjaGVja1BsdWdpbiA9IGZ1bmN0aW9uIGNoZWNrUGx1Z2luKG1haW4pIHtcbiAgICBpZiAobWFpbi5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSB7XG4gICAgICAgIG1haW4gPSBtYWluLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgdmFyIHBsdWdpbl9uYW1lID0gbWFpbi5ucG1fbmFtZTtcbiAgICB2YXIgY2hlY2sgPSB0cnVlO1xuXG4gICAgaWYgKCFtYWluLmhhc093blByb3BlcnR5KCdpbmNpZGVudHMnKSkge1xuICAgICAgICBoZWxwZXIuZXJyb3IoJ0Vycm9yIG9uIHBsdWdpbiAnICsgcGx1Z2luX25hbWUgKyAnLiBBIHBsdWdpbiBtdXN0IGV4cG9zZSBhdCBsZWFzdCBvbmUgSW5jaWRlbnQuXFxuICAgICAgICBFeHBvc2VkIHBsdWdpbiBJbmNpZGVudHMgc2hvdWxkIGJlIGRlZmluZWQgb24gdGhlIFwiaW5jaWRlbnRzXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUuJyk7XG4gICAgICAgIGNoZWNrID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCFoZWxwZXIuaXNBcnJheShtYWluLmluY2lkZW50cykpIHtcbiAgICAgICAgaGVscGVyLmVycm9yKCdFcnJvciBvbiBwbHVnaW4gJyArIHBsdWdpbl9uYW1lICsgJy4gdGhlUGx1Z2luIGV4cG9zZWQgSW5jaWRlbnRzIGFyZSBkZWZpbmVkIG9uIHRoZSBcImluY2lkZW50c1wiIGtleSBvZiB0aGUgbWFpbi5qcyBmaWxlIGluIGFycmF5IGZvcm1hdC5cXG4gICAgICAgIFBsZWFzZSByZWZlciB0byB0aGUgZG9jdW1lbnRhdGlvbicpO1xuICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFpbi5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uID0gbWFpbi5pbmNpZGVudHNbaV07XG4gICAgICAgICAgICBpZiAoX3R5cGVvZihleHBvc2VkSW5jaWRlbnREZWZpbml0aW9uLmV4cG9ydGFibGUpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5oYXNPd25Qcm9wZXJ0eSgnZGVmYXVsdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZSA9IGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBJbmNpZGVudCkpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIuZXJyb3IoJ0Vycm9yIG9uIHBsdWdpbiAnICsgcGx1Z2luX25hbWUgKyAnLiBFeHBvcnRhYmxlIEluY2lkZW50cyBieSBhbnkgcGx1Z2luIG11c3QgZXh0ZW5kIG9uZSBvZiB0aGUgYmFzZSBjbGFzc2VzIHByb3ZpZGVkIGJ5IE1vdG9yQ29ydGV4LlxcbiAgICAgICAgICAgICAgICAnICsgZXhwb3NlZEluY2lkZW50RGVmaW5pdGlvbi5leHBvcnRhYmxlLmNvbnN0cnVjdG9yLm5hbWUgKyAnIGRvZXNuXFwndC5cXG4gICAgICAgICAgICAgICAgUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb24nKTtcbiAgICAgICAgICAgICAgICBjaGVjayA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uaGFzT3duUHJvcGVydHkoJ3Byb3BUeXBlcycpKSB7XG4gICAgICAgICAgICAgICAgaGVscGVyLmxvZygnV2FybmluZyBvbiBwbHVnaW4gJyArIHBsdWdpbl9uYW1lICsgJy5cXG4gICAgICAgICAgICAgICAgSXRcXCdzIGFsd2F5cyBnb29kIGZvciBwbHVnaW5zIHRvIGRlZmluZSB0aGUgc3VwcG9ydGVkIHByb3BUeXBlcyBvZiB0aGVpciBleHBvc2VkIEluY2lkZW50c1xcJyBzdXBwb3J0ZWQgcHJvcGVydGllcy5cXG4gICAgICAgICAgICAgICAgJyArIGV4cG9zZWRJbmNpZGVudERlZmluaXRpb24uZXhwb3J0YWJsZS5jb25zdHJ1Y3Rvci5uYW1lICsgJyBkb2VzblxcJ3QuXFxuICAgICAgICAgICAgICAgIFBsZWFzZSByZWZlciB0byBkb2N1bWVudGF0aW9uJywgJ3dhcm5pbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbWFpbi5oYXNPd25Qcm9wZXJ0eSgnY2hhbm5lbCcpKSB7XG4gICAgICAgIGhlbHBlci5lcnJvcignRXJyb3Igb24gcGx1Z2luICcgKyBwbHVnaW5fbmFtZSArICcuIEEgcGx1Z2luIG11c3QgYWx3YXlzIGRlZmluZSBpdHMgQ2hhbm5lbCBvbiB0aGUgXCJjaGFubmVsXCIga2V5IG9mIHRoZSBtYWluLmpzIGZpbGUuXFxuICAgICAgICBJdFxcJ3MgbWlzc2luZy4gUGxlYXNlIHJlZmVyIHRvIGRvY3VtZW50YXRpb24nKTtcbiAgICAgICAgY2hlY2sgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX3R5cGVvZihtYWluLmNoYW5uZWwpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAobWFpbi5jaGFubmVsLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICBtYWluLmNoYW5uZWwgPSBtYWluLmNoYW5uZWwuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjaGVjaztcbn07XG5cbi8vIHBsdWdpbl9uYW1lIGlzIHRoZSB1bmlxdWUgbmFtZSBvZiB0aGUgcGx1Z2luXG5mdW5jdGlvbiBsb2FkUGx1Z2luKHBsdWdpbikge1xuICAgIGlmIChwbHVnaW4uaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkge1xuICAgICAgICBwbHVnaW4gPSBwbHVnaW4uZGVmYXVsdDtcbiAgICB9XG5cbiAgICBpZiAoIXBsdWdpbi5oYXNPd25Qcm9wZXJ0eSgnbnBtX25hbWUnKSkge1xuICAgICAgICBwbHVnaW4ubnBtX25hbWUgPSAncGx1Z2luXycgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICBpZiAoIXBsdWdpbi5oYXNPd25Qcm9wZXJ0eSgnY2hhbm5lbCcpKSB7XG4gICAgICAgIHBsdWdpbi5jaGFubmVsID0gQ2hhbm5lbDtcbiAgICB9XG4gICAgaWYgKCFjaGVja1BsdWdpbihwbHVnaW4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVQbHVnaW4gaXMgdGhlIHBsdWdpbiBvYmplY3Qgd2hpY2ggd2lsbCBob2xkIG9uIGl0cyBrZXlzXG4gICAgICAgIC8vIHRoZSBuYW1lcyBvZiB0aGUgZXhwb3NlZCBJbmNpZGVudHMgb2YgaXRzLiBUaGUga2V5cyBvZiB0aGlzIG9iamVjdFxuICAgICAgICAvLyBhcmUgZ29pbmcgdG8gYmUgaWRlbnRpY2FsIHdpdGggdGhlIG5hbWVzIG9mIHRoZSBjbGFzc2VzIGV4cG9zZWRcbiAgICAgICAgdmFyIHRoZVBsdWdpbiA9IHt9O1xuXG4gICAgICAgIGlmIChwbHVnaW4uaGFzT3duUHJvcGVydHkoJ2NsaXAnKSkge1xuICAgICAgICAgICAgaWYgKF90eXBlb2YocGx1Z2luLmNsaXApID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5jbGlwLmhhc093blByb3BlcnR5KCdkZWZhdWx0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luLmNsaXAgPSBwbHVnaW4uY2xpcC5kZWZhdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoZVBsdWdpbi5DbGlwID0gcGx1Z2luLmNsaXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmb3IgZWFjaCBvZiB0aGUgZXhwb3NlZCBJbmNpZGVudHNcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpKSB7XG4gICAgICAgICAgICB2YXIgaW5jaWRlbnRDbGFzcyA9IHBsdWdpbi5pbmNpZGVudHNbaV0uZXhwb3J0YWJsZTtcblxuICAgICAgICAgICAgLy8gVE9ETyBoYW5sZGUgdGhlIGRpZmZlcmVudCBjc3Mgc3R5bGUgaXNvbGF0aW9uIHZlcnNpb25zIHRocm91Z2ggdGhlIGNzc0lzb2xhdGlvbiBwYXJhbWV0ZXIgb2YgdGhlIGNvbnRhaW5lclBhcmFtcyBvZiB0aGUgaW5jaWRlbnRcblxuICAgICAgICAgICAgLy8gZHluYW1pY2FsbHkgYXNzaWduIGdldHRlcnMgb24gdGhlIEluY2lkZW50J3MgbmFtZSBrZXkgb2YgdGhlIHRoZVBsdWdpbiBvYmplY3RcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGVQbHVnaW4sIGluY2lkZW50Q2xhc3MubmFtZSwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZ2V0dGVyIHdpbGwgY29uc3RydWN0IGEgd3JhcHBlciBjbGFzcyB3aGljaCBvbiB0aGUgY29uc3RydWN0b3Igd2lsbCBpbnN0YW50aWF0ZSBhbiBvYmplY3Qgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4cG9zZWQgY2xhc3MsIHNldCB0byBpdCB0aGUgcGx1Z2luIG5hbWUgYW5kIGNoYW5uZWwgY2xhc3MgcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICAgICAgICAgIHZhciBXcmFwcGVyQ2xhc3MgPSBmdW5jdGlvbiBXcmFwcGVyQ2xhc3MoYXR0cnMsIHByb3BzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV3JhcHBlckNsYXNzKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbnRpYXRlZEluY2lkZW50ID0gbmV3IGluY2lkZW50Q2xhc3MoYXR0cnMsIHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbnRpYXRlZEluY2lkZW50LnBsdWdpbl9jaGFubmVsX2NsYXNzID0gcGx1Z2luLmNoYW5uZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YW50aWF0ZWRJbmNpZGVudC5tY19wbHVnaW5fbnBtX25hbWUgPSBwbHVnaW4ubnBtX25hbWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwbHVnaW4uY2hhbm5lbC50eXBlID09PSBcImF0dHJpYnV0ZXNcIiAmJiAoIXByb3BzLmhhc093blByb3BlcnR5KCdzZWxlY3RvcicpIHx8IHByb3BzLnNlbGVjdG9yID09PSBudWxsIHx8IHByb3BzLnNlbGVjdG9yID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyLmVycm9yKCdZb3UgdHJpZWQgdG8gaW5zdGFudGlhdGUgYW4gSW5jaWRlbnQgb2YgcGx1Z2luICcgKyBwbHVnaW4ubnBtX25hbWUgKyAnIHdpdGhvdXQgcGFzc2luZyBwcm9wcy5zZWxlY3Rvci4gVGhpcyBwbHVnaW4gdXNlcyB0aGUgQXR0cmlidXRlQ2hhbm5lbCBhbmQgdGh1cyBhbGwgb2YgaXRzIGluY2lkZW50cyBtdXN0IFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlIGluaXRpYWxpc2VkIHdpdGggYSB2YWxpZCBwcm9wcy5zZWxlY3Rvci4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3MgYSBnb29kIGlkZWEgdG8gYm90aCB2YWxpZGF0ZSB0aGUgcHJvcHMgaGVyZSBiZWZvcmUgcmV0dXJuaW5nIHRoZSBuZXcgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGlzIGEgZ29vZCBpZGVhIHRvIGNyZWF0ZSBhIFByb3h5IGZvciB0aGUgaW5zdGFudGlhdGVkIEluY2lkZW50IHRvIHByZXZlbnQgc2V0dGluZzpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlkLCBwbHVnaW5fY2hhbm5lbF9jbGFzcywgbWNfcGx1Z2luX25wbV9uYW1lXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW50aWF0ZWRJbmNpZGVudDtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICA7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFdyYXBwZXJDbGFzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbi5pbmNpZGVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF9sb29wKGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGVQbHVnaW47XG4gICAgfVxufVxuXG52YXIgUHJvZ3JhbW1hdGljSW5jaWRlbnRQbHVnaW5EZWZpbml0aW9uID0gcmVxdWlyZSgnLi9jb3JlUGx1Z2lucy9Qcm9ncmFtbWF0aWNJbmNpZGVudHMvbWFpbi5qcycpO1xudmFyIFByb2dyYW1tYXRpY0luY2lkZW50UGx1Z2luID0gbG9hZFBsdWdpbihQcm9ncmFtbWF0aWNJbmNpZGVudFBsdWdpbkRlZmluaXRpb24pO1xuXG52YXIgU2VsZkNvbnRhaW5lZEluY2lkZW50c1BsdWdpbkRlZmluaXRpb24gPSByZXF1aXJlKCcuL2NvcmVQbHVnaW5zL1NlbGZDb250YWluZWRJbmNpZGVudHMvbWFpbi5qcycpO1xudmFyIFNlbGZDb250YWluZWRJbmNpZGVudHNQbHVnaW4gPSBsb2FkUGx1Z2luKFNlbGZDb250YWluZWRJbmNpZGVudHNQbHVnaW5EZWZpbml0aW9uKTtcblxudmFyIFRpbWVDYXBzdWxlID0gcmVxdWlyZSgnLi9fY29yZVV0aWxzL1RpbWVDYXBzdWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENoYW5uZWw6IENoYW5uZWwsXG4gICAgR3JvdXA6IEdyb3VwLFxuICAgIENsaXA6IFNlbGZDb250YWluZWRJbmNpZGVudHNQbHVnaW4uQ2xpcCxcbiAgICBDbGlwRnJvbURlZmluaXRpb246IENsaXBGcm9tRGVmaW5pdGlvbixcbiAgICBJbmNpZGVudDogSW5jaWRlbnQsXG4gICAgUHJvZ3JhbW1hdGljSW5jaWRlbnQ6IFByb2dyYW1tYXRpY0luY2lkZW50UGx1Z2luLlByb2dyYW1tYXRpY0luY2lkZW50LFxuICAgIER1bW15SW5jaWRlbnQ6IFByb2dyYW1tYXRpY0luY2lkZW50UGx1Z2luLkR1bW15SW5jaWRlbnQsXG4gICAgVGltZWRJbmNpZGVudDogVGltZWRJbmNpZGVudCxcblxuICAgIC8vIGNoYW5uZWxzXG4gICAgQXR0cmlidXRlQ2hhbm5lbDogQXR0cmlidXRlQ2hhbm5lbCxcblxuICAgIFRpbWVDYXBzdWxlOiBUaW1lQ2Fwc3VsZSxcblxuICAgIGNvbmY6IGNvbmYsXG4gICAgVGltZXI6IFRpbWVyLFxuXG4gICAgSGVscGVyOiBIZWxwZXIsXG5cbiAgICBsb2FkUGx1Z2luOiBsb2FkUGx1Z2luXG59OyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/main.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Helper = __webpack_require__(/*! ../_coreUtils/Helper */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/Helper.js\");\nvar helper = new Helper();\nvar conf = __webpack_require__(/*! ../configuration/generalConf */ \"./node_modules/@kissmybutton/motorcortex/dist/configuration/generalConf.js\");\nvar Draggabilly = __webpack_require__(/*! draggabilly */ \"./node_modules/draggabilly/draggabilly.js\");\nvar TimeCapsule = __webpack_require__(/*! ../_coreUtils/TimeCapsule */ \"./node_modules/@kissmybutton/motorcortex/dist/_coreUtils/TimeCapsule.js\");\nvar timeCapsule = new TimeCapsule();\nvar journey = null;\n\n/**\n * @classdesc\n * Timer's purpose is to provide an interface through which any TimedIncident (such as a Scene or a Clip)\n * can both privide info regarding their timing state but also provide an interface for interacting /\n * altering the timing of it\n */\n\nvar Timer = function () {\n    function Timer(props) {\n        _classCallCheck(this, Timer);\n\n        this.id = props.id || helper.getAnId();\n        this.cursor = document.getElementById('time-cursor');\n        this.leftSlot = document.getElementsByClassName('left-slot')[0];\n        this.rightSlot = document.getElementsByClassName('right-slot')[0];\n        this.playButton = document.getElementById('play-pause');\n        this.Incident = props.Incident;\n        this.subscribeToTimer();\n        this.subscribeToEvents();\n        this.afterRender();\n        this.previousTimestamp = 0;\n        this.previousIncidentState = 'idle';\n        this.width = props.width;\n        this.cursorWidth = props.cursorWidth || 10;\n    }\n\n    _createClass(Timer, [{\n        key: 'millisecondChange',\n        value: function millisecondChange(millisecond, state) {\n            // helper.log(millisecond);\n            this.cursor.style.left = 'calc(' + millisecond * 100 / this.Incident.duration + '% - ' + this.cursorWidth + 'px)';\n            this.leftSlot.innerHTML = millisecond;\n            this.rightSlot.innerHTML = this.Incident.duration - millisecond;\n        }\n    }, {\n        key: 'eventBroadcast',\n        value: function eventBroadcast(eventName, meta) {\n            if (eventName === 'state-change') {\n                if (meta.newState === 'waiting') {\n                    this.playButton.innerHTML = 'Resume';\n                } else if (meta.newState === 'playing') {\n                    this.playButton.innerHTML = 'Pause';\n                } else if (meta.newState === 'completed') {\n                    this.leftSlot.innerHTML = this.Incident.duration;\n                    this.rightSlot.innerHTML = 0;\n                    this.playButton.innerHTML = \"completed\";\n                    helper.log(this.Incident);\n                } else if (meta.newState === 'transitional') {\n                    this.playButton.innerHTML = \"transitioning\";\n                } else if (meta.newState === 'idle') {\n                    this.playButton.innerHTML = \"Play\";\n                }\n            } else if (eventName === 'attribute-rejection') {\n                helper.log('Attributes', meta.attributes, 'have been rejected from animation with id ' + meta.animationID);\n            } else if (eventName === 'animation-rejection') {\n                helper.log('Animation ' + meta.animationID + ' has been rejected as all attributes of it overlap on specific elements because of existing animations');\n            } else if (eventName === 'duration-change') {\n                this.millisecondChange(this.Incident.runTimeInfo.currentMillisecond, this.Incident.state);\n            }\n        }\n    }, {\n        key: 'subscribeToEvents',\n        value: function subscribeToEvents() {\n            // helper.error('Timer is subscirbing to the clips events');\n            this.Incident.subscribeToEvents(this.id, this.eventBroadcast.bind(this));\n        }\n    }, {\n        key: 'subscribeToTimer',\n        value: function subscribeToTimer() {\n            // helper.log('Timer is subscirbing to the clips timer', 'notice');\n            this.Incident.subscribe(this.id, this.millisecondChange.bind(this));\n        }\n    }, {\n        key: 'handleDragStart',\n        value: function handleDragStart(event, pointer) {\n            // helper.log('drag is starting', 'warning')\n            journey = timeCapsule.startJourney(this.Incident);\n        }\n    }, {\n        key: 'handleDrag',\n        value: function handleDrag(event, pointer, position) {\n            var millisecond = Math.round(this.Incident.duration * position.x / this.width);\n            if (millisecond < 0) {\n                millisecond = 0;\n            }\n            this.leftSlot.innerHTML = millisecond;\n            this.rightSlot.innerHTML = this.Incident.duration - millisecond;\n\n            journey.station(millisecond);\n        }\n    }, {\n        key: 'handleDragEnd',\n        value: function handleDragEnd(event, pointer) {\n            //  Velocity.defaults.speed=1;\n            // this.previousTimestamp is the target millisecond of the drag\n\n            journey.destination();\n\n            helper.log(this.Incident.exportState());\n        }\n    }, {\n        key: 'afterRender',\n        value: function afterRender() {\n            var that = this;\n\n            this.playButton.onclick = function (e) {\n                if (that.Incident.state === 'playing') {\n                    that.Incident.wait();\n                } else if (that.Incident.state === 'waiting') {\n                    that.Incident.resume();\n                } else if (that.Incident.state === 'idle') {\n                    that.Incident.play();\n                }\n            };\n\n            var elem = document.querySelector('#time-cursor');\n            var draggie = new Draggabilly(elem, {\n                axis: 'x',\n                containment: '.bar'\n            });\n\n            draggie.on('dragStart', this.handleDragStart.bind(this));\n            draggie.on('dragMove', function (event, pointer) {\n                that.handleDrag(event, pointer, draggie.position);\n            });\n            draggie.on('dragEnd', this.handleDragEnd.bind(this));\n        }\n    }, {\n        key: 'render',\n        value: function render(container) {}\n    }]);\n\n    return Timer;\n}();\n\nmodule.exports = Timer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9kaXN0L3V0aWxzL1RpbWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BraXNzbXlidXR0b24vbW90b3Jjb3J0ZXgvZGlzdC91dGlscy9UaW1lci5qcz85NmYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEhlbHBlciA9IHJlcXVpcmUoJy4uL19jb3JlVXRpbHMvSGVscGVyJyk7XG52YXIgaGVscGVyID0gbmV3IEhlbHBlcigpO1xudmFyIGNvbmYgPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2dlbmVyYWxDb25mJyk7XG52YXIgRHJhZ2dhYmlsbHkgPSByZXF1aXJlKCdkcmFnZ2FiaWxseScpO1xudmFyIFRpbWVDYXBzdWxlID0gcmVxdWlyZSgnLi4vX2NvcmVVdGlscy9UaW1lQ2Fwc3VsZScpO1xudmFyIHRpbWVDYXBzdWxlID0gbmV3IFRpbWVDYXBzdWxlKCk7XG52YXIgam91cm5leSA9IG51bGw7XG5cbi8qKlxuICogQGNsYXNzZGVzY1xuICogVGltZXIncyBwdXJwb3NlIGlzIHRvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIHRocm91Z2ggd2hpY2ggYW55IFRpbWVkSW5jaWRlbnQgKHN1Y2ggYXMgYSBTY2VuZSBvciBhIENsaXApXG4gKiBjYW4gYm90aCBwcml2aWRlIGluZm8gcmVnYXJkaW5nIHRoZWlyIHRpbWluZyBzdGF0ZSBidXQgYWxzbyBwcm92aWRlIGFuIGludGVyZmFjZSBmb3IgaW50ZXJhY3RpbmcgL1xuICogYWx0ZXJpbmcgdGhlIHRpbWluZyBvZiBpdFxuICovXG5cbnZhciBUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaW1lcihwcm9wcykge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGltZXIpO1xuXG4gICAgICAgIHRoaXMuaWQgPSBwcm9wcy5pZCB8fCBoZWxwZXIuZ2V0QW5JZCgpO1xuICAgICAgICB0aGlzLmN1cnNvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0aW1lLWN1cnNvcicpO1xuICAgICAgICB0aGlzLmxlZnRTbG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnbGVmdC1zbG90JylbMF07XG4gICAgICAgIHRoaXMucmlnaHRTbG90ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmlnaHQtc2xvdCcpWzBdO1xuICAgICAgICB0aGlzLnBsYXlCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGxheS1wYXVzZScpO1xuICAgICAgICB0aGlzLkluY2lkZW50ID0gcHJvcHMuSW5jaWRlbnQ7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG9UaW1lcigpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZVRvRXZlbnRzKCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJSZW5kZXIoKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1RpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMucHJldmlvdXNJbmNpZGVudFN0YXRlID0gJ2lkbGUnO1xuICAgICAgICB0aGlzLndpZHRoID0gcHJvcHMud2lkdGg7XG4gICAgICAgIHRoaXMuY3Vyc29yV2lkdGggPSBwcm9wcy5jdXJzb3JXaWR0aCB8fCAxMDtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoVGltZXIsIFt7XG4gICAgICAgIGtleTogJ21pbGxpc2Vjb25kQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIG1pbGxpc2Vjb25kQ2hhbmdlKG1pbGxpc2Vjb25kLCBzdGF0ZSkge1xuICAgICAgICAgICAgLy8gaGVscGVyLmxvZyhtaWxsaXNlY29uZCk7XG4gICAgICAgICAgICB0aGlzLmN1cnNvci5zdHlsZS5sZWZ0ID0gJ2NhbGMoJyArIG1pbGxpc2Vjb25kICogMTAwIC8gdGhpcy5JbmNpZGVudC5kdXJhdGlvbiArICclIC0gJyArIHRoaXMuY3Vyc29yV2lkdGggKyAncHgpJztcbiAgICAgICAgICAgIHRoaXMubGVmdFNsb3QuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0U2xvdC5pbm5lckhUTUwgPSB0aGlzLkluY2lkZW50LmR1cmF0aW9uIC0gbWlsbGlzZWNvbmQ7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2V2ZW50QnJvYWRjYXN0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV2ZW50QnJvYWRjYXN0KGV2ZW50TmFtZSwgbWV0YSkge1xuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3N0YXRlLWNoYW5nZScpIHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YS5uZXdTdGF0ZSA9PT0gJ3dhaXRpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGxheUJ1dHRvbi5pbm5lckhUTUwgPSAnUmVzdW1lJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5uZXJIVE1MID0gJ1BhdXNlJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGEubmV3U3RhdGUgPT09ICdjb21wbGV0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVmdFNsb3QuaW5uZXJIVE1MID0gdGhpcy5JbmNpZGVudC5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yaWdodFNsb3QuaW5uZXJIVE1MID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlubmVySFRNTCA9IFwiY29tcGxldGVkXCI7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlci5sb2codGhpcy5JbmNpZGVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhLm5ld1N0YXRlID09PSAndHJhbnNpdGlvbmFsJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24uaW5uZXJIVE1MID0gXCJ0cmFuc2l0aW9uaW5nXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRhLm5ld1N0YXRlID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5QnV0dG9uLmlubmVySFRNTCA9IFwiUGxheVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnYXR0cmlidXRlLXJlamVjdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoZWxwZXIubG9nKCdBdHRyaWJ1dGVzJywgbWV0YS5hdHRyaWJ1dGVzLCAnaGF2ZSBiZWVuIHJlamVjdGVkIGZyb20gYW5pbWF0aW9uIHdpdGggaWQgJyArIG1ldGEuYW5pbWF0aW9uSUQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdhbmltYXRpb24tcmVqZWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGhlbHBlci5sb2coJ0FuaW1hdGlvbiAnICsgbWV0YS5hbmltYXRpb25JRCArICcgaGFzIGJlZW4gcmVqZWN0ZWQgYXMgYWxsIGF0dHJpYnV0ZXMgb2YgaXQgb3ZlcmxhcCBvbiBzcGVjaWZpYyBlbGVtZW50cyBiZWNhdXNlIG9mIGV4aXN0aW5nIGFuaW1hdGlvbnMnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnZHVyYXRpb24tY2hhbmdlJykge1xuICAgICAgICAgICAgICAgIHRoaXMubWlsbGlzZWNvbmRDaGFuZ2UodGhpcy5JbmNpZGVudC5ydW5UaW1lSW5mby5jdXJyZW50TWlsbGlzZWNvbmQsIHRoaXMuSW5jaWRlbnQuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmVUb0V2ZW50cycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzdWJzY3JpYmVUb0V2ZW50cygpIHtcbiAgICAgICAgICAgIC8vIGhlbHBlci5lcnJvcignVGltZXIgaXMgc3Vic2NpcmJpbmcgdG8gdGhlIGNsaXBzIGV2ZW50cycpO1xuICAgICAgICAgICAgdGhpcy5JbmNpZGVudC5zdWJzY3JpYmVUb0V2ZW50cyh0aGlzLmlkLCB0aGlzLmV2ZW50QnJvYWRjYXN0LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdzdWJzY3JpYmVUb1RpbWVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnNjcmliZVRvVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdUaW1lciBpcyBzdWJzY2lyYmluZyB0byB0aGUgY2xpcHMgdGltZXInLCAnbm90aWNlJyk7XG4gICAgICAgICAgICB0aGlzLkluY2lkZW50LnN1YnNjcmliZSh0aGlzLmlkLCB0aGlzLm1pbGxpc2Vjb25kQ2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICdoYW5kbGVEcmFnU3RhcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ1N0YXJ0KGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICAgICAgICAvLyBoZWxwZXIubG9nKCdkcmFnIGlzIHN0YXJ0aW5nJywgJ3dhcm5pbmcnKVxuICAgICAgICAgICAgam91cm5leSA9IHRpbWVDYXBzdWxlLnN0YXJ0Sm91cm5leSh0aGlzLkluY2lkZW50KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFuZGxlRHJhZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEcmFnKGV2ZW50LCBwb2ludGVyLCBwb3NpdGlvbikge1xuICAgICAgICAgICAgdmFyIG1pbGxpc2Vjb25kID0gTWF0aC5yb3VuZCh0aGlzLkluY2lkZW50LmR1cmF0aW9uICogcG9zaXRpb24ueCAvIHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgaWYgKG1pbGxpc2Vjb25kIDwgMCkge1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubGVmdFNsb3QuaW5uZXJIVE1MID0gbWlsbGlzZWNvbmQ7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0U2xvdC5pbm5lckhUTUwgPSB0aGlzLkluY2lkZW50LmR1cmF0aW9uIC0gbWlsbGlzZWNvbmQ7XG5cbiAgICAgICAgICAgIGpvdXJuZXkuc3RhdGlvbihtaWxsaXNlY29uZCk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhbmRsZURyYWdFbmQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRHJhZ0VuZChldmVudCwgcG9pbnRlcikge1xuICAgICAgICAgICAgLy8gIFZlbG9jaXR5LmRlZmF1bHRzLnNwZWVkPTE7XG4gICAgICAgICAgICAvLyB0aGlzLnByZXZpb3VzVGltZXN0YW1wIGlzIHRoZSB0YXJnZXQgbWlsbGlzZWNvbmQgb2YgdGhlIGRyYWdcblxuICAgICAgICAgICAgam91cm5leS5kZXN0aW5hdGlvbigpO1xuXG4gICAgICAgICAgICBoZWxwZXIubG9nKHRoaXMuSW5jaWRlbnQuZXhwb3J0U3RhdGUoKSk7XG4gICAgICAgIH1cbiAgICB9LCB7XG4gICAgICAgIGtleTogJ2FmdGVyUmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFmdGVyUmVuZGVyKCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgICAgICB0aGlzLnBsYXlCdXR0b24ub25jbGljayA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQuSW5jaWRlbnQuc3RhdGUgPT09ICdwbGF5aW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LkluY2lkZW50LndhaXQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoYXQuSW5jaWRlbnQuc3RhdGUgPT09ICd3YWl0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LkluY2lkZW50LnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhhdC5JbmNpZGVudC5zdGF0ZSA9PT0gJ2lkbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuSW5jaWRlbnQucGxheSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBlbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3RpbWUtY3Vyc29yJyk7XG4gICAgICAgICAgICB2YXIgZHJhZ2dpZSA9IG5ldyBEcmFnZ2FiaWxseShlbGVtLCB7XG4gICAgICAgICAgICAgICAgYXhpczogJ3gnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5tZW50OiAnLmJhcidcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkcmFnZ2llLm9uKCdkcmFnU3RhcnQnLCB0aGlzLmhhbmRsZURyYWdTdGFydC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGRyYWdnaWUub24oJ2RyYWdNb3ZlJywgZnVuY3Rpb24gKGV2ZW50LCBwb2ludGVyKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5oYW5kbGVEcmFnKGV2ZW50LCBwb2ludGVyLCBkcmFnZ2llLnBvc2l0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZHJhZ2dpZS5vbignZHJhZ0VuZCcsIHRoaXMuaGFuZGxlRHJhZ0VuZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVuZGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihjb250YWluZXIpIHt9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFRpbWVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/dist/utils/Timer.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used to compose bitmasks for cloning. */\nvar CLONE_DEEP_FLAG = 1,\n    CLONE_FLAT_FLAG = 2,\n    CLONE_SYMBOLS_FLAG = 4;\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match `RegExp` flags from their coerced string values. */\nvar reFlags = /\\w*$/;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Used to identify `toStringTag` values supported by `_.clone`. */\nvar cloneableTags = {};\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\ncloneableTags[boolTag] = cloneableTags[dateTag] =\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\ncloneableTags[numberTag] = cloneableTags[objectTag] =\ncloneableTags[regexpTag] = cloneableTags[setTag] =\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\ncloneableTags[errorTag] = cloneableTags[funcTag] =\ncloneableTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsMap = nodeUtil && nodeUtil.isMap,\n    nodeIsSet = nodeUtil && nodeUtil.isSet,\n    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.forEach` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns `array`.\n */\nfunction arrayEach(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (iteratee(array[index], index, array) === false) {\n      break;\n    }\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,\n    getPrototype = overArg(Object.getPrototypeOf, Object),\n    objectCreate = Object.create,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\n\n/**\n * The base implementation of `_.create` without support for assigning\n * properties to the created object.\n *\n * @private\n * @param {Object} proto The object to inherit from.\n * @returns {Object} Returns the new object.\n */\nvar baseCreate = (function() {\n  function object() {}\n  return function(proto) {\n    if (!isObject(proto)) {\n      return {};\n    }\n    if (objectCreate) {\n      return objectCreate(proto);\n    }\n    object.prototype = proto;\n    var result = new object;\n    object.prototype = undefined;\n    return result;\n  };\n}());\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.assign` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssign(object, source) {\n  return object && copyObject(source, keys(source), object);\n}\n\n/**\n * The base implementation of `_.assignIn` without support for multiple sources\n * or `customizer` functions.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @returns {Object} Returns `object`.\n */\nfunction baseAssignIn(object, source) {\n  return object && copyObject(source, keysIn(source), object);\n}\n\n/**\n * The base implementation of `assignValue` and `assignMergeValue` without\n * value checks.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction baseAssignValue(object, key, value) {\n  if (key == '__proto__' && defineProperty) {\n    defineProperty(object, key, {\n      'configurable': true,\n      'enumerable': true,\n      'value': value,\n      'writable': true\n    });\n  } else {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\n * traversed objects.\n *\n * @private\n * @param {*} value The value to clone.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Deep clone\n *  2 - Flatten inherited properties\n *  4 - Clone symbols\n * @param {Function} [customizer] The function to customize cloning.\n * @param {string} [key] The key of `value`.\n * @param {Object} [object] The parent object of `value`.\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\n * @returns {*} Returns the cloned value.\n */\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\n  var result,\n      isDeep = bitmask & CLONE_DEEP_FLAG,\n      isFlat = bitmask & CLONE_FLAT_FLAG,\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\n\n  if (customizer) {\n    result = object ? customizer(value, key, object, stack) : customizer(value);\n  }\n  if (result !== undefined) {\n    return result;\n  }\n  if (!isObject(value)) {\n    return value;\n  }\n  var isArr = isArray(value);\n  if (isArr) {\n    result = initCloneArray(value);\n    if (!isDeep) {\n      return copyArray(value, result);\n    }\n  } else {\n    var tag = getTag(value),\n        isFunc = tag == funcTag || tag == genTag;\n\n    if (isBuffer(value)) {\n      return cloneBuffer(value, isDeep);\n    }\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\n      if (!isDeep) {\n        return isFlat\n          ? copySymbolsIn(value, baseAssignIn(result, value))\n          : copySymbols(value, baseAssign(result, value));\n      }\n    } else {\n      if (!cloneableTags[tag]) {\n        return object ? value : {};\n      }\n      result = initCloneByTag(value, tag, isDeep);\n    }\n  }\n  // Check for circular references and return its corresponding clone.\n  stack || (stack = new Stack);\n  var stacked = stack.get(value);\n  if (stacked) {\n    return stacked;\n  }\n  stack.set(value, result);\n\n  if (isSet(value)) {\n    value.forEach(function(subValue) {\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n    });\n\n    return result;\n  }\n\n  if (isMap(value)) {\n    value.forEach(function(subValue, key) {\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\n    });\n\n    return result;\n  }\n\n  var keysFunc = isFull\n    ? (isFlat ? getAllKeysIn : getAllKeys)\n    : (isFlat ? keysIn : keys);\n\n  var props = isArr ? undefined : keysFunc(value);\n  arrayEach(props || value, function(subValue, key) {\n    if (props) {\n      key = subValue;\n      subValue = value[key];\n    }\n    // Recursively populate clone (susceptible to call stack limits).\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\n  });\n  return result;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isMap` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n */\nfunction baseIsMap(value) {\n  return isObjectLike(value) && getTag(value) == mapTag;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isSet` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n */\nfunction baseIsSet(value) {\n  return isObjectLike(value) && getTag(value) == setTag;\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Creates a clone of  `buffer`.\n *\n * @private\n * @param {Buffer} buffer The buffer to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Buffer} Returns the cloned buffer.\n */\nfunction cloneBuffer(buffer, isDeep) {\n  if (isDeep) {\n    return buffer.slice();\n  }\n  var length = buffer.length,\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n\n  buffer.copy(result);\n  return result;\n}\n\n/**\n * Creates a clone of `arrayBuffer`.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\n * @returns {ArrayBuffer} Returns the cloned array buffer.\n */\nfunction cloneArrayBuffer(arrayBuffer) {\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\n  return result;\n}\n\n/**\n * Creates a clone of `dataView`.\n *\n * @private\n * @param {Object} dataView The data view to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned data view.\n */\nfunction cloneDataView(dataView, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n}\n\n/**\n * Creates a clone of `regexp`.\n *\n * @private\n * @param {Object} regexp The regexp to clone.\n * @returns {Object} Returns the cloned regexp.\n */\nfunction cloneRegExp(regexp) {\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n  result.lastIndex = regexp.lastIndex;\n  return result;\n}\n\n/**\n * Creates a clone of the `symbol` object.\n *\n * @private\n * @param {Object} symbol The symbol object to clone.\n * @returns {Object} Returns the cloned symbol object.\n */\nfunction cloneSymbol(symbol) {\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\n}\n\n/**\n * Creates a clone of `typedArray`.\n *\n * @private\n * @param {Object} typedArray The typed array to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the cloned typed array.\n */\nfunction cloneTypedArray(typedArray, isDeep) {\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n}\n\n/**\n * Copies the values of `source` to `array`.\n *\n * @private\n * @param {Array} source The array to copy values from.\n * @param {Array} [array=[]] The array to copy values to.\n * @returns {Array} Returns `array`.\n */\nfunction copyArray(source, array) {\n  var index = -1,\n      length = source.length;\n\n  array || (array = Array(length));\n  while (++index < length) {\n    array[index] = source[index];\n  }\n  return array;\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  var isNew = !object;\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    if (newValue === undefined) {\n      newValue = source[key];\n    }\n    if (isNew) {\n      baseAssignValue(object, key, newValue);\n    } else {\n      assignValue(object, key, newValue);\n    }\n  }\n  return object;\n}\n\n/**\n * Copies own symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbols(source, object) {\n  return copyObject(source, getSymbols(source), object);\n}\n\n/**\n * Copies own and inherited symbols of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy symbols from.\n * @param {Object} [object={}] The object to copy symbols to.\n * @returns {Object} Returns `object`.\n */\nfunction copySymbolsIn(source, object) {\n  return copyObject(source, getSymbolsIn(source), object);\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Creates an array of own and inherited enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeysIn(object) {\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Creates an array of the own and inherited enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n  var result = [];\n  while (object) {\n    arrayPush(result, getSymbols(object));\n    object = getPrototype(object);\n  }\n  return result;\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Initializes an array clone.\n *\n * @private\n * @param {Array} array The array to clone.\n * @returns {Array} Returns the initialized clone.\n */\nfunction initCloneArray(array) {\n  var length = array.length,\n      result = new array.constructor(length);\n\n  // Add properties assigned by `RegExp#exec`.\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\n    result.index = array.index;\n    result.input = array.input;\n  }\n  return result;\n}\n\n/**\n * Initializes an object clone.\n *\n * @private\n * @param {Object} object The object to clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneObject(object) {\n  return (typeof object.constructor == 'function' && !isPrototype(object))\n    ? baseCreate(getPrototype(object))\n    : {};\n}\n\n/**\n * Initializes an object clone based on its `toStringTag`.\n *\n * **Note:** This function only supports cloning values with tags of\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\n *\n * @private\n * @param {Object} object The object to clone.\n * @param {string} tag The `toStringTag` of the object to clone.\n * @param {boolean} [isDeep] Specify a deep clone.\n * @returns {Object} Returns the initialized clone.\n */\nfunction initCloneByTag(object, tag, isDeep) {\n  var Ctor = object.constructor;\n  switch (tag) {\n    case arrayBufferTag:\n      return cloneArrayBuffer(object);\n\n    case boolTag:\n    case dateTag:\n      return new Ctor(+object);\n\n    case dataViewTag:\n      return cloneDataView(object, isDeep);\n\n    case float32Tag: case float64Tag:\n    case int8Tag: case int16Tag: case int32Tag:\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\n      return cloneTypedArray(object, isDeep);\n\n    case mapTag:\n      return new Ctor;\n\n    case numberTag:\n    case stringTag:\n      return new Ctor(object);\n\n    case regexpTag:\n      return cloneRegExp(object);\n\n    case setTag:\n      return new Ctor;\n\n    case symbolTag:\n      return cloneSymbol(object);\n  }\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.clone` except that it recursively clones `value`.\n *\n * @static\n * @memberOf _\n * @since 1.0.0\n * @category Lang\n * @param {*} value The value to recursively clone.\n * @returns {*} Returns the deep cloned value.\n * @see _.clone\n * @example\n *\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\n *\n * var deep = _.cloneDeep(objects);\n * console.log(deep[0] === objects[0]);\n * // => false\n */\nfunction cloneDeep(value) {\n  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Map` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\n * @example\n *\n * _.isMap(new Map);\n * // => true\n *\n * _.isMap(new WeakMap);\n * // => false\n */\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n\n/**\n * Checks if `value` is classified as a `Set` object.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\n * @example\n *\n * _.isSet(new Set);\n * // => true\n *\n * _.isSet(new WeakSet);\n * // => false\n */\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = cloneDeep;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmNsb25lZGVlcC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guY2xvbmVkZWVwL2luZGV4LmpzPzAzYzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGAgZmxhZ3MgZnJvbSB0aGVpciBjb2VyY2VkIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVGbGFncyA9IC9cXHcqJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc01hcCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzTWFwLFxuICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpID09PSBmYWxzZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBhbGxvY1Vuc2FmZSA9IEJ1ZmZlciA/IEJ1ZmZlci5hbGxvY1Vuc2FmZSA6IHVuZGVmaW5lZCxcbiAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICBvYmplY3RDcmVhdGUgPSBPYmplY3QuY3JlYXRlLFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY3JlYXRlYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFzc2lnbmluZ1xuICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbnZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBvYmplY3QoKSB7fVxuICByZXR1cm4gZnVuY3Rpb24ocHJvdG8pIHtcbiAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICB9XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgIG9iamVjdC5wcm90b3R5cGUgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIG11bHRpcGxlIHNvdXJjZXNcbiAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25JbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gRGVlcCBjbG9uZVxuICogIDIgLSBGbGF0dGVuIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gKiAgNCAtIENsb25lIHN5bWJvbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCBvYmplY3QsIHN0YWNrKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRyxcbiAgICAgIGlzRnVsbCA9IGJpdG1hc2sgJiBDTE9ORV9TWU1CT0xTX0ZMQUc7XG5cbiAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICByZXN1bHQgPSBvYmplY3QgPyBjdXN0b21pemVyKHZhbHVlLCBrZXksIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcih2YWx1ZSk7XG4gIH1cbiAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgaWYgKGlzQXJyKSB7XG4gICAgcmVzdWx0ID0gaW5pdENsb25lQXJyYXkodmFsdWUpO1xuICAgIGlmICghaXNEZWVwKSB7XG4gICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgaXNGdW5jID0gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcblxuICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICB9XG4gICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgcmVzdWx0ID0gKGlzRmxhdCB8fCBpc0Z1bmMpID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgaWYgKCFpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgID8gY29weVN5bWJvbHNJbih2YWx1ZSwgYmFzZUFzc2lnbkluKHJlc3VsdCwgdmFsdWUpKVxuICAgICAgICAgIDogY29weVN5bWJvbHModmFsdWUsIGJhc2VBc3NpZ24ocmVzdWx0LCB2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWNsb25lYWJsZVRhZ3NbdGFnXSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBjaXJjdWxhciByZWZlcmVuY2VzIGFuZCByZXR1cm4gaXRzIGNvcnJlc3BvbmRpbmcgY2xvbmUuXG4gIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KHZhbHVlKTtcbiAgaWYgKHN0YWNrZWQpIHtcbiAgICByZXR1cm4gc3RhY2tlZDtcbiAgfVxuICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgIHJlc3VsdC5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnNldChrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gbWFwVGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1NldGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzU2V0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gc2V0VGFnO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNJbmAgd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5c0luKG9iamVjdCkge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gIH1cbiAgdmFyIGlzUHJvdG8gPSBpc1Byb3RvdHlwZShvYmplY3QpLFxuICAgICAgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIGJ1ZmZlci5jb3B5KHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBhcnJheUJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGFycmF5QnVmZmVyIFRoZSBhcnJheSBidWZmZXIgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgbmV3IFVpbnQ4QXJyYXkocmVzdWx0KS5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGRhdGFWaWV3YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFWaWV3IFRoZSBkYXRhIHZpZXcgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIGRhdGEgdmlldy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gIHJldHVybiBuZXcgZGF0YVZpZXcuY29uc3RydWN0b3IoYnVmZmVyLCBkYXRhVmlldy5ieXRlT2Zmc2V0LCBkYXRhVmlldy5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgYHN5bWJvbGAgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc3ltYm9sIFRoZSBzeW1ib2wgb2JqZWN0IHRvIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICBpZiAoaXNOZXcpIHtcbiAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9scyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbi8qKlxuICogQ29waWVzIG93biBhbmQgaW5oZXJpdGVkIHN5bWJvbHMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzSW4oc291cmNlLCBvYmplY3QpIHtcbiAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gZ2V0VmFsdWUob2JqZWN0LCBrZXkpO1xuICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmF3IGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICB2YXIgaXNPd24gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBzeW1Ub1N0cmluZ1RhZyksXG4gICAgICB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG5cbiAgdHJ5IHtcbiAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB1bmRlZmluZWQ7XG4gICAgdmFyIHVubWFza2VkID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIGlmICh1bm1hc2tlZCkge1xuICAgIGlmIChpc093bikge1xuICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdGFnO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHJldHVybiBhcnJheUZpbHRlcihuYXRpdmVHZXRTeW1ib2xzKG9iamVjdCksIGZ1bmN0aW9uKHN5bWJvbCkge1xuICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9sc0luID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB3aGlsZSAob2JqZWN0KSB7XG4gICAgYXJyYXlQdXNoKHJlc3VsdCwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICBvYmplY3QgPSBnZXRQcm90b3R5cGUob2JqZWN0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBuZXcgYXJyYXkuY29uc3RydWN0b3IobGVuZ3RoKTtcblxuICAvLyBBZGQgcHJvcGVydGllcyBhc3NpZ25lZCBieSBgUmVnRXhwI2V4ZWNgLlxuICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgIHJlc3VsdC5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgIHJlc3VsdC5pbnB1dCA9IGFycmF5LmlucHV0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUgYmFzZWQgb24gaXRzIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTWFwYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBgU2V0YCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lQXJyYXlCdWZmZXIob2JqZWN0KTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3IoK29iamVjdCk7XG5cbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgY2FzZSBmbG9hdDMyVGFnOiBjYXNlIGZsb2F0NjRUYWc6XG4gICAgY2FzZSBpbnQ4VGFnOiBjYXNlIGludDE2VGFnOiBjYXNlIGludDMyVGFnOlxuICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICByZXR1cm4gY2xvbmVUeXBlZEFycmF5KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgbWFwVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgcmV0dXJuIGNsb25lUmVnRXhwKG9iamVjdCk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAqIFtgT2JqZWN0LmtleXNgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGV4Y2VwdCB0aGF0IGl0IGluY2x1ZGVzIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIG5hdGl2ZUtleXNJbihvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNvdXJjZSBjb2RlLlxuICovXG5mdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gIGlmIChmdW5jICE9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBjbG9uZXMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmVjdXJzaXZlbHkgY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gKiBAc2VlIF8uY2xvbmVcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbeyAnYSc6IDEgfSwgeyAnYic6IDIgfV07XG4gKlxuICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAqIGNvbnNvbGUubG9nKGRlZXBbMF0gPT09IG9iamVjdHNbMF0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gY2xvbmVEZWVwKHZhbHVlKSB7XG4gIHJldHVybiBiYXNlQ2xvbmUodmFsdWUsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRyk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBtYXAsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc01hcChuZXcgTWFwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTWFwKG5ldyBXZWFrTWFwKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc01hcCA9IG5vZGVJc01hcCA/IGJhc2VVbmFyeShub2RlSXNNYXApIDogYmFzZUlzTWFwO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.clonedeep/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object);\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = filter;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbHRlci9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmlsdGVyL2luZGV4LmpzP2MyNTQiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBwcm9wZXJ0eSBuYW1lcyB3aXRoaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sXG4gICAgcmVQcm9wTmFtZSA9IC9bXi5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwkKSkvZztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFwoXFxcXCk/L2c7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICBzcGxpY2UgPSBhcnJheVByb3RvLnNwbGljZSxcbiAgICBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUdldFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLFxuICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUocm9vdCwgJ0RhdGFWaWV3JyksXG4gICAgTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdNYXAnKSxcbiAgICBQcm9taXNlID0gZ2V0TmF0aXZlKHJvb3QsICdQcm9taXNlJyksXG4gICAgU2V0ID0gZ2V0TmF0aXZlKHJvb3QsICdTZXQnKSxcbiAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKHJvb3QsICdXZWFrTWFwJyksXG4gICAgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWFwcywgc2V0cywgYW5kIHdlYWttYXBzLiAqL1xudmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwKSxcbiAgICBwcm9taXNlQ3RvclN0cmluZyA9IHRvU291cmNlKFByb21pc2UpLFxuICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcCk7XG5cbi8qKiBVc2VkIHRvIGNvbnZlcnQgc3ltYm9scyB0byBwcmltaXRpdmVzIGFuZCBzdHJpbmdzLiAqL1xudmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgaGFzaCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIEhhc2goZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgSGFzaFxuICovXG5mdW5jdGlvbiBoYXNoQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyAoZGF0YVtrZXldICE9PSB1bmRlZmluZWQpIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGhhc2ggYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBoYXNoIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBoYXNoU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICBkYXRhW2tleV0gPSAobmF0aXZlQ3JlYXRlICYmIHZhbHVlID09PSB1bmRlZmluZWQpID8gSEFTSF9VTkRFRklORUQgOiB2YWx1ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBIYXNoYC5cbkhhc2gucHJvdG90eXBlLmNsZWFyID0gaGFzaENsZWFyO1xuSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbkhhc2gucHJvdG90eXBlLmdldCA9IGhhc2hHZXQ7XG5IYXNoLnByb3RvdHlwZS5oYXMgPSBoYXNoSGFzO1xuSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGxpc3QgY2FjaGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBMaXN0Q2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gW107XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICByZXR1cm4gaW5kZXggPCAwID8gdW5kZWZpbmVkIDogZGF0YVtpbmRleF1bMV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbGlzdCBjYWNoZSB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBhc3NvY0luZGV4T2YodGhpcy5fX2RhdGFfXywga2V5KSA+IC0xO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcCBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpWydkZWxldGUnXShrZXkpO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLFxuICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplID8gMCA6IDE7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBhZGRcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQGFsaWFzIHB1c2hcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNhY2hlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlQWRkKHZhbHVlKSB7XG4gIHRoaXMuX19kYXRhX18uc2V0KHZhbHVlLCBIQVNIX1VOREVGSU5FRCk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTZXRDYWNoZWAuXG5TZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcblNldENhY2hlLnByb3RvdHlwZS5oYXMgPSBzZXRDYWNoZUhhcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlKGVudHJpZXMpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsdGVyYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICogcHJvcGVydGllcyByZXR1cm5lZCBieSBga2V5c0Z1bmNgIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbnZhciBiYXNlRm9yID0gY3JlYXRlQmFzZUZvcigpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyBhbiBhcnJheSBvZiBhbGwgZWxlbWVudHNcbiAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAqIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKiBAc2VlIF8ucmVqZWN0XG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiBfLmZpbHRlcih1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b1N0cmluZyhudWxsKTtcbiAqIC8vID0+ICcnXG4gKlxuICogXy50b1N0cmluZygtMCk7XG4gKiAvLyA9PiAnLTAnXG4gKlxuICogXy50b1N0cmluZyhbMSwgMiwgM10pO1xuICogLy8gPT4gJzEsMiwzJ1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBhIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFtcbiAqICAgeyAnYSc6IHsgJ2InOiAyIH0gfSxcbiAqICAgeyAnYSc6IHsgJ2InOiAxIH0gfVxuICogXTtcbiAqXG4gKiBfLm1hcChvYmplY3RzLCBfLnByb3BlcnR5KCdhLmInKSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqXG4gKiBfLm1hcChfLnNvcnRCeShvYmplY3RzLCBfLnByb3BlcnR5KFsnYScsICdiJ10pKSwgJ2EuYicpO1xuICogLy8gPT4gWzEsIDJdXG4gKi9cbmZ1bmN0aW9uIHByb3BlcnR5KHBhdGgpIHtcbiAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaWx0ZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.filter/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js ***!
  \****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Creates a `_.find` or `_.findLast` function.\n *\n * @private\n * @param {Function} findIndexFunc The function to find the collection index.\n * @returns {Function} Returns the new find function.\n */\nfunction createFind(findIndexFunc) {\n  return function(collection, predicate, fromIndex) {\n    var iterable = Object(collection);\n    if (!isArrayLike(collection)) {\n      var iteratee = baseIteratee(predicate, 3);\n      collection = keys(collection);\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\n    }\n    var index = findIndexFunc(collection, predicate, fromIndex);\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Iterates over elements of `collection`, returning the first element\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {*} Returns the matched element, else `undefined`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'age': 36, 'active': true },\n *   { 'user': 'fred',    'age': 40, 'active': false },\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\n * ];\n *\n * _.find(users, function(o) { return o.age < 40; });\n * // => object for 'barney'\n *\n * // The `_.matches` iteratee shorthand.\n * _.find(users, { 'age': 1, 'active': true });\n * // => object for 'pebbles'\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.find(users, ['active', false]);\n * // => object for 'fred'\n *\n * // The `_.property` iteratee shorthand.\n * _.find(users, 'active');\n * // => object for 'barney'\n */\nvar find = createFind(findIndex);\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = find;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmQvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmQvaW5kZXguanM/MjFiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgaW5jbHVkZT1cImZpbHRlcixzb3J0QnksZmluZEluZGV4LGZpbmQsZm9yRWFjaCxjbG9uZURlZXBcIiBleHBvcnRzPVwibnBtXCJgXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pzLmZvdW5kYXRpb24vPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgYXMgdGhlIG1heGltdW0gbWVtb2l6ZSBjYWNoZSBzaXplLiAqL1xudmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4LFxuICAgIE5BTiA9IDAgLyAwO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltID0gL15cXHMrfFxccyskL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGJhY2tzbGFzaGVzIGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpKS4gKi9cbnZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyxcbiAgICBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KSxcbiAgICBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIEhhc2hcbiAqL1xuZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmF0aXZlQ3JlYXRlID8gbmF0aXZlQ3JlYXRlKG51bGwpIDoge307XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChuYXRpdmVDcmVhdGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gZGF0YVtrZXldO1xuICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICB9XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkgPyBkYXRhW2tleV0gOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgdGhpcy5zaXplICs9IHRoaXMuaGFzKGtleSkgPyAwIDogMTtcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgZGF0YS5wb3AoKTtcbiAgfSBlbHNlIHtcbiAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gIH1cbiAgLS10aGlzLnNpemU7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICArK3RoaXMuc2l6ZTtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICB0aGlzLmNsZWFyKCk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUNsZWFyKCkge1xuICB0aGlzLnNpemUgPSAwO1xuICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICdoYXNoJzogbmV3IEhhc2gsXG4gICAgJ21hcCc6IG5ldyAoTWFwIHx8IExpc3RDYWNoZSksXG4gICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gIH07XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVIYXMoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbi8qKlxuICpcbiAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzID09IG51bGwgPyAwIDogdmFsdWVzLmxlbmd0aDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIFN0YWNrXG4gKi9cbmZ1bmN0aW9uIHN0YWNrQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTGlzdENhY2hlO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0RlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgcmVzdWx0ID0gZGF0YVsnZGVsZXRlJ10oa2V5KTtcblxuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrSGFzKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBzdGFjayBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICBpZiAoIU1hcCB8fCAocGFpcnMubGVuZ3RoIDwgTEFSR0VfQVJSQVlfU0laRSAtIDEpKSB7XG4gICAgICBwYWlycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZ2V0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZmF1bHQgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gKiBga2V5c0Z1bmNgIGFuZCBgc3ltYm9sc0Z1bmNgIHRvIGdldCB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmRcbiAqIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzeW1ib2xzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXNGdW5jKG9iamVjdCk7XG4gIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc0luYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSGFzSW4ob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gKiBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAqICAxIC0gVW5vcmRlcmVkIGNvbXBhcmlzb25cbiAqICAyIC0gUGFydGlhbCBjb21wYXJpc29uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzT2JqZWN0TGlrZShvdGhlcikpKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gIH1cbiAgcmV0dXJuIGJhc2VJc0VxdWFsRGVlcCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGJhc2VJc0VxdWFsLCBzdGFjayk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pdGVyYXRlZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBpdGVyYXRlZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUl0ZXJhdGVlKHZhbHVlKSB7XG4gIC8vIERvbid0IHN0b3JlIHRoZSBgdHlwZW9mYCByZXN1bHQgaW4gYSB2YXJpYWJsZSB0byBhdm9pZCBhIEpJVCBidWcgaW4gU2FmYXJpIDkuXG4gIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBpZGVudGl0eTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpXG4gICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgOiBiYXNlTWF0Y2hlcyh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNvdXJjZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlcyhzb3VyY2UpIHtcbiAgdmFyIG1hdGNoRGF0YSA9IGdldE1hdGNoRGF0YShzb3VyY2UpO1xuICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShtYXRjaERhdGFbMF1bMF0sIG1hdGNoRGF0YVswXVsxXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VQcm9wZXJ0eWAgd2hpY2ggc3VwcG9ydHMgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9TdHJpbmdgIHdoaWNoIGRvZXNuJ3QgY29udmVydCBudWxsaXNoXG4gKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gIC8vIEV4aXQgZWFybHkgZm9yIHN0cmluZ3MgdG8gYXZvaWQgYSBwZXJmb3JtYW5jZSBoaXQgaW4gc29tZSBlbnZpcm9ubWVudHMuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyAnJztcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN5bWJvbFRvU3RyaW5nID8gc3ltYm9sVG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgfVxuICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLmZpbmRgIG9yIGBfLmZpbmRMYXN0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZmluZEluZGV4RnVuYyBUaGUgZnVuY3Rpb24gdG8gZmluZCB0aGUgY29sbGVjdGlvbiBpbmRleC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZpbmQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZpbmQoZmluZEluZGV4RnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICBjb2xsZWN0aW9uID0ga2V5cyhjb2xsZWN0aW9uKTtcbiAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgfVxuICAgIHZhciBpbmRleCA9IGZpbmRJbmRleEZ1bmMoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBmcm9tSW5kZXgpO1xuICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICBzZWVuID0gKGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHKSA/IG5ldyBTZXRDYWNoZSA6IHVuZGVmaW5lZDtcblxuICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBhcnJheSk7XG5cbiAgLy8gSWdub3JlIG5vbi1pbmRleCBwcm9wZXJ0aWVzLlxuICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgIHZhciBhcnJWYWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltpbmRleF07XG5cbiAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIGlmIChjb21wYXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmIChzZWVuKSB7XG4gICAgICBpZiAoIWFycmF5U29tZShvdGhlciwgZnVuY3Rpb24ob3RoVmFsdWUsIG90aEluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgIChhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXR1cm4gc2Vlbi5wdXNoKG90aEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSkge1xuICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghKFxuICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spXG4gICAgICAgICkpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YWNrWydkZWxldGUnXShhcnJheSk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICogdGhlIHNhbWUgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE51bWJlcmAsIGBSZWdFeHBgLCBvciBgU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAob2JqZWN0LmJ5dGVPZmZzZXQgIT0gb3RoZXIuYnl0ZU9mZnNldCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIGlmICgob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCkgfHxcbiAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgLy8gQ29lcmNlIGJvb2xlYW5zIHRvIGAxYCBvciBgMGAgYW5kIGRhdGVzIHRvIG1pbGxpc2Vjb25kcy5cbiAgICAgIC8vIEludmFsaWQgZGF0ZXMgYXJlIGNvZXJjZWQgdG8gYE5hTmAuXG4gICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICByZXR1cm4gb2JqZWN0Lm5hbWUgPT0gb3RoZXIubmFtZSAmJiBvYmplY3QubWVzc2FnZSA9PSBvdGhlci5tZXNzYWdlO1xuXG4gICAgY2FzZSByZWdleHBUYWc6XG4gICAgY2FzZSBzdHJpbmdUYWc6XG4gICAgICAvLyBDb2VyY2UgcmVnZXhlcyB0byBzdHJpbmdzIGFuZCB0cmVhdCBzdHJpbmdzLCBwcmltaXRpdmVzIGFuZCBvYmplY3RzLFxuICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIHJldHVybiBvYmplY3QgPT0gKG90aGVyICsgJycpO1xuXG4gICAgY2FzZSBtYXBUYWc6XG4gICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG5cbiAgICBjYXNlIHNldFRhZzpcbiAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICBjb252ZXJ0IHx8IChjb252ZXJ0ID0gc2V0VG9BcnJheSk7XG5cbiAgICAgIGlmIChvYmplY3Quc2l6ZSAhPSBvdGhlci5zaXplICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICAgICAgfVxuICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuXG4gICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIG9iamVjdHMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgIHZhciByZXN1bHQgPSBlcXVhbEFycmF5cyhjb252ZXJ0KG9iamVjdCksIGNvbnZlcnQob3RoZXIpLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvYmplY3QpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgaWYgKHN5bWJvbFZhbHVlT2YpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGdldEFsbEtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSBhbmQgcHJvbWlzZXMgaW4gTm9kZS5qcyA8IDYuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBiYXNlR2V0VGFnKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6ICcnO1xuXG4gICAgaWYgKGN0b3JTdHJpbmcpIHtcbiAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICBjYXNlIGRhdGFWaWV3Q3RvclN0cmluZzogcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICBjYXNlIG1hcEN0b3JTdHJpbmc6IHJldHVybiBtYXBUYWc7XG4gICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICBjYXNlIHNldEN0b3JTdHJpbmc6IHJldHVybiBzZXRUYWc7XG4gICAgICAgIGNhc2Ugd2Vha01hcEN0b3JTdHJpbmc6IHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgZXhpc3RzIG9uIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrIHByb3BlcnRpZXMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgaGFzRnVuYykge1xuICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gdG9LZXkocGF0aFtpbmRleF0pO1xuICAgIGlmICghKHJlc3VsdCA9IG9iamVjdCAhPSBudWxsICYmIGhhc0Z1bmMob2JqZWN0LCBrZXkpKSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICB9XG4gIGlmIChyZXN1bHQgfHwgKytpbmRleCAhPSBsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGxlbmd0aCA9IG9iamVjdCA9PSBudWxsID8gMCA6IG9iamVjdC5sZW5ndGg7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lIGFuZCBub3QgYSBwcm9wZXJ0eSBwYXRoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGlmICh0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicgfHxcbiAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgIChvYmplY3QgIT0gbnVsbCAmJiB2YWx1ZSBpbiBPYmplY3Qob2JqZWN0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlmIHN1aXRhYmxlIGZvciBzdHJpY3RcbiAqICBlcXVhbGl0eSBjb21wYXJpc29ucywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1N0cmljdENvbXBhcmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSAmJiAhaXNPYmplY3QodmFsdWUpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgbWF0Y2hlc1Byb3BlcnR5YCBmb3Igc291cmNlIHZhbHVlcyBzdWl0YWJsZVxuICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKGtleSwgc3JjVmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAoc3JjVmFsdWUgIT09IHVuZGVmaW5lZCB8fCAoa2V5IGluIE9iamVjdChvYmplY3QpKSk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1lbW9pemVgIHdoaWNoIGNsZWFycyB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24nc1xuICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICB2YXIgcmVzdWx0ID0gbWVtb2l6ZShmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoY2FjaGUuc2l6ZSA9PT0gTUFYX01FTU9JWkVfU0laRSkge1xuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbiAgfSk7XG5cbiAgdmFyIGNhY2hlID0gcmVzdWx0LmNhY2hlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRocmVlXG4gKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ2Jhcm5leSdcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCB7ICdhZ2UnOiAxLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdCBmb3IgJ3BlYmJsZXMnXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKi9cbnZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.find/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\n * support for iteratee shorthands.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {Function} predicate The function invoked per iteration.\n * @param {number} fromIndex The index to search from.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\n  var length = array.length,\n      index = fromIndex + (fromRight ? 1 : -1);\n\n  while ((fromRight ? index-- : ++index < length)) {\n    if (predicate(array[index], index, array)) {\n      return index;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * This method is like `_.find` except that it returns the index of the first\n * element `predicate` returns truthy for instead of the element itself.\n *\n * @static\n * @memberOf _\n * @since 1.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @param {number} [fromIndex=0] The index to search from.\n * @returns {number} Returns the index of the found element, else `-1`.\n * @example\n *\n * var users = [\n *   { 'user': 'barney',  'active': false },\n *   { 'user': 'fred',    'active': false },\n *   { 'user': 'pebbles', 'active': true }\n * ];\n *\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\n * // => 0\n *\n * // The `_.matches` iteratee shorthand.\n * _.findIndex(users, { 'user': 'fred', 'active': false });\n * // => 1\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.findIndex(users, ['active', false]);\n * // => 0\n *\n * // The `_.property` iteratee shorthand.\n * _.findIndex(users, 'active');\n * // => 2\n */\nfunction findIndex(array, predicate, fromIndex) {\n  var length = array == null ? 0 : array.length;\n  if (!length) {\n    return -1;\n  }\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\n  if (index < 0) {\n    index = nativeMax(length + index, 0);\n  }\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = findIndex;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLmZpbmRpbmRleC9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guZmluZGluZGV4L2luZGV4LmpzP2I3OGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGBjYWNoZWAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IGNhY2hlIFRoZSBjYWNoZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBjYWNoZUhhcyhjYWNoZSwga2V5KSB7XG4gIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgU3ltYm9sID0gcm9vdC5TeW1ib2wsXG4gICAgVWludDhBcnJheSA9IHJvb3QuVWludDhBcnJheSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLFxuICAgIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gKiBjYWNoZSB3aGVuIGl0IGV4Y2VlZHMgYE1BWF9NRU1PSVpFX1NJWkVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gIHZhciByZXN1bHQgPSBtZW1vaXplKGZ1bmMsIGZ1bmN0aW9uKGtleSkge1xuICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICBjYWNoZS5jbGVhcigpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9KTtcblxuICB2YXIgY2FjaGUgPSByZXN1bHQuY2FjaGU7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHN0cmluZ2AgdG8gYSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xudmFyIHN0cmluZ1RvUGF0aCA9IG1lbW9pemVDYXBwZWQoZnVuY3Rpb24oc3RyaW5nKSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN1YlN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3RcbiAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICogXTtcbiAqXG4gKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIHsgJ3VzZXInOiAnZnJlZCcsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbmRJbmRleCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gMFxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IDJcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEyLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0Zpbml0ZSgzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b0Zpbml0ZShOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9GaW5pdGUoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvRmluaXRlKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b0Zpbml0ZSh2YWx1ZSkge1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICB9XG4gIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICB2YXIgc2lnbiA9ICh2YWx1ZSA8IDAgPyAtMSA6IDEpO1xuICAgIHJldHVybiBzaWduICogTUFYX0lOVEVHRVI7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/IHZhbHVlIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGFuIGludGVnZXIuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9JbnRlZ2VyYF0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvaW50ZWdlcikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b0ludGVnZXIoMy4yKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLnRvSW50ZWdlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDBcbiAqXG4gKiBfLnRvSW50ZWdlcihJbmZpbml0eSk7XG4gKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICpcbiAqIF8udG9JbnRlZ2VyKCczLjInKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gdG9JbnRlZ2VyKHZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICByZW1haW5kZXIgPSByZXN1bHQgJSAxO1xuXG4gIHJldHVybiByZXN1bHQgPT09IHJlc3VsdCA/IChyZW1haW5kZXIgPyByZXN1bHQgLSByZW1haW5kZXIgOiByZXN1bHQpIDogMDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UocmVUcmltLCAnJyk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEluZGV4O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.findindex/index.js\n");

/***/ }),

/***/ "./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, module) {/**\n * Lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize include=\"filter,sortBy,findIndex,find,forEach,cloneDeep\" exports=\"npm\"`\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the size to enable large array optimizations. */\nvar LARGE_ARRAY_SIZE = 200;\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as the maximum memoize cache size. */\nvar MAX_MEMOIZE_SIZE = 500;\n\n/** Used to compose bitmasks for value comparisons. */\nvar COMPARE_PARTIAL_FLAG = 1,\n    COMPARE_UNORDERED_FLAG = 2;\n\n/** Used to detect hot functions by number of calls within a span of milliseconds. */\nvar HOT_COUNT = 800,\n    HOT_SPAN = 16;\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    arrayTag = '[object Array]',\n    asyncTag = '[object AsyncFunction]',\n    boolTag = '[object Boolean]',\n    dateTag = '[object Date]',\n    errorTag = '[object Error]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    mapTag = '[object Map]',\n    numberTag = '[object Number]',\n    nullTag = '[object Null]',\n    objectTag = '[object Object]',\n    promiseTag = '[object Promise]',\n    proxyTag = '[object Proxy]',\n    regexpTag = '[object RegExp]',\n    setTag = '[object Set]',\n    stringTag = '[object String]',\n    symbolTag = '[object Symbol]',\n    undefinedTag = '[object Undefined]',\n    weakMapTag = '[object WeakMap]';\n\nvar arrayBufferTag = '[object ArrayBuffer]',\n    dataViewTag = '[object DataView]',\n    float32Tag = '[object Float32Array]',\n    float64Tag = '[object Float64Array]',\n    int8Tag = '[object Int8Array]',\n    int16Tag = '[object Int16Array]',\n    int32Tag = '[object Int32Array]',\n    uint8Tag = '[object Uint8Array]',\n    uint8ClampedTag = '[object Uint8ClampedArray]',\n    uint16Tag = '[object Uint16Array]',\n    uint32Tag = '[object Uint32Array]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/** Used to identify `toStringTag` values of typed arrays. */\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\ntypedArrayTags[weakMapTag] = false;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Detect free variable `exports`. */\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\n\n/** Detect free variable `module`. */\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\n\n/** Detect the popular CommonJS extension `module.exports`. */\nvar moduleExports = freeModule && freeModule.exports === freeExports;\n\n/** Detect free variable `process` from Node.js. */\nvar freeProcess = moduleExports && freeGlobal.process;\n\n/** Used to access faster Node.js helpers. */\nvar nodeUtil = (function() {\n  try {\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\n  } catch (e) {}\n}());\n\n/* Node.js helper references. */\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * A specialized version of `_.filter` for arrays without support for\n * iteratee shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction arrayFilter(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      resIndex = 0,\n      result = [];\n\n  while (++index < length) {\n    var value = array[index];\n    if (predicate(value, index, array)) {\n      result[resIndex++] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * A specialized version of `_.map` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction arrayMap(array, iteratee) {\n  var index = -1,\n      length = array == null ? 0 : array.length,\n      result = Array(length);\n\n  while (++index < length) {\n    result[index] = iteratee(array[index], index, array);\n  }\n  return result;\n}\n\n/**\n * Appends the elements of `values` to `array`.\n *\n * @private\n * @param {Array} array The array to modify.\n * @param {Array} values The values to append.\n * @returns {Array} Returns `array`.\n */\nfunction arrayPush(array, values) {\n  var index = -1,\n      length = values.length,\n      offset = array.length;\n\n  while (++index < length) {\n    array[offset + index] = values[index];\n  }\n  return array;\n}\n\n/**\n * A specialized version of `_.some` for arrays without support for iteratee\n * shorthands.\n *\n * @private\n * @param {Array} [array] The array to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {boolean} Returns `true` if any element passes the predicate check,\n *  else `false`.\n */\nfunction arraySome(array, predicate) {\n  var index = -1,\n      length = array == null ? 0 : array.length;\n\n  while (++index < length) {\n    if (predicate(array[index], index, array)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * The base implementation of `_.property` without support for deep paths.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\n/**\n * The base implementation of `_.sortBy` which uses `comparer` to define the\n * sort order of `array` and replaces criteria objects with their corresponding\n * values.\n *\n * @private\n * @param {Array} array The array to sort.\n * @param {Function} comparer The function to define sort order.\n * @returns {Array} Returns `array`.\n */\nfunction baseSortBy(array, comparer) {\n  var length = array.length;\n\n  array.sort(comparer);\n  while (length--) {\n    array[length] = array[length].value;\n  }\n  return array;\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.unary` without support for storing metadata.\n *\n * @private\n * @param {Function} func The function to cap arguments for.\n * @returns {Function} Returns the new capped function.\n */\nfunction baseUnary(func) {\n  return function(value) {\n    return func(value);\n  };\n}\n\n/**\n * Checks if a `cache` value for `key` exists.\n *\n * @private\n * @param {Object} cache The cache to query.\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction cacheHas(cache, key) {\n  return cache.has(key);\n}\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Converts `map` to its key-value pairs.\n *\n * @private\n * @param {Object} map The map to convert.\n * @returns {Array} Returns the key-value pairs.\n */\nfunction mapToArray(map) {\n  var index = -1,\n      result = Array(map.size);\n\n  map.forEach(function(value, key) {\n    result[++index] = [key, value];\n  });\n  return result;\n}\n\n/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\n/**\n * Converts `set` to an array of its values.\n *\n * @private\n * @param {Object} set The set to convert.\n * @returns {Array} Returns the values.\n */\nfunction setToArray(set) {\n  var index = -1,\n      result = Array(set.size);\n\n  set.forEach(function(value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Buffer = moduleExports ? root.Buffer : undefined,\n    Symbol = root.Symbol,\n    Uint8Array = root.Uint8Array,\n    propertyIsEnumerable = objectProto.propertyIsEnumerable,\n    splice = arrayProto.splice,\n    spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,\n    symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\nvar defineProperty = (function() {\n  try {\n    var func = getNative(Object, 'defineProperty');\n    func({}, '', {});\n    return func;\n  } catch (e) {}\n}());\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeGetSymbols = Object.getOwnPropertySymbols,\n    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n    nativeKeys = overArg(Object.keys, Object),\n    nativeMax = Math.max,\n    nativeNow = Date.now;\n\n/* Built-in method references that are verified to be native. */\nvar DataView = getNative(root, 'DataView'),\n    Map = getNative(root, 'Map'),\n    Promise = getNative(root, 'Promise'),\n    Set = getNative(root, 'Set'),\n    WeakMap = getNative(root, 'WeakMap'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to detect maps, sets, and weakmaps. */\nvar dataViewCtorString = toSource(DataView),\n    mapCtorString = toSource(Map),\n    promiseCtorString = toSource(Promise),\n    setCtorString = toSource(Set),\n    weakMapCtorString = toSource(WeakMap);\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  var result = this.has(key) && delete this.__data__[key];\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  this.size += this.has(key) ? 0 : 1;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  --this.size;\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    ++this.size;\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries == null ? 0 : entries.length;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.size = 0;\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  var result = getMapData(this, key)['delete'](key);\n  this.size -= result ? 1 : 0;\n  return result;\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  var data = getMapData(this, key),\n      size = data.size;\n\n  data.set(key, value);\n  this.size += data.size == size ? 0 : 1;\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n *\n * Creates an array cache object to store unique values.\n *\n * @private\n * @constructor\n * @param {Array} [values] The values to cache.\n */\nfunction SetCache(values) {\n  var index = -1,\n      length = values == null ? 0 : values.length;\n\n  this.__data__ = new MapCache;\n  while (++index < length) {\n    this.add(values[index]);\n  }\n}\n\n/**\n * Adds `value` to the array cache.\n *\n * @private\n * @name add\n * @memberOf SetCache\n * @alias push\n * @param {*} value The value to cache.\n * @returns {Object} Returns the cache instance.\n */\nfunction setCacheAdd(value) {\n  this.__data__.set(value, HASH_UNDEFINED);\n  return this;\n}\n\n/**\n * Checks if `value` is in the array cache.\n *\n * @private\n * @name has\n * @memberOf SetCache\n * @param {*} value The value to search for.\n * @returns {number} Returns `true` if `value` is found, else `false`.\n */\nfunction setCacheHas(value) {\n  return this.__data__.has(value);\n}\n\n// Add methods to `SetCache`.\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\nSetCache.prototype.has = setCacheHas;\n\n/**\n * Creates a stack cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Stack(entries) {\n  var data = this.__data__ = new ListCache(entries);\n  this.size = data.size;\n}\n\n/**\n * Removes all key-value entries from the stack.\n *\n * @private\n * @name clear\n * @memberOf Stack\n */\nfunction stackClear() {\n  this.__data__ = new ListCache;\n  this.size = 0;\n}\n\n/**\n * Removes `key` and its value from the stack.\n *\n * @private\n * @name delete\n * @memberOf Stack\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction stackDelete(key) {\n  var data = this.__data__,\n      result = data['delete'](key);\n\n  this.size = data.size;\n  return result;\n}\n\n/**\n * Gets the stack value for `key`.\n *\n * @private\n * @name get\n * @memberOf Stack\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction stackGet(key) {\n  return this.__data__.get(key);\n}\n\n/**\n * Checks if a stack value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Stack\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction stackHas(key) {\n  return this.__data__.has(key);\n}\n\n/**\n * Sets the stack `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Stack\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the stack cache instance.\n */\nfunction stackSet(key, value) {\n  var data = this.__data__;\n  if (data instanceof ListCache) {\n    var pairs = data.__data__;\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\n      pairs.push([key, value]);\n      this.size = ++data.size;\n      return this;\n    }\n    data = this.__data__ = new MapCache(pairs);\n  }\n  data.set(key, value);\n  this.size = data.size;\n  return this;\n}\n\n// Add methods to `Stack`.\nStack.prototype.clear = stackClear;\nStack.prototype['delete'] = stackDelete;\nStack.prototype.get = stackGet;\nStack.prototype.has = stackHas;\nStack.prototype.set = stackSet;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  var isArr = isArray(value),\n      isArg = !isArr && isArguments(value),\n      isBuff = !isArr && !isArg && isBuffer(value),\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\n      skipIndexes = isArr || isArg || isBuff || isType,\n      result = skipIndexes ? baseTimes(value.length, String) : [],\n      length = result.length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (\n           // Safari 9 has enumerable `arguments.length` in strict mode.\n           key == 'length' ||\n           // Node.js 0.10 has enumerable non-index properties on buffers.\n           (isBuff && (key == 'offset' || key == 'parent')) ||\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\n           // Skip index properties.\n           isIndex(key, length)\n        ))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.forEach` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array|Object} Returns `collection`.\n */\nvar baseEach = createBaseEach(baseForOwn);\n\n/**\n * The base implementation of `_.flatten` with support for restricting flattening.\n *\n * @private\n * @param {Array} array The array to flatten.\n * @param {number} depth The maximum recursion depth.\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\n * @param {Array} [result=[]] The initial result value.\n * @returns {Array} Returns the new flattened array.\n */\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\n  var index = -1,\n      length = array.length;\n\n  predicate || (predicate = isFlattenable);\n  result || (result = []);\n\n  while (++index < length) {\n    var value = array[index];\n    if (depth > 0 && predicate(value)) {\n      if (depth > 1) {\n        // Recursively flatten arrays (susceptible to call stack limits).\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\n      } else {\n        arrayPush(result, value);\n      }\n    } else if (!isStrict) {\n      result[result.length] = value;\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `baseForOwn` which iterates over `object`\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\n * Iteratee functions may exit iteration early by explicitly returning `false`.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @returns {Object} Returns `object`.\n */\nvar baseFor = createBaseFor();\n\n/**\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Object} Returns `object`.\n */\nfunction baseForOwn(object, iteratee) {\n  return object && baseFor(object, iteratee, keys);\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\n * symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Function} keysFunc The function to get the keys of `object`.\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\n  var result = keysFunc(object);\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\n}\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * The base implementation of `_.hasIn` without support for deep paths.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {Array|string} key The key to check.\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\n */\nfunction baseHasIn(object, key) {\n  return object != null && key in Object(object);\n}\n\n/**\n * The base implementation of `_.isArguments`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n */\nfunction baseIsArguments(value) {\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\n}\n\n/**\n * The base implementation of `_.isEqual` which supports partial comparisons\n * and tracks traversed objects.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @param {boolean} bitmask The bitmask flags.\n *  1 - Unordered comparison\n *  2 - Partial comparison\n * @param {Function} [customizer] The function to customize comparisons.\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n */\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\n  if (value === other) {\n    return true;\n  }\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n}\n\n/**\n * A specialized version of `baseIsEqual` for arrays and objects which performs\n * deep comparisons and tracks traversed objects enabling objects with circular\n * references to be compared.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = objIsArr ? arrayTag : getTag(object),\n      othTag = othIsArr ? arrayTag : getTag(other);\n\n  objTag = objTag == argsTag ? objectTag : objTag;\n  othTag = othTag == argsTag ? objectTag : othTag;\n\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && isBuffer(object)) {\n    if (!isBuffer(other)) {\n      return false;\n    }\n    objIsArr = true;\n    objIsObj = false;\n  }\n  if (isSameTag && !objIsObj) {\n    stack || (stack = new Stack);\n    return (objIsArr || isTypedArray(object))\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n  }\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n    if (objIsWrapped || othIsWrapped) {\n      var objUnwrapped = objIsWrapped ? object.value() : object,\n          othUnwrapped = othIsWrapped ? other.value() : other;\n\n      stack || (stack = new Stack);\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n    }\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stack || (stack = new Stack);\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n}\n\n/**\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\n *\n * @private\n * @param {Object} object The object to inspect.\n * @param {Object} source The object of property values to match.\n * @param {Array} matchData The property names, values, and compare flags to match.\n * @param {Function} [customizer] The function to customize comparisons.\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n */\nfunction baseIsMatch(object, source, matchData, customizer) {\n  var index = matchData.length,\n      length = index,\n      noCustomizer = !customizer;\n\n  if (object == null) {\n    return !length;\n  }\n  object = Object(object);\n  while (index--) {\n    var data = matchData[index];\n    if ((noCustomizer && data[2])\n          ? data[1] !== object[data[0]]\n          : !(data[0] in object)\n        ) {\n      return false;\n    }\n  }\n  while (++index < length) {\n    data = matchData[index];\n    var key = data[0],\n        objValue = object[key],\n        srcValue = data[1];\n\n    if (noCustomizer && data[2]) {\n      if (objValue === undefined && !(key in object)) {\n        return false;\n      }\n    } else {\n      var stack = new Stack;\n      if (customizer) {\n        var result = customizer(objValue, srcValue, key, object, source, stack);\n      }\n      if (!(result === undefined\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\n            : result\n          )) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n */\nfunction baseIsTypedArray(value) {\n  return isObjectLike(value) &&\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n}\n\n/**\n * The base implementation of `_.iteratee`.\n *\n * @private\n * @param {*} [value=_.identity] The value to convert to an iteratee.\n * @returns {Function} Returns the iteratee.\n */\nfunction baseIteratee(value) {\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n  if (typeof value == 'function') {\n    return value;\n  }\n  if (value == null) {\n    return identity;\n  }\n  if (typeof value == 'object') {\n    return isArray(value)\n      ? baseMatchesProperty(value[0], value[1])\n      : baseMatches(value);\n  }\n  return property(value);\n}\n\n/**\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeys(object) {\n  if (!isPrototype(object)) {\n    return nativeKeys(object);\n  }\n  var result = [];\n  for (var key in Object(object)) {\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.map` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the new mapped array.\n */\nfunction baseMap(collection, iteratee) {\n  var index = -1,\n      result = isArrayLike(collection) ? Array(collection.length) : [];\n\n  baseEach(collection, function(value, key, collection) {\n    result[++index] = iteratee(value, key, collection);\n  });\n  return result;\n}\n\n/**\n * The base implementation of `_.matches` which doesn't clone `source`.\n *\n * @private\n * @param {Object} source The object of property values to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatches(source) {\n  var matchData = getMatchData(source);\n  if (matchData.length == 1 && matchData[0][2]) {\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n  }\n  return function(object) {\n    return object === source || baseIsMatch(object, source, matchData);\n  };\n}\n\n/**\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n *\n * @private\n * @param {string} path The path of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction baseMatchesProperty(path, srcValue) {\n  if (isKey(path) && isStrictComparable(srcValue)) {\n    return matchesStrictComparable(toKey(path), srcValue);\n  }\n  return function(object) {\n    var objValue = get(object, path);\n    return (objValue === undefined && objValue === srcValue)\n      ? hasIn(object, path)\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n  };\n}\n\n/**\n * The base implementation of `_.orderBy` without param guards.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.\n * @param {string[]} orders The sort orders of `iteratees`.\n * @returns {Array} Returns the new sorted array.\n */\nfunction baseOrderBy(collection, iteratees, orders) {\n  var index = -1;\n  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));\n\n  var result = baseMap(collection, function(value, key, collection) {\n    var criteria = arrayMap(iteratees, function(iteratee) {\n      return iteratee(value);\n    });\n    return { 'criteria': criteria, 'index': ++index, 'value': value };\n  });\n\n  return baseSortBy(result, function(object, other) {\n    return compareMultiple(object, other, orders);\n  });\n}\n\n/**\n * A specialized version of `baseProperty` which supports deep paths.\n *\n * @private\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n */\nfunction basePropertyDeep(path) {\n  return function(object) {\n    return baseGet(object, path);\n  };\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  return setToString(overRest(func, start, identity), func + '');\n}\n\n/**\n * The base implementation of `setToString` without support for hot loop shorting.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\n  return defineProperty(func, 'toString', {\n    'configurable': true,\n    'enumerable': false,\n    'value': constant(string),\n    'writable': true\n  });\n};\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isArray(value)) {\n    // Recursively convert values (susceptible to call stack limits).\n    return arrayMap(value, baseToString) + '';\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @param {Object} [object] The object to query keys on.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value, object) {\n  if (isArray(value)) {\n    return value;\n  }\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\n}\n\n/**\n * Compares values to sort them in ascending order.\n *\n * @private\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {number} Returns the sort order indicator for `value`.\n */\nfunction compareAscending(value, other) {\n  if (value !== other) {\n    var valIsDefined = value !== undefined,\n        valIsNull = value === null,\n        valIsReflexive = value === value,\n        valIsSymbol = isSymbol(value);\n\n    var othIsDefined = other !== undefined,\n        othIsNull = other === null,\n        othIsReflexive = other === other,\n        othIsSymbol = isSymbol(other);\n\n    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||\n        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||\n        (valIsNull && othIsDefined && othIsReflexive) ||\n        (!valIsDefined && othIsReflexive) ||\n        !valIsReflexive) {\n      return 1;\n    }\n    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||\n        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||\n        (othIsNull && valIsDefined && valIsReflexive) ||\n        (!othIsDefined && valIsReflexive) ||\n        !othIsReflexive) {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * Used by `_.orderBy` to compare multiple properties of a value to another\n * and stable sort them.\n *\n * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,\n * specify an order of \"desc\" for descending or \"asc\" for ascending sort order\n * of corresponding values.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {boolean[]|string[]} orders The order to sort by for each property.\n * @returns {number} Returns the sort order indicator for `object`.\n */\nfunction compareMultiple(object, other, orders) {\n  var index = -1,\n      objCriteria = object.criteria,\n      othCriteria = other.criteria,\n      length = objCriteria.length,\n      ordersLength = orders.length;\n\n  while (++index < length) {\n    var result = compareAscending(objCriteria[index], othCriteria[index]);\n    if (result) {\n      if (index >= ordersLength) {\n        return result;\n      }\n      var order = orders[index];\n      return result * (order == 'desc' ? -1 : 1);\n    }\n  }\n  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications\n  // that causes it, under certain circumstances, to provide the same value for\n  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247\n  // for more details.\n  //\n  // This also ensures a stable sort in V8 and other engines.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.\n  return object.index - other.index;\n}\n\n/**\n * Creates a `baseEach` or `baseEachRight` function.\n *\n * @private\n * @param {Function} eachFunc The function to iterate over a collection.\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseEach(eachFunc, fromRight) {\n  return function(collection, iteratee) {\n    if (collection == null) {\n      return collection;\n    }\n    if (!isArrayLike(collection)) {\n      return eachFunc(collection, iteratee);\n    }\n    var length = collection.length,\n        index = fromRight ? length : -1,\n        iterable = Object(collection);\n\n    while ((fromRight ? index-- : ++index < length)) {\n      if (iteratee(iterable[index], index, iterable) === false) {\n        break;\n      }\n    }\n    return collection;\n  };\n}\n\n/**\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n *\n * @private\n * @param {boolean} [fromRight] Specify iterating from right to left.\n * @returns {Function} Returns the new base function.\n */\nfunction createBaseFor(fromRight) {\n  return function(object, iteratee, keysFunc) {\n    var index = -1,\n        iterable = Object(object),\n        props = keysFunc(object),\n        length = props.length;\n\n    while (length--) {\n      var key = props[fromRight ? length : ++index];\n      if (iteratee(iterable[key], key, iterable) === false) {\n        break;\n      }\n    }\n    return object;\n  };\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for arrays with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Array} array The array to compare.\n * @param {Array} other The other array to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `array` and `other` objects.\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n */\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      arrLength = array.length,\n      othLength = other.length;\n\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n    return false;\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(array);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var index = -1,\n      result = true,\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\n\n  stack.set(array, other);\n  stack.set(other, array);\n\n  // Ignore non-index properties.\n  while (++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, arrValue, index, other, array, stack)\n        : customizer(arrValue, othValue, index, array, other, stack);\n    }\n    if (compared !== undefined) {\n      if (compared) {\n        continue;\n      }\n      result = false;\n      break;\n    }\n    // Recursively compare arrays (susceptible to call stack limits).\n    if (seen) {\n      if (!arraySome(other, function(othValue, othIndex) {\n            if (!cacheHas(seen, othIndex) &&\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n              return seen.push(othIndex);\n            }\n          })) {\n        result = false;\n        break;\n      }\n    } else if (!(\n          arrValue === othValue ||\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\n        )) {\n      result = false;\n      break;\n    }\n  }\n  stack['delete'](array);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for comparing objects of\n * the same `toStringTag`.\n *\n * **Note:** This function only supports comparing values with tags of\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {string} tag The `toStringTag` of the objects to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n  switch (tag) {\n    case dataViewTag:\n      if ((object.byteLength != other.byteLength) ||\n          (object.byteOffset != other.byteOffset)) {\n        return false;\n      }\n      object = object.buffer;\n      other = other.buffer;\n\n    case arrayBufferTag:\n      if ((object.byteLength != other.byteLength) ||\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n        return false;\n      }\n      return true;\n\n    case boolTag:\n    case dateTag:\n    case numberTag:\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\n      // Invalid dates are coerced to `NaN`.\n      return eq(+object, +other);\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case regexpTag:\n    case stringTag:\n      // Coerce regexes to strings and treat strings, primitives and objects,\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n      // for more details.\n      return object == (other + '');\n\n    case mapTag:\n      var convert = mapToArray;\n\n    case setTag:\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n      convert || (convert = setToArray);\n\n      if (object.size != other.size && !isPartial) {\n        return false;\n      }\n      // Assume cyclic values are equal.\n      var stacked = stack.get(object);\n      if (stacked) {\n        return stacked == other;\n      }\n      bitmask |= COMPARE_UNORDERED_FLAG;\n\n      // Recursively compare objects (susceptible to call stack limits).\n      stack.set(object, other);\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n      stack['delete'](object);\n      return result;\n\n    case symbolTag:\n      if (symbolValueOf) {\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\n      }\n  }\n  return false;\n}\n\n/**\n * A specialized version of `baseIsEqualDeep` for objects with support for\n * partial deep comparisons.\n *\n * @private\n * @param {Object} object The object to compare.\n * @param {Object} other The other object to compare.\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\n * @param {Function} customizer The function to customize comparisons.\n * @param {Function} equalFunc The function to determine equivalents of values.\n * @param {Object} stack Tracks traversed `object` and `other` objects.\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n */\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\n      objProps = getAllKeys(object),\n      objLength = objProps.length,\n      othProps = getAllKeys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isPartial) {\n    return false;\n  }\n  var index = objLength;\n  while (index--) {\n    var key = objProps[index];\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n      return false;\n    }\n  }\n  // Assume cyclic values are equal.\n  var stacked = stack.get(object);\n  if (stacked && stack.get(other)) {\n    return stacked == other;\n  }\n  var result = true;\n  stack.set(object, other);\n  stack.set(other, object);\n\n  var skipCtor = isPartial;\n  while (++index < objLength) {\n    key = objProps[index];\n    var objValue = object[key],\n        othValue = other[key];\n\n    if (customizer) {\n      var compared = isPartial\n        ? customizer(othValue, objValue, key, other, object, stack)\n        : customizer(objValue, othValue, key, object, other, stack);\n    }\n    // Recursively compare objects (susceptible to call stack limits).\n    if (!(compared === undefined\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\n          : compared\n        )) {\n      result = false;\n      break;\n    }\n    skipCtor || (skipCtor = key == 'constructor');\n  }\n  if (result && !skipCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    // Non `Object` object instances with different constructors are not equal.\n    if (objCtor != othCtor &&\n        ('constructor' in object && 'constructor' in other) &&\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n      result = false;\n    }\n  }\n  stack['delete'](object);\n  stack['delete'](other);\n  return result;\n}\n\n/**\n * Creates an array of own enumerable property names and symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names and symbols.\n */\nfunction getAllKeys(object) {\n  return baseGetAllKeys(object, keys, getSymbols);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the property names, values, and compare flags of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the match data of `object`.\n */\nfunction getMatchData(object) {\n  var result = keys(object),\n      length = result.length;\n\n  while (length--) {\n    var key = result[length],\n        value = object[key];\n\n    result[length] = [key, value, isStrictComparable(value)];\n  }\n  return result;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\n/**\n * Creates an array of the own enumerable symbols of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of symbols.\n */\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n  if (object == null) {\n    return [];\n  }\n  object = Object(object);\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\n    return propertyIsEnumerable.call(object, symbol);\n  });\n};\n\n/**\n * Gets the `toStringTag` of `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nvar getTag = baseGetTag;\n\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\n    (Map && getTag(new Map) != mapTag) ||\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\n    (Set && getTag(new Set) != setTag) ||\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\n  getTag = function(value) {\n    var result = baseGetTag(value),\n        Ctor = result == objectTag ? value.constructor : undefined,\n        ctorString = Ctor ? toSource(Ctor) : '';\n\n    if (ctorString) {\n      switch (ctorString) {\n        case dataViewCtorString: return dataViewTag;\n        case mapCtorString: return mapTag;\n        case promiseCtorString: return promiseTag;\n        case setCtorString: return setTag;\n        case weakMapCtorString: return weakMapTag;\n      }\n    }\n    return result;\n  };\n}\n\n/**\n * Checks if `path` exists on `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @param {Function} hasFunc The function to check properties.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n */\nfunction hasPath(object, path, hasFunc) {\n  path = castPath(path, object);\n\n  var index = -1,\n      length = path.length,\n      result = false;\n\n  while (++index < length) {\n    var key = toKey(path[index]);\n    if (!(result = object != null && hasFunc(object, key))) {\n      break;\n    }\n    object = object[key];\n  }\n  if (result || ++index != length) {\n    return result;\n  }\n  length = object == null ? 0 : object.length;\n  return !!length && isLength(length) && isIndex(key, length) &&\n    (isArray(object) || isArguments(object));\n}\n\n/**\n * Checks if `value` is a flattenable `arguments` object or array.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\n */\nfunction isFlattenable(value) {\n  return isArray(value) || isArguments(value) ||\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  var type = typeof value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n\n  return !!length &&\n    (type == 'number' ||\n      (type != 'symbol' && reIsUint.test(value))) &&\n        (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` if suitable for strict\n *  equality comparisons, else `false`.\n */\nfunction isStrictComparable(value) {\n  return value === value && !isObject(value);\n}\n\n/**\n * A specialized version of `matchesProperty` for source values suitable\n * for strict equality comparisons, i.e. `===`.\n *\n * @private\n * @param {string} key The key of the property to get.\n * @param {*} srcValue The value to match.\n * @returns {Function} Returns the new spec function.\n */\nfunction matchesStrictComparable(key, srcValue) {\n  return function(object) {\n    if (object == null) {\n      return false;\n    }\n    return object[key] === srcValue &&\n      (srcValue !== undefined || (key in Object(object)));\n  };\n}\n\n/**\n * A specialized version of `_.memoize` which clears the memoized function's\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\n *\n * @private\n * @param {Function} func The function to have its output memoized.\n * @returns {Function} Returns the new memoized function.\n */\nfunction memoizeCapped(func) {\n  var result = memoize(func, function(key) {\n    if (cache.size === MAX_MEMOIZE_SIZE) {\n      cache.clear();\n    }\n    return key;\n  });\n\n  var cache = result.cache;\n  return result;\n}\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/**\n * A specialized version of `baseRest` which transforms the rest array.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @param {Function} transform The rest array transform.\n * @returns {Function} Returns the new function.\n */\nfunction overRest(func, start, transform) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = transform(array);\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Sets the `toString` method of `func` to return `string`.\n *\n * @private\n * @param {Function} func The function to modify.\n * @param {Function} string The `toString` result.\n * @returns {Function} Returns `func`.\n */\nvar setToString = shortOut(baseSetToString);\n\n/**\n * Creates a function that'll short out and invoke `identity` instead\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\n * milliseconds.\n *\n * @private\n * @param {Function} func The function to restrict.\n * @returns {Function} Returns the new shortable function.\n */\nfunction shortOut(func) {\n  var count = 0,\n      lastCalled = 0;\n\n  return function() {\n    var stamp = nativeNow(),\n        remaining = HOT_SPAN - (stamp - lastCalled);\n\n    lastCalled = stamp;\n    if (remaining > 0) {\n      if (++count >= HOT_COUNT) {\n        return arguments[0];\n      }\n    } else {\n      count = 0;\n    }\n    return func.apply(undefined, arguments);\n  };\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoizeCapped(function(string) {\n  var result = [];\n  if (string.charCodeAt(0) === 46 /* . */) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, subString) {\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to convert.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates an array of elements, sorted in ascending order by the results of\n * running each element in a collection thru each iteratee. This method\n * performs a stable sort, that is, it preserves the original sort order of\n * equal elements. The iteratees are invoked with one argument: (value).\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {...(Function|Function[])} [iteratees=[_.identity]]\n *  The iteratees to sort by.\n * @returns {Array} Returns the new sorted array.\n * @example\n *\n * var users = [\n *   { 'user': 'fred',   'age': 48 },\n *   { 'user': 'barney', 'age': 36 },\n *   { 'user': 'fred',   'age': 40 },\n *   { 'user': 'barney', 'age': 34 }\n * ];\n *\n * _.sortBy(users, [function(o) { return o.user; }]);\n * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]\n *\n * _.sortBy(users, ['user', 'age']);\n * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]\n */\nvar sortBy = baseRest(function(collection, iteratees) {\n  if (collection == null) {\n    return [];\n  }\n  var length = iteratees.length;\n  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n    iteratees = [];\n  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n    iteratees = [iteratees[0]];\n  }\n  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n});\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result) || cache;\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Expose `MapCache`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\n    !propertyIsEnumerable.call(value, 'callee');\n};\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * Checks if `value` is a buffer.\n *\n * @static\n * @memberOf _\n * @since 4.3.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n * @example\n *\n * _.isBuffer(new Buffer(2));\n * // => true\n *\n * _.isBuffer(new Uint8Array(2));\n * // => false\n */\nvar isBuffer = nativeIsBuffer || stubFalse;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  if (!isObject(value)) {\n    return false;\n  }\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\n  var tag = baseGetTag(value);\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/**\n * Checks if `value` is classified as a typed array.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n * @example\n *\n * _.isTypedArray(new Uint8Array);\n * // => true\n *\n * _.isTypedArray([]);\n * // => false\n */\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\n/**\n * Checks if `path` is a direct or inherited property of `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path to check.\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\n * @example\n *\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n *\n * _.hasIn(object, 'a');\n * // => true\n *\n * _.hasIn(object, 'a.b');\n * // => true\n *\n * _.hasIn(object, ['a', 'b']);\n * // => true\n *\n * _.hasIn(object, 'b');\n * // => false\n */\nfunction hasIn(object, path) {\n  return object != null && hasPath(object, path, baseHasIn);\n}\n\n/**\n * Creates an array of the own enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects. See the\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * for more details.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keys(new Foo);\n * // => ['a', 'b'] (iteration order is not guaranteed)\n *\n * _.keys('hi');\n * // => ['0', '1']\n */\nfunction keys(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n}\n\n/**\n * Creates a function that returns `value`.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {*} value The value to return from the new function.\n * @returns {Function} Returns the new constant function.\n * @example\n *\n * var objects = _.times(2, _.constant({ 'a': 1 }));\n *\n * console.log(objects);\n * // => [{ 'a': 1 }, { 'a': 1 }]\n *\n * console.log(objects[0] === objects[1]);\n * // => true\n */\nfunction constant(value) {\n  return function() {\n    return value;\n  };\n}\n\n/**\n * This method returns the first argument it receives.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Util\n * @param {*} value Any value.\n * @returns {*} Returns `value`.\n * @example\n *\n * var object = { 'a': 1 };\n *\n * console.log(_.identity(object) === object);\n * // => true\n */\nfunction identity(value) {\n  return value;\n}\n\n/**\n * Creates a function that returns the value at `path` of a given object.\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Util\n * @param {Array|string} path The path of the property to get.\n * @returns {Function} Returns the new accessor function.\n * @example\n *\n * var objects = [\n *   { 'a': { 'b': 2 } },\n *   { 'a': { 'b': 1 } }\n * ];\n *\n * _.map(objects, _.property('a.b'));\n * // => [2, 1]\n *\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n * // => [1, 2]\n */\nfunction property(path) {\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n}\n\n/**\n * This method returns a new empty array.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {Array} Returns the new empty array.\n * @example\n *\n * var arrays = _.times(2, _.stubArray);\n *\n * console.log(arrays);\n * // => [[], []]\n *\n * console.log(arrays[0] === arrays[1]);\n * // => false\n */\nfunction stubArray() {\n  return [];\n}\n\n/**\n * This method returns `false`.\n *\n * @static\n * @memberOf _\n * @since 4.13.0\n * @category Util\n * @returns {boolean} Returns `false`.\n * @example\n *\n * _.times(2, _.stubFalse);\n * // => [false, false]\n */\nfunction stubFalse() {\n  return false;\n}\n\nmodule.exports = sortBy;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../../../webpack/buildin/module.js */ \"./node_modules/webpack/buildin/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleC9sb2Rhc2gtY3VzdG9tLWJ1aWxkL21vZHVsYXJpemUvbG9kYXNoLnNvcnRieS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Aa2lzc215YnV0dG9uL21vdG9yY29ydGV4L2xvZGFzaC1jdXN0b20tYnVpbGQvbW9kdWxhcml6ZS9sb2Rhc2guc29ydGJ5L2luZGV4LmpzP2FjM2YiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGluY2x1ZGU9XCJmaWx0ZXIsc29ydEJ5LGZpbmRJbmRleCxmaW5kLGZvckVhY2gsY2xvbmVEZWVwXCIgZXhwb3J0cz1cIm5wbVwiYFxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9ycyA8aHR0cHM6Ly9qcy5mb3VuZGF0aW9uLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDEsXG4gICAgQ09NUEFSRV9VTk9SREVSRURfRkxBRyA9IDI7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3QgZnVuY3Rpb25zIGJ5IG51bWJlciBvZiBjYWxscyB3aXRoaW4gYSBzcGFuIG9mIG1pbGxpc2Vjb25kcy4gKi9cbnZhciBIT1RfQ09VTlQgPSA4MDAsXG4gICAgSE9UX1NQQU4gPSAxNjtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLFxuICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZpbHRlcmAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBlbGVtZW50cyBvZiBgdmFsdWVzYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYXBwZW5kLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5UHVzaChhcnJheSwgdmFsdWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIG9mZnNldCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zb21lYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTb21lKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRCeWAgd2hpY2ggdXNlcyBgY29tcGFyZXJgIHRvIGRlZmluZSB0aGVcbiAqIHNvcnQgb3JkZXIgb2YgYGFycmF5YCBhbmQgcmVwbGFjZXMgY3JpdGVyaWEgb2JqZWN0cyB3aXRoIHRoZWlyIGNvcnJlc3BvbmRpbmdcbiAqIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJlciBUaGUgZnVuY3Rpb24gdG8gZGVmaW5lIHNvcnQgb3JkZXIuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvcnRCeShhcnJheSwgY29tcGFyZXIpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHZhbHVlIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgbWFwYCB0byBpdHMga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICovXG5mdW5jdGlvbiBtYXBUb0FycmF5KG1hcCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICBtYXAuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gW2tleSwgdmFsdWVdO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLFxuICAgIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZSxcbiAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvdmVycmVhY2hpbmcgY29yZS1qcyBzaGltcy4gKi9cbnZhciBjb3JlSnNEYXRhID0gcm9vdFsnX19jb3JlLWpzX3NoYXJlZF9fJ107XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtZXRob2RzIG1hc3F1ZXJhZGluZyBhcyBuYXRpdmUuICovXG52YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8ICcnKTtcbiAgcmV0dXJuIHVpZCA/ICgnU3ltYm9sKHNyYylfMS4nICsgdWlkKSA6ICcnO1xufSgpKTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmdW5jVG9TdHJpbmcuY2FsbChoYXNPd25Qcm9wZXJ0eSkucmVwbGFjZShyZVJlZ0V4cENoYXIsICdcXFxcJCYnKVxuICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbik7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQsXG4gICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCksXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBoYXNoIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGhhc2ggdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgcmV0dXJuIG5hdGl2ZUNyZWF0ZSA/IChkYXRhW2tleV0gIT09IHVuZGVmaW5lZCkgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIC0tdGhpcy5zaXplO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlR2V0KGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIHJldHVybiBpbmRleCA8IDAgPyB1bmRlZmluZWQgOiBkYXRhW2luZGV4XVsxXTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgbGlzdCBjYWNoZSBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgKyt0aGlzLnNpemU7XG4gICAgZGF0YS5wdXNoKFtrZXksIHZhbHVlXSk7XG4gIH0gZWxzZSB7XG4gICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYExpc3RDYWNoZWAuXG5MaXN0Q2FjaGUucHJvdG90eXBlLmNsZWFyID0gbGlzdENhY2hlQ2xlYXI7XG5MaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbkxpc3RDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbGlzdENhY2hlR2V0O1xuTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG5MaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5zaXplID0gMDtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBtYXAgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlR2V0KGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIG1hcCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICBzaXplID0gZGF0YS5zaXplO1xuXG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG5NYXBDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBtYXBDYWNoZUNsZWFyO1xuTWFwQ2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IG1hcENhY2hlRGVsZXRlO1xuTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuTWFwQ2FjaGUucHJvdG90eXBlLmhhcyA9IG1hcENhY2hlSGFzO1xuTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuXG4vKipcbiAqXG4gKiBDcmVhdGVzIGFuIGFycmF5IGNhY2hlIG9iamVjdCB0byBzdG9yZSB1bmlxdWUgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFNldENhY2hlKHZhbHVlcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHZhbHVlcyA9PSBudWxsID8gMCA6IHZhbHVlcy5sZW5ndGg7XG5cbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB0aGlzLmFkZCh2YWx1ZXNbaW5kZXhdKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYHZhbHVlYCB0byB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGFkZFxuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAYWxpYXMgcHVzaFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2FjaGUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbiAgdGhpcy5zaXplID0gMDtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAoZGF0YSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGRhdGEuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU3RhY2tgLlxuU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcblN0YWNrLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBzdGFja0RlbGV0ZTtcblN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcblN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcblN0YWNrLnByb3RvdHlwZS5zZXQgPSBzdGFja1NldDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhc0luKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0KG9iamVjdCk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNFcXVhbGAgd2hpY2ggc3VwcG9ydHMgcGFydGlhbCBjb21wYXJpc29uc1xuICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gKiAgMiAtIFBhcnRpYWwgY29tcGFyaXNvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgaWYgKHZhbHVlID09PSBvdGhlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsIHx8IG90aGVyID09IG51bGwgfHwgKCFpc09iamVjdExpa2UodmFsdWUpICYmICFpc09iamVjdExpa2Uob3RoZXIpKSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyO1xuICB9XG4gIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxgIGZvciBhcnJheXMgYW5kIG9iamVjdHMgd2hpY2ggcGVyZm9ybXNcbiAqIGRlZXAgY29tcGFyaXNvbnMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksXG4gICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgb3RoVGFnID0gb3RoVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvdGhUYWc7XG5cbiAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihvdGhlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgb2JqSXNBcnIgPSB0cnVlO1xuICAgIG9iaklzT2JqID0gZmFsc2U7XG4gIH1cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgaXRlcmF0ZWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAvLyBEb24ndCBzdG9yZSB0aGUgYHR5cGVvZmAgcmVzdWx0IGluIGEgdmFyaWFibGUgdG8gYXZvaWQgYSBKSVQgYnVnIGluIFNhZmFyaSA5LlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjAzNCBmb3IgbW9yZSBkZXRhaWxzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpdHk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBpc0FycmF5KHZhbHVlKVxuICAgICAgPyBiYXNlTWF0Y2hlc1Byb3BlcnR5KHZhbHVlWzBdLCB2YWx1ZVsxXSlcbiAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICB9XG4gIHJldHVybiBwcm9wZXJ0eSh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXBgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pID8gQXJyYXkoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IGl0ZXJhdGVlKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc1Byb3BlcnR5YCB3aGljaCBkb2Vzbid0IGNsb25lIGBzcmNWYWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzUHJvcGVydHkocGF0aCwgc3JjVmFsdWUpIHtcbiAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgcmV0dXJuIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIG9ialZhbHVlID09PSBzcmNWYWx1ZSlcbiAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgOiBiYXNlSXNFcXVhbChzcmNWYWx1ZSwgb2JqVmFsdWUsIENPTVBBUkVfUEFSVElBTF9GTEFHIHwgQ09NUEFSRV9VTk9SREVSRURfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIHZhciBpbmRleCA9IC0xO1xuICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMubGVuZ3RoID8gaXRlcmF0ZWVzIDogW2lkZW50aXR5XSwgYmFzZVVuYXJ5KGJhc2VJdGVyYXRlZSkpO1xuXG4gIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgY3JpdGVyaWEgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gaXRlcmF0ZWUodmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiB7ICdjcml0ZXJpYSc6IGNyaXRlcmlhLCAnaW5kZXgnOiArK2luZGV4LCAndmFsdWUnOiB2YWx1ZSB9O1xuICB9KTtcblxuICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICByZXR1cm4gY29tcGFyZU11bHRpcGxlKG9iamVjdCwgb3RoZXIsIG9yZGVycyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbnZlcnQgdmFsdWVzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYSBwYXRoIGFycmF5IGlmIGl0J3Mgbm90IG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xufVxuXG4vKipcbiAqIENvbXBhcmVzIHZhbHVlcyB0byBzb3J0IHRoZW0gaW4gYXNjZW5kaW5nIG9yZGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICovXG5mdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKHZhbHVlLCBvdGhlcikge1xuICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgdmFyIHZhbElzRGVmaW5lZCA9IHZhbHVlICE9PSB1bmRlZmluZWQsXG4gICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG5cbiAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgIG90aElzUmVmbGV4aXZlID0gb3RoZXIgPT09IG90aGVyLFxuICAgICAgICBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKG90aGVyKTtcblxuICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICh2YWxJc1N5bWJvbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgJiYgIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wpIHx8XG4gICAgICAgICh2YWxJc051bGwgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgIXZhbElzUmVmbGV4aXZlKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgaWYgKCghdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCAmJiAhb3RoSXNTeW1ib2wgJiYgdmFsdWUgPCBvdGhlcikgfHxcbiAgICAgICAgKG90aElzU3ltYm9sICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSAmJiAhdmFsSXNOdWxsICYmICF2YWxJc1N5bWJvbCkgfHxcbiAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghb3RoSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBiYXNlRWFjaGAgb3IgYGJhc2VFYWNoUmlnaHRgIGZ1bmN0aW9uLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICBpdGVyYWJsZSA9IE9iamVjdChjb2xsZWN0aW9uKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgYXJyYXlzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gIGlmIChzdGFja2VkICYmIHN0YWNrLmdldChvdGhlcikpIHtcbiAgICByZXR1cm4gc3RhY2tlZCA9PSBvdGhlcjtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzKG9iamVjdCkge1xuICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBkYXRhIGZvciBgbWFwYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgcmVmZXJlbmNlIGtleS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFwRGF0YShtYXAsIGtleSkge1xuICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgcmV0dXJuIGlzS2V5YWJsZShrZXkpXG4gICAgPyBkYXRhW3R5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyAnc3RyaW5nJyA6ICdoYXNoJ11cbiAgICA6IGRhdGEubWFwO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG1hdGNoIGRhdGEgb2YgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgdmFyIHJlc3VsdCA9IGtleXMob2JqZWN0KSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgdmFyIGtleSA9IHJlc3VsdFtsZW5ndGhdLFxuICAgICAgICB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gKi9cbnZhciBnZXRTeW1ib2xzID0gIW5hdGl2ZUdldFN5bWJvbHMgPyBzdHViQXJyYXkgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICByZXR1cm4gcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChvYmplY3QsIHN5bWJvbCk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFzRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2sgcHJvcGVydGllcy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBmYWxzZTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gIH1cbiAgaWYgKHJlc3VsdCB8fCArK2luZGV4ICE9IGxlbmd0aCkge1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZmxhdHRlbmFibGUgYGFyZ3VtZW50c2Agb2JqZWN0IG9yIGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzRmxhdHRlbmFibGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICEhKHNwcmVhZGFibGVTeW1ib2wgJiYgdmFsdWUgJiYgdmFsdWVbc3ByZWFkYWJsZVN5bWJvbF0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gKHR5cGUgPT0gJ3N0cmluZycgfHwgdHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nKVxuICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICA6ICh2YWx1ZSA9PT0gbnVsbCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gKiAgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYG1hdGNoZXNQcm9wZXJ0eWAgZm9yIHNvdXJjZSB2YWx1ZXMgc3VpdGFibGVcbiAqIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdFtrZXldID09PSBzcmNWYWx1ZSAmJlxuICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICB9O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nIHVzaW5nIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKi9cbnZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChzdHJpbmcuY2hhckNvZGVBdCgwKSA9PT0gNDYgLyogLiAqLykge1xuICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgfVxuICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcga2V5IGlmIGl0J3Mgbm90IGEgc3RyaW5nIG9yIHN5bWJvbC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIHRvS2V5KHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAqIHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiB0aHJ1IGVhY2ggaXRlcmF0ZWUuIFRoaXMgbWV0aG9kXG4gKiBwZXJmb3JtcyBhIHN0YWJsZSBzb3J0LCB0aGF0IGlzLCBpdCBwcmVzZXJ2ZXMgdGhlIG9yaWdpbmFsIHNvcnQgb3JkZXIgb2ZcbiAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2l0ZXJhdGVlcz1bXy5pZGVudGl0eV1dXG4gKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQ4IH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH0sXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH1cbiAqIF07XG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFtmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXI7IH1dKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsIDM2XSwgWydiYXJuZXknLCAzNF0sIFsnZnJlZCcsIDQ4XSwgWydmcmVkJywgNDBdXVxuICpcbiAqIF8uc29ydEJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzRdLCBbJ2Jhcm5leScsIDM2XSwgWydmcmVkJywgNDBdLCBbJ2ZyZWQnLCA0OF1dXG4gKi9cbnZhciBzb3J0QnkgPSBiYXNlUmVzdChmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZXMpIHtcbiAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW107XG4gIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICB9XG4gIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG59KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICogcHJvdmlkZWQsIGl0IGRldGVybWluZXMgdGhlIGNhY2hlIGtleSBmb3Igc3RvcmluZyB0aGUgcmVzdWx0IGJhc2VkIG9uIHRoZVxuICogYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbi4gQnkgZGVmYXVsdCwgdGhlIGZpcnN0IGFyZ3VtZW50XG4gKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICogaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKlxuICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICogZnVuY3Rpb24uIEl0cyBjcmVhdGlvbiBtYXkgYmUgY3VzdG9taXplZCBieSByZXBsYWNpbmcgdGhlIGBfLm1lbW9pemUuQ2FjaGVgXG4gKiBjb25zdHJ1Y3RvciB3aXRoIG9uZSB3aG9zZSBpbnN0YW5jZXMgaW1wbGVtZW50IHRoZVxuICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAqIG1ldGhvZCBpbnRlcmZhY2Ugb2YgYGNsZWFyYCwgYGRlbGV0ZWAsIGBnZXRgLCBgaGFzYCwgYW5kIGBzZXRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3Jlc29sdmVyXSBUaGUgZnVuY3Rpb24gdG8gcmVzb2x2ZSB0aGUgY2FjaGUga2V5LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdjJzogMywgJ2QnOiA0IH07XG4gKlxuICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIHZhbHVlcyhvdGhlcik7XG4gKiAvLyA9PiBbMywgNF1cbiAqXG4gKiBvYmplY3QuYSA9IDI7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsxLCAyXVxuICpcbiAqIC8vIE1vZGlmeSB0aGUgcmVzdWx0IGNhY2hlLlxuICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICogdmFsdWVzKG9iamVjdCk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddXG4gKlxuICogLy8gUmVwbGFjZSBgXy5tZW1vaXplLkNhY2hlYC5cbiAqIF8ubWVtb2l6ZS5DYWNoZSA9IFdlYWtNYXA7XG4gKi9cbmZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicgfHwgKHJlc29sdmVyICE9IG51bGwgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCkgfHwgY2FjaGU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEV4cG9zZSBgTWFwQ2FjaGVgLlxubWVtb2l6ZS5DYWNoZSA9IE1hcENhY2hlO1xuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcuIEFuIGVtcHR5IHN0cmluZyBpcyByZXR1cm5lZCBmb3IgYG51bGxgXG4gKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb25zdGFudCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uY29uc3RhbnQoeyAnYSc6IDEgfSkpO1xuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICogLy8gPT4gW3sgJ2EnOiAxIH0sIHsgJ2EnOiAxIH1dXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKlxuICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW1xuICogICB7ICdhJzogeyAnYic6IDIgfSB9LFxuICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gKiBdO1xuICpcbiAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAqIC8vID0+IFsyLCAxXVxuICpcbiAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqL1xuZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICByZXR1cm4gaXNLZXkocGF0aCkgPyBiYXNlUHJvcGVydHkodG9LZXkocGF0aCkpIDogYmFzZVByb3BlcnR5RGVlcChwYXRoKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGVtcHR5IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZW1wdHkgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBhcnJheXMgPSBfLnRpbWVzKDIsIF8uc3R1YkFycmF5KTtcbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXMpO1xuICogLy8gPT4gW1tdLCBbXV1cbiAqXG4gKiBjb25zb2xlLmxvZyhhcnJheXNbMF0gPT09IGFycmF5c1sxXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gIHJldHVybiBbXTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRCeTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@kissmybutton/motorcortex/lodash-custom-build/modularize/lodash.sortby/index.js\n");

/***/ }),

/***/ "./node_modules/draggabilly/draggabilly.js":
/*!*************************************************!*\
  !*** ./node_modules/draggabilly/draggabilly.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Draggabilly v2.2.0\n * Make that shiz draggable\n * https://draggabilly.desandro.com\n * MIT license\n */\n\n/*jshint browser: true, strict: true, undef: true, unused: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*globals define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n        __webpack_require__(/*! get-size/get-size */ \"./node_modules/get-size/get-size.js\"),\n        __webpack_require__(/*! unidragger/unidragger */ \"./node_modules/unidragger/unidragger.js\")\n      ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( getSize, Unidragger ) {\n        return factory( window, getSize, Unidragger );\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, getSize, Unidragger ) {\n\n'use strict';\n\n// -------------------------- helpers & variables -------------------------- //\n\n// extend objects\nfunction extend( a, b ) {\n  for ( var prop in b ) {\n    a[ prop ] = b[ prop ];\n  }\n  return a;\n}\n\nfunction noop() {}\n\nvar jQuery = window.jQuery;\n\n// --------------------------  -------------------------- //\n\nfunction Draggabilly( element, options ) {\n  // querySelector if string\n  this.element = typeof element == 'string' ?\n    document.querySelector( element ) : element;\n\n  if ( jQuery ) {\n    this.$element = jQuery( this.element );\n  }\n\n  // options\n  this.options = extend( {}, this.constructor.defaults );\n  this.option( options );\n\n  this._create();\n}\n\n// inherit Unidragger methods\nvar proto = Draggabilly.prototype = Object.create( Unidragger.prototype );\n\nDraggabilly.defaults = {\n};\n\n/**\n * set options\n * @param {Object} opts\n */\nproto.option = function( opts ) {\n  extend( this.options, opts );\n};\n\n// css position values that don't need to be set\nvar positionValues = {\n  relative: true,\n  absolute: true,\n  fixed: true\n};\n\nproto._create = function() {\n  // properties\n  this.position = {};\n  this._getPosition();\n\n  this.startPoint = { x: 0, y: 0 };\n  this.dragPoint = { x: 0, y: 0 };\n\n  this.startPosition = extend( {}, this.position );\n\n  // set relative positioning\n  var style = getComputedStyle( this.element );\n  if ( !positionValues[ style.position ] ) {\n    this.element.style.position = 'relative';\n  }\n\n  // events, bridge jQuery events from vanilla\n  this.on( 'pointerDown', this.onPointerDown );\n  this.on( 'pointerMove', this.onPointerMove );\n  this.on( 'pointerUp', this.onPointerUp );\n\n  this.enable();\n  this.setHandles();\n};\n\n/**\n * set this.handles and bind start events to 'em\n */\nproto.setHandles = function() {\n  this.handles = this.options.handle ?\n    this.element.querySelectorAll( this.options.handle ) : [ this.element ];\n\n  this.bindHandles();\n};\n\n/**\n * emits events via EvEmitter and jQuery events\n * @param {String} type - name of event\n * @param {Event} event - original event\n * @param {Array} args - extra arguments\n */\nproto.dispatchEvent = function( type, event, args ) {\n  var emitArgs = [ event ].concat( args );\n  this.emitEvent( type, emitArgs );\n  this.dispatchJQueryEvent( type, event, args );\n};\n\nproto.dispatchJQueryEvent = function( type, event, args ) {\n  var jQuery = window.jQuery;\n  // trigger jQuery event\n  if ( !jQuery || !this.$element ) {\n    return;\n  }\n  // create jQuery event\n  var $event = jQuery.Event( event );\n  $event.type = type;\n  this.$element.trigger( $event, args );\n};\n\n// -------------------------- position -------------------------- //\n\n// get x/y position from style\nproto._getPosition = function() {\n  var style = getComputedStyle( this.element );\n  var x = this._getPositionCoord( style.left, 'width' );\n  var y = this._getPositionCoord( style.top, 'height' );\n  // clean up 'auto' or other non-integer values\n  this.position.x = isNaN( x ) ? 0 : x;\n  this.position.y = isNaN( y ) ? 0 : y;\n\n  this._addTransformPosition( style );\n};\n\nproto._getPositionCoord = function( styleSide, measure ) {\n  if ( styleSide.indexOf('%') != -1 ) {\n    // convert percent into pixel for Safari, #75\n    var parentSize = getSize( this.element.parentNode );\n    // prevent not-in-DOM element throwing bug, #131\n    return !parentSize ? 0 :\n      ( parseFloat( styleSide ) / 100 ) * parentSize[ measure ];\n  }\n  return parseInt( styleSide, 10 );\n};\n\n// add transform: translate( x, y ) to position\nproto._addTransformPosition = function( style ) {\n  var transform = style.transform;\n  // bail out if value is 'none'\n  if ( transform.indexOf('matrix') !== 0 ) {\n    return;\n  }\n  // split matrix(1, 0, 0, 1, x, y)\n  var matrixValues = transform.split(',');\n  // translate X value is in 12th or 4th position\n  var xIndex = transform.indexOf('matrix3d') === 0 ? 12 : 4;\n  var translateX = parseInt( matrixValues[ xIndex ], 10 );\n  // translate Y value is in 13th or 5th position\n  var translateY = parseInt( matrixValues[ xIndex + 1 ], 10 );\n  this.position.x += translateX;\n  this.position.y += translateY;\n};\n\n// -------------------------- events -------------------------- //\n\nproto.onPointerDown = function( event, pointer ) {\n  this.element.classList.add('is-pointer-down');\n  this.dispatchJQueryEvent( 'pointerDown', event, [ pointer ] );\n};\n\n/**\n * drag start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragStart = function( event, pointer ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  this._getPosition();\n  this.measureContainment();\n  // position _when_ drag began\n  this.startPosition.x = this.position.x;\n  this.startPosition.y = this.position.y;\n  // reset left/top style\n  this.setLeftTop();\n\n  this.dragPoint.x = 0;\n  this.dragPoint.y = 0;\n\n  this.element.classList.add('is-dragging');\n  this.dispatchEvent( 'dragStart', event, [ pointer ] );\n  // start animation\n  this.animate();\n};\n\nproto.measureContainment = function() {\n  var container = this.getContainer();\n  if ( !container ) {\n    return;\n  }\n\n  var elemSize = getSize( this.element );\n  var containerSize = getSize( container );\n  var elemRect = this.element.getBoundingClientRect();\n  var containerRect = container.getBoundingClientRect();\n\n  var borderSizeX = containerSize.borderLeftWidth + containerSize.borderRightWidth;\n  var borderSizeY = containerSize.borderTopWidth + containerSize.borderBottomWidth;\n\n  var position = this.relativeStartPosition = {\n    x: elemRect.left - ( containerRect.left + containerSize.borderLeftWidth ),\n    y: elemRect.top - ( containerRect.top + containerSize.borderTopWidth )\n  };\n\n  this.containSize = {\n    width: ( containerSize.width - borderSizeX ) - position.x - elemSize.width,\n    height: ( containerSize.height - borderSizeY ) - position.y - elemSize.height\n  };\n};\n\nproto.getContainer = function() {\n  var containment = this.options.containment;\n  if ( !containment ) {\n    return;\n  }\n  var isElement = containment instanceof HTMLElement;\n  // use as element\n  if ( isElement ) {\n    return containment;\n  }\n  // querySelector if string\n  if ( typeof containment == 'string' ) {\n    return document.querySelector( containment );\n  }\n  // fallback to parent element\n  return this.element.parentNode;\n};\n\n// ----- move event ----- //\n\nproto.onPointerMove = function( event, pointer, moveVector ) {\n  this.dispatchJQueryEvent( 'pointerMove', event, [ pointer, moveVector ] );\n};\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragMove = function( event, pointer, moveVector ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  var dragX = moveVector.x;\n  var dragY = moveVector.y;\n\n  var grid = this.options.grid;\n  var gridX = grid && grid[0];\n  var gridY = grid && grid[1];\n\n  dragX = applyGrid( dragX, gridX );\n  dragY = applyGrid( dragY, gridY );\n\n  dragX = this.containDrag( 'x', dragX, gridX );\n  dragY = this.containDrag( 'y', dragY, gridY );\n\n  // constrain to axis\n  dragX = this.options.axis == 'y' ? 0 : dragX;\n  dragY = this.options.axis == 'x' ? 0 : dragY;\n\n  this.position.x = this.startPosition.x + dragX;\n  this.position.y = this.startPosition.y + dragY;\n  // set dragPoint properties\n  this.dragPoint.x = dragX;\n  this.dragPoint.y = dragY;\n\n  this.dispatchEvent( 'dragMove', event, [ pointer, moveVector ] );\n};\n\nfunction applyGrid( value, grid, method ) {\n  method = method || 'round';\n  return grid ? Math[ method ]( value / grid ) * grid : value;\n}\n\nproto.containDrag = function( axis, drag, grid ) {\n  if ( !this.options.containment ) {\n    return drag;\n  }\n  var measure = axis == 'x' ? 'width' : 'height';\n\n  var rel = this.relativeStartPosition[ axis ];\n  var min = applyGrid( -rel, grid, 'ceil' );\n  var max = this.containSize[ measure ];\n  max = applyGrid( max, grid, 'floor' );\n  return  Math.max( min, Math.min( max, drag ) );\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.onPointerUp = function( event, pointer ) {\n  this.element.classList.remove('is-pointer-down');\n  this.dispatchJQueryEvent( 'pointerUp', event, [ pointer ] );\n};\n\n/**\n * drag end\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.dragEnd = function( event, pointer ) {\n  if ( !this.isEnabled ) {\n    return;\n  }\n  // use top left position when complete\n  this.element.style.transform = '';\n  this.setLeftTop();\n  this.element.classList.remove('is-dragging');\n  this.dispatchEvent( 'dragEnd', event, [ pointer ] );\n};\n\n// -------------------------- animation -------------------------- //\n\nproto.animate = function() {\n  // only render and animate if dragging\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.positionDrag();\n\n  var _this = this;\n  requestAnimationFrame( function animateFrame() {\n    _this.animate();\n  });\n\n};\n\n// left/top positioning\nproto.setLeftTop = function() {\n  this.element.style.left = this.position.x + 'px';\n  this.element.style.top  = this.position.y + 'px';\n};\n\nproto.positionDrag = function() {\n  this.element.style.transform = 'translate3d( ' + this.dragPoint.x +\n    'px, ' + this.dragPoint.y + 'px, 0)';\n};\n\n// ----- staticClick ----- //\n\nproto.staticClick = function( event, pointer ) {\n  this.dispatchEvent( 'staticClick', event, [ pointer ] );\n};\n\n// ----- methods ----- //\n\n/**\n * @param {Number} x\n * @param {Number} y\n */\nproto.setPosition = function( x, y ) {\n  this.position.x = x;\n  this.position.y = y;\n  this.setLeftTop();\n};\n\nproto.enable = function() {\n  this.isEnabled = true;\n};\n\nproto.disable = function() {\n  this.isEnabled = false;\n  if ( this.isDragging ) {\n    this.dragEnd();\n  }\n};\n\nproto.destroy = function() {\n  this.disable();\n  // reset styles\n  this.element.style.transform = '';\n  this.element.style.left = '';\n  this.element.style.top = '';\n  this.element.style.position = '';\n  // unbind handles\n  this.unbindHandles();\n  // remove jQuery data\n  if ( this.$element ) {\n    this.$element.removeData('draggabilly');\n  }\n};\n\n// ----- jQuery bridget ----- //\n\n// required for jQuery bridget\nproto._init = noop;\n\nif ( jQuery && jQuery.bridget ) {\n  jQuery.bridget( 'draggabilly', Draggabilly );\n}\n\n// -----  ----- //\n\nreturn Draggabilly;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZHJhZ2dhYmlsbHkvZHJhZ2dhYmlsbHkuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZHJhZ2dhYmlsbHkvZHJhZ2dhYmlsbHkuanM/Y2U4OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIERyYWdnYWJpbGx5IHYyLjIuMFxuICogTWFrZSB0aGF0IHNoaXogZHJhZ2dhYmxlXG4gKiBodHRwczovL2RyYWdnYWJpbGx5LmRlc2FuZHJvLmNvbVxuICogTUlUIGxpY2Vuc2VcbiAqL1xuXG4vKmpzaGludCBicm93c2VyOiB0cnVlLCBzdHJpY3Q6IHRydWUsIHVuZGVmOiB0cnVlLCB1bnVzZWQ6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggd2luZG93LCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAgICdnZXQtc2l6ZS9nZXQtc2l6ZScsXG4gICAgICAgICd1bmlkcmFnZ2VyL3VuaWRyYWdnZXInXG4gICAgICBdLFxuICAgICAgZnVuY3Rpb24oIGdldFNpemUsIFVuaWRyYWdnZXIgKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUsIFVuaWRyYWdnZXIgKTtcbiAgICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgnZ2V0LXNpemUnKSxcbiAgICAgIHJlcXVpcmUoJ3VuaWRyYWdnZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuRHJhZ2dhYmlsbHkgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgd2luZG93LmdldFNpemUsXG4gICAgICB3aW5kb3cuVW5pZHJhZ2dlclxuICAgICk7XG4gIH1cblxufSggd2luZG93LCBmdW5jdGlvbiBmYWN0b3J5KCB3aW5kb3csIGdldFNpemUsIFVuaWRyYWdnZXIgKSB7XG5cbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAmIHZhcmlhYmxlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBleHRlbmQgb2JqZWN0c1xuZnVuY3Rpb24gZXh0ZW5kKCBhLCBiICkge1xuICBmb3IgKCB2YXIgcHJvcCBpbiBiICkge1xuICAgIGFbIHByb3AgXSA9IGJbIHByb3AgXTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gRHJhZ2dhYmlsbHkoIGVsZW1lbnQsIG9wdGlvbnMgKSB7XG4gIC8vIHF1ZXJ5U2VsZWN0b3IgaWYgc3RyaW5nXG4gIHRoaXMuZWxlbWVudCA9IHR5cGVvZiBlbGVtZW50ID09ICdzdHJpbmcnID9cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBlbGVtZW50ICkgOiBlbGVtZW50O1xuXG4gIGlmICggalF1ZXJ5ICkge1xuICAgIHRoaXMuJGVsZW1lbnQgPSBqUXVlcnkoIHRoaXMuZWxlbWVudCApO1xuICB9XG5cbiAgLy8gb3B0aW9uc1xuICB0aGlzLm9wdGlvbnMgPSBleHRlbmQoIHt9LCB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRzICk7XG4gIHRoaXMub3B0aW9uKCBvcHRpb25zICk7XG5cbiAgdGhpcy5fY3JlYXRlKCk7XG59XG5cbi8vIGluaGVyaXQgVW5pZHJhZ2dlciBtZXRob2RzXG52YXIgcHJvdG8gPSBEcmFnZ2FiaWxseS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBVbmlkcmFnZ2VyLnByb3RvdHlwZSApO1xuXG5EcmFnZ2FiaWxseS5kZWZhdWx0cyA9IHtcbn07XG5cbi8qKlxuICogc2V0IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnByb3RvLm9wdGlvbiA9IGZ1bmN0aW9uKCBvcHRzICkge1xuICBleHRlbmQoIHRoaXMub3B0aW9ucywgb3B0cyApO1xufTtcblxuLy8gY3NzIHBvc2l0aW9uIHZhbHVlcyB0aGF0IGRvbid0IG5lZWQgdG8gYmUgc2V0XG52YXIgcG9zaXRpb25WYWx1ZXMgPSB7XG4gIHJlbGF0aXZlOiB0cnVlLFxuICBhYnNvbHV0ZTogdHJ1ZSxcbiAgZml4ZWQ6IHRydWVcbn07XG5cbnByb3RvLl9jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgLy8gcHJvcGVydGllc1xuICB0aGlzLnBvc2l0aW9uID0ge307XG4gIHRoaXMuX2dldFBvc2l0aW9uKCk7XG5cbiAgdGhpcy5zdGFydFBvaW50ID0geyB4OiAwLCB5OiAwIH07XG4gIHRoaXMuZHJhZ1BvaW50ID0geyB4OiAwLCB5OiAwIH07XG5cbiAgdGhpcy5zdGFydFBvc2l0aW9uID0gZXh0ZW5kKCB7fSwgdGhpcy5wb3NpdGlvbiApO1xuXG4gIC8vIHNldCByZWxhdGl2ZSBwb3NpdGlvbmluZ1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLmVsZW1lbnQgKTtcbiAgaWYgKCAhcG9zaXRpb25WYWx1ZXNbIHN0eWxlLnBvc2l0aW9uIF0gKSB7XG4gICAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcbiAgfVxuXG4gIC8vIGV2ZW50cywgYnJpZGdlIGpRdWVyeSBldmVudHMgZnJvbSB2YW5pbGxhXG4gIHRoaXMub24oICdwb2ludGVyRG93bicsIHRoaXMub25Qb2ludGVyRG93biApO1xuICB0aGlzLm9uKCAncG9pbnRlck1vdmUnLCB0aGlzLm9uUG9pbnRlck1vdmUgKTtcbiAgdGhpcy5vbiggJ3BvaW50ZXJVcCcsIHRoaXMub25Qb2ludGVyVXAgKTtcblxuICB0aGlzLmVuYWJsZSgpO1xuICB0aGlzLnNldEhhbmRsZXMoKTtcbn07XG5cbi8qKlxuICogc2V0IHRoaXMuaGFuZGxlcyBhbmQgYmluZCBzdGFydCBldmVudHMgdG8gJ2VtXG4gKi9cbnByb3RvLnNldEhhbmRsZXMgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5oYW5kbGVzID0gdGhpcy5vcHRpb25zLmhhbmRsZSA/XG4gICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoIHRoaXMub3B0aW9ucy5oYW5kbGUgKSA6IFsgdGhpcy5lbGVtZW50IF07XG5cbiAgdGhpcy5iaW5kSGFuZGxlcygpO1xufTtcblxuLyoqXG4gKiBlbWl0cyBldmVudHMgdmlhIEV2RW1pdHRlciBhbmQgalF1ZXJ5IGV2ZW50c1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgLSBuYW1lIG9mIGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIG9yaWdpbmFsIGV2ZW50XG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIC0gZXh0cmEgYXJndW1lbnRzXG4gKi9cbnByb3RvLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGFyZ3MgKSB7XG4gIHZhciBlbWl0QXJncyA9IFsgZXZlbnQgXS5jb25jYXQoIGFyZ3MgKTtcbiAgdGhpcy5lbWl0RXZlbnQoIHR5cGUsIGVtaXRBcmdzICk7XG4gIHRoaXMuZGlzcGF0Y2hKUXVlcnlFdmVudCggdHlwZSwgZXZlbnQsIGFyZ3MgKTtcbn07XG5cbnByb3RvLmRpc3BhdGNoSlF1ZXJ5RXZlbnQgPSBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIGFyZ3MgKSB7XG4gIHZhciBqUXVlcnkgPSB3aW5kb3cualF1ZXJ5O1xuICAvLyB0cmlnZ2VyIGpRdWVyeSBldmVudFxuICBpZiAoICFqUXVlcnkgfHwgIXRoaXMuJGVsZW1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIGNyZWF0ZSBqUXVlcnkgZXZlbnRcbiAgdmFyICRldmVudCA9IGpRdWVyeS5FdmVudCggZXZlbnQgKTtcbiAgJGV2ZW50LnR5cGUgPSB0eXBlO1xuICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoICRldmVudCwgYXJncyApO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gcG9zaXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLy8gZ2V0IHgveSBwb3NpdGlvbiBmcm9tIHN0eWxlXG5wcm90by5fZ2V0UG9zaXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5lbGVtZW50ICk7XG4gIHZhciB4ID0gdGhpcy5fZ2V0UG9zaXRpb25Db29yZCggc3R5bGUubGVmdCwgJ3dpZHRoJyApO1xuICB2YXIgeSA9IHRoaXMuX2dldFBvc2l0aW9uQ29vcmQoIHN0eWxlLnRvcCwgJ2hlaWdodCcgKTtcbiAgLy8gY2xlYW4gdXAgJ2F1dG8nIG9yIG90aGVyIG5vbi1pbnRlZ2VyIHZhbHVlc1xuICB0aGlzLnBvc2l0aW9uLnggPSBpc05hTiggeCApID8gMCA6IHg7XG4gIHRoaXMucG9zaXRpb24ueSA9IGlzTmFOKCB5ICkgPyAwIDogeTtcblxuICB0aGlzLl9hZGRUcmFuc2Zvcm1Qb3NpdGlvbiggc3R5bGUgKTtcbn07XG5cbnByb3RvLl9nZXRQb3NpdGlvbkNvb3JkID0gZnVuY3Rpb24oIHN0eWxlU2lkZSwgbWVhc3VyZSApIHtcbiAgaWYgKCBzdHlsZVNpZGUuaW5kZXhPZignJScpICE9IC0xICkge1xuICAgIC8vIGNvbnZlcnQgcGVyY2VudCBpbnRvIHBpeGVsIGZvciBTYWZhcmksICM3NVxuICAgIHZhciBwYXJlbnRTaXplID0gZ2V0U2l6ZSggdGhpcy5lbGVtZW50LnBhcmVudE5vZGUgKTtcbiAgICAvLyBwcmV2ZW50IG5vdC1pbi1ET00gZWxlbWVudCB0aHJvd2luZyBidWcsICMxMzFcbiAgICByZXR1cm4gIXBhcmVudFNpemUgPyAwIDpcbiAgICAgICggcGFyc2VGbG9hdCggc3R5bGVTaWRlICkgLyAxMDAgKSAqIHBhcmVudFNpemVbIG1lYXN1cmUgXTtcbiAgfVxuICByZXR1cm4gcGFyc2VJbnQoIHN0eWxlU2lkZSwgMTAgKTtcbn07XG5cbi8vIGFkZCB0cmFuc2Zvcm06IHRyYW5zbGF0ZSggeCwgeSApIHRvIHBvc2l0aW9uXG5wcm90by5fYWRkVHJhbnNmb3JtUG9zaXRpb24gPSBmdW5jdGlvbiggc3R5bGUgKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm07XG4gIC8vIGJhaWwgb3V0IGlmIHZhbHVlIGlzICdub25lJ1xuICBpZiAoIHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgnKSAhPT0gMCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc3BsaXQgbWF0cml4KDEsIDAsIDAsIDEsIHgsIHkpXG4gIHZhciBtYXRyaXhWYWx1ZXMgPSB0cmFuc2Zvcm0uc3BsaXQoJywnKTtcbiAgLy8gdHJhbnNsYXRlIFggdmFsdWUgaXMgaW4gMTJ0aCBvciA0dGggcG9zaXRpb25cbiAgdmFyIHhJbmRleCA9IHRyYW5zZm9ybS5pbmRleE9mKCdtYXRyaXgzZCcpID09PSAwID8gMTIgOiA0O1xuICB2YXIgdHJhbnNsYXRlWCA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCBdLCAxMCApO1xuICAvLyB0cmFuc2xhdGUgWSB2YWx1ZSBpcyBpbiAxM3RoIG9yIDV0aCBwb3NpdGlvblxuICB2YXIgdHJhbnNsYXRlWSA9IHBhcnNlSW50KCBtYXRyaXhWYWx1ZXNbIHhJbmRleCArIDEgXSwgMTAgKTtcbiAgdGhpcy5wb3NpdGlvbi54ICs9IHRyYW5zbGF0ZVg7XG4gIHRoaXMucG9zaXRpb24ueSArPSB0cmFuc2xhdGVZO1xufTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZXZlbnRzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnByb3RvLm9uUG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdpcy1wb2ludGVyLWRvd24nKTtcbiAgdGhpcy5kaXNwYXRjaEpRdWVyeUV2ZW50KCAncG9pbnRlckRvd24nLCBldmVudCwgWyBwb2ludGVyIF0gKTtcbn07XG5cbi8qKlxuICogZHJhZyBzdGFydFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8uZHJhZ1N0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fZ2V0UG9zaXRpb24oKTtcbiAgdGhpcy5tZWFzdXJlQ29udGFpbm1lbnQoKTtcbiAgLy8gcG9zaXRpb24gX3doZW5fIGRyYWcgYmVnYW5cbiAgdGhpcy5zdGFydFBvc2l0aW9uLnggPSB0aGlzLnBvc2l0aW9uLng7XG4gIHRoaXMuc3RhcnRQb3NpdGlvbi55ID0gdGhpcy5wb3NpdGlvbi55O1xuICAvLyByZXNldCBsZWZ0L3RvcCBzdHlsZVxuICB0aGlzLnNldExlZnRUb3AoKTtcblxuICB0aGlzLmRyYWdQb2ludC54ID0gMDtcbiAgdGhpcy5kcmFnUG9pbnQueSA9IDA7XG5cbiAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lzLWRyYWdnaW5nJyk7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ2RyYWdTdGFydCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xuICAvLyBzdGFydCBhbmltYXRpb25cbiAgdGhpcy5hbmltYXRlKCk7XG59O1xuXG5wcm90by5tZWFzdXJlQ29udGFpbm1lbnQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0Q29udGFpbmVyKCk7XG4gIGlmICggIWNvbnRhaW5lciApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZWxlbVNpemUgPSBnZXRTaXplKCB0aGlzLmVsZW1lbnQgKTtcbiAgdmFyIGNvbnRhaW5lclNpemUgPSBnZXRTaXplKCBjb250YWluZXIgKTtcbiAgdmFyIGVsZW1SZWN0ID0gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgY29udGFpbmVyUmVjdCA9IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICB2YXIgYm9yZGVyU2l6ZVggPSBjb250YWluZXJTaXplLmJvcmRlckxlZnRXaWR0aCArIGNvbnRhaW5lclNpemUuYm9yZGVyUmlnaHRXaWR0aDtcbiAgdmFyIGJvcmRlclNpemVZID0gY29udGFpbmVyU2l6ZS5ib3JkZXJUb3BXaWR0aCArIGNvbnRhaW5lclNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG5cbiAgdmFyIHBvc2l0aW9uID0gdGhpcy5yZWxhdGl2ZVN0YXJ0UG9zaXRpb24gPSB7XG4gICAgeDogZWxlbVJlY3QubGVmdCAtICggY29udGFpbmVyUmVjdC5sZWZ0ICsgY29udGFpbmVyU2l6ZS5ib3JkZXJMZWZ0V2lkdGggKSxcbiAgICB5OiBlbGVtUmVjdC50b3AgLSAoIGNvbnRhaW5lclJlY3QudG9wICsgY29udGFpbmVyU2l6ZS5ib3JkZXJUb3BXaWR0aCApXG4gIH07XG5cbiAgdGhpcy5jb250YWluU2l6ZSA9IHtcbiAgICB3aWR0aDogKCBjb250YWluZXJTaXplLndpZHRoIC0gYm9yZGVyU2l6ZVggKSAtIHBvc2l0aW9uLnggLSBlbGVtU2l6ZS53aWR0aCxcbiAgICBoZWlnaHQ6ICggY29udGFpbmVyU2l6ZS5oZWlnaHQgLSBib3JkZXJTaXplWSApIC0gcG9zaXRpb24ueSAtIGVsZW1TaXplLmhlaWdodFxuICB9O1xufTtcblxucHJvdG8uZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb250YWlubWVudCA9IHRoaXMub3B0aW9ucy5jb250YWlubWVudDtcbiAgaWYgKCAhY29udGFpbm1lbnQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpc0VsZW1lbnQgPSBjb250YWlubWVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICAvLyB1c2UgYXMgZWxlbWVudFxuICBpZiAoIGlzRWxlbWVudCApIHtcbiAgICByZXR1cm4gY29udGFpbm1lbnQ7XG4gIH1cbiAgLy8gcXVlcnlTZWxlY3RvciBpZiBzdHJpbmdcbiAgaWYgKCB0eXBlb2YgY29udGFpbm1lbnQgPT0gJ3N0cmluZycgKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGNvbnRhaW5tZW50ICk7XG4gIH1cbiAgLy8gZmFsbGJhY2sgdG8gcGFyZW50IGVsZW1lbnRcbiAgcmV0dXJuIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlO1xufTtcblxuLy8gLS0tLS0gbW92ZSBldmVudCAtLS0tLSAvL1xuXG5wcm90by5vblBvaW50ZXJNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xuICB0aGlzLmRpc3BhdGNoSlF1ZXJ5RXZlbnQoICdwb2ludGVyTW92ZScsIGV2ZW50LCBbIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuLyoqXG4gKiBkcmFnIG1vdmVcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLmRyYWdNb3ZlID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICkge1xuICBpZiAoICF0aGlzLmlzRW5hYmxlZCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGRyYWdYID0gbW92ZVZlY3Rvci54O1xuICB2YXIgZHJhZ1kgPSBtb3ZlVmVjdG9yLnk7XG5cbiAgdmFyIGdyaWQgPSB0aGlzLm9wdGlvbnMuZ3JpZDtcbiAgdmFyIGdyaWRYID0gZ3JpZCAmJiBncmlkWzBdO1xuICB2YXIgZ3JpZFkgPSBncmlkICYmIGdyaWRbMV07XG5cbiAgZHJhZ1ggPSBhcHBseUdyaWQoIGRyYWdYLCBncmlkWCApO1xuICBkcmFnWSA9IGFwcGx5R3JpZCggZHJhZ1ksIGdyaWRZICk7XG5cbiAgZHJhZ1ggPSB0aGlzLmNvbnRhaW5EcmFnKCAneCcsIGRyYWdYLCBncmlkWCApO1xuICBkcmFnWSA9IHRoaXMuY29udGFpbkRyYWcoICd5JywgZHJhZ1ksIGdyaWRZICk7XG5cbiAgLy8gY29uc3RyYWluIHRvIGF4aXNcbiAgZHJhZ1ggPSB0aGlzLm9wdGlvbnMuYXhpcyA9PSAneScgPyAwIDogZHJhZ1g7XG4gIGRyYWdZID0gdGhpcy5vcHRpb25zLmF4aXMgPT0gJ3gnID8gMCA6IGRyYWdZO1xuXG4gIHRoaXMucG9zaXRpb24ueCA9IHRoaXMuc3RhcnRQb3NpdGlvbi54ICsgZHJhZ1g7XG4gIHRoaXMucG9zaXRpb24ueSA9IHRoaXMuc3RhcnRQb3NpdGlvbi55ICsgZHJhZ1k7XG4gIC8vIHNldCBkcmFnUG9pbnQgcHJvcGVydGllc1xuICB0aGlzLmRyYWdQb2ludC54ID0gZHJhZ1g7XG4gIHRoaXMuZHJhZ1BvaW50LnkgPSBkcmFnWTtcblxuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnTW92ZScsIGV2ZW50LCBbIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuZnVuY3Rpb24gYXBwbHlHcmlkKCB2YWx1ZSwgZ3JpZCwgbWV0aG9kICkge1xuICBtZXRob2QgPSBtZXRob2QgfHwgJ3JvdW5kJztcbiAgcmV0dXJuIGdyaWQgPyBNYXRoWyBtZXRob2QgXSggdmFsdWUgLyBncmlkICkgKiBncmlkIDogdmFsdWU7XG59XG5cbnByb3RvLmNvbnRhaW5EcmFnID0gZnVuY3Rpb24oIGF4aXMsIGRyYWcsIGdyaWQgKSB7XG4gIGlmICggIXRoaXMub3B0aW9ucy5jb250YWlubWVudCApIHtcbiAgICByZXR1cm4gZHJhZztcbiAgfVxuICB2YXIgbWVhc3VyZSA9IGF4aXMgPT0gJ3gnID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIHZhciByZWwgPSB0aGlzLnJlbGF0aXZlU3RhcnRQb3NpdGlvblsgYXhpcyBdO1xuICB2YXIgbWluID0gYXBwbHlHcmlkKCAtcmVsLCBncmlkLCAnY2VpbCcgKTtcbiAgdmFyIG1heCA9IHRoaXMuY29udGFpblNpemVbIG1lYXN1cmUgXTtcbiAgbWF4ID0gYXBwbHlHcmlkKCBtYXgsIGdyaWQsICdmbG9vcicgKTtcbiAgcmV0dXJuICBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCBkcmFnICkgKTtcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgdXBcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLm9uUG9pbnRlclVwID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnaXMtcG9pbnRlci1kb3duJyk7XG4gIHRoaXMuZGlzcGF0Y2hKUXVlcnlFdmVudCggJ3BvaW50ZXJVcCcsIGV2ZW50LCBbIHBvaW50ZXIgXSApO1xufTtcblxuLyoqXG4gKiBkcmFnIGVuZFxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqL1xucHJvdG8uZHJhZ0VuZCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCAhdGhpcy5pc0VuYWJsZWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHVzZSB0b3AgbGVmdCBwb3NpdGlvbiB3aGVuIGNvbXBsZXRlXG4gIHRoaXMuZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAnJztcbiAgdGhpcy5zZXRMZWZ0VG9wKCk7XG4gIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdpcy1kcmFnZ2luZycpO1xuICB0aGlzLmRpc3BhdGNoRXZlbnQoICdkcmFnRW5kJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBhbmltYXRpb24gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxucHJvdG8uYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyBvbmx5IHJlbmRlciBhbmQgYW5pbWF0ZSBpZiBkcmFnZ2luZ1xuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5wb3NpdGlvbkRyYWcoKTtcblxuICB2YXIgX3RoaXMgPSB0aGlzO1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGZ1bmN0aW9uIGFuaW1hdGVGcmFtZSgpIHtcbiAgICBfdGhpcy5hbmltYXRlKCk7XG4gIH0pO1xuXG59O1xuXG4vLyBsZWZ0L3RvcCBwb3NpdGlvbmluZ1xucHJvdG8uc2V0TGVmdFRvcCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IHRoaXMucG9zaXRpb24ueCArICdweCc7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgID0gdGhpcy5wb3NpdGlvbi55ICsgJ3B4Jztcbn07XG5cbnByb3RvLnBvc2l0aW9uRHJhZyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCAnICsgdGhpcy5kcmFnUG9pbnQueCArXG4gICAgJ3B4LCAnICsgdGhpcy5kcmFnUG9pbnQueSArICdweCwgMCknO1xufTtcblxuLy8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cblxucHJvdG8uc3RhdGljQ2xpY2sgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZGlzcGF0Y2hFdmVudCggJ3N0YXRpY0NsaWNrJywgZXZlbnQsIFsgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLSBtZXRob2RzIC0tLS0tIC8vXG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gKi9cbnByb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24oIHgsIHkgKSB7XG4gIHRoaXMucG9zaXRpb24ueCA9IHg7XG4gIHRoaXMucG9zaXRpb24ueSA9IHk7XG4gIHRoaXMuc2V0TGVmdFRvcCgpO1xufTtcblxucHJvdG8uZW5hYmxlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuaXNFbmFibGVkID0gdHJ1ZTtcbn07XG5cbnByb3RvLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5pc0VuYWJsZWQgPSBmYWxzZTtcbiAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgdGhpcy5kcmFnRW5kKCk7XG4gIH1cbn07XG5cbnByb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5kaXNhYmxlKCk7XG4gIC8vIHJlc2V0IHN0eWxlc1xuICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJyc7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS5sZWZ0ID0gJyc7XG4gIHRoaXMuZWxlbWVudC5zdHlsZS50b3AgPSAnJztcbiAgdGhpcy5lbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gIC8vIHVuYmluZCBoYW5kbGVzXG4gIHRoaXMudW5iaW5kSGFuZGxlcygpO1xuICAvLyByZW1vdmUgalF1ZXJ5IGRhdGFcbiAgaWYgKCB0aGlzLiRlbGVtZW50ICkge1xuICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlRGF0YSgnZHJhZ2dhYmlsbHknKTtcbiAgfVxufTtcblxuLy8gLS0tLS0galF1ZXJ5IGJyaWRnZXQgLS0tLS0gLy9cblxuLy8gcmVxdWlyZWQgZm9yIGpRdWVyeSBicmlkZ2V0XG5wcm90by5faW5pdCA9IG5vb3A7XG5cbmlmICggalF1ZXJ5ICYmIGpRdWVyeS5icmlkZ2V0ICkge1xuICBqUXVlcnkuYnJpZGdldCggJ2RyYWdnYWJpbGx5JywgRHJhZ2dhYmlsbHkgKTtcbn1cblxuLy8gLS0tLS0gIC0tLS0tIC8vXG5cbnJldHVybiBEcmFnZ2FiaWxseTtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQSxXQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/draggabilly/draggabilly.js\n");

/***/ }),

/***/ "./node_modules/ev-emitter/ev-emitter.js":
/*!***********************************************!*\
  !*** ./node_modules/ev-emitter/ev-emitter.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * EvEmitter v1.1.0\n * Lil' event emitter\n * MIT License\n */\n\n/* jshint unused: true, undef: true, strict: true */\n\n( function( global, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /* globals define, module, window */\n  if ( true ) {\n    // AMD - RequireJS\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( typeof window != 'undefined' ? window : this, function() {\n\n\"use strict\";\n\nfunction EvEmitter() {}\n\nvar proto = EvEmitter.prototype;\n\nproto.on = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // set events hash\n  var events = this._events = this._events || {};\n  // set listeners array\n  var listeners = events[ eventName ] = events[ eventName ] || [];\n  // only add once\n  if ( listeners.indexOf( listener ) == -1 ) {\n    listeners.push( listener );\n  }\n\n  return this;\n};\n\nproto.once = function( eventName, listener ) {\n  if ( !eventName || !listener ) {\n    return;\n  }\n  // add event\n  this.on( eventName, listener );\n  // set once flag\n  // set onceEvents hash\n  var onceEvents = this._onceEvents = this._onceEvents || {};\n  // set onceListeners object\n  var onceListeners = onceEvents[ eventName ] = onceEvents[ eventName ] || {};\n  // set flag\n  onceListeners[ listener ] = true;\n\n  return this;\n};\n\nproto.off = function( eventName, listener ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  var index = listeners.indexOf( listener );\n  if ( index != -1 ) {\n    listeners.splice( index, 1 );\n  }\n\n  return this;\n};\n\nproto.emitEvent = function( eventName, args ) {\n  var listeners = this._events && this._events[ eventName ];\n  if ( !listeners || !listeners.length ) {\n    return;\n  }\n  // copy over to avoid interference if .off() in listener\n  listeners = listeners.slice(0);\n  args = args || [];\n  // once stuff\n  var onceListeners = this._onceEvents && this._onceEvents[ eventName ];\n\n  for ( var i=0; i < listeners.length; i++ ) {\n    var listener = listeners[i]\n    var isOnce = onceListeners && onceListeners[ listener ];\n    if ( isOnce ) {\n      // remove listener\n      // remove before trigger to prevent recursion\n      this.off( eventName, listener );\n      // unset once flag\n      delete onceListeners[ listener ];\n    }\n    // trigger listener\n    listener.apply( this, args );\n  }\n\n  return this;\n};\n\nproto.allOff = function() {\n  delete this._events;\n  delete this._onceEvents;\n};\n\nreturn EvEmitter;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXYtZW1pdHRlci9ldi1lbWl0dGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V2LWVtaXR0ZXIvZXYtZW1pdHRlci5qcz8wOTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRXZFbWl0dGVyIHYxLjEuMFxuICogTGlsJyBldmVudCBlbWl0dGVyXG4gKiBNSVQgTGljZW5zZVxuICovXG5cbi8qIGpzaGludCB1bnVzZWQ6IHRydWUsIHVuZGVmOiB0cnVlLCBzdHJpY3Q6IHRydWUgKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsLCBmYWN0b3J5ICkge1xuICAvLyB1bml2ZXJzYWwgbW9kdWxlIGRlZmluaXRpb25cbiAgLyoganNoaW50IHN0cmljdDogZmFsc2UgKi8gLyogZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgd2luZG93ICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EIC0gUmVxdWlyZUpTXG4gICAgZGVmaW5lKCBmYWN0b3J5ICk7XG4gIH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgKSB7XG4gICAgLy8gQ29tbW9uSlMgLSBCcm93c2VyaWZ5LCBXZWJwYWNrXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZ2xvYmFsLkV2RW1pdHRlciA9IGZhY3RvcnkoKTtcbiAgfVxuXG59KCB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBFdkVtaXR0ZXIoKSB7fVxuXG52YXIgcHJvdG8gPSBFdkVtaXR0ZXIucHJvdG90eXBlO1xuXG5wcm90by5vbiA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBzZXQgZXZlbnRzIGhhc2hcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IGxpc3RlbmVycyBhcnJheVxuICB2YXIgbGlzdGVuZXJzID0gZXZlbnRzWyBldmVudE5hbWUgXSA9IGV2ZW50c1sgZXZlbnROYW1lIF0gfHwgW107XG4gIC8vIG9ubHkgYWRkIG9uY2VcbiAgaWYgKCBsaXN0ZW5lcnMuaW5kZXhPZiggbGlzdGVuZXIgKSA9PSAtMSApIHtcbiAgICBsaXN0ZW5lcnMucHVzaCggbGlzdGVuZXIgKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxucHJvdG8ub25jZSA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGxpc3RlbmVyICkge1xuICBpZiAoICFldmVudE5hbWUgfHwgIWxpc3RlbmVyICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBhZGQgZXZlbnRcbiAgdGhpcy5vbiggZXZlbnROYW1lLCBsaXN0ZW5lciApO1xuICAvLyBzZXQgb25jZSBmbGFnXG4gIC8vIHNldCBvbmNlRXZlbnRzIGhhc2hcbiAgdmFyIG9uY2VFdmVudHMgPSB0aGlzLl9vbmNlRXZlbnRzID0gdGhpcy5fb25jZUV2ZW50cyB8fCB7fTtcbiAgLy8gc2V0IG9uY2VMaXN0ZW5lcnMgb2JqZWN0XG4gIHZhciBvbmNlTGlzdGVuZXJzID0gb25jZUV2ZW50c1sgZXZlbnROYW1lIF0gPSBvbmNlRXZlbnRzWyBldmVudE5hbWUgXSB8fCB7fTtcbiAgLy8gc2V0IGZsYWdcbiAgb25jZUxpc3RlbmVyc1sgbGlzdGVuZXIgXSA9IHRydWU7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5vZmYgPSBmdW5jdGlvbiggZXZlbnROYW1lLCBsaXN0ZW5lciApIHtcbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbIGV2ZW50TmFtZSBdO1xuICBpZiAoICFsaXN0ZW5lcnMgfHwgIWxpc3RlbmVycy5sZW5ndGggKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBpbmRleCA9IGxpc3RlbmVycy5pbmRleE9mKCBsaXN0ZW5lciApO1xuICBpZiAoIGluZGV4ICE9IC0xICkge1xuICAgIGxpc3RlbmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbnByb3RvLmVtaXRFdmVudCA9IGZ1bmN0aW9uKCBldmVudE5hbWUsIGFyZ3MgKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHMgJiYgdGhpcy5fZXZlbnRzWyBldmVudE5hbWUgXTtcbiAgaWYgKCAhbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoICkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBjb3B5IG92ZXIgdG8gYXZvaWQgaW50ZXJmZXJlbmNlIGlmIC5vZmYoKSBpbiBsaXN0ZW5lclxuICBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuc2xpY2UoMCk7XG4gIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAvLyBvbmNlIHN0dWZmXG4gIHZhciBvbmNlTGlzdGVuZXJzID0gdGhpcy5fb25jZUV2ZW50cyAmJiB0aGlzLl9vbmNlRXZlbnRzWyBldmVudE5hbWUgXTtcblxuICBmb3IgKCB2YXIgaT0wOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXVxuICAgIHZhciBpc09uY2UgPSBvbmNlTGlzdGVuZXJzICYmIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgaWYgKCBpc09uY2UgKSB7XG4gICAgICAvLyByZW1vdmUgbGlzdGVuZXJcbiAgICAgIC8vIHJlbW92ZSBiZWZvcmUgdHJpZ2dlciB0byBwcmV2ZW50IHJlY3Vyc2lvblxuICAgICAgdGhpcy5vZmYoIGV2ZW50TmFtZSwgbGlzdGVuZXIgKTtcbiAgICAgIC8vIHVuc2V0IG9uY2UgZmxhZ1xuICAgICAgZGVsZXRlIG9uY2VMaXN0ZW5lcnNbIGxpc3RlbmVyIF07XG4gICAgfVxuICAgIC8vIHRyaWdnZXIgbGlzdGVuZXJcbiAgICBsaXN0ZW5lci5hcHBseSggdGhpcywgYXJncyApO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5wcm90by5hbGxPZmYgPSBmdW5jdGlvbigpIHtcbiAgZGVsZXRlIHRoaXMuX2V2ZW50cztcbiAgZGVsZXRlIHRoaXMuX29uY2VFdmVudHM7XG59O1xuXG5yZXR1cm4gRXZFbWl0dGVyO1xuXG59KSk7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLFdBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ev-emitter/ev-emitter.js\n");

/***/ }),

/***/ "./node_modules/get-size/get-size.js":
/*!*******************************************!*\
  !*** ./node_modules/get-size/get-size.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * getSize v2.0.3\n * measure size of elements\n * MIT license\n */\n\n/* jshint browser: true, strict: true, undef: true, unused: true */\n/* globals console: false */\n\n( function( window, factory ) {\n  /* jshint strict: false */ /* globals define, module */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n})( window, function factory() {\n'use strict';\n\n// -------------------------- helpers -------------------------- //\n\n// get a number from a string, not a percentage\nfunction getStyleSize( value ) {\n  var num = parseFloat( value );\n  // not a percent like '100%', and a number\n  var isValid = value.indexOf('%') == -1 && !isNaN( num );\n  return isValid && num;\n}\n\nfunction noop() {}\n\nvar logError = typeof console == 'undefined' ? noop :\n  function( message ) {\n    console.error( message );\n  };\n\n// -------------------------- measurements -------------------------- //\n\nvar measurements = [\n  'paddingLeft',\n  'paddingRight',\n  'paddingTop',\n  'paddingBottom',\n  'marginLeft',\n  'marginRight',\n  'marginTop',\n  'marginBottom',\n  'borderLeftWidth',\n  'borderRightWidth',\n  'borderTopWidth',\n  'borderBottomWidth'\n];\n\nvar measurementsLength = measurements.length;\n\nfunction getZeroSize() {\n  var size = {\n    width: 0,\n    height: 0,\n    innerWidth: 0,\n    innerHeight: 0,\n    outerWidth: 0,\n    outerHeight: 0\n  };\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    size[ measurement ] = 0;\n  }\n  return size;\n}\n\n// -------------------------- getStyle -------------------------- //\n\n/**\n * getStyle, get style of element, check for Firefox bug\n * https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n */\nfunction getStyle( elem ) {\n  var style = getComputedStyle( elem );\n  if ( !style ) {\n    logError( 'Style returned ' + style +\n      '. Are you running this code in a hidden iframe on Firefox? ' +\n      'See https://bit.ly/getsizebug1' );\n  }\n  return style;\n}\n\n// -------------------------- setup -------------------------- //\n\nvar isSetup = false;\n\nvar isBoxSizeOuter;\n\n/**\n * setup\n * check isBoxSizerOuter\n * do on first getSize() rather than on page load for Firefox bug\n */\nfunction setup() {\n  // setup once\n  if ( isSetup ) {\n    return;\n  }\n  isSetup = true;\n\n  // -------------------------- box sizing -------------------------- //\n\n  /**\n   * Chrome & Safari measure the outer-width on style.width on border-box elems\n   * IE11 & Firefox<29 measures the inner-width\n   */\n  var div = document.createElement('div');\n  div.style.width = '200px';\n  div.style.padding = '1px 2px 3px 4px';\n  div.style.borderStyle = 'solid';\n  div.style.borderWidth = '1px 2px 3px 4px';\n  div.style.boxSizing = 'border-box';\n\n  var body = document.body || document.documentElement;\n  body.appendChild( div );\n  var style = getStyle( div );\n  // round value for browser zoom. desandro/masonry#928\n  isBoxSizeOuter = Math.round( getStyleSize( style.width ) ) == 200;\n  getSize.isBoxSizeOuter = isBoxSizeOuter;\n\n  body.removeChild( div );\n}\n\n// -------------------------- getSize -------------------------- //\n\nfunction getSize( elem ) {\n  setup();\n\n  // use querySeletor if elem is string\n  if ( typeof elem == 'string' ) {\n    elem = document.querySelector( elem );\n  }\n\n  // do not proceed on non-objects\n  if ( !elem || typeof elem != 'object' || !elem.nodeType ) {\n    return;\n  }\n\n  var style = getStyle( elem );\n\n  // if hidden, everything is 0\n  if ( style.display == 'none' ) {\n    return getZeroSize();\n  }\n\n  var size = {};\n  size.width = elem.offsetWidth;\n  size.height = elem.offsetHeight;\n\n  var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';\n\n  // get all measurements\n  for ( var i=0; i < measurementsLength; i++ ) {\n    var measurement = measurements[i];\n    var value = style[ measurement ];\n    var num = parseFloat( value );\n    // any 'auto', 'medium' value will be 0\n    size[ measurement ] = !isNaN( num ) ? num : 0;\n  }\n\n  var paddingWidth = size.paddingLeft + size.paddingRight;\n  var paddingHeight = size.paddingTop + size.paddingBottom;\n  var marginWidth = size.marginLeft + size.marginRight;\n  var marginHeight = size.marginTop + size.marginBottom;\n  var borderWidth = size.borderLeftWidth + size.borderRightWidth;\n  var borderHeight = size.borderTopWidth + size.borderBottomWidth;\n\n  var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;\n\n  // overwrite width and height if we can get it from style\n  var styleWidth = getStyleSize( style.width );\n  if ( styleWidth !== false ) {\n    size.width = styleWidth +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth );\n  }\n\n  var styleHeight = getStyleSize( style.height );\n  if ( styleHeight !== false ) {\n    size.height = styleHeight +\n      // add padding and border unless it's already including it\n      ( isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight );\n  }\n\n  size.innerWidth = size.width - ( paddingWidth + borderWidth );\n  size.innerHeight = size.height - ( paddingHeight + borderHeight );\n\n  size.outerWidth = size.width + marginWidth;\n  size.outerHeight = size.height + marginHeight;\n\n  return size;\n}\n\nreturn getSize;\n\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2V0LXNpemUvZ2V0LXNpemUuanM/NDBhZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGdldFNpemUgdjIuMC4zXG4gKiBtZWFzdXJlIHNpemUgb2YgZWxlbWVudHNcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLyoganNoaW50IGJyb3dzZXI6IHRydWUsIHN0cmljdDogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSAqL1xuLyogZ2xvYmFscyBjb25zb2xlOiBmYWxzZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qIGdsb2JhbHMgZGVmaW5lLCBtb2R1bGUgKi9cbiAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcbiAgICAvLyBBTURcbiAgICBkZWZpbmUoIGZhY3RvcnkgKTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGJyb3dzZXIgZ2xvYmFsXG4gICAgd2luZG93LmdldFNpemUgPSBmYWN0b3J5KCk7XG4gIH1cblxufSkoIHdpbmRvdywgZnVuY3Rpb24gZmFjdG9yeSgpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gaGVscGVycyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG4vLyBnZXQgYSBudW1iZXIgZnJvbSBhIHN0cmluZywgbm90IGEgcGVyY2VudGFnZVxuZnVuY3Rpb24gZ2V0U3R5bGVTaXplKCB2YWx1ZSApIHtcbiAgdmFyIG51bSA9IHBhcnNlRmxvYXQoIHZhbHVlICk7XG4gIC8vIG5vdCBhIHBlcmNlbnQgbGlrZSAnMTAwJScsIGFuZCBhIG51bWJlclxuICB2YXIgaXNWYWxpZCA9IHZhbHVlLmluZGV4T2YoJyUnKSA9PSAtMSAmJiAhaXNOYU4oIG51bSApO1xuICByZXR1cm4gaXNWYWxpZCAmJiBudW07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG52YXIgbG9nRXJyb3IgPSB0eXBlb2YgY29uc29sZSA9PSAndW5kZWZpbmVkJyA/IG5vb3AgOlxuICBmdW5jdGlvbiggbWVzc2FnZSApIHtcbiAgICBjb25zb2xlLmVycm9yKCBtZXNzYWdlICk7XG4gIH07XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIG1lYXN1cmVtZW50cyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAvL1xuXG52YXIgbWVhc3VyZW1lbnRzID0gW1xuICAncGFkZGluZ0xlZnQnLFxuICAncGFkZGluZ1JpZ2h0JyxcbiAgJ3BhZGRpbmdUb3AnLFxuICAncGFkZGluZ0JvdHRvbScsXG4gICdtYXJnaW5MZWZ0JyxcbiAgJ21hcmdpblJpZ2h0JyxcbiAgJ21hcmdpblRvcCcsXG4gICdtYXJnaW5Cb3R0b20nLFxuICAnYm9yZGVyTGVmdFdpZHRoJyxcbiAgJ2JvcmRlclJpZ2h0V2lkdGgnLFxuICAnYm9yZGVyVG9wV2lkdGgnLFxuICAnYm9yZGVyQm90dG9tV2lkdGgnXG5dO1xuXG52YXIgbWVhc3VyZW1lbnRzTGVuZ3RoID0gbWVhc3VyZW1lbnRzLmxlbmd0aDtcblxuZnVuY3Rpb24gZ2V0WmVyb1NpemUoKSB7XG4gIHZhciBzaXplID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBpbm5lcldpZHRoOiAwLFxuICAgIGlubmVySGVpZ2h0OiAwLFxuICAgIG91dGVyV2lkdGg6IDAsXG4gICAgb3V0ZXJIZWlnaHQ6IDBcbiAgfTtcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gMDtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gZ2V0U3R5bGUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuLyoqXG4gKiBnZXRTdHlsZSwgZ2V0IHN0eWxlIG9mIGVsZW1lbnQsIGNoZWNrIGZvciBGaXJlZm94IGJ1Z1xuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlKCBlbGVtICkge1xuICB2YXIgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG4gIGlmICggIXN0eWxlICkge1xuICAgIGxvZ0Vycm9yKCAnU3R5bGUgcmV0dXJuZWQgJyArIHN0eWxlICtcbiAgICAgICcuIEFyZSB5b3UgcnVubmluZyB0aGlzIGNvZGUgaW4gYSBoaWRkZW4gaWZyYW1lIG9uIEZpcmVmb3g/ICcgK1xuICAgICAgJ1NlZSBodHRwczovL2JpdC5seS9nZXRzaXplYnVnMScgKTtcbiAgfVxuICByZXR1cm4gc3R5bGU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIHNldHVwIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbnZhciBpc1NldHVwID0gZmFsc2U7XG5cbnZhciBpc0JveFNpemVPdXRlcjtcblxuLyoqXG4gKiBzZXR1cFxuICogY2hlY2sgaXNCb3hTaXplck91dGVyXG4gKiBkbyBvbiBmaXJzdCBnZXRTaXplKCkgcmF0aGVyIHRoYW4gb24gcGFnZSBsb2FkIGZvciBGaXJlZm94IGJ1Z1xuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgLy8gc2V0dXAgb25jZVxuICBpZiAoIGlzU2V0dXAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlzU2V0dXAgPSB0cnVlO1xuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGJveCBzaXppbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuICAvKipcbiAgICogQ2hyb21lICYgU2FmYXJpIG1lYXN1cmUgdGhlIG91dGVyLXdpZHRoIG9uIHN0eWxlLndpZHRoIG9uIGJvcmRlci1ib3ggZWxlbXNcbiAgICogSUUxMSAmIEZpcmVmb3g8MjkgbWVhc3VyZXMgdGhlIGlubmVyLXdpZHRoXG4gICAqL1xuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5zdHlsZS53aWR0aCA9ICcyMDBweCc7XG4gIGRpdi5zdHlsZS5wYWRkaW5nID0gJzFweCAycHggM3B4IDRweCc7XG4gIGRpdi5zdHlsZS5ib3JkZXJTdHlsZSA9ICdzb2xpZCc7XG4gIGRpdi5zdHlsZS5ib3JkZXJXaWR0aCA9ICcxcHggMnB4IDNweCA0cHgnO1xuICBkaXYuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuXG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIGJvZHkuYXBwZW5kQ2hpbGQoIGRpdiApO1xuICB2YXIgc3R5bGUgPSBnZXRTdHlsZSggZGl2ICk7XG4gIC8vIHJvdW5kIHZhbHVlIGZvciBicm93c2VyIHpvb20uIGRlc2FuZHJvL21hc29ucnkjOTI4XG4gIGlzQm94U2l6ZU91dGVyID0gTWF0aC5yb3VuZCggZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApICkgPT0gMjAwO1xuICBnZXRTaXplLmlzQm94U2l6ZU91dGVyID0gaXNCb3hTaXplT3V0ZXI7XG5cbiAgYm9keS5yZW1vdmVDaGlsZCggZGl2ICk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGdldFNpemUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cblxuZnVuY3Rpb24gZ2V0U2l6ZSggZWxlbSApIHtcbiAgc2V0dXAoKTtcblxuICAvLyB1c2UgcXVlcnlTZWxldG9yIGlmIGVsZW0gaXMgc3RyaW5nXG4gIGlmICggdHlwZW9mIGVsZW0gPT0gJ3N0cmluZycgKSB7XG4gICAgZWxlbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGVsZW0gKTtcbiAgfVxuXG4gIC8vIGRvIG5vdCBwcm9jZWVkIG9uIG5vbi1vYmplY3RzXG4gIGlmICggIWVsZW0gfHwgdHlwZW9mIGVsZW0gIT0gJ29iamVjdCcgfHwgIWVsZW0ubm9kZVR5cGUgKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHN0eWxlID0gZ2V0U3R5bGUoIGVsZW0gKTtcblxuICAvLyBpZiBoaWRkZW4sIGV2ZXJ5dGhpbmcgaXMgMFxuICBpZiAoIHN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnICkge1xuICAgIHJldHVybiBnZXRaZXJvU2l6ZSgpO1xuICB9XG5cbiAgdmFyIHNpemUgPSB7fTtcbiAgc2l6ZS53aWR0aCA9IGVsZW0ub2Zmc2V0V2lkdGg7XG4gIHNpemUuaGVpZ2h0ID0gZWxlbS5vZmZzZXRIZWlnaHQ7XG5cbiAgdmFyIGlzQm9yZGVyQm94ID0gc2l6ZS5pc0JvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PSAnYm9yZGVyLWJveCc7XG5cbiAgLy8gZ2V0IGFsbCBtZWFzdXJlbWVudHNcbiAgZm9yICggdmFyIGk9MDsgaSA8IG1lYXN1cmVtZW50c0xlbmd0aDsgaSsrICkge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgdmFsdWUgPSBzdHlsZVsgbWVhc3VyZW1lbnQgXTtcbiAgICB2YXIgbnVtID0gcGFyc2VGbG9hdCggdmFsdWUgKTtcbiAgICAvLyBhbnkgJ2F1dG8nLCAnbWVkaXVtJyB2YWx1ZSB3aWxsIGJlIDBcbiAgICBzaXplWyBtZWFzdXJlbWVudCBdID0gIWlzTmFOKCBudW0gKSA/IG51bSA6IDA7XG4gIH1cblxuICB2YXIgcGFkZGluZ1dpZHRoID0gc2l6ZS5wYWRkaW5nTGVmdCArIHNpemUucGFkZGluZ1JpZ2h0O1xuICB2YXIgcGFkZGluZ0hlaWdodCA9IHNpemUucGFkZGluZ1RvcCArIHNpemUucGFkZGluZ0JvdHRvbTtcbiAgdmFyIG1hcmdpbldpZHRoID0gc2l6ZS5tYXJnaW5MZWZ0ICsgc2l6ZS5tYXJnaW5SaWdodDtcbiAgdmFyIG1hcmdpbkhlaWdodCA9IHNpemUubWFyZ2luVG9wICsgc2l6ZS5tYXJnaW5Cb3R0b207XG4gIHZhciBib3JkZXJXaWR0aCA9IHNpemUuYm9yZGVyTGVmdFdpZHRoICsgc2l6ZS5ib3JkZXJSaWdodFdpZHRoO1xuICB2YXIgYm9yZGVySGVpZ2h0ID0gc2l6ZS5ib3JkZXJUb3BXaWR0aCArIHNpemUuYm9yZGVyQm90dG9tV2lkdGg7XG5cbiAgdmFyIGlzQm9yZGVyQm94U2l6ZU91dGVyID0gaXNCb3JkZXJCb3ggJiYgaXNCb3hTaXplT3V0ZXI7XG5cbiAgLy8gb3ZlcndyaXRlIHdpZHRoIGFuZCBoZWlnaHQgaWYgd2UgY2FuIGdldCBpdCBmcm9tIHN0eWxlXG4gIHZhciBzdHlsZVdpZHRoID0gZ2V0U3R5bGVTaXplKCBzdHlsZS53aWR0aCApO1xuICBpZiAoIHN0eWxlV2lkdGggIT09IGZhbHNlICkge1xuICAgIHNpemUud2lkdGggPSBzdHlsZVdpZHRoICtcbiAgICAgIC8vIGFkZCBwYWRkaW5nIGFuZCBib3JkZXIgdW5sZXNzIGl0J3MgYWxyZWFkeSBpbmNsdWRpbmcgaXRcbiAgICAgICggaXNCb3JkZXJCb3hTaXplT3V0ZXIgPyAwIDogcGFkZGluZ1dpZHRoICsgYm9yZGVyV2lkdGggKTtcbiAgfVxuXG4gIHZhciBzdHlsZUhlaWdodCA9IGdldFN0eWxlU2l6ZSggc3R5bGUuaGVpZ2h0ICk7XG4gIGlmICggc3R5bGVIZWlnaHQgIT09IGZhbHNlICkge1xuICAgIHNpemUuaGVpZ2h0ID0gc3R5bGVIZWlnaHQgK1xuICAgICAgLy8gYWRkIHBhZGRpbmcgYW5kIGJvcmRlciB1bmxlc3MgaXQncyBhbHJlYWR5IGluY2x1ZGluZyBpdFxuICAgICAgKCBpc0JvcmRlckJveFNpemVPdXRlciA/IDAgOiBwYWRkaW5nSGVpZ2h0ICsgYm9yZGVySGVpZ2h0ICk7XG4gIH1cblxuICBzaXplLmlubmVyV2lkdGggPSBzaXplLndpZHRoIC0gKCBwYWRkaW5nV2lkdGggKyBib3JkZXJXaWR0aCApO1xuICBzaXplLmlubmVySGVpZ2h0ID0gc2l6ZS5oZWlnaHQgLSAoIHBhZGRpbmdIZWlnaHQgKyBib3JkZXJIZWlnaHQgKTtcblxuICBzaXplLm91dGVyV2lkdGggPSBzaXplLndpZHRoICsgbWFyZ2luV2lkdGg7XG4gIHNpemUub3V0ZXJIZWlnaHQgPSBzaXplLmhlaWdodCArIG1hcmdpbkhlaWdodDtcblxuICByZXR1cm4gc2l6ZTtcbn1cblxucmV0dXJuIGdldFNpemU7XG5cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQSxXQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/get-size/get-size.js\n");

/***/ }),

/***/ "./node_modules/unidragger/unidragger.js":
/*!***********************************************!*\
  !*** ./node_modules/unidragger/unidragger.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unidragger v2.3.0\n * Draggable base class\n * MIT license\n */\n\n/*jshint browser: true, unused: true, undef: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /*jshint strict: false */ /*globals define, module, require */\n\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! unipointer/unipointer */ \"./node_modules/unipointer/unipointer.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( Unipointer ) {\n      return factory( window, Unipointer );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, Unipointer ) {\n\n'use strict';\n\n// -------------------------- Unidragger -------------------------- //\n\nfunction Unidragger() {}\n\n// inherit Unipointer & EvEmitter\nvar proto = Unidragger.prototype = Object.create( Unipointer.prototype );\n\n// ----- bind start ----- //\n\nproto.bindHandles = function() {\n  this._bindHandles( true );\n};\n\nproto.unbindHandles = function() {\n  this._bindHandles( false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd\n */\nproto._bindHandles = function( isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  // bind each handle\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n  var touchAction = isAdd ? this._touchActionValue : '';\n  for ( var i=0; i < this.handles.length; i++ ) {\n    var handle = this.handles[i];\n    this._bindStartEvent( handle, isAdd );\n    handle[ bindMethod ]( 'click', this );\n    // touch-action: none to override browser touch gestures. metafizzy/flickity#540\n    if ( window.PointerEvent ) {\n      handle.style.touchAction = touchAction;\n    }\n  }\n};\n\n// prototype so it can be overwriteable by Flickity\nproto._touchActionValue = 'none';\n\n// ----- start event ----- //\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerDown = function( event, pointer ) {\n  var isOkay = this.okayPointerDown( event );\n  if ( !isOkay ) {\n    return;\n  }\n  // track start event position\n  this.pointerDownPointer = pointer;\n\n  event.preventDefault();\n  this.pointerDownBlur();\n  // bind move and end events\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// nodes that have text fields\nvar cursorNodes = {\n  TEXTAREA: true,\n  INPUT: true,\n  SELECT: true,\n  OPTION: true,\n};\n\n// input types that do not have text fields\nvar clickTypes = {\n  radio: true,\n  checkbox: true,\n  button: true,\n  submit: true,\n  image: true,\n  file: true,\n};\n\n// dismiss inputs with text fields. flickity#403, flickity#404\nproto.okayPointerDown = function( event ) {\n  var isCursorNode = cursorNodes[ event.target.nodeName ];\n  var isClickType = clickTypes[ event.target.type ];\n  var isOkay = !isCursorNode || isClickType;\n  if ( !isOkay ) {\n    this._pointerReset();\n  }\n  return isOkay;\n};\n\n// kludge to blur previously focused input\nproto.pointerDownBlur = function() {\n  var focused = document.activeElement;\n  // do not blur body for IE10, metafizzy/flickity#117\n  var canBlur = focused && focused.blur && focused != document.body;\n  if ( canBlur ) {\n    focused.blur();\n  }\n};\n\n// ----- move event ----- //\n\n/**\n * drag move\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerMove = function( event, pointer ) {\n  var moveVector = this._dragPointerMove( event, pointer );\n  this.emitEvent( 'pointerMove', [ event, pointer, moveVector ] );\n  this._dragMove( event, pointer, moveVector );\n};\n\n// base pointer move logic\nproto._dragPointerMove = function( event, pointer ) {\n  var moveVector = {\n    x: pointer.pageX - this.pointerDownPointer.pageX,\n    y: pointer.pageY - this.pointerDownPointer.pageY\n  };\n  // start drag if pointer has moved far enough to start drag\n  if ( !this.isDragging && this.hasDragStarted( moveVector ) ) {\n    this._dragStart( event, pointer );\n  }\n  return moveVector;\n};\n\n// condition if pointer has moved far enough to start drag\nproto.hasDragStarted = function( moveVector ) {\n  return Math.abs( moveVector.x ) > 3 || Math.abs( moveVector.y ) > 3;\n};\n\n// ----- end event ----- //\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n  this._dragPointerUp( event, pointer );\n};\n\nproto._dragPointerUp = function( event, pointer ) {\n  if ( this.isDragging ) {\n    this._dragEnd( event, pointer );\n  } else {\n    // pointer didn't move enough for drag to start\n    this._staticClick( event, pointer );\n  }\n};\n\n// -------------------------- drag -------------------------- //\n\n// dragStart\nproto._dragStart = function( event, pointer ) {\n  this.isDragging = true;\n  // prevent clicks\n  this.isPreventingClicks = true;\n  this.dragStart( event, pointer );\n};\n\nproto.dragStart = function( event, pointer ) {\n  this.emitEvent( 'dragStart', [ event, pointer ] );\n};\n\n// dragMove\nproto._dragMove = function( event, pointer, moveVector ) {\n  // do not drag if not dragging yet\n  if ( !this.isDragging ) {\n    return;\n  }\n\n  this.dragMove( event, pointer, moveVector );\n};\n\nproto.dragMove = function( event, pointer, moveVector ) {\n  event.preventDefault();\n  this.emitEvent( 'dragMove', [ event, pointer, moveVector ] );\n};\n\n// dragEnd\nproto._dragEnd = function( event, pointer ) {\n  // set flags\n  this.isDragging = false;\n  // re-enable clicking async\n  setTimeout( function() {\n    delete this.isPreventingClicks;\n  }.bind( this ) );\n\n  this.dragEnd( event, pointer );\n};\n\nproto.dragEnd = function( event, pointer ) {\n  this.emitEvent( 'dragEnd', [ event, pointer ] );\n};\n\n// ----- onclick ----- //\n\n// handle all clicks and prevent clicks when dragging\nproto.onclick = function( event ) {\n  if ( this.isPreventingClicks ) {\n    event.preventDefault();\n  }\n};\n\n// ----- staticClick ----- //\n\n// triggered after pointer down & up with no/tiny movement\nproto._staticClick = function( event, pointer ) {\n  // ignore emulated mouse up clicks\n  if ( this.isIgnoringMouseUp && event.type == 'mouseup' ) {\n    return;\n  }\n\n  this.staticClick( event, pointer );\n\n  // set flag for emulated clicks 300ms after touchend\n  if ( event.type != 'mouseup' ) {\n    this.isIgnoringMouseUp = true;\n    // reset flag after 300ms\n    setTimeout( function() {\n      delete this.isIgnoringMouseUp;\n    }.bind( this ), 400 );\n  }\n};\n\nproto.staticClick = function( event, pointer ) {\n  this.emitEvent( 'staticClick', [ event, pointer ] );\n};\n\n// ----- utils ----- //\n\nUnidragger.getPointerPoint = Unipointer.getPointerPoint;\n\n// -----  ----- //\n\nreturn Unidragger;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pZHJhZ2dlci91bmlkcmFnZ2VyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaWRyYWdnZXIvdW5pZHJhZ2dlci5qcz9lZjYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVW5pZHJhZ2dlciB2Mi4zLjBcbiAqIERyYWdnYWJsZSBiYXNlIGNsYXNzXG4gKiBNSVQgbGljZW5zZVxuICovXG5cbi8qanNoaW50IGJyb3dzZXI6IHRydWUsIHVudXNlZDogdHJ1ZSwgdW5kZWY6IHRydWUsIHN0cmljdDogdHJ1ZSAqL1xuXG4oIGZ1bmN0aW9uKCB3aW5kb3csIGZhY3RvcnkgKSB7XG4gIC8vIHVuaXZlcnNhbCBtb2R1bGUgZGVmaW5pdGlvblxuICAvKmpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFscyBkZWZpbmUsIG1vZHVsZSwgcmVxdWlyZSAqL1xuXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAndW5pcG9pbnRlci91bmlwb2ludGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBVbmlwb2ludGVyICkge1xuICAgICAgcmV0dXJuIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzICkge1xuICAgIC8vIENvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KFxuICAgICAgd2luZG93LFxuICAgICAgcmVxdWlyZSgndW5pcG9pbnRlcicpXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBicm93c2VyIGdsb2JhbFxuICAgIHdpbmRvdy5VbmlkcmFnZ2VyID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHdpbmRvdy5Vbmlwb2ludGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgVW5pcG9pbnRlciApIHtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBVbmlkcmFnZ2VyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbmZ1bmN0aW9uIFVuaWRyYWdnZXIoKSB7fVxuXG4vLyBpbmhlcml0IFVuaXBvaW50ZXIgJiBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaWRyYWdnZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggVW5pcG9pbnRlci5wcm90b3R5cGUgKTtcblxuLy8gLS0tLS0gYmluZCBzdGFydCAtLS0tLSAvL1xuXG5wcm90by5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kSGFuZGxlcyA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9iaW5kSGFuZGxlcyggZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZFxuICovXG5wcm90by5fYmluZEhhbmRsZXMgPSBmdW5jdGlvbiggaXNBZGQgKSB7XG4gIC8vIG11bmdlIGlzQWRkLCBkZWZhdWx0IHRvIHRydWVcbiAgaXNBZGQgPSBpc0FkZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzQWRkO1xuICAvLyBiaW5kIGVhY2ggaGFuZGxlXG4gIHZhciBiaW5kTWV0aG9kID0gaXNBZGQgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAncmVtb3ZlRXZlbnRMaXN0ZW5lcic7XG4gIHZhciB0b3VjaEFjdGlvbiA9IGlzQWRkID8gdGhpcy5fdG91Y2hBY3Rpb25WYWx1ZSA6ICcnO1xuICBmb3IgKCB2YXIgaT0wOyBpIDwgdGhpcy5oYW5kbGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciBoYW5kbGUgPSB0aGlzLmhhbmRsZXNbaV07XG4gICAgdGhpcy5fYmluZFN0YXJ0RXZlbnQoIGhhbmRsZSwgaXNBZGQgKTtcbiAgICBoYW5kbGVbIGJpbmRNZXRob2QgXSggJ2NsaWNrJywgdGhpcyApO1xuICAgIC8vIHRvdWNoLWFjdGlvbjogbm9uZSB0byBvdmVycmlkZSBicm93c2VyIHRvdWNoIGdlc3R1cmVzLiBtZXRhZml6enkvZmxpY2tpdHkjNTQwXG4gICAgaWYgKCB3aW5kb3cuUG9pbnRlckV2ZW50ICkge1xuICAgICAgaGFuZGxlLnN0eWxlLnRvdWNoQWN0aW9uID0gdG91Y2hBY3Rpb247XG4gICAgfVxuICB9XG59O1xuXG4vLyBwcm90b3R5cGUgc28gaXQgY2FuIGJlIG92ZXJ3cml0ZWFibGUgYnkgRmxpY2tpdHlcbnByb3RvLl90b3VjaEFjdGlvblZhbHVlID0gJ25vbmUnO1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLnBvaW50ZXJEb3duID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB2YXIgaXNPa2F5ID0gdGhpcy5va2F5UG9pbnRlckRvd24oIGV2ZW50ICk7XG4gIGlmICggIWlzT2theSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdHJhY2sgc3RhcnQgZXZlbnQgcG9zaXRpb25cbiAgdGhpcy5wb2ludGVyRG93blBvaW50ZXIgPSBwb2ludGVyO1xuXG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIHRoaXMucG9pbnRlckRvd25CbHVyKCk7XG4gIC8vIGJpbmQgbW92ZSBhbmQgZW5kIGV2ZW50c1xuICB0aGlzLl9iaW5kUG9zdFN0YXJ0RXZlbnRzKCBldmVudCApO1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJEb3duJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyBub2RlcyB0aGF0IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjdXJzb3JOb2RlcyA9IHtcbiAgVEVYVEFSRUE6IHRydWUsXG4gIElOUFVUOiB0cnVlLFxuICBTRUxFQ1Q6IHRydWUsXG4gIE9QVElPTjogdHJ1ZSxcbn07XG5cbi8vIGlucHV0IHR5cGVzIHRoYXQgZG8gbm90IGhhdmUgdGV4dCBmaWVsZHNcbnZhciBjbGlja1R5cGVzID0ge1xuICByYWRpbzogdHJ1ZSxcbiAgY2hlY2tib3g6IHRydWUsXG4gIGJ1dHRvbjogdHJ1ZSxcbiAgc3VibWl0OiB0cnVlLFxuICBpbWFnZTogdHJ1ZSxcbiAgZmlsZTogdHJ1ZSxcbn07XG5cbi8vIGRpc21pc3MgaW5wdXRzIHdpdGggdGV4dCBmaWVsZHMuIGZsaWNraXR5IzQwMywgZmxpY2tpdHkjNDA0XG5wcm90by5va2F5UG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciBpc0N1cnNvck5vZGUgPSBjdXJzb3JOb2Rlc1sgZXZlbnQudGFyZ2V0Lm5vZGVOYW1lIF07XG4gIHZhciBpc0NsaWNrVHlwZSA9IGNsaWNrVHlwZXNbIGV2ZW50LnRhcmdldC50eXBlIF07XG4gIHZhciBpc09rYXkgPSAhaXNDdXJzb3JOb2RlIHx8IGlzQ2xpY2tUeXBlO1xuICBpZiAoICFpc09rYXkgKSB7XG4gICAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIH1cbiAgcmV0dXJuIGlzT2theTtcbn07XG5cbi8vIGtsdWRnZSB0byBibHVyIHByZXZpb3VzbHkgZm9jdXNlZCBpbnB1dFxucHJvdG8ucG9pbnRlckRvd25CbHVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBmb2N1c2VkID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgLy8gZG8gbm90IGJsdXIgYm9keSBmb3IgSUUxMCwgbWV0YWZpenp5L2ZsaWNraXR5IzExN1xuICB2YXIgY2FuQmx1ciA9IGZvY3VzZWQgJiYgZm9jdXNlZC5ibHVyICYmIGZvY3VzZWQgIT0gZG9jdW1lbnQuYm9keTtcbiAgaWYgKCBjYW5CbHVyICkge1xuICAgIGZvY3VzZWQuYmx1cigpO1xuICB9XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbi8qKlxuICogZHJhZyBtb3ZlXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB0aGlzLl9kcmFnUG9pbnRlck1vdmUoIGV2ZW50LCBwb2ludGVyICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yIF0gKTtcbiAgdGhpcy5fZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG4vLyBiYXNlIHBvaW50ZXIgbW92ZSBsb2dpY1xucHJvdG8uX2RyYWdQb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdmFyIG1vdmVWZWN0b3IgPSB7XG4gICAgeDogcG9pbnRlci5wYWdlWCAtIHRoaXMucG9pbnRlckRvd25Qb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVkgLSB0aGlzLnBvaW50ZXJEb3duUG9pbnRlci5wYWdlWVxuICB9O1xuICAvLyBzdGFydCBkcmFnIGlmIHBvaW50ZXIgaGFzIG1vdmVkIGZhciBlbm91Z2ggdG8gc3RhcnQgZHJhZ1xuICBpZiAoICF0aGlzLmlzRHJhZ2dpbmcgJiYgdGhpcy5oYXNEcmFnU3RhcnRlZCggbW92ZVZlY3RvciApICkge1xuICAgIHRoaXMuX2RyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfVxuICByZXR1cm4gbW92ZVZlY3Rvcjtcbn07XG5cbi8vIGNvbmRpdGlvbiBpZiBwb2ludGVyIGhhcyBtb3ZlZCBmYXIgZW5vdWdoIHRvIHN0YXJ0IGRyYWdcbnByb3RvLmhhc0RyYWdTdGFydGVkID0gZnVuY3Rpb24oIG1vdmVWZWN0b3IgKSB7XG4gIHJldHVybiBNYXRoLmFicyggbW92ZVZlY3Rvci54ICkgPiAzIHx8IE1hdGguYWJzKCBtb3ZlVmVjdG9yLnkgKSA+IDM7XG59O1xuXG4vLyAtLS0tLSBlbmQgZXZlbnQgLS0tLS0gLy9cblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICovXG5wcm90by5wb2ludGVyVXAgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlclVwJywgWyBldmVudCwgcG9pbnRlciBdICk7XG4gIHRoaXMuX2RyYWdQb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5fZHJhZ1BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgaWYgKCB0aGlzLmlzRHJhZ2dpbmcgKSB7XG4gICAgdGhpcy5fZHJhZ0VuZCggZXZlbnQsIHBvaW50ZXIgKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwb2ludGVyIGRpZG4ndCBtb3ZlIGVub3VnaCBmb3IgZHJhZyB0byBzdGFydFxuICAgIHRoaXMuX3N0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuICB9XG59O1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBkcmFnIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXG5cbi8vIGRyYWdTdGFydFxucHJvdG8uX2RyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgLy8gcHJldmVudCBjbGlja3NcbiAgdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgPSB0cnVlO1xuICB0aGlzLmRyYWdTdGFydCggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbnByb3RvLmRyYWdTdGFydCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnU3RhcnQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGRyYWdNb3ZlXG5wcm90by5fZHJhZ01vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgKSB7XG4gIC8vIGRvIG5vdCBkcmFnIGlmIG5vdCBkcmFnZ2luZyB5ZXRcbiAgaWYgKCAhdGhpcy5pc0RyYWdnaW5nICkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZHJhZ01vdmUoIGV2ZW50LCBwb2ludGVyLCBtb3ZlVmVjdG9yICk7XG59O1xuXG5wcm90by5kcmFnTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciwgbW92ZVZlY3RvciApIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgdGhpcy5lbWl0RXZlbnQoICdkcmFnTW92ZScsIFsgZXZlbnQsIHBvaW50ZXIsIG1vdmVWZWN0b3IgXSApO1xufTtcblxuLy8gZHJhZ0VuZFxucHJvdG8uX2RyYWdFbmQgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIC8vIHNldCBmbGFnc1xuICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgLy8gcmUtZW5hYmxlIGNsaWNraW5nIGFzeW5jXG4gIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLmlzUHJldmVudGluZ0NsaWNrcztcbiAgfS5iaW5kKCB0aGlzICkgKTtcblxuICB0aGlzLmRyYWdFbmQoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG5wcm90by5kcmFnRW5kID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ2RyYWdFbmQnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIG9uY2xpY2sgLS0tLS0gLy9cblxuLy8gaGFuZGxlIGFsbCBjbGlja3MgYW5kIHByZXZlbnQgY2xpY2tzIHdoZW4gZHJhZ2dpbmdcbnByb3RvLm9uY2xpY2sgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggdGhpcy5pc1ByZXZlbnRpbmdDbGlja3MgKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgfVxufTtcblxuLy8gLS0tLS0gc3RhdGljQ2xpY2sgLS0tLS0gLy9cblxuLy8gdHJpZ2dlcmVkIGFmdGVyIHBvaW50ZXIgZG93biAmIHVwIHdpdGggbm8vdGlueSBtb3ZlbWVudFxucHJvdG8uX3N0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICAvLyBpZ25vcmUgZW11bGF0ZWQgbW91c2UgdXAgY2xpY2tzXG4gIGlmICggdGhpcy5pc0lnbm9yaW5nTW91c2VVcCAmJiBldmVudC50eXBlID09ICdtb3VzZXVwJyApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLnN0YXRpY0NsaWNrKCBldmVudCwgcG9pbnRlciApO1xuXG4gIC8vIHNldCBmbGFnIGZvciBlbXVsYXRlZCBjbGlja3MgMzAwbXMgYWZ0ZXIgdG91Y2hlbmRcbiAgaWYgKCBldmVudC50eXBlICE9ICdtb3VzZXVwJyApIHtcbiAgICB0aGlzLmlzSWdub3JpbmdNb3VzZVVwID0gdHJ1ZTtcbiAgICAvLyByZXNldCBmbGFnIGFmdGVyIDMwMG1zXG4gICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICBkZWxldGUgdGhpcy5pc0lnbm9yaW5nTW91c2VVcDtcbiAgICB9LmJpbmQoIHRoaXMgKSwgNDAwICk7XG4gIH1cbn07XG5cbnByb3RvLnN0YXRpY0NsaWNrID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3N0YXRpY0NsaWNrJywgWyBldmVudCwgcG9pbnRlciBdICk7XG59O1xuXG4vLyAtLS0tLSB1dGlscyAtLS0tLSAvL1xuXG5VbmlkcmFnZ2VyLmdldFBvaW50ZXJQb2ludCA9IFVuaXBvaW50ZXIuZ2V0UG9pbnRlclBvaW50O1xuXG4vLyAtLS0tLSAgLS0tLS0gLy9cblxucmV0dXJuIFVuaWRyYWdnZXI7XG5cbn0pKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/unidragger/unidragger.js\n");

/***/ }),

/***/ "./node_modules/unipointer/unipointer.js":
/*!***********************************************!*\
  !*** ./node_modules/unipointer/unipointer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!\n * Unipointer v2.3.0\n * base class for doing one thing with pointer event\n * MIT license\n */\n\n/*jshint browser: true, undef: true, unused: true, strict: true */\n\n( function( window, factory ) {\n  // universal module definition\n  /* jshint strict: false */ /*global define, module, require */\n  if ( true ) {\n    // AMD\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n      __webpack_require__(/*! ev-emitter/ev-emitter */ \"./node_modules/ev-emitter/ev-emitter.js\")\n    ], __WEBPACK_AMD_DEFINE_RESULT__ = (function( EvEmitter ) {\n      return factory( window, EvEmitter );\n    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n\n}( window, function factory( window, EvEmitter ) {\n\n'use strict';\n\nfunction noop() {}\n\nfunction Unipointer() {}\n\n// inherit EvEmitter\nvar proto = Unipointer.prototype = Object.create( EvEmitter.prototype );\n\nproto.bindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, true );\n};\n\nproto.unbindStartEvent = function( elem ) {\n  this._bindStartEvent( elem, false );\n};\n\n/**\n * Add or remove start event\n * @param {Boolean} isAdd - remove if falsey\n */\nproto._bindStartEvent = function( elem, isAdd ) {\n  // munge isAdd, default to true\n  isAdd = isAdd === undefined ? true : isAdd;\n  var bindMethod = isAdd ? 'addEventListener' : 'removeEventListener';\n\n  // default to mouse events\n  var startEvent = 'mousedown';\n  if ( window.PointerEvent ) {\n    // Pointer Events\n    startEvent = 'pointerdown';\n  } else if ( 'ontouchstart' in window ) {\n    // Touch Events. iOS Safari\n    startEvent = 'touchstart';\n  }\n  elem[ bindMethod ]( startEvent, this );\n};\n\n// trigger handler methods for events\nproto.handleEvent = function( event ) {\n  var method = 'on' + event.type;\n  if ( this[ method ] ) {\n    this[ method ]( event );\n  }\n};\n\n// returns the touch that we're keeping track of\nproto.getTouch = function( touches ) {\n  for ( var i=0; i < touches.length; i++ ) {\n    var touch = touches[i];\n    if ( touch.identifier == this.pointerIdentifier ) {\n      return touch;\n    }\n  }\n};\n\n// ----- start event ----- //\n\nproto.onmousedown = function( event ) {\n  // dismiss clicks from right or middle buttons\n  var button = event.button;\n  if ( button && ( button !== 0 && button !== 1 ) ) {\n    return;\n  }\n  this._pointerDown( event, event );\n};\n\nproto.ontouchstart = function( event ) {\n  this._pointerDown( event, event.changedTouches[0] );\n};\n\nproto.onpointerdown = function( event ) {\n  this._pointerDown( event, event );\n};\n\n/**\n * pointer start\n * @param {Event} event\n * @param {Event or Touch} pointer\n */\nproto._pointerDown = function( event, pointer ) {\n  // dismiss right click and other pointers\n  // button = 0 is okay, 1-4 not\n  if ( event.button || this.isPointerDown ) {\n    return;\n  }\n\n  this.isPointerDown = true;\n  // save pointer identifier to match up touch events\n  this.pointerIdentifier = pointer.pointerId !== undefined ?\n    // pointerId for pointer events, touch.indentifier for touch events\n    pointer.pointerId : pointer.identifier;\n\n  this.pointerDown( event, pointer );\n};\n\nproto.pointerDown = function( event, pointer ) {\n  this._bindPostStartEvents( event );\n  this.emitEvent( 'pointerDown', [ event, pointer ] );\n};\n\n// hash of events to be bound after start event\nvar postStartEvents = {\n  mousedown: [ 'mousemove', 'mouseup' ],\n  touchstart: [ 'touchmove', 'touchend', 'touchcancel' ],\n  pointerdown: [ 'pointermove', 'pointerup', 'pointercancel' ],\n};\n\nproto._bindPostStartEvents = function( event ) {\n  if ( !event ) {\n    return;\n  }\n  // get proper events to match start event\n  var events = postStartEvents[ event.type ];\n  // bind events to node\n  events.forEach( function( eventName ) {\n    window.addEventListener( eventName, this );\n  }, this );\n  // save these arguments\n  this._boundPointerEvents = events;\n};\n\nproto._unbindPostStartEvents = function() {\n  // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)\n  if ( !this._boundPointerEvents ) {\n    return;\n  }\n  this._boundPointerEvents.forEach( function( eventName ) {\n    window.removeEventListener( eventName, this );\n  }, this );\n\n  delete this._boundPointerEvents;\n};\n\n// ----- move event ----- //\n\nproto.onmousemove = function( event ) {\n  this._pointerMove( event, event );\n};\n\nproto.onpointermove = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerMove( event, event );\n  }\n};\n\nproto.ontouchmove = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerMove( event, touch );\n  }\n};\n\n/**\n * pointer move\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerMove = function( event, pointer ) {\n  this.pointerMove( event, pointer );\n};\n\n// public\nproto.pointerMove = function( event, pointer ) {\n  this.emitEvent( 'pointerMove', [ event, pointer ] );\n};\n\n// ----- end event ----- //\n\n\nproto.onmouseup = function( event ) {\n  this._pointerUp( event, event );\n};\n\nproto.onpointerup = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerUp( event, event );\n  }\n};\n\nproto.ontouchend = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerUp( event, touch );\n  }\n};\n\n/**\n * pointer up\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerUp = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerUp( event, pointer );\n};\n\n// public\nproto.pointerUp = function( event, pointer ) {\n  this.emitEvent( 'pointerUp', [ event, pointer ] );\n};\n\n// ----- pointer done ----- //\n\n// triggered on pointer up & pointer cancel\nproto._pointerDone = function() {\n  this._pointerReset();\n  this._unbindPostStartEvents();\n  this.pointerDone();\n};\n\nproto._pointerReset = function() {\n  // reset properties\n  this.isPointerDown = false;\n  delete this.pointerIdentifier;\n};\n\nproto.pointerDone = noop;\n\n// ----- pointer cancel ----- //\n\nproto.onpointercancel = function( event ) {\n  if ( event.pointerId == this.pointerIdentifier ) {\n    this._pointerCancel( event, event );\n  }\n};\n\nproto.ontouchcancel = function( event ) {\n  var touch = this.getTouch( event.changedTouches );\n  if ( touch ) {\n    this._pointerCancel( event, touch );\n  }\n};\n\n/**\n * pointer cancel\n * @param {Event} event\n * @param {Event or Touch} pointer\n * @private\n */\nproto._pointerCancel = function( event, pointer ) {\n  this._pointerDone();\n  this.pointerCancel( event, pointer );\n};\n\n// public\nproto.pointerCancel = function( event, pointer ) {\n  this.emitEvent( 'pointerCancel', [ event, pointer ] );\n};\n\n// -----  ----- //\n\n// utility function for getting x/y coords from event\nUnipointer.getPointerPoint = function( pointer ) {\n  return {\n    x: pointer.pageX,\n    y: pointer.pageY\n  };\n};\n\n// -----  ----- //\n\nreturn Unipointer;\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdW5pcG9pbnRlci91bmlwb2ludGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3VuaXBvaW50ZXIvdW5pcG9pbnRlci5qcz9lMGY1Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVW5pcG9pbnRlciB2Mi4zLjBcbiAqIGJhc2UgY2xhc3MgZm9yIGRvaW5nIG9uZSB0aGluZyB3aXRoIHBvaW50ZXIgZXZlbnRcbiAqIE1JVCBsaWNlbnNlXG4gKi9cblxuLypqc2hpbnQgYnJvd3NlcjogdHJ1ZSwgdW5kZWY6IHRydWUsIHVudXNlZDogdHJ1ZSwgc3RyaWN0OiB0cnVlICovXG5cbiggZnVuY3Rpb24oIHdpbmRvdywgZmFjdG9yeSApIHtcbiAgLy8gdW5pdmVyc2FsIG1vZHVsZSBkZWZpbml0aW9uXG4gIC8qIGpzaGludCBzdHJpY3Q6IGZhbHNlICovIC8qZ2xvYmFsIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlICovXG4gIGlmICggdHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgKSB7XG4gICAgLy8gQU1EXG4gICAgZGVmaW5lKCBbXG4gICAgICAnZXYtZW1pdHRlci9ldi1lbWl0dGVyJ1xuICAgIF0sIGZ1bmN0aW9uKCBFdkVtaXR0ZXIgKSB7XG4gICAgICByZXR1cm4gZmFjdG9yeSggd2luZG93LCBFdkVtaXR0ZXIgKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmICggdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyApIHtcbiAgICAvLyBDb21tb25KU1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShcbiAgICAgIHdpbmRvdyxcbiAgICAgIHJlcXVpcmUoJ2V2LWVtaXR0ZXInKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYnJvd3NlciBnbG9iYWxcbiAgICB3aW5kb3cuVW5pcG9pbnRlciA9IGZhY3RvcnkoXG4gICAgICB3aW5kb3csXG4gICAgICB3aW5kb3cuRXZFbWl0dGVyXG4gICAgKTtcbiAgfVxuXG59KCB3aW5kb3csIGZ1bmN0aW9uIGZhY3RvcnkoIHdpbmRvdywgRXZFbWl0dGVyICkge1xuXG4ndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBVbmlwb2ludGVyKCkge31cblxuLy8gaW5oZXJpdCBFdkVtaXR0ZXJcbnZhciBwcm90byA9IFVuaXBvaW50ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXZFbWl0dGVyLnByb3RvdHlwZSApO1xuXG5wcm90by5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgdHJ1ZSApO1xufTtcblxucHJvdG8udW5iaW5kU3RhcnRFdmVudCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuICB0aGlzLl9iaW5kU3RhcnRFdmVudCggZWxlbSwgZmFsc2UgKTtcbn07XG5cbi8qKlxuICogQWRkIG9yIHJlbW92ZSBzdGFydCBldmVudFxuICogQHBhcmFtIHtCb29sZWFufSBpc0FkZCAtIHJlbW92ZSBpZiBmYWxzZXlcbiAqL1xucHJvdG8uX2JpbmRTdGFydEV2ZW50ID0gZnVuY3Rpb24oIGVsZW0sIGlzQWRkICkge1xuICAvLyBtdW5nZSBpc0FkZCwgZGVmYXVsdCB0byB0cnVlXG4gIGlzQWRkID0gaXNBZGQgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBpc0FkZDtcbiAgdmFyIGJpbmRNZXRob2QgPSBpc0FkZCA/ICdhZGRFdmVudExpc3RlbmVyJyA6ICdyZW1vdmVFdmVudExpc3RlbmVyJztcblxuICAvLyBkZWZhdWx0IHRvIG1vdXNlIGV2ZW50c1xuICB2YXIgc3RhcnRFdmVudCA9ICdtb3VzZWRvd24nO1xuICBpZiAoIHdpbmRvdy5Qb2ludGVyRXZlbnQgKSB7XG4gICAgLy8gUG9pbnRlciBFdmVudHNcbiAgICBzdGFydEV2ZW50ID0gJ3BvaW50ZXJkb3duJztcbiAgfSBlbHNlIGlmICggJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICkge1xuICAgIC8vIFRvdWNoIEV2ZW50cy4gaU9TIFNhZmFyaVxuICAgIHN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCc7XG4gIH1cbiAgZWxlbVsgYmluZE1ldGhvZCBdKCBzdGFydEV2ZW50LCB0aGlzICk7XG59O1xuXG4vLyB0cmlnZ2VyIGhhbmRsZXIgbWV0aG9kcyBmb3IgZXZlbnRzXG5wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdmFyIG1ldGhvZCA9ICdvbicgKyBldmVudC50eXBlO1xuICBpZiAoIHRoaXNbIG1ldGhvZCBdICkge1xuICAgIHRoaXNbIG1ldGhvZCBdKCBldmVudCApO1xuICB9XG59O1xuXG4vLyByZXR1cm5zIHRoZSB0b3VjaCB0aGF0IHdlJ3JlIGtlZXBpbmcgdHJhY2sgb2ZcbnByb3RvLmdldFRvdWNoID0gZnVuY3Rpb24oIHRvdWNoZXMgKSB7XG4gIGZvciAoIHZhciBpPTA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrICkge1xuICAgIHZhciB0b3VjaCA9IHRvdWNoZXNbaV07XG4gICAgaWYgKCB0b3VjaC5pZGVudGlmaWVyID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgICByZXR1cm4gdG91Y2g7XG4gICAgfVxuICB9XG59O1xuXG4vLyAtLS0tLSBzdGFydCBldmVudCAtLS0tLSAvL1xuXG5wcm90by5vbm1vdXNlZG93biA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgLy8gZGlzbWlzcyBjbGlja3MgZnJvbSByaWdodCBvciBtaWRkbGUgYnV0dG9uc1xuICB2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuICBpZiAoIGJ1dHRvbiAmJiAoIGJ1dHRvbiAhPT0gMCAmJiBidXR0b24gIT09IDEgKSApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fcG9pbnRlckRvd24oIGV2ZW50LCBldmVudCApO1xufTtcblxucHJvdG8ub250b3VjaHN0YXJ0ID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJkb3duID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyRG93biggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgc3RhcnRcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKi9cbnByb3RvLl9wb2ludGVyRG93biA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgLy8gZGlzbWlzcyByaWdodCBjbGljayBhbmQgb3RoZXIgcG9pbnRlcnNcbiAgLy8gYnV0dG9uID0gMCBpcyBva2F5LCAxLTQgbm90XG4gIGlmICggZXZlbnQuYnV0dG9uIHx8IHRoaXMuaXNQb2ludGVyRG93biApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLmlzUG9pbnRlckRvd24gPSB0cnVlO1xuICAvLyBzYXZlIHBvaW50ZXIgaWRlbnRpZmllciB0byBtYXRjaCB1cCB0b3VjaCBldmVudHNcbiAgdGhpcy5wb2ludGVySWRlbnRpZmllciA9IHBvaW50ZXIucG9pbnRlcklkICE9PSB1bmRlZmluZWQgP1xuICAgIC8vIHBvaW50ZXJJZCBmb3IgcG9pbnRlciBldmVudHMsIHRvdWNoLmluZGVudGlmaWVyIGZvciB0b3VjaCBldmVudHNcbiAgICBwb2ludGVyLnBvaW50ZXJJZCA6IHBvaW50ZXIuaWRlbnRpZmllcjtcblxuICB0aGlzLnBvaW50ZXJEb3duKCBldmVudCwgcG9pbnRlciApO1xufTtcblxucHJvdG8ucG9pbnRlckRvd24gPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuX2JpbmRQb3N0U3RhcnRFdmVudHMoIGV2ZW50ICk7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlckRvd24nLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIGhhc2ggb2YgZXZlbnRzIHRvIGJlIGJvdW5kIGFmdGVyIHN0YXJ0IGV2ZW50XG52YXIgcG9zdFN0YXJ0RXZlbnRzID0ge1xuICBtb3VzZWRvd246IFsgJ21vdXNlbW92ZScsICdtb3VzZXVwJyBdLFxuICB0b3VjaHN0YXJ0OiBbICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnIF0sXG4gIHBvaW50ZXJkb3duOiBbICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmNhbmNlbCcgXSxcbn07XG5cbnByb3RvLl9iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoICFldmVudCApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gZ2V0IHByb3BlciBldmVudHMgdG8gbWF0Y2ggc3RhcnQgZXZlbnRcbiAgdmFyIGV2ZW50cyA9IHBvc3RTdGFydEV2ZW50c1sgZXZlbnQudHlwZSBdO1xuICAvLyBiaW5kIGV2ZW50cyB0byBub2RlXG4gIGV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuICAvLyBzYXZlIHRoZXNlIGFyZ3VtZW50c1xuICB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgPSBldmVudHM7XG59O1xuXG5wcm90by5fdW5iaW5kUG9zdFN0YXJ0RXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIC8vIGNoZWNrIGZvciBfYm91bmRFdmVudHMsIGluIGNhc2UgZHJhZ0VuZCB0cmlnZ2VyZWQgdHdpY2UgKG9sZCBJRTggYnVnKVxuICBpZiAoICF0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHMgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2JvdW5kUG9pbnRlckV2ZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBldmVudE5hbWUsIHRoaXMgKTtcbiAgfSwgdGhpcyApO1xuXG4gIGRlbGV0ZSB0aGlzLl9ib3VuZFBvaW50ZXJFdmVudHM7XG59O1xuXG4vLyAtLS0tLSBtb3ZlIGV2ZW50IC0tLS0tIC8vXG5cbnByb3RvLm9ubW91c2Vtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICB0aGlzLl9wb2ludGVyTW92ZSggZXZlbnQsIGV2ZW50ICk7XG59O1xuXG5wcm90by5vbnBvaW50ZXJtb3ZlID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJNb3ZlKCBldmVudCwgZXZlbnQgKTtcbiAgfVxufTtcblxucHJvdG8ub250b3VjaG1vdmUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlck1vdmUoIGV2ZW50LCB0b3VjaCApO1xuICB9XG59O1xuXG4vKipcbiAqIHBvaW50ZXIgbW92ZVxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7RXZlbnQgb3IgVG91Y2h9IHBvaW50ZXJcbiAqIEBwcml2YXRlXG4gKi9cbnByb3RvLl9wb2ludGVyTW92ZSA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5wb2ludGVyTW92ZSggZXZlbnQsIHBvaW50ZXIgKTtcbn07XG5cbi8vIHB1YmxpY1xucHJvdG8ucG9pbnRlck1vdmUgPSBmdW5jdGlvbiggZXZlbnQsIHBvaW50ZXIgKSB7XG4gIHRoaXMuZW1pdEV2ZW50KCAncG9pbnRlck1vdmUnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIGVuZCBldmVudCAtLS0tLSAvL1xuXG5cbnByb3RvLm9ubW91c2V1cCA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgZXZlbnQgKTtcbn07XG5cbnByb3RvLm9ucG9pbnRlcnVwID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiAoIGV2ZW50LnBvaW50ZXJJZCA9PSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyICkge1xuICAgIHRoaXMuX3BvaW50ZXJVcCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hlbmQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlclVwKCBldmVudCwgdG91Y2ggKTtcbiAgfVxufTtcblxuLyoqXG4gKiBwb2ludGVyIHVwXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICogQHBhcmFtIHtFdmVudCBvciBUb3VjaH0gcG9pbnRlclxuICogQHByaXZhdGVcbiAqL1xucHJvdG8uX3BvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyVXAoIGV2ZW50LCBwb2ludGVyICk7XG59O1xuXG4vLyBwdWJsaWNcbnByb3RvLnBvaW50ZXJVcCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5lbWl0RXZlbnQoICdwb2ludGVyVXAnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tIHBvaW50ZXIgZG9uZSAtLS0tLSAvL1xuXG4vLyB0cmlnZ2VyZWQgb24gcG9pbnRlciB1cCAmIHBvaW50ZXIgY2FuY2VsXG5wcm90by5fcG9pbnRlckRvbmUgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fcG9pbnRlclJlc2V0KCk7XG4gIHRoaXMuX3VuYmluZFBvc3RTdGFydEV2ZW50cygpO1xuICB0aGlzLnBvaW50ZXJEb25lKCk7XG59O1xuXG5wcm90by5fcG9pbnRlclJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIC8vIHJlc2V0IHByb3BlcnRpZXNcbiAgdGhpcy5pc1BvaW50ZXJEb3duID0gZmFsc2U7XG4gIGRlbGV0ZSB0aGlzLnBvaW50ZXJJZGVudGlmaWVyO1xufTtcblxucHJvdG8ucG9pbnRlckRvbmUgPSBub29wO1xuXG4vLyAtLS0tLSBwb2ludGVyIGNhbmNlbCAtLS0tLSAvL1xuXG5wcm90by5vbnBvaW50ZXJjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmICggZXZlbnQucG9pbnRlcklkID09IHRoaXMucG9pbnRlcklkZW50aWZpZXIgKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIGV2ZW50ICk7XG4gIH1cbn07XG5cbnByb3RvLm9udG91Y2hjYW5jZWwgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIHZhciB0b3VjaCA9IHRoaXMuZ2V0VG91Y2goIGV2ZW50LmNoYW5nZWRUb3VjaGVzICk7XG4gIGlmICggdG91Y2ggKSB7XG4gICAgdGhpcy5fcG9pbnRlckNhbmNlbCggZXZlbnQsIHRvdWNoICk7XG4gIH1cbn07XG5cbi8qKlxuICogcG9pbnRlciBjYW5jZWxcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcGFyYW0ge0V2ZW50IG9yIFRvdWNofSBwb2ludGVyXG4gKiBAcHJpdmF0ZVxuICovXG5wcm90by5fcG9pbnRlckNhbmNlbCA9IGZ1bmN0aW9uKCBldmVudCwgcG9pbnRlciApIHtcbiAgdGhpcy5fcG9pbnRlckRvbmUoKTtcbiAgdGhpcy5wb2ludGVyQ2FuY2VsKCBldmVudCwgcG9pbnRlciApO1xufTtcblxuLy8gcHVibGljXG5wcm90by5wb2ludGVyQ2FuY2VsID0gZnVuY3Rpb24oIGV2ZW50LCBwb2ludGVyICkge1xuICB0aGlzLmVtaXRFdmVudCggJ3BvaW50ZXJDYW5jZWwnLCBbIGV2ZW50LCBwb2ludGVyIF0gKTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBnZXR0aW5nIHgveSBjb29yZHMgZnJvbSBldmVudFxuVW5pcG9pbnRlci5nZXRQb2ludGVyUG9pbnQgPSBmdW5jdGlvbiggcG9pbnRlciApIHtcbiAgcmV0dXJuIHtcbiAgICB4OiBwb2ludGVyLnBhZ2VYLFxuICAgIHk6IHBvaW50ZXIucGFnZVlcbiAgfTtcbn07XG5cbi8vIC0tLS0tICAtLS0tLSAvL1xuXG5yZXR1cm4gVW5pcG9pbnRlcjtcblxufSkpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBLFdBWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/unipointer/unipointer.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanM/Y2QwMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSwgZXZhbCkoXCJ0aGlzXCIpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL21vZHVsZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanM/Y2VkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/module.js\n");

/***/ }),

/***/ "./testPlugin/TestChannel.js":
/*!***********************************!*\
  !*** ./testPlugin/TestChannel.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _motorcortex = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nvar _motorcortex2 = _interopRequireDefault(_motorcortex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = _motorcortex2.default.AttributeChannel;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90ZXN0UGx1Z2luL1Rlc3RDaGFubmVsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL3Rlc3RQbHVnaW4vVGVzdENoYW5uZWwuanM/MGQ0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTUMgZnJvbSBcIkBraXNzbXlidXR0b24vbW90b3Jjb3J0ZXhcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBNQy5BdHRyaWJ1dGVDaGFubmVsO1xuIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7Ozs7O0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./testPlugin/TestChannel.js\n");

/***/ }),

/***/ "./testPlugin/TestIncident.js":
/*!************************************!*\
  !*** ./testPlugin/TestIncident.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _motorcortex = __webpack_require__(/*! @kissmybutton/motorcortex */ \"./node_modules/@kissmybutton/motorcortex/dist/main.js\");\n\nvar _motorcortex2 = _interopRequireDefault(_motorcortex);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar TimedIncident = _motorcortex2.default.TimedIncident;\n\nvar TestIncident = function (_TimedIncident) {\n  _inherits(TestIncident, _TimedIncident);\n\n  function TestIncident() {\n    _classCallCheck(this, TestIncident);\n\n    return _possibleConstructorReturn(this, (TestIncident.__proto__ || Object.getPrototypeOf(TestIncident)).apply(this, arguments));\n  }\n\n  _createClass(TestIncident, [{\n    key: \"onProgress\",\n    value: function onProgress(progress /*, millisecond*/) {\n      for (var i = 0; i < this.elements.length; i++) {\n        for (var attr in this.attrs.animatedAttrs) {\n          var delta = this.attrs.animatedAttrs[attr] - this.initialValues[attr];\n          var value = this.initialValues[attr] + delta * progress;\n          this.elements[i].setAttribute(attr, value);\n        }\n      }\n    }\n  }, {\n    key: \"getScratchValue\",\n    value: function getScratchValue(mcid, attribute) {\n      // console.log(this.props.mcid)\n      if (this.props.mcid) {\n        return this.attrs[attribute];\n      }\n      var element = this.getElementByMCID(mcid);\n      if (element === null) {\n        return null;\n      }\n      var val = element.getAttribute(attribute);\n      if (val === null || val === \"\") {\n        return 0;\n      } else {\n        return parseInt(val);\n      }\n    }\n  }]);\n\n  return TestIncident;\n}(TimedIncident);\n\nmodule.exports = TestIncident;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90ZXN0UGx1Z2luL1Rlc3RJbmNpZGVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy90ZXN0UGx1Z2luL1Rlc3RJbmNpZGVudC5qcz9kN2FiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBNQyBmcm9tIFwiQGtpc3NteWJ1dHRvbi9tb3RvcmNvcnRleFwiO1xuXG5jb25zdCB7IFRpbWVkSW5jaWRlbnQgfSA9IE1DO1xuXG5jbGFzcyBUZXN0SW5jaWRlbnQgZXh0ZW5kcyBUaW1lZEluY2lkZW50IHtcbiAgb25Qcm9ncmVzcyhwcm9ncmVzcyAvKiwgbWlsbGlzZWNvbmQqLykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChjb25zdCBhdHRyIGluIHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRycykge1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuYXR0cnMuYW5pbWF0ZWRBdHRyc1thdHRyXSAtIHRoaXMuaW5pdGlhbFZhbHVlc1thdHRyXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmluaXRpYWxWYWx1ZXNbYXR0cl0gKyBkZWx0YSAqIHByb2dyZXNzO1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZ2V0U2NyYXRjaFZhbHVlKG1jaWQsIGF0dHJpYnV0ZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucHJvcHMubWNpZClcbiAgICBpZiAodGhpcy5wcm9wcy5tY2lkKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdHRyc1thdHRyaWJ1dGVdO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50QnlNQ0lEKG1jaWQpO1xuICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgdmFsID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZUludCh2YWwpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRlc3RJbmNpZGVudDtcbiJdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7Ozs7Ozs7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUExQkE7QUFDQTtBQTRCQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./testPlugin/TestIncident.js\n");

/***/ }),

/***/ "./testPlugin/main.js":
/*!****************************!*\
  !*** ./testPlugin/main.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar TestChannel = __webpack_require__(/*! ./TestChannel */ \"./testPlugin/TestChannel.js\");\nvar TestIncident = __webpack_require__(/*! ./TestIncident */ \"./testPlugin/TestIncident.js\");\n\nmodule.exports = {\n  npm_name: \"@kissmybutton/test-plugin\",\n  incidents: [{\n    exportable: TestIncident\n  }],\n  channel: TestChannel\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi90ZXN0UGx1Z2luL21haW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdGVzdFBsdWdpbi9tYWluLmpzP2RjOTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVGVzdENoYW5uZWwgPSByZXF1aXJlKFwiLi9UZXN0Q2hhbm5lbFwiKTtcbmNvbnN0IFRlc3RJbmNpZGVudCA9IHJlcXVpcmUoXCIuL1Rlc3RJbmNpZGVudFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5wbV9uYW1lOiBcIkBraXNzbXlidXR0b24vdGVzdC1wbHVnaW5cIixcbiAgaW5jaWRlbnRzOiBbXG4gICAge1xuICAgICAgZXhwb3J0YWJsZTogVGVzdEluY2lkZW50XG4gICAgfVxuICBdLFxuICBjaGFubmVsOiBUZXN0Q2hhbm5lbFxufTtcbiJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQURBO0FBSUE7QUFQQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./testPlugin/main.js\n");

/***/ })

/******/ });